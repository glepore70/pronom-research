SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00013         TEXT WINDOWING ROUTINES                                           1      05-28-9314:08ALL                      SWAG SUPPORT TEAM        Execute DOS in a Window  IMPORT              78     F…Æü {$A+,B-,D+,E-,F-,G-,I-,L-,N-,O-,P-,Q-,R-,S-,T-,V-,X+,Y-}„{$M   16384,0,655360}„Unit  ExecWin;„Interface„Var   SaveInt10 : Pointer;„„Procedure ExecWindow(X1,Y1,X2,Y2,„                     Attr         : Byte;„                     Path,CmdLine : String);„„Implementation„Uses„  Crt,Dos;„Type„  PageType  = Array [1..50,1..80] of Word;„Var„  Window    : Record„    X1,Y1,X2,Y2,„    Attr         : Byte;„    CurX,CurY    : Byte;„  end;„  Regs      : Registers;„  Cleared   : Boolean;„  Screen    : ^PageType;„  ActPage,„  VideoMode : ^Byte;„  {$ifOPT D+}„  Fnc,„  OldFnc    : Byte;„  {$endif}„„{$ifOPT D+}„Function FStr(Num : LongInt) : String;„Var„  Dummy : String;„begin„  Str(Num,Dummy);„  FStr := Dummy;„end;„„Procedure WriteXY(X,Y,Attr : Byte;TextStr : String);„Var„  Loop : Byte;„begin„  if Length(TextStr)>0 then„  begin„    Loop := 0;„    Repeat„      Inc(Loop);„      Screen^[Y,X+(Loop-1)] := ord(TextStr[Loop])+Word(Attr SHL 8);„    Until Loop=Length(TextStr);„  end;„end;„{$endif}„„Procedure ScrollUp(X1,Y1,X2,Y2,Attr : Byte); Assembler;„Asm„  mov   ah,$06„  mov   al,$01„  mov   bh,Attr„  mov   ch,Y1„  mov   cl,X1„  mov   dh,Y2„  mov   dl,X2„  dec   ch„  dec   cl„  dec   dh„  dec   dl„  int   $10„end;„„Procedure ClearXY(X1,Y1,X2,Y2,Attr : Byte); Assembler;„Asm„  mov   ah,$06„  mov   al,$00„  mov   bh,Attr„  mov   ch,Y1„  mov   cl,X1„  mov   dh,Y2„  mov   dl,X2„  dec   ch„  dec   cl„  dec   dh„  dec   dl„  int   $10„end;„„{$ifOPT D+}„Procedure Beep(Freq,Delay1,Delay2 : Word);„begin„  Sound(Freq);„  Delay(Delay1);„  NoSound;„  Delay(Delay2);„end;„{$endif}„„{$F+}„Procedure NewInt10(Flags,CS,IP,AX,BX,CX,„                   DX,SI,DI,DS,ES,BP : Word); Interrupt;„Var„  X, Y, X1,„  Y1, X2, Y2   : Byte;„  Loop, DummyW : Word;„begin„  SetIntVec($10,SaveInt10);„  {$ifOPT D+}„  Fnc := Hi(AX);„  if Fnc<>OldFnc then„  begin„    WriteXY(1,1,14,'Coordinates:');„    WriteXY(20,1,14,'Register:');„    WriteXY(20,2,14,'AH: '+FStr(Hi(AX))+'  ');„    WriteXY(20,3,14,'AL: '+FStr(Lo(AX))+'  ');„    WriteXY(20,4,14,'BH: '+FStr(Hi(BX))+'  ');„    WriteXY(20,5,14,'BL: '+FStr(Lo(BX))+'  ');„    WriteXY(30,2,14,'CH: '+FStr(Hi(CX))+'  ');„    WriteXY(30,3,14,'CL: '+FStr(Lo(CX))+'  ');„    WriteXY(30,4,14,'DH: '+FStr(Hi(DX))+'  ');„    WriteXY(30,5,14,'DL: '+FStr(Lo(DX))+'  ');„    Case Fnc of„      $0 : WriteXY(40,1,14,'Set video mode.                        ');„      $1 : WriteXY(40,1,14,'Set cursor shape.                      ');„      $2 : WriteXY(40,1,14,'Set cursor position.                   ');„      $3 : WriteXY(40,1,14,'Get cursor position.                   ');„      $4 : WriteXY(40,1,14,'Get lightpen position.                 ');„      $5 : WriteXY(40,1,14,'Set active page.                       ');„      $6 : WriteXY(40,1,14,'Scroll up lines.                       ');„      $7 : WriteXY(40,1,14,'Scroll down lines.                     ');„      $8 : WriteXY(40,1,14,'Get Character/attribute.               ');„      $9 : WriteXY(40,1,14,'Write Character/attribute.             ');„      $A : WriteXY(40,1,14,'Write Character.                       ');„      $D : WriteXY(40,1,14,'Get pixel in Graphic mode.             ');„      $E : WriteXY(40,1,14,'Write Character.                       ');„      $F : WriteXY(40,1,14,'Get video mode.                        ');„      else WriteXY(40,1,14,'(unknown/ignored Function)             ');„    end;„    Case Hi(AX) of„      $0..$E : Beep(Hi(AX)*100,2,5);„          else begin„                 Beep(1000,50,0);„                 Repeat Until ReadKey<>#0;„               end;„    end;„  end;„  {$endif}„  Case Hi(AX) of„    $00 : begin„            ClearXY(Window.X1,Window.Y1,Window.X2,Window.Y2,Window.Attr);„            GotoXY(Window.X1,Window.Y1);„            Window.CurX := Window.X1;„            Window.CurY := Window.Y1;„          end;„    $01 : begin„            Regs.AH := $01;„            Regs.CX := CX;„            Intr($10,Regs);„          end;„    $02 : begin„            X           := Lo(DX);„            Y           := Hi(DX);„            Window.CurX := X+1;„            if Cleared then„            begin„              Window.CurY := Window.Y1;„              Cleared     := False;„            end„            else Window.CurY := Y+1;„            if Window.CurX<=Window.X2 then„            begin„              Regs.AH     := $02;„              Regs.BH     := ActPage^;„              Regs.DL     := X;„              Regs.DH     := Y;„              Intr($10,Regs);„            end;„          end;„    $03 : begin„            Regs.AH     := $03;„            Regs.BH     := ActPage^;„            Intr($10,Regs);„            DX          := (Window.X1-Regs.DL)+((Window.Y1-Regs.DH) SHL 8);„            CX          := Regs.CX;„          end;„    $04 : AX := Lo(AX);„    $06 : begin„            X1      := Window.X1+Lo(CX)-1;„            Y1      := Window.Y1+Hi(CX)-1;„            X2      := Window.X2+Lo(DX)-1;„            Y2      := Window.Y2+Hi(DX)-1;„            if Lo(AX)=0 then„            begin„              ClearXY(Window.X1,Window.Y1,„                      Window.X2,Window.Y2,Window.Attr);„              GotoXY(Window.X1,Window.Y1);„              Window.CurX := Window.X1;„              Window.CurY := Window.Y1;„              Cleared     := True;„            end„            else„            begin„              if X2>Window.X2 then X2 := Window.X2;„              if Y2>Window.Y2 then Y2 := Window.Y2;„              Regs.AH := $06;„              Regs.AL := Lo(AX);„              Regs.CL := X1;„              Regs.CH := Y1;„              Regs.DL := X2;„              Regs.DH := Y2;„              Regs.BH := Window.Attr;„              Intr($10,Regs);„            end;„          end;„    $07 : begin„            X1      := Window.X1+Lo(CX)-1;„            Y1      := Window.Y1+Hi(CX)-1;„            X2      := Window.X2+Lo(DX)-1;„            Y2      := Window.Y2+Hi(DX)-1;„            if X2>Window.X2 then„              X2 := Window.X2;„            if Y2>Window.Y2 then„              Y2 := Window.Y2;„            Regs.AH := $07;„            Regs.AL := Lo(AX);„            Regs.CL := X1;„            Regs.CH := Y1;„            Regs.DL := X2;„            Regs.DH := Y2;„            Regs.BH := Window.Attr;„            Intr($10,Regs);„          end;„    $08 : begin„            Regs.AH := $08;„            Regs.BH := ActPage^;„            Intr($10,Regs);„            AX      := Regs.AX;„          end;„    $09,„    $0A : begin„            Regs.AH := $09;„            Regs.BH := ActPage^;„            Regs.CX := CX;„            Regs.AL := Lo(AX);„            Regs.BL := Window.Attr;„            Intr($10,Regs);„          end;„    $0D : AX := Hi(AX) SHL 8;„    $0D : AX := Hi(AX) SHL 8;„    $0E : begin„            Case Lo(AX) of„               7 : Write(#7);„              13 : begin„                     Window.CurX := Window.X1-1;„                     if Window.CurY>=Window.Y2 then„                     begin„                       Window.CurY := Window.Y2-1;„                       ScrollUp(Window.X1,Window.Y1,„                                Window.X2,Window.Y2,Window.Attr);„                     end;„                   end;„              else„                begin„                  Regs.AH := $0E;„                  Regs.AL := Lo(AX);„                  Regs.BL := Window.Attr;„                  Intr($10,Regs);„                end;„            end;„            Inc(Window.CurX);„            GotoXY(Window.CurX,Window.CurY);„          end;„    $0F : begin„            AX := $03+(80 SHL 8);„            BX := Lo(BX);„          end;„     else„       begin„         Regs.AX    := AX;„         Regs.BX    := BX;„         Regs.CX    := CX;„         Regs.DX    := DX;„         Regs.SI    := SI;„         Regs.DI    := DI;„         Regs.DS    := DS;„         Regs.ES    := ES;„         Regs.BP    := BP;„         Regs.Flags := Flags;„         Intr($10,Regs);„         AX         := Regs.AX;„         BX         := Regs.BX;„         CX         := Regs.CX;„         DX         := Regs.DX;„         SI         := Regs.SI;„         DI         := Regs.DI;„         DS         := Regs.DS;„         ES         := Regs.ES;„         BP         := Regs.BP;„         Flags      := Regs.Flags;„       end;„  end;„  {$ifOPT D+}„  if Fnc<>OldFnc then„  begin„    WriteXY(1,2,14,FStr(Window.CurX)+':'+FStr(Window.CurY)+'  ');„    WriteXY(1,3,14,FStr(Window.CurX-Window.X1+1)+':'+„                   FStr(Window.CurY-Window.Y1+1)+'  ');„    WriteXY(40,2,14,'AH: '+FStr(Hi(AX))+'  ');„    WriteXY(40,3,14,'AL: '+FStr(Lo(AX))+'  ');„    WriteXY(40,4,14,'BH: '+FStr(Hi(BX))+'  ');„    WriteXY(40,5,14,'BL: '+FStr(Lo(BX))+'  ');„    WriteXY(50,2,14,'CH: '+FStr(Hi(CX))+'  ');„    WriteXY(50,3,14,'CL: '+FStr(Lo(CX))+'  ');„    WriteXY(50,4,14,'DH: '+FStr(Hi(DX))+'  ');„    WriteXY(50,5,14,'DL: '+FStr(Lo(DX))+'  ');„    OldFnc := Fnc;„  end;„  {$endif}„  SetIntVec($10,@NewInt10);„end;„{$F-}„„Procedure ExecWindow;„begin„  Window.X1   := X1;„  Window.Y1   := Y1;„  Window.X2   := X2;„  Window.Y2   := Y2;„  Window.Attr := Attr;„  {$ifOPT D+}„  Fnc         := 255;„  OldFnc      := 255;„  {$endif}„  ClearXY(Window.X1,Window.Y1,„          Window.X2,Window.Y2,Window.Attr);„  GotoXY(Window.X1,Window.Y1);„  Window.CurX := Window.X1;„  Window.CurY := Window.Y1;„  SwapVectors;„  GetIntVec($10,SaveInt10);„  SetIntVec($10,@NewInt10);„  Exec(Path,CmdLine);„  SetIntVec($10,SaveInt10);„  SwapVectors;„end;„„begin„  Window.X1   := Lo(WindMin);„  Window.Y1   := Hi(WindMin);„  Window.X2   := Lo(WindMax);„  Window.Y2   := Hi(WindMax);„  Window.Attr := TextAttr;„  Window.CurX := WhereX;„  Window.CurY := WhereY;„  Cleared     := False;„  ActPage     := Ptr(Seg0040,$0062);„  VideoMode   := Ptr(Seg0040,$0049);„  if VideoMode^=7 then„    Screen := Ptr(SegB000,$0000)„  else„    Screen := Ptr(SegB800,$0000);„end.„                                                                                             2      05-28-9314:08ALL                      SWAG SUPPORT TEAM        SHADOW1.PAS              IMPORT              10     F…ye {„> I Write the following Procedure to shadow Text behind a box.  It works„> fine (so Far), but am not sure if there is a quicker, easier way.„„You are searching through the video-RAM For the Char and Attr, you want to„change. Perhaps, it is easier and faster to use the interrupt, that returns„you the Char under the Cursor , than you can change the attribute.„}„Uses„  Dos, Crt;„„Procedure Shadow(x1, y1, x2, y2 : Byte);„Var„  s, i, j : Byte;„„  Procedure Z(x, y : Byte);„  Var„    r : Registers;„  begin„    r.ah := $02;„       { Function 2hex (Put Position of Cursor) }„    r.bh := 0;„    r.dh := y - 1;        { Y-Position }„    r.dl := x - 1;        { X-Position }„    intr($10,r);„    r.ah := $08;„       { Fkt. 8hex ( Read Char under cursor ) }„    r.bh := 0;„    intr($10, r);„    Write(chr(r.al));„  end;„„begin„  s := TextAttr; { save Attr }„  TextAttr := 8;„  For i := y1 + 1 to y2 + 1 do„    For j := x1 + 1 to x2 + 1 do„      z(i, j);„  TextAttr := s; { Attr back }„end;„„begin„  Shadow(10,10,20,20);„  ReadKey;„end.                                                                                                                          3      05-28-9314:08ALL                      SWAG SUPPORT TEAM        SHADOW2.PAS              IMPORT              8      F…øÏ {„I Write the following Procedure to shadow Text behind a box.  It works„fine (so Far), but am not sure if there is a quicker, easier way.„}„„Procedure Shadow(x, y, xlength, ylength : Byte);„Var„  xshad,„  yshad : Word;„  i     : Byte;„begin„  xlength := xlength shl 1;     { xlength * 2 }„  xshad := ((x*2)+(y*160)-162) + ((ylength+1) * 160) + 4;   { x coord }„  yshad := ((x*2)+(y*160)-162) + (xlength);                 { y coord }„  if Odd(Xshad) then Inc(XShad);            { we want attr not Char }„  if not Odd(YShad) then Inc(YShad);        { " }„  For i := 1 to xlength Do„    if Odd(i) then„      Mem[$B800:xshad+i] := 8;              { put x shadow }„  For i := 1 to ylength Do„  begin„    Mem[$B800:yshad+(i*160)] := 8;          { put y shadows }„    Mem[$B800:yshad+2+(i*160)] := 8„  end„end;„                                                                                           4      05-28-9314:08ALL                      SWAG SUPPORT TEAM        WINDOWS1.PAS             IMPORT              38     F…IO {„>   Okay...it works fine, but I want to somehow be able to kindo of remove t„> Window.  I'm not sure if there is any way of doing this?„„You need to save the screen data at the location you wish to make„a Window, then after you're done With the Window simply restore„the screen data back to what it was.  Here's some example„routines of what you can do, you must call InitWindows once at„the begining of the Program before using the OpenWindow„Procedure, then CloseWindow to restore the screen.„}„„Uses„  Crt;„„Type„  ShadeType = (Shading, NoShading);„  ScreenBlock = Array [1..2000] of Integer;„  ScreenLine  = Array [1..80] of Word;„  ScreenArray = Array [1..25] of ScreenLine;„  WindowLink  = ^WindowControlBlock;„  WindowControlBlock = Record„    X,Y      : Byte;          { start position }„    Hight    : Byte;          { Menu Hight     }„    Width    : Byte;          { Menu width     }„    ID       : Byte;          { Menu number    }„    BackLink : WindowLink;    { previous block }„    MenuItem : Byte;          { select item    }„    ScreenData : ScreenBlock; { saved screen data }„  end;„  String30 = String[30];„  ScreenPtr = ^ScreenRec;„  ScreenRec = Array [1..25,1..80] of Integer;„„„Var„  Screen       : ScreenPtr;„  ActiveWindow : Pointer;„„Procedure InitWindows;„begin„  If LastMode = Mono Then„    Screen := Ptr($B000,0)„  Else„    Screen := Ptr($B800,0);„  ActiveWindow := Nil;„end;„„Procedure OpenWindow(X, Y, Lines, Columns, FrameColor,„                     ForeGround, BackGround : Byte;„                     Title : String30; Shade : ShadeType);„Var„  A, X1, X2,„  Y1, Y2        : Integer;„  OldAttr       : Integer;„  WindowSize    : Integer;„  Block         : WindowLink;„begin„  OldAttr := TextAttr;„„  WindowSize := (Lines + 3) * (Columns + 5) * 2 +„                 Sizeof(WindowControlBlock) - Sizeof(ScreenBlock);„„  If MemAvail < WindowSize Then„  begin„    WriteLn;WriteLn('Program out of memory');„    Halt;„  end;„„  GetMem(Block,WindowSize);„  Block^.X := X - 2;„  Block^.Y := Y - 1;„  Block^.Hight := Lines + 3;„  Block^.Width := Columns + 5;„  Block^.BackLink := ActiveWindow;„„  ActiveWindow := Block;„  A := 1;„  For Y1 := Block^.Y to Block^.Y+Block^.Hight-1 Do„  begin„    Move(Screen^[Y1, Block^.X], Block^.ScreenData[A], Block^.Width * 2);„    A := A + Block^.Width;„  end;„„  TextColor(FrameColor);„  If BackGround = Black Then„    TextBackGround(LightGray)    { This will keep exploding Window visable }„  Else„    TextBackground(BackGround);„„  X1 := X + Columns Div 2;„  X2 := X1 + 1;„  Y1 := Y + Lines Div 2;„  Y2 := Y1 + 1;„„  Repeat„    Window(X1, Y1, X2, Y2);„    ClrScr;„    If Columns < 20 Then„      Delay(20);„    If X1 > X Then„      Dec(X1);„    If X2 < X + Columns Then„      Inc(X2);„    If Y1 > Y Then„      Dec(Y1);„    If Y2 < Y + Lines Then„      Inc(Y2);„  Until (X2 - X1 >= Columns ) And (Y2 - Y1 >= Lines);„„  Window(X - 1, Y, X + Columns, Y + Lines);„  TextBackground(BackGround);„  ClrScr;„  TextColor(FrameColor);„  Window(1, 1, 80, 24);„  GotoXY(X - 2, Y - 1);„  Write('⁄');„  For A := 1 to Columns + 2 Do„    Write('ƒ');„„  Write('ø');„  For A := 1 to Lines Do„  begin„    GotoXY(X - 2, Y + A - 1);„    Write('≥');„    GotoXY(X + Columns + 1, Y + A - 1);„    Write('≥');„  end;„  GotoXY(X - 2, Y + Lines);„  Write('¿');„  For A := 1 to Columns + 2 Do„    Write('ƒ');„  Write('Ÿ');„  If Shade = Shading Then„  begin„    For A := Y to Y + Lines + 1 Do„      Screen^[A, X + Columns + 2] := Screen^[A, X + Columns + 2] And $07FF;„    For A := X - 1 to X + Columns + 1 Do„      Screen^[Y + Lines + 1, A] := Screen^[Y + Lines + 1, A] And $07FF;„  end;„  If Title <> '' Then„  begin„    TextColor(FrameColor);„    GotoXY(X + ((Columns - Length(Title)) div 2) - 1, Y - 1);„    Write(' ', Title, ' ');„  end;„  Window(1, 1, 80, 24);„end;„„Procedure CloseWindow;„Var„  Block   : WindowLink;„  A       : Integer;„  Y1      : Integer;„  WindowSize : Integer;„begin„  If ActiveWindow = Nil Then„    Exit;„  Block := ActiveWindow;„  WindowSize := (Block^.Hight) * (Block^.Width) * 2 +„                 Sizeof(WindowControlBlock) - Sizeof(ScreenBlock);„  A := 1;„  For Y1 := Block^.Y to Block^.Y+Block^.Hight - 1 Do„    begin„    Move(Block^.ScreenData[A], Screen^[Y1, Block^.X], Block^.Width * 2);„    A := A + Block^.Width;„    end;„  ActiveWindow := Block^.BackLink;„  FreeMem(Block, WindowSize);„end;„„begin„  InitWindows;„  OpenWindow(10, 5, 10, 50, LightGreen, LightBlue, Magenta,„                     'Test Window', Shading);„  ReadKey;„  OpenWindow(20, 6, 6, 30, Green, Yellow, Blue,„                     'Test Window 2', Shading);„  ReadKey;„  CloseWindow;„  ReadKey;„  CloseWindow;„  ReadKey;„  GotoXY(1,24);„„end.„                                                     5      05-28-9314:08ALL                      SWAG SUPPORT TEAM        WINDOWS2.PAS             IMPORT              37     F…E[ Uses Crt;„„Type„„   BufferType = Array[0..3999] of Byte; { screen size      }„   PtrBufferType = ^BufferType;         { For dynamic use  }„„Var„  Screen: BufferType Absolute $B800:$0; { direct access to }„                                        { Text screen      }„„Function CharS(Len:Byte; C: Char): String;„Var„  S: String;„begin                       { This Function returns a String of }„  FillChar(S, Len+1, C);    { Length Len and of Chars C.        }„  S[0] := Chr(Len);„  CharS := S;„end;„„Function Center(X1, X2: Byte; S: String): Byte;„Var„  L, Max: Integer;„begin                           { This Function is used to center     }„  Max := (X2 - (X1-1)) div 2;   { a String between two X coordinates. }„  L := Length(S);„  if Odd(L) then Inc(L);„  Center := X1 + (Max - (L div 2));„end;„„„Procedure DrawBox(X1, Y1, X2, Y2: Integer; Attr: Byte; Title: String);„Var„  L, Y, X: Integer;„  S: String;„„begin„  X := X2 - (X1-1);      { find box width  }„  Y := Y2 - (Y1-1);      { find box height }„  { draw box }„  S := Concat('…', CharS(X-2, 'Õ'), 'ª');„  GotoXY(X1, Y1);„  TextAttr := Attr;„  Write(S);„  Title := Concat('µ ', Title,' ∆');„  GotoXY(Center(X1, X2, Title), Y1);„  Write(Title);„  For L := 2 to (Y-1) do„    begin„      GotoXY(X1, Y1+L-1);„      Write('∫', CharS(X-2, ' '), '∫');„    end;„  GotoXY(X1, Y2);„   Write('»', CharS(X-2, 'Õ'), 'º');„„end;„„Procedure SaveBox(X1, Y1, X2, Y2: Integer; Var BufPtr: PtrBufferType);„Var„  Poff, Soff, Y, XW, YW, Size: Integer;„„begin„  XW := X2 - (X1 -1);   { find box width  }„  YW := Y2 - (Y1 -1);   { find box height }„  Size := (XW*2 ) * YW; { size needed to store background }„  GetMem(BufPtr, Size); { allocate memory to buffer }„  For Y := 1 to YW do   { copy line by line to buffer }„    begin„      Soff := (((Y1-1) + (Y-1)) * 160) + ((X1-1)*2);„      Poff := ((XW * 2) * (Y-1));„      Move(Screen[Soff], BufPtr^[Poff], (XW * 2)); { Write to buffer }„    end;„end;„„(*************** end of PART 1 of 2. *****************************)„(****** PART 2 of 2 ********************************)„Procedure RestoreBox(X1, Y1, X2, Y2: Integer; Var BufPtr: PtrBufferType);„Var„  Poff, Soff, X, Y, XW, YW, Size: Integer;„  F: File;„„begin„  XW := X2 - (X1-1); { once again...find box width }„  YW := Y2 - (Y1-1); { find height }„  Size := (XW *2) * YW; { memory size to deallocate from buffer }„  For Y := 1 to YW do   { move back, line by line }„    begin„      Soff := (( (Y1-1) + (Y-1)) * 160) + ((X1-1)*2);„      Poff := ((XW*2) * (Y-1));„      Move(BufPtr^[Poff], Screen[Soff],  (XW*2));„    end;„  FreeMem(BufPtr, Size);„end;„„„Procedure Shadow(X1, Y1, X2, Y2: Byte);„Var„  Equip: Byte Absolute $40:$10;„  Vert, Height, offset: Integer;„„begin„  if (Equip and 48) = 48 then Exit;„„  For Vert := (Y1+1) to (Y2+1) do„    For Height := (X2+1) to (X2+2) do„      begin„        offset := (Vert - 1) * 160 + (Height-1) * 2 + 1;„        Screen[offset] := 8;„      end;„  Vert := Y2 + 1;„  For Height := (X1+2) to (X2+2) do„    begin„      offset := (Vert-1) * 160 + (Height-1) * 2 + 1;„      Screen[offset] := 8;„    end;„end;„„Procedure Hello;„Var„  BufPtr: PtrBufferType;„begin„  { note, that if you use shadow, save an xtra 2 columns„    and 1 line to accomadate what Shadow does }„   {             V   V   }„  SaveBox(7, 7, 73, 15, BufPtr);„  DrawBox(7, 7, 71, 13, $4F, 'Hello');„  Shadow(7, 7, 71, 13);„  GotoXY(9, 9);„  Write('Hello Terry! I hope this is what you were asking For.');„  GotoXY(9, 11);„  Write('Press Enter');„  While ReadKey <> #13 do;„  RestoreBox(7, 7, 73, 14, BufPtr);„end;„„Procedure Disclaimer;„Var„  BufPtr: PtrBufferType;„begin„  SaveBox(5, 5, 77, 21, BufPtr);„  DrawBox(5, 5, 75, 20, $1F, 'DISCLAIMER');„  Shadow(5, 5, 75, 20);„  Window(7, 7, 73, 19);„  Writeln('  Seeing as I came up With these Procedures For');„  Writeln('my own future Programs (I just recently wrote these)');„  Writeln('please don''t Forget who wrote them originally if you');„  Writeln('decide to use them in your own.  Maybe a ''thanks to Eric Miller');„  Writeln('For Window routines'' somewhere in your doCs?');„  Writeln;„  Writeln('  Also, if anyone can streamline this source, well, I''d');„  Writeln('I''d like to see it...not that too much can be done.');„  Writeln;„  Writeln('                    Eric Miller');„  Window(1,1,80,25);„  Hello;„  TextAttr := $1F;„  GotoXY(9, 18);„  Writeln('Press Enter...');„  While ReadKey <> #13 do;„  RestoreBox(5, 5, 77, 21, BufPtr);„end;„„begin„  TextAttr := $3F;„  ClrScr;„  Disclaimer;„end.„(***** end of PART 1 of 2 ******************************)„                                                  6      05-28-9314:08ALL                      SWAG SUPPORT TEAM        WINDOWS3.PAS             IMPORT              17     F…+û DS>  Like say there is a Text Window that pops up when someone makes a„DS>choice. Then they select something else and a Text Window is made that„DS>overlaps the previous one.  Then I'd like to have it so if the user„DS>were to press, say, escape, the current Text Window would be "removed"„DS>and the old Window would still be there as is was....„DS>How can this be done??  Please keep in mind that I'm still sort of„„Here's two Procedures a friend of mine wrote (David Thomas: give credit„whree credit is due).  It works great With regular Text screens.„„„Put This in you Type section:„„  WindowStatus = (OnScreen, OffScreen);„  WindowType = Record„                 Point    : Pointer;„                 Status   : WindowStatus;„                 Col,„                 Row,„                 SaveAttr : Byte;„               end;„„Procedure GetWindow (Var Name : WindowType);„Var„  Size,„  endOffset,„  StartOffset  : Integer;„begin   { GetWindow }„„  With Name Do„    begin„      Col := WhereX;„      Row := WhereY;„      SaveAttr := TextAttr;„„      StartOffset := 0;„      endOffset   := 25 * 160;„      Size := endOffset - StartOffset;„      GetMem (Point, Size);„„      Move (Mem[$B800:StartOffset], Point^, Size);„      Status := OnScreen;„    end; { With }„„end;    { GetWindow }„{--------------------------------------------------------------------}„Procedure PutWindow (Var Name : WindowType);„Var„  Size,„  endOffset,„  StartOffset  : Integer;„begin   { PutWindow }„„  With Name Do„    begin„      StartOffset := 0;„      endOffset   := 25 * 160;„      Size := endOffset - StartOffset;„„      Move (Point^, Mem[$B800:StartOffset], Size);„„      FreeMem (Point, Size);„      Status := OffScreen;„„      TextAttr := SaveAttr;„      GotoXY (Col, Row);„    end; { With }„„end;    { PutWindow }„„„Very easy to use.  Just declare a Varibale of WindowType, call the„GETWindow routine, then display whatever.  When you're done, call the„PUTWindow routine and it Zap, it's back to how it was.  Very face, very„nice.„                                  7      05-28-9314:08ALL                      SALIM SAMAHA             WINDOWS4.PAS             IMPORT              10     F…˜Ï { SALIM SAMAHA }„„Unit Windows;„„Interface„„Uses„  Crt;„„Const„  Max = 3;„„Type„  ScreenImage = Array [0..1999] of Word;„  FrameRec    = Record„    Upperleft    : Word;„    LowerRight   : Word;„    ScreenMemory : ScreenImage;„  end;„„Var„  SnapShot   : ^ScreenImage;„  FrameStore : Array [1..10] of ^FrameRec;„  WindowNum  : Byte;„„Procedure OpenWindow(UpLeftX, UpLeftY, LoRightX, LoRightY : Byte);„Procedure CloseWindow;„„Implementation„„Procedure OpenWindow(UpLeftX, UpLeftY, LoRightX, LoRightY : Byte);„begin„  SnapShot := Ptr( $B800, $0000);„  Inc(WindowNum);„  New(FrameStore[WindowNum]);„  With Framestore[WindowNum]^ do„  begin„    ScreenMemory := SnapShot^;„    UpperLeft    := WindMin;„    LowerRight   := WindMax;„  end;„  Window(UpLeftX, UpLeftY, LoRightX, LoRightY);„end;„„Procedure CloseWindow;„begin„  With Framestore[WindowNum]^ do„  begin„    Snapshot^ := ScreenMemory;„    Window ((Lo(UpperLeft) + 1), (Hi(UpperLeft) + 1),„            (Lo(LowerRight) + 1), (Hi(LowerRight) + 1));„  end;„  Dispose(Framestore[WindowNum]);„  Dec(WindowNum);„end;„„                                                                                          8      08-27-9322:02ALL                      SEAN PALMER              Moving Text Images       IMPORT              12     F…   {„SEAN PALMER„„>I was looking threw a Turbo C++ manual and noted some„>Procedures that deal With the Text screen, such as„>Get/PutTextImage. I was wondering if anyone has created one„>for Pascal to move/save Text images around the screen like„>in C++.„„Copies a rectangular section from one video buffer (any size) to another„}„„Procedure moveScr(Var srcBuf; srcX, srcY, width, height, srcBufW,„                      srcBufH : Word; Var dstBuf; dstX, dstY, dstBufW,„                      dstBufH : Word); Assembler;„Asm„  cld„  push ds„  lds  si, srcBuf    {calc src adr}„  mov  ax, srcBufW„  mul  srcY„  add  ax, srcX„  shl  ax, 1„  add  si, ax„  les  di, dstBuf    {calc dst adr}„  mov  ax, dstBufW„  mul  dstY„  add  ax, dstX„  shl  ax, 1„  add  di, ax„  mov  dx, height    {num lines}„  mov  ax, SrcBufW   {calc ofs between src lines}„  sub  ax, width„  shl  ax, 1„  mov  bx, dstBufW   {calc ofs between dst lines}„  sub  bx, width„  shl  bx, 1„ @L:„  mov  cx, width„  rep  movsw„  add  si, ax„  add  di, bx„  dec  dx„  jnz  @L„  pop  ds„end;„„Var„  s : Array [0..24,0..79,0..1] of Char Absolute $B800 : 0;„  d : Array [0..11,0..39,0..1] of Char;„  i : Integer;„„begin„  For i := 1 to 25 * 10 do„    Write('(--)(--)');„  moveScr(s,0,0,40,12,80,25,d,0,0,40,12); {copy 40x12 block to buf}„  readln;„  moveScr(d,0,0,38,10,40,12,s,5,5,80,25); {copy part back to screen}„  readln;„end.„„                      9      11-02-9305:03ALL                      KIMBA DOUGHTY            Shadow Boxes             IMPORT              18     F…   { Updated SCREEN.SWG on November 2, 1993 }„„{„KIMBA DOUGHTY„„> could someone tell me how to do a shadow Window.. you know the Type that„> has a Window then a shadow of what is under the Window in color 8 or dark„> gray... Either in Inline assembly or Straight Pascal...„}„„Unit shadow;„„Interface„„Uses„  Crt, Dos;„„Procedure WriteXY(X, Y : Integer; S : String);„Function  GetCharXY(X, Y : Integer) : Char;„Procedure SHADE(PX, PY, QX, QY : Integer);„Procedure BOX(PX, PY, QX, QY : Integer);„Procedure SHADOWBOX(PX, PY, QX, QY : Integer; fg, bg : Byte);„„Implementation„„Procedure menubox(x1, y1, x2, y2 : Integer; fg, bg : Byte);„Var„  count : Integer;„begin„  TextColor(fg);„  TextBackGround(bg);„  Writexy(x1 + 1, y1, '…');„„  For count := x1 + 2 to x2 - 2 do„    Writexy(count, y1, 'Õ');„„  Writexy(x2 - 1, y1, 'ª');„  For count := y1 + 1 to y2 - 1 do„    Writexy(x1 + 1, count, '∫');„„  Writexy(x1 + 1, y2, '»');„  For count := y1 + 1 to y2 - 1 do„    Writexy(x2 - 1, count, '∫');„„  Writexy(x2 - 1, y2, 'º');„  For count := x1 + 2 to x2 - 2 do„    Writexy(count, y2, 'Õ');„end;„„Procedure WriteXY(X, Y : Integer; S : String);„Var„  SX, SY : Integer ;„begin„  SX := WhereX;„  SY := WhereY;„  GotoXY(X, Y);„  Write(S);„  GotoXY(SX, SY);„end;„„Function GetCharXY(X, Y : Integer) : Char;„Var„  Regs : Registers;„  SX, SY : Integer;„begin„  SX := WhereX;„  SY := WhereY;„  GotoXY(X, Y);„  Regs.AH := $08;„  Regs.BH := $00;„  Intr($10, Regs);„  GetCharXY := Char(Regs.AL);„  GotoXY(SX, SY);„end;„„Procedure SHADE(PX, PY, QX, QY : Integer);„Var„  X, Y : Integer;„begin„  TextColor(8);„  TextBackGround(black);„  For Y := PY to QY Do„  For X := PX to QX Do„    WriteXY(X, Y, GetCharXY(X, Y));„end;„„Procedure BOX(PX, PY, QX, QY : Integer);„begin„  Window(PX, PY, QX, QY);„  ClrScr;„end;„„Procedure SHADOWBOX(PX, PY, QX, QY: Integer; fg, bg : Byte);„begin„  TextColor(fg);„  TextBackGround(bg);„  BOX(PX, PY, QX, QY);„  Window(1, 1, 80, 25);„  SHADE(PX + 2, QY + 1, QX + 2, QY + 1);„  SHADE(QX + 2, PY + 1, QX + 2, QY + 1);„  SHADE(QX + 1, PY + 1, QX + 1, QY + 1);„  MENUBOX(PX, PY, QX, QY, fg, bg);„end;„„end.„„                                                                    10     11-02-9305:43ALL                      KELLY SMALL              Get TextAttr Colors      IMPORT              4      F…   {„KELLY SMALL„„>Get the foreground/background/blink attr out of TextAttr.„„Assuming you're using TP/BP:„}„„Procedure GetColor(Var f, b : Byte; Var BlinkOn : Boolean);„begin„  f := TextAttr And $F;„  b := (TextAttr Shr 4) And 7;„  BlinkOn := TextAttr And $80 = $80;„end;„                                                                                                                  11     11-21-9309:29ALL                      TIM SCHEMPP              Text DrawLine Functions  IMPORT              63     F…   { WRITTEN BY TIM SCHEMPP„  OCTOBER 21, 1993       }„„unit drawline;„„interface„„   procedure horizline(x1,x2,y:integer; default:char);„   procedure vertline(x,y1,y2:integer; default:char);„   procedure rectlines(x1,y1,x2,y2:integer; default:char);„„{ IF writetomemory IS SET TO TRUE, LINES WILL BE DRAWN AN AVERAGE OF„  ABOUT 15 TO 20 PERCENT FASTER THAN IF writetomemory IS SET TO FALSE.„  HOWEVER, IF DATA IS WRITTEN DIRECTLY TO VIDEO MEMORY, YOU ARE STUCK WITH„  THE SCREENS CURRENT COLORS (TEXTCOLOR AND TEXTBACKGROUND HAVE NO EFFECT).„  THE DEFAULT VALUE OF writetomemory IS FALSE. }„„var writetomemory:boolean;„„implementation„ uses crt; {for gotoxy, wherex and wherey}„„     const symbols:array[1..40] of char=„                      ('≥','¥','µ','∂','∑','∏','π','∫','ª','º','Ω','æ','ø',„                       '¿','¡','¬','√','ƒ','≈','∆','«','»','…',' ','À','Ã',„                       'Õ','Œ','œ','–','—','“','”','‘','’','÷','◊','ÿ','Ÿ',„                       '⁄');„„           codes:array[1..40] of string[4]=„                    ('1010','1011','1012','2021','0021','0012','2022','2020',„                     '0022','2002','2001','1002','0011','1100','1101','0111',„                     '1110','0101','1111','1210','2120','2200','0220','2202',„                     '0222','2220','0202','2222','1202','2101','0212','0121',„                     '2100','1200','0210','0120','2121','1212','1001','0110');„„            {THE SCREEN DIMENSIONS}„            screenwidth=80;   screenlength=25;„„{******}„„{READS A CHARACTER FROM VIDEO MEMORY AT THE GIVEN COORDINANTS}„function Memread(col,row:integer):char;„„  Const„    Seg = $B000; { Video memory address for color system  }„    Ofs = $8000; { For monochrome system, make Ofs = $0000 }„  Var„    SChar : Integer;„  Begin„          SChar := ((Row-1)*160) + ((Col-1)*2); { Compute starting location }„          memread:=chr(Mem[Seg:Ofs + SChar]);   { read character from memory}„  End;„„{******}„„{WRITES A CHARACTER DIRECTORY TO VIDEO MEMORY AT THE GIVEN COORDINATES}„{NOTE: THE CURRENT COLORS AT THE GIVEN COORDINANTS ARE USED FOR DRAWING.}„procedure Memwrite(col,row:integer; c:char);„„  Const„    Seg = $B000; { Video memory address for color system  }„    Ofs = $8000; { For monochrome system, make Ofs = $0000 }„  Var„    SChar : Integer;„  Begin„          SChar := ((Row-1)*160) + ((Col-1)*2); { Compute starting location }„          Mem[Seg:Ofs + SChar]:=ord(c);         { write character to memory}„  End;„„{******}„„   {PROCEDURE USED INTERNALLY TO CREATE A SET OF CHARACTER CODES}„   function getcode(c:char; direction:byte):char;„   var counter:integer;„   begin„    counter:=1;„    while (counter<=40) and (c<>symbols[counter]) do inc(counter);„    if counter>40 then getcode:='0' else getcode:=codes[counter,direction];„   end;„„{******}„„   {PROCEDURE DRAWS A LINE IN TEXT MODE FROM (X1,Y) TO (X2,Y)}„   {DEFAULT IS EITHER '1' OR '2' FOR SINGLE OF DOUBLE LINES}„   procedure horizline(x1,x2,y:integer; default:char);„„    var code:string[4];„        defaultchar:char;„        c,index:integer;„        xpos,ypos:integer;„„    begin„     xpos:=wherex; ypos:=wherey;„     if x2<x1 then begin c:=x1; x1:=x2; x2:=c; end;„     if default='1' then defaultchar:=symbols[18]„                    else defaultchar:=symbols[27];„     for c:=x1 to x2 do„      begin„       code:='0000';„       if y<>0 then code[1]:=getcode(memread(c,y-1),3) else code[1]:='0';„       if (c=x2) and (x2=screenwidth) then code[2]:='0'„          else if (c=x2) then code[2]:=getcode(memread(x2+1,y),4)„                         else code[2]:=default;„       if y<>screenlength then code[3]:=getcode(memread(c,y+1),1)„                          else code[3]:='0';„       if (c=x1) and (x1=1) then code[4]:='0'„          else„           if (c=x1) then code[4]:=getcode(memread(x1-1,y),2)„                     else code[4]:=default;„       index:=1;„       while (index<=40) and (code<>codes[index]) do inc(index);„       if writetomemory then„         if index>40 then memwrite(c,y,defaultchar)„                     else memwrite(c,y,symbols[index])„                   else„         if index>40 then begin gotoxy(c,y); write(defaultchar); end„                     else begin gotoxy(c,y); write(symbols[index]); end;„      end; {counter}„      if not writetomemory then gotoxy(xpos,ypos);„   end;„„{******}„„   {PROCEDURE DRAWS A LINE IN TEXT MODE FROM (X,Y1) TO (X,Y2)}„   {DEFAULT IS EITHER '1' OR '2' FOR SINGLE OF DOUBLE LINES}„   procedure vertline(x,y1,y2:integer; default:char);„„    var code:string[4];„        defaultchar:char;„        c,index:integer;„        xpos,ypos:integer;„„    begin„     xpos:=wherex; ypos:=wherey;„     if y2<y1 then begin c:=y1; y1:=y2; y2:=c; end;„     if default='1' then defaultchar:=symbols[1]„                    else defaultchar:=symbols[8];„     for c:=y1 to y2 do„      begin„       code:='0000';„       if (c=y2) and (y2=screenlength) then code[3]:='0'„          else if (c=y2) then code[3]:=getcode(memread(x,y2+1),1)„                         else code[3]:=default;„       if x<>screenwidth then code[2]:=getcode(memread(x+1,c),4)„                         else code[1]:='0';„       if x<>1 then code[4]:=getcode(memread(x-1,c),2)„               else code[1]:='0';„       if (c=y1) and (y1=0) then code[1]:='0'„          else if (c=y1) then code[1]:=getcode(memread(x,y1-1),3)„                         else code[1]:=default;„       index:=1;„       while (index<=40) and (code<>codes[index]) do inc(index);„„       if writetomemory then„             if index>40 then memwrite(x,c,defaultchar)„                         else memwrite(x,c,symbols[index])„                        else„             if index>40 then begin gotoxy(x,c); write(defaultchar) end„                         else begin gotoxy(x,c); write(symbols[index]); end;„      end; {counter}„     if not writetomemory then gotoxy(xpos,ypos);„    end;„„{******}„„   {PROCEDURE DRAWS A RECTANGLE IN TEXT MODE}„   {DEFAULT IS EITHER '1' OR '2' FOR SINGLE OF DOUBLE LINES}„   procedure rectlines(x1,y1,x2,y2:integer; default:char);„„   begin„    horizline(x1,x2,y1,default);„    horizline(x1,x2,y2,default);„    vertline(x1,y1,y2,default);„    vertline(x2,y1,y2,default);„   end;„„{******}„„ begin„  writetomemory:=false;„ end. {unit}„„„ {-------------------   DEMO PROGRAM ------------------------}„ { ----------------      CUT HERE  --------------------------}„„ { WRITTEN BY TIM SCHEMPP„  OCTOBER 21, 1993       }„„   {THIS PROGRAM DEMONSTARTES THE USE OF THE UNIT drawline.  UNIT DRAWLINE„    WILL USE THE ASCII SET TO DRAW LINES.  WHEN LINE INTERSECTIONS ARE„    FOUND, THE PROCEDURES DESCIDE WHICH CHARACTER FITS BEST.  THUS MAKING„    IT VERY EASY TO CREATE VARIOUS TABLES AND OTHER SCREEN SET UPS.  THE„    UNIT ALSO HAS THE ABILITY TO WRITE DIRECTORY TO VIDEO MEMORY FOR„    A 15% TO 20% IMPROVEMENT IN SPEED.  SEE DRAWLINE.DOC FOR MORE INFO.}„„program demo;„„ uses crt,drawline;„„ var counter:integer;„„ begin„  {SET THE SCREEN UP}„  textbackground(black);„  textcolor(white);„  clrscr;„„  {THE CALL TO CLEAR SCREEN FILLED THE SCREEN WITH SPACES WITH A BLACK„   BACKGROUND AND A WHITE FOREGROUND.  IF writetomemory IS SET TO TRUE,„   ALL OF THE OUTPUT WILL BE WRITTEN WITH A BLACK BACKGROUND AND A WHITE„   FOREGROUND REGARDLESS OF TEXT ATTRIBUTE CHANGES.}„„  {writetomemory:=true;} { <--- ADD THIS STATEMENT AND SEE COLOR DIFFERENCE}„„  {WRITE SOME TEXT}„   gotoxy(22,6);„   textcolor(lightblue);„   write('LINE DRAWING DEMONSTARTATION PROGRAM');„   textcolor(yellow);„  {DRAW A RECTANGLE WITH DOUBLE LINES}„  rectlines(10,4,70,20,'2');„  {DRAW SOME HORIZONTAL SINGLE LINES}„  for counter:=9 to 19 do„   horizline(10,70,counter,'1');„  {DRAW SOME SINGLE VERTICLE LINES}„   counter:=20;„   while counter<=60 do„    begin„     vertline(counter,8,20,'1');„     inc(counter,10);„    end; {WHILE}„  {DRAW ONE LAST HORIZONTAL DOUBLE LINE}„   horizline(10,70,8,'2');„„  repeat until keypressed;„ end.   12     02-03-9410:59ALL                      DAVID DAHL               Graphics Win in Text ModeIMPORT              105    F…   {„ STG>Does anyone know off hand if I can be in text mode and window in a„ STG>window and put the wondow only in graphics mode?„ STG>I have a program that I need to have a graph in.  Does anyone have some„ STG>code for using the PLOT procedure to plot variables.  The values for„ STG>the Y axis are from 1 - 2000, and for the X axis from 1 - 24.„„        Yes, it's possible... sort of.   If you have a VGA (or„EGA) you can have 2 separate character sets on screen at once.„Use one character set for text, and redefine the other for your„graphics window.  The only problem is that your graphics window„can only be composed of 256 characters total.  So, a 16 X 16„character square would only give you a vertical resolution of 256„pixels and a horizontal resolution of 128 pixels.  The following„code is an example of how one would do this.„„                                                Dave„„}„„Program GraphicsInTextModeExample;„„{================================================„„         Graphics In Text Mode Example„            Programmed by David Dahl„                    12/24/93„    This program and source are PUBLIC DOMAIN„„ ------------------------------------------------„„   This example uses a second font as a pseudo-„   graphics window.  This program requires VGA.„„ ================================================}„„Uses  CRT;„„Const { Dimentions of The Graphics Window in Characters }„      ChrSizeX = 32;„      ChrSizeY = 256 DIV ChrSizeX;„      { Dimentions of The Graphics Window in Pixels }„      MaxX     = ChrSizeX * 8;„      MaxY     = ChrSizeY * 16;„„{-[ Set Character Width to 8 Pixels ]-------------------------------------}„Procedure SetCharWidthTo8; Assembler;„Asm„   { Change To 640 Horz Res }„   MOV DX, $3CC„   IN  AL, DX„   AND AL, Not(4 OR 8)„   MOV DX, $3C2„   OUT DX, AL„   { Turn Off Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 0„   OUT DX, AL„   { Reset Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„   { Switch To 8 Pixel Wide Fonts }„   MOV DX, $3C4„   MOV AL, 1„   OUT DX, AL„   MOV DX, $3C5„   IN  AL, DX„   OR  AL, 1„   OUT DX, AL„   { Turn Off Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 0„   OUT DX, AL„   { Reset Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„   { Center Screen }„   MOV DX, $3DA„   IN  AL, DX„   MOV DX, $3C0„   MOV AL, $13 OR 32„   OUT DX, AL„   MOV AL, 0„   OUT DX, AL„End;„{-[ Turn On Dual Fonts ]--------------------------------------------------}„Procedure SetDualFonts; Assembler;„ASM„   { Set Fonts 0 & 1 }„   MOV BL, 4„   MOV AX, $1103„   INT $10„END;„{-[ Turn On Access To Font Memory ]---------------------------------------}„Procedure SetAccessToFontMemory; Assembler;„ASM„   { Turn Off Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 1„   OUT DX, AL„   { Reset Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„   { Change From Odd/Even Addressing to Linear }„   MOV DX, $3C4„   MOV AL, 4„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 7„   OUT DX, AL„   { Switch Write Access To Plane 2 }„   MOV DX, $3C4„   MOV AL, 2„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 4„   OUT DX, AL„   { Set Read Map Reg To Plane 2 }„   MOV DX, $3CE„   MOV AL, 4„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 2„   OUT DX, AL„   { Set Graphics Mode Reg }„   MOV DX, $3CE„   MOV AL, 5„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 0„   OUT DX, AL„   { Set Misc. Reg }„   MOV DX, $3CE„   MOV AL, 6„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 12„   OUT DX, AL„End;„{-[ Turn On Access to Text Memory ]---------------------------------------}„Procedure SetAccessToTextMemory; Assembler;„ASM„   { Turn Off Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 1„   OUT DX, AL„   { Reset Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„   { Change To Odd/Even Addressing }„   MOV DX, $3C4„   MOV AL, 4„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„   { Switch Write Access }„   MOV DX, $3C4„   MOV AL, 2„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3  {?}„   OUT DX, AL„   { Set Read Map Reg }„   MOV DX, $3CE„   MOV AL, 4„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 0„   OUT DX, AL„   { Set Graphics Mode Reg }„   MOV DX, $3CE„   MOV AL, 5„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, $10„   OUT DX, AL„   { Set Misc. Reg }„   MOV DX, $3CE„   MOV AL, 6„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 14„   OUT DX, AL„End;„{-[ Clear The Pseudo-Graphics Window by Clearing Font Definition ]--------}„Procedure ClearGraphicsWindow;„Begin„     SetAccessToFontMemory;„     FillChar (MEM[$B800:$4000], 32 * 256, 0);„     SetAccessToTextMemory;„End;„{-[ Turn The Cursor Off ]-------------------------------------------------}„Procedure TurnCursorOff; Assembler;„ASM„   MOV DX, $3D4„   MOV AL, $0A„   OUT DX, AL„   MOV DX, $3D5„   IN  AL, DX„   OR  AL, 32„   OUT DX, AL„End;„{-[ Turn The Cursor On ]--------------------------------------------------}„Procedure TurnCursorOn; Assembler;„ASM„   MOV DX, $3D4„   MOV AL, $0A„   OUT DX, AL„   MOV DX, $3D5„   IN  AL, DX„   AND AL, Not(32)„   OUT DX, AL„End;„{-[ Set Up The Pseudo-Graphics Window ]-----------------------------------}„Procedure SetGraphicsWindow (XCoord, YCoord    : Byte;„                             Color, BackGround : Byte);„Var CounterX,„    CounterY  : Byte;„Begin„     For CounterY := 0 to (ChrSizeY-1) do„         For CounterX := 0 to (ChrSizeX-1) do„             MEMW[$B800:CounterX*2 + XCoord*2 + (YCoord * 80 * 2) +„                 (CounterY * 80 * 2)] :=„                   (CounterX + CounterY * ChrSizeX) OR„                   (((Color OR 8) OR ((BackGround AND 15) SHL 4)) SHL 8);„End;„{-[ Plot a Pixel in The Pseudo-Graphics Window ]--------------------------}„Procedure PutPixel (Xin, Yin : Word);„Var RealY,„    RealX      : Word;„Begin„     If (Xin < MaxX) AND„        (Yin < MaxY)„     Then„     Begin„          RealX := (Xin DIV 8) * 32;„          RealY := (Yin MOD 16) + ((Yin DIV 16) * (32 * ChrSizeX));„          SetAccessToFontMemory;„          MEM[$B800:$4000 + RealX + RealY] :=„              MEM[$B800:$4000 + RealX + RealY] OR (128 SHR (Xin MOD 8));„          SetAccessToTextMemory;„     End;„End;„{-[ Draw A Line ]---------------------------------------------------------}„{ OCTANT DDA Subroutine converted from the BASIC listing on pages 26 - 27 }„{ from the book _Microcomputer_Displays,_Graphics,_ And_Animation_ by     }„{ Bruce A. Artwick                                                        }„Procedure Line (XStart, YStart, XEnd, YEnd : Word);„Var StartX,„    StartY,„    EndX,„    EndY    : Word;„    DX,„    DY      : Integer;„    CNTDWN  : Integer;„    Errr    : Integer;„    Temp    : Integer;„    NotDone : Boolean;„Begin„     NotDone := True;„     StartX := XStart;„     StartY := YStart;„     EndX   := XEnd;„     EndY   := YEnd;„     If EndX < StartX Then„     Begin„          { Mirror Quadrants 2,3 to 1,4 }„          Temp   := StartX;„          StartX := EndX;„          EndX   := Temp;„          Temp   := StartY;„          StartY := EndY;„          EndY   := Temp;„     End;„     DX := EndX - StartX;„     DY := EndY - StartY;„     If DY < 0 Then„     Begin„          If -DY > DX Then„          Begin„               { Octant 7 Line Generation }„               CntDwn := -DY + 1;„               ERRR   := -(-DY shr 1);   {Fast Divide By 2}„               While NotDone do„               Begin„                    PutPixel (StartX, StartY);„                    Dec (CntDwn);„                    If CntDwn <= 0„                    Then NotDone := False„                    Else„                    Begin„                         Dec(StartY);„                         Inc(Errr, DX);„                         If Errr >= 0 Then„                         Begin„                              Inc(StartX);„                              Inc(Errr, DY);„                         End;„                    End;„               End;„          End„          Else„          Begin„               { Octant 8 Line Generation }„               CntDwn := DX + 1;„               ERRR   := -(DX shr 1);   {Fast Divide By 2}„               While NotDone do„               Begin„                    PutPixel (StartX, StartY);„                    Dec (CntDwn);„                    If CntDwn <= 0„                    Then NotDone := False„                    Else„                    Begin„                         Inc(StartX);„                         Dec(Errr, DY);„                         If Errr >= 0 Then„                         Begin„                              Dec(StartY);„                              Dec(Errr, DX);„                         End;„                    End;„               End;„          End;„     End„     Else If DY > DX Then„          Begin„               { Octant 2 Line Generation }„               CntDwn := DY + 1;„               ERRR   := -(DY shr 1);   {Fast Divide By 2}„               While NotDone do„               Begin„                    PutPixel (StartX, StartY);„                    Dec (CntDwn);„                    If CntDwn <= 0„                    Then NotDone := False„                    Else„                    Begin„                         Inc(StartY);„                         Inc(Errr, DX);„                         If Errr >= 0 Then„                         Begin„                              Inc(StartX);„                              Dec(Errr, DY);„                         End;„                    End;„               End;„          End„          Else„          { Octant 1 Line Generation }„          Begin„               CntDwn := DX + 1;„               ERRR   := -(DX shr 1);   {Fast Divide By 2}„               While NotDone do„               Begin„                    PutPixel (StartX, StartY);„                    Dec (CntDwn);„                    If CntDwn <= 0„                    Then NotDone := False„                    Else„                    Begin„                         Inc(StartX);„                         Inc(Errr, DY);„                         If Errr >= 0 Then„                         Begin„                              Inc(StartY);„                              Dec(Errr, DX);„                         End;„                    End;„               End;„          End;„End;„{-[ Draw A Circle ]-----------------------------------------------------}„{ Algorithm based on the Pseudocode from page 83 of the book _Advanced  }„{ Graphics_In_C_ by Nelson Johnson                                      }„Procedure Circle (XCoord, YCoord, Radius : Integer);„Var   d     : Integer;„      X, Y  : Integer;„    Procedure Symmetry (xc, yc, x, y : integer);„    Begin„         PutPixel ( X+xc,  Y+yc);„         PutPixel ( X+xc, -Y+yc);„         PutPixel (-X+xc, -Y+yc);„         PutPixel (-X+xc,  Y+yc);„         PutPixel ( Y+xc,  X+yc);„         PutPixel ( Y+xc, -X+yc);„         PutPixel (-Y+xc, -X+yc);„         PutPixel (-Y+xc,  X+yc);„    End;„Begin„     x := 0;„     y := abs(Radius);„     d := 3 - 2 * y;„     While (x < y) do„     Begin„          Symmetry (XCoord, YCoord, x, y);„          if (d < 0) Then„             inc(d, (4 * x) + 6)„          else„          Begin„               inc (d, 4 * (x - y) + 10);„               dec (y);„          End;„          inc(x);„     End;„     If x = y then„        Symmetry (XCoord, YCoord, x, y);„End;„{-[ Draw A Rectangle ]----------------------------------------------------}„Procedure Rectangle (X1, Y1, X2, Y2 : Word);„Begin„     { Draw Top Of Box }„     Line (X1, Y1, X2, Y1);„     { Draw Right Side Of Box }„     Line (X2, Y1, X2, Y2);„     { Draw Left Side Of Box }„     Line (X1, Y1, X1, Y2);„     { Draw Botton Of Box }„     Line (X1, Y2, X2, Y2);„End;„{=[ Main Program ]========================================================}„„Var C : Word;„    Key : Char;„Begin„„     TextMode (C80);„     TurnCursorOff;„     SetCharWidthTo8;„     SetDualFonts;„     ClearGraphicsWindow;„     TextColor(LightGray);„     ClrScr;„„     SetGraphicsWindow (40, 0, White, Blue);   {X, Y, Color, BGColor}„„     Writeln ('Graphics In Text Mode Example');„     Writeln ('Programmed by David Dahl');„     Writeln ('This is PUBLIC DOMAIN');„     Writeln;„     Writeln ('The graphics window to the right is');„     Writeln ('made up of custom characters of the');„     Writeln ('second font.');„     Writeln;„     Writeln ('There are four graphics primitives');„     Writeln ('available in this example program.');„     Writeln ('Circle, Line, PutPixel, and ');„     Writeln ('Rectangle are avaiable for your own');„     Writeln ('use.');„     Writeln;„„     Randomize;„     For C := 1 to 10 do„     Begin„          Line (Random(MaxX), Random(MaxY),„                Random(MaxX), Random(MaxY));„„          Circle (Random(MaxX), Random(MaxY), Random(30));„„          Rectangle (Random(MaxX), Random(MaxY),„                     Random(MaxX), Random(MaxY));„     End;„„     Writeln ('Press [RETURN] to exit.');„     Readln;„     TurnCursorOn;„     TextMode (C80);„End.„                                                                                                                             13     05-26-9407:31ALL                      SWAG SUPPORT TEAM        Small Window Unit        SWAG9405            26     F…   „unit windows;„„interface„uses crt;„„procedure sh;„procedure sn;„procedure Drawbox(x1,y1,x2,y2: byte);„procedure PopWindow(x1,y1,x2,y2: byte);„procedure CloseWindow;„procedure Drawshadowbox(x1,y1,x2,y2: byte);„procedure shh;„procedure snn;„„const„ color: boolean = true;„„type„ windowtype = record„               x1,x2,y1,y2: byte;„               scrsave: array[1..4096] of byte;„              end;„ scrarray= array[1..4096] of byte;„ scrptr= ^scrarray;„const„ screenbase: word =$B800;„var„ numwindows: byte;„ ws: array[1..3] of windowtype;„ cursorpos: integer;„ fileabs: array[1..20] of word;„ searchdir: byte;„ searchwild: string;„ searchdate: string;„ searchuploader: string;„ searchsize: longint;„ searchtext: string;„ numindex: word;„ sortprimary,sortsecondary: byte;„ filelow: longint;„ numentries: byte;„„procedure textcolor(i: byte);„procedure textbackground(i: byte);„„implementation„„procedure Textcolor(i: byte);„begin;„ if color then crt.textcolor(i) else begin;„  case i of„    0: crt.textcolor(0);„    7: crt.textcolor(7);„   11..15: crt.textcolor(15);„  end;„ end;„end;„„procedure TextBackGround(i: byte);„begin;„ if color then crt.textbackground(i) else begin;„  case i of„   0..6: crt.textbackground(0);„   7: crt.textbackground(7);„  end;„ end;„end;„„procedure sh;„begin;„ if color then begin;„  textcolor(blue);„  textbackground(7);„ end else begin;„  textcolor(0);„  textbackground(7);„ end;„end;„„procedure sn;„begin;„ textcolor(white);„ textbackground(blue);„end;„„procedure Drawbox(x1,y1,x2,y2: byte);„var„ x,y: byte;„begin;„ gotoxy(x1,y1);„ for x:=x1+1 to x2 do write('Õ');„ gotoxy(x1,y2);„ for x:=x1+1 to x2 do write('Õ');„ for y:=y1+1 to y2-1 do begin;„  gotoxy(x1,y);„  write('≥');„  gotoxy(x2,y);„  write('≥');„ end;„ gotoxy(x1,y1);„ write('’');„ gotoxy(x2,y1);„ write('∏');„ gotoxy(x1,y2);„ write('‘');„ gotoxy(x2,y2);„ write('æ');„end;„„procedure PopWindow(x1,y1,x2,y2: byte);„begin;„ inc(numwindows);„ ws[numwindows].x1:=lo(windmin)+1;„ ws[numwindows].x2:=lo(windmax)+1;„ ws[numwindows].y1:=hi(windmin)+1;„ ws[numwindows].y2:=hi(windmax)+1;„ move(mem[screenbase:0000],ws[numwindows].scrsave,4096);„ window(1,1,80,25);„ drawbox(x1,y1,x2,y2);„ window(x1+1,y1+1,x2-1,y2-1);„end;„„procedure CloseWindow;„begin;„ move(ws[numwindows].scrsave,mem[screenbase:0000],4096);„ window(ws[numwindows].x1,ws[numwindows].y1,ws[numwindows].x2,ws[numwindows].y2);„ dec(numwindows);„end;„„procedure Drawshadowbox(x1,y1,x2,y2: byte);„var„ x,y: byte;„begin;„ textbackground(0);„ textcolor(7);„ gotoxy(x1,y1);„ for x:=x1+1 to x2 do write('Õ');„ gotoxy(x1,y2);„ for x:=x1+1 to x2 do write('Õ');„ for y:=y1+1 to y2-1 do begin;„  gotoxy(x1,y);„  write('≥');„  gotoxy(x2,y);„  write('≥');„ end;„ gotoxy(x1,y1);„ write('’');„ gotoxy(x2,y1);„ write('∏');„ gotoxy(x1,y2);„ write('‘');„ gotoxy(x2,y2);„ write('æ');„ textcolor(7);„ textbackground(0);„ for y:=y1+1 to y2+1 do begin;„  gotoxy(x2+1,y);„  write(' ');„ end;„ for x:=x1+1 to x2+1 do begin;„  gotoxy(x,y2+1);„  write(' ');„ end;„end;„„procedure shh;„begin;„ textcolor(0);„ textbackground(7);„end;„„procedure snn;„begin;„ textcolor(7);„ textbackground(0);„end;„„end.                                                                          