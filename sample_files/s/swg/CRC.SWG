SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00016         16/32 BIT CRC ROUTINES                                            1      05-28-9313:35ALL                      SWAG SUPPORT TEAM        16BITCRC Routines        IMPORT              6      N0à0 {„>I'm looking For code to calculate the CRC32 of a series of Characters.„„  ...Unless you're CRCing a very large amount of data, this CRC-16„  routine should do.„„  NOTE: This routine requires either TP6 or TP7 to compile.„}„„{ Return a 16-bit CRC number For binary data. }„„Function Crc16(Var Data; wo_Size : Word) : Word; Assembler;„Asm„  push   ds„  xor    dx, dx„  lds    si, Data„  mov    bx, wo_Size„@L1:„  xor    ah, ah„  lodsb„  mov    cx, 8„  shl    ax, cl„  xor    dx, ax„  mov    cx, 8„@L2:„  shl    dx, 1„  jnc    @L3„  xor    dx, $1021„@L3:„  loop   @L2„  dec    bx„  jnz    @L1„  pop    ds„  mov    ax, dx„end; { Crc16. }    2      05-28-9313:35ALL                      SWAG SUPPORT TEAM        File CHECKSUM            IMPORT              21     N08© {nice Program/utility which can be used to check the 'sorted' File and the data„File. It produces the Byte CheckSum of the Files (which must be identical), and„can check the sortorder of the File (when given the option -s)...„}„{$A+,B-,D-,F-,G+,I-,L-,N-,O-,R-,S+,V-,X-}„{$M 16384,0,655360}„{ Here is the Program CHECKSUM that you can run to check the master data„  File For TeeCee's String sorting contest. if you have a slow machine I„  suggest you set the Program running and go to bed!! :-)„„  Code size: 5952 Bytes„  Data size:  924 Bytes„  .EXE size: 6304 Bytes„}„Uses Crt;„Const„  Version = 'CheckSum 1.0 (c) 1992 DwarFools & Consultancy, '+„                                  'by drs. Robert E. Swart'#13#10;„  Usage = 'Usage: CheckSum dataFile [-s]'#13#10 +„   '       Options: -s to check the sortorder of the Strings'#13#10;„  MaxStr = 30;„  Error: LongInt = 0;„  Records: LongInt = 0;„  CheckSum: Byte = 0;   { Byte CheckSum of all Bytes in data File xor'ed }„  Sortorder: Boolean = False;            { Assume option -s is not given }„„Var Str: String[MaxStr];„    len: Byte Absolute Str;„    ByteStr: Array[0..MaxStr] of Byte Absolute Str;„    PrevStr,UpperStr: String[MaxStr];„    f: File;„    i: Integer;„„begin„  Writeln(Version);„  if ParamCount = 0 then„  begin„    Writeln(Usage);„    Halt„  end;„„  assign(f,ParamStr(1)); { Change this to your chosen File name }„  reset(f,1);„  if Ioresult <> 0 then„  begin„    Writeln('Error: could not open ',ParamStr(1));„    Writeln(Usage);„    Halt(1)„  end;„„  if (ParamCount = 2) and„    ((ParamStr(2) = '-s') or (ParamStr(2) = '-S')) then Sortorder := True;„„  Writeln('Strings x 1000 checked:');„  While not eof(f) do„  begin„    BlockRead(f,len,1);„    BlockRead(f,Str[1],len);„    For i:=0 to len do CheckSum := CheckSum xor ByteStr[i];„    if Sortorder then„    begin„      UpperStr[0] := Str[0];„      For i:=1 to len do UpperStr[i] := UpCase(Str[i]);„      if Records > 0 then„      begin„        if PrevStr > UpperStr then„        begin„          Inc(Error);„          Writeln;„          Writeln('Error: ',PrevStr,' > ',UpperStr);„        end;„        PrevStr := UpperStr„      end„    end;„    Inc(Records);„    if (Records mod 1000) = 0 then„    begin„      GotoXY(1,WhereY);„      Write(Records div 1000:3);„    end„  end;„  close(f);„  Writeln;„  Write(Records,' Strings checked, ');„  if Sortorder then Writeln(Error,' Errors found, ');„  Writeln('Byte CheckSum = ',CheckSum)„end.„                                                                                                          3      05-28-9313:35ALL                      SWAG SUPPORT TEAM        16 BIT CRC               IMPORT              35     N0› {„ The following is a Turbo/Quick Pascal Implementation of calculating„ the XModem Type of 16-bit cyclic redundancy checking (CRC).„„ Is there a preference For the language of the next CRC-16 example„ (80x86 Assembly, BASIC, or C) ?„}„„(*******************************************************************)„Program TPCRC16;    { Compiler: TurboPascal 4.0+ & QuickPascal 1.0+ }„{ Turbo Pascal 16-bit Cyclic Redundancy Checking (CRC) a.la. XModem }„{ Greg Vigneault, Box 7169, Station A, toronto, Canada M5W 1X8.     }„„Const   Beep        = #7;                       { ASCII bell tone   }„Type    bArray      = Array [1..$4000] of Byte; { define buffer     }„        bPointer    = ^bArray;                  { Pointer to buffer }„Var     DataPtr     : bPointer;                 { Pointer to data   }„        fName       : String;                   { File name         }„        fHandle     : File;                     { File handle       }„        BytesIn     : Word;                     { For counting data }„        CRC16       : Integer;                  { running CRC-16    }„„{-------------------------------------------------------------------}„ Procedure WriteHex( raw : Integer );   { display hexadecimal value }„    Var ch      : Char;„        shft    : Byte;„    begin„        if (raw = 0) then Write('0')            { if zero           }„        else begin„            shft := 16;                         { bit count         }„            Repeat  { isolate each hex nibble, and convert to ASCII }„                DEC( shft, 4 );                 { shift by nibble   }„                ch := CHR( raw SHR shft and $F or orD('0') ); {0..9 }„                if (ch > '9') then inC( ch, 7 );              {A..F }„                Write( ch );                    { display the digit }„            Until (shft = 0);„        end;„    end {WriteHex};„„{-------------------------------------------------------------------}„ Function UpdateCRC16(CRC       : Integer;      { CRC-16 to update  }„                      InBuf     : bPointer;     { Pointer to data   }„                      InLen     : Integer) :Integer;  { data count  }„    Var Bit, ByteCount          : Integer;„        Carry                   : Boolean;      { catch overflow    }„    begin„    For ByteCount := 1 to InLen do              { all data Bytes    }„        For Bit := 7 doWNto 0 do begin          { 8 bits per Byte   }„            Carry := CRC and $8000 <> 0;        { shift overlow?    }„            CRC := CRC SHL 1 or InBuf^[ByteCount] SHR Bit and 1;„            if Carry then CRC := CRC xor $1021; { apply polynomial  }„        end; { For Bit & ByteCount }            { all Bytes & bits  }„    UpdateCRC16 := CRC;                         { updated CRC-16    }„    end {UpdateCRC16};„„{-------------------------------------------------------------------}„begin„    if ( MaxAvail < Sizeof(bArray) ) then begin { check For memory  }„        WriteLn( 'not enough memory!', Beep );„        Halt(1);„    end;„    if (ParamCount <> 1) then begin             { File name input?  }„        WriteLn( 'Use TPCRC16 <fName>', Beep );;„        Halt(2);„    end;„    fName := ParamStr(1);                       { get File name     }„    Assign( fHandle, fName );                   { open the File     }„    {$i-} Reset( fHandle, 1 ); {$i+}            { open succeeded?   }„    if (IoResult <> 0) then begin               { if not ...        }„        WriteLn( 'File access ERRor', Beep );„        Halt(3);„    end;„    New( DataPtr );                             { allocate memory   }„    CRC16 := 0;                                 { initialize CRC-16 }„    Repeat„        BlockRead( fHandle, DataPtr^[1], Sizeof(bArray), BytesIn );„        CRC16 := UpdateCRC16( CRC16, DataPtr, BytesIn );„    Until (BytesIn <> Sizeof(bArray)) or Eof(fHandle);„    Close( fHandle );                           { close input File  }„    DataPtr^[1] := 0; DataPtr^[2] := 0;         { insert two nulls  }„    CRC16 := UpdateCRC16( CRC16, DataPtr, 2 );  { For final calc    }„    Dispose( DataPtr );                         { release memory    }„    Write( 'The CRC-16 of File ', fName, ' is $' );„    WriteHex( CRC16 );  WriteLn;„„end {TPCRCXMO}.„(*********************************************************************)„                                                                                          4      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Another 16Bit CRC        IMPORT              27     N0† Unit Crc16;„Interface„{ Note: Your crc Variable must be initialized to 0, before       }„{       using tis routine.                                       }„{ Translated to Turbo Pascal (tm) V4.0 March, 1988 by J.R.Louvau }„{                                                                }„Function UpdCrc(cp: Byte; crc: Word): Word;„„Implementation„„(* crctab calculated by Mark G. Mendel, Network Systems Corporation *)„Const crctab : Array[0..255] of Word = („    $0000,  $1021,  $2042,  $3063,  $4084,  $50a5,  $60c6,  $70e7,„    $8108,  $9129,  $a14a,  $b16b,  $c18c,  $d1ad,  $e1ce,  $f1ef,„    $1231,  $0210,  $3273,  $2252,  $52b5,  $4294,  $72f7,  $62d6,„    $9339,  $8318,  $b37b,  $a35a,  $d3bd,  $c39c,  $f3ff,  $e3de,„    $2462,  $3443,  $0420,  $1401,  $64e6,  $74c7,  $44a4,  $5485,„    $a56a,  $b54b,  $8528,  $9509,  $e5ee,  $f5cf,  $c5ac,  $d58d,„    $3653,  $2672,  $1611,  $0630,  $76d7,  $66f6,  $5695,  $46b4,„    $b75b,  $a77a,  $9719,  $8738,  $f7df,  $e7fe,  $d79d,  $c7bc,„    $48c4,  $58e5,  $6886,  $78a7,  $0840,  $1861,  $2802,  $3823,„    $c9cc,  $d9ed,  $e98e,  $f9af,  $8948,  $9969,  $a90a,  $b92b,„    $5af5,  $4ad4,  $7ab7,  $6a96,  $1a71,  $0a50,  $3a33,  $2a12,„    $dbfd,  $cbdc,  $fbbf,  $eb9e,  $9b79,  $8b58,  $bb3b,  $ab1a,„    $6ca6,  $7c87,  $4ce4,  $5cc5,  $2c22,  $3c03,  $0c60,  $1c41,„    $edae,  $fd8f,  $cdec,  $ddcd,  $ad2a,  $bd0b,  $8d68,  $9d49,„    $7e97,  $6eb6,  $5ed5,  $4ef4,  $3e13,  $2e32,  $1e51,  $0e70,„    $ff9f,  $efbe,  $dfdd,  $cffc,  $bf1b,  $af3a,  $9f59,  $8f78,„    $9188,  $81a9,  $b1ca,  $a1eb,  $d10c,  $c12d,  $f14e,  $e16f,„    $1080,  $00a1,  $30c2,  $20e3,  $5004,  $4025,  $7046,  $6067,„    $83b9,  $9398,  $a3fb,  $b3da,  $c33d,  $d31c,  $e37f,  $f35e,„    $02b1,  $1290,  $22f3,  $32d2,  $4235,  $5214,  $6277,  $7256,„    $b5ea,  $a5cb,  $95a8,  $8589,  $f56e,  $e54f,  $d52c,  $c50d,„    $34e2,  $24c3,  $14a0,  $0481,  $7466,  $6447,  $5424,  $4405,„    $a7db,  $b7fa,  $8799,  $97b8,  $e75f,  $f77e,  $c71d,  $d73c,„    $26d3,  $36f2,  $0691,  $16b0,  $6657,  $7676,  $4615,  $5634,„    $d94c,  $c96d,  $f90e,  $e92f,  $99c8,  $89e9,  $b98a,  $a9ab,„    $5844,  $4865,  $7806,  $6827,  $18c0,  $08e1,  $3882,  $28a3,„    $cb7d,  $db5c,  $eb3f,  $fb1e,  $8bf9,  $9bd8,  $abbb,  $bb9a,„    $4a75,  $5a54,  $6a37,  $7a16,  $0af1,  $1ad0,  $2ab3,  $3a92,„    $fd2e,  $ed0f,  $dd6c,  $cd4d,  $bdaa,  $ad8b,  $9de8,  $8dc9,„    $7c26,  $6c07,  $5c64,  $4c45,  $3ca2,  $2c83,  $1ce0,  $0cc1,„    $ef1f,  $ff3e,  $cf5d,  $df7c,  $af9b,  $bfba,  $8fd9,  $9ff8,„    $6e17,  $7e36,  $4e55,  $5e74,  $2e93,  $3eb2,  $0ed1,  $1ef0„);„„(*„ * updcrc derived from article Copyright (C) 1986 Stephen Satchell.„ *  NOTE: First argument must be in range 0 to 255.„ *        Second argument is referenced twice.„ *„ * Programmers may incorporate any or all code into their Programs,„ * giving proper credit within the source. Publication of the„ * source routines is permitted so long as proper credit is given„ * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg,„ * Omen Technology.„ *)„Function UpdCrc(cp: Byte; crc: Word): Word;„begin { UpdCrc }„  UpdCrc := crctab[((crc SHR 8) and 255)] xor (crc SHL 8) xor cp„end;„„end. {Unit}„                                                                                                                    5      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Checksum/16/32 CRC       IMPORT              72     N0Åh { Default Compiler Directives}„{$S-,R-,V-,I-,N-,B-,F-}„„{$IFNDEF Ver40}„  {Allow overlays}„  {$F+,O-,X+,A-}„{$ENDIF}„„UNIT CRC;„„INTERFACE„„function UpdateChecksum(CurByte : Byte; CheckSum : Word) : Word;„  {-Returns an updated checksum}„„function UpdateCrc(CurByte : Byte; CurCrc : Word) : Word;„  {-Returns an updated Crc16}„„FUNCTION UPDateCrcReverse (curByte : BYTE; CurCRC : WORD) : WORD;„  { -returns reversed crc16}„„function UpdateCrcKermit(CurByte : Byte; CurCrc : Word) : Word;„  {-Returns an updated Crc16 (kermit style)}„„const„  Crc32Table : array[0..255] of LongInt = („  $00000000, $77073096, $ee0e612c, $990951ba, $076dc419, $706af48f, $e963a535,„  $9e6495a3, $0edb8832, $79dcb8a4, $e0d5e91e, $97d2d988, $09b64c2b, $7eb17cbd,„  $e7b82d07, $90bf1d91, $1db71064, $6ab020f2, $f3b97148, $84be41de, $1adad47d,„  $6ddde4eb, $f4d4b551, $83d385c7, $136c9856, $646ba8c0, $fd62f97a, $8a65c9ec,„  $14015c4f, $63066cd9, $fa0f3d63, $8d080df5, $3b6e20c8, $4c69105e, $d56041e4,„  $a2677172, $3c03e4d1, $4b04d447, $d20d85fd, $a50ab56b, $35b5a8fa, $42b2986c,„  $dbbbc9d6, $acbcf940, $32d86ce3, $45df5c75, $dcd60dcf, $abd13d59, $26d930ac,„  $51de003a, $c8d75180, $bfd06116, $21b4f4b5, $56b3c423, $cfba9599, $b8bda50f,„  $2802b89e, $5f058808, $c60cd9b2, $b10be924, $2f6f7c87, $58684c11, $c1611dab,„  $b6662d3d, $76dc4190, $01db7106, $98d220bc, $efd5102a, $71b18589, $06b6b51f,„  $9fbfe4a5, $e8b8d433, $7807c9a2, $0f00f934, $9609a88e, $e10e9818, $7f6a0dbb,„  $086d3d2d, $91646c97, $e6635c01, $6b6b51f4, $1c6c6162, $856530d8, $f262004e,„  $6c0695ed, $1b01a57b, $8208f4c1, $f50fc457, $65b0d9c6, $12b7e950, $8bbeb8ea,„  $fcb9887c, $62dd1ddf, $15da2d49, $8cd37cf3, $fbd44c65, $4db26158, $3ab551ce,„  $a3bc0074, $d4bb30e2, $4adfa541, $3dd895d7, $a4d1c46d, $d3d6f4fb, $4369e96a,„  $346ed9fc, $ad678846, $da60b8d0, $44042d73, $33031de5, $aa0a4c5f, $dd0d7cc9,„  $5005713c, $270241aa, $be0b1010, $c90c2086, $5768b525, $206f85b3, $b966d409,„  $ce61e49f, $5edef90e, $29d9c998, $b0d09822, $c7d7a8b4, $59b33d17, $2eb40d81,„  $b7bd5c3b, $c0ba6cad, $edb88320, $9abfb3b6, $03b6e20c, $74b1d29a, $ead54739,„  $9dd277af, $04db2615, $73dc1683, $e3630b12, $94643b84, $0d6d6a3e, $7a6a5aa8,„  $e40ecf0b, $9309ff9d, $0a00ae27, $7d079eb1, $f00f9344, $8708a3d2, $1e01f268,„  $6906c2fe, $f762575d, $806567cb, $196c3671, $6e6b06e7, $fed41b76, $89d32be0,„  $10da7a5a, $67dd4acc, $f9b9df6f, $8ebeeff9, $17b7be43, $60b08ed5, $d6d6a3e8,„  $a1d1937e, $38d8c2c4, $4fdff252, $d1bb67f1, $a6bc5767, $3fb506dd, $48b2364b,„  $d80d2bda, $af0a1b4c, $36034af6, $41047a60, $df60efc3, $a867df55, $316e8eef,„  $4669be79, $cb61b38c, $bc66831a, $256fd2a0, $5268e236, $cc0c7795, $bb0b4703,„  $220216b9, $5505262f, $c5ba3bbe, $b2bd0b28, $2bb45a92, $5cb36a04, $c2d7ffa7,„  $b5d0cf31, $2cd99e8b, $5bdeae1d, $9b64c2b0, $ec63f226, $756aa39c, $026d930a,„  $9c0906a9, $eb0e363f, $72076785, $05005713, $95bf4a82, $e2b87a14, $7bb12bae,„  $0cb61b38, $92d28e9b, $e5d5be0d, $7cdcefb7, $0bdbdf21, $86d3d2d4, $f1d4e242,„  $68ddb3f8, $1fda836e, $81be16cd, $f6b9265b, $6fb077e1, $18b74777, $88085ae6,„  $ff0f6a70, $66063bca, $11010b5c, $8f659eff, $f862ae69, $616bffd3, $166ccf45,„  $a00ae278, $d70dd2ee, $4e048354, $3903b3c2, $a7672661, $d06016f7, $4969474d,„  $3e6e77db, $aed16a4a, $d9d65adc, $40df0b66, $37d83bf0, $a9bcae53, $debb9ec5,„  $47b2cf7f, $30b5ffe9, $bdbdf21c, $cabac28a, $53b39330, $24b4a3a6, $bad03605,„  $cdd70693, $54de5729, $23d967bf, $b3667a2e, $c4614ab8, $5d681b02, $2a6f2b94,„  $b40bbe37, $c30c8ea1, $5a05df1b, $2d02ef8d„  );„„var„  Crc32TableOfs : Word;„„function UpdateCrc32(CurByte : Byte; CurCrc : LongInt) : LongInt;„  {-Returns an updated crc32}„„  (* Model for inline code below„  UpdateCrc32 := Crc32Table[Byte(CurCrc xor LongInt(CurByte))] xor„                 ((CurCrc shr 8) and $00FFFFFF);„  *)„„Inline(„                         {;Get args -- DX:BX = CurCrc, CX = CurByte;}„  $5B/                   {        POP     BX}„  $5A/                   {        POP     DX}„  $59/                   {        POP     CX}„  $52/                   {        PUSH    DX}„  $53/                   {        PUSH    BX      ;Save original CurCrc}„                         {;CX:AX := Get Crc32Table[CurCrc xor CurByte];} {!!.10}„  $31/$CB/               {        XOR     BX,CX   ;DX:BX = CurCrc xor CurByte}„  $30/$FF/               {        XOR     BH,BH   ;Byte(DX:BX)}„  $D1/$E3/               {        SHL     BX,1    ;LongInt index}„  $D1/$E3/               {        SHL     BX,1}„  { $C4/$87/>CRC32TABLE/           LES     AX,>Crc32Table[BX]}         {!!.10}„  $03/$1E/>CRC32TABLEOFS/{        ADD     BX,[>Crc32TableOfs]}         {!!.10}„  $8B/$07/               {        MOV     AX,[BX]}                     {!!.10}„  $8B/$4F/$02/           {        MOV     CX,[BX+2]}                   {!!.10}„                         {;DX:BX := (CurCrc shr 8) and $00FFFFFF;}„  $5B/                   {        POP     BX      ;Get original CurCrc}„  $5A/                   {        POP     DX}„  $51/                   {        PUSH    CX      ;Save CX}            {!!.10}„  $B9/$08/$00/           {        MOV     CX,8    ;Shift 8 bits}„  $D1/$EA/               {C1:     SHR     DX,1    ;Hi reg into carry}„  $D1/$DB/               {        RCR     BX,1    ;Carry into lo reg}„  $E2/$FA/               {        LOOP    C1      ; for 8 bits}„  $81/$E2/$FF/$00/       {        AND     DX,$00FF}„                         {;DX:AX := ES:AX xor DX:BX (sets function result)}„  $59/                   {        POP     CX}                          {!!.10}„  $31/$D8/               {        XOR     AX,BX}„  $89/$CB/               {        MOV     BX,CX}                       {!!.10}„  $31/$DA);              {        XOR     DX,BX}„„const„  {The following table is used internally only. It is interfaced so„   that other programmers can use them with their own CRC routines}„„  CrcTable: array[0..255] of Word = („    $0000,  $1021,  $2042,  $3063,  $4084,  $50a5,  $60c6,  $70e7,„    $8108,  $9129,  $a14a,  $b16b,  $c18c,  $d1ad,  $e1ce,  $f1ef,„    $1231,  $0210,  $3273,  $2252,  $52b5,  $4294,  $72f7,  $62d6,„    $9339,  $8318,  $b37b,  $a35a,  $d3bd,  $c39c,  $f3ff,  $e3de,„    $2462,  $3443,  $0420,  $1401,  $64e6,  $74c7,  $44a4,  $5485,„    $a56a,  $b54b,  $8528,  $9509,  $e5ee,  $f5cf,  $c5ac,  $d58d,„    $3653,  $2672,  $1611,  $0630,  $76d7,  $66f6,  $5695,  $46b4,„    $b75b,  $a77a,  $9719,  $8738,  $f7df,  $e7fe,  $d79d,  $c7bc,„    $48c4,  $58e5,  $6886,  $78a7,  $0840,  $1861,  $2802,  $3823,„    $c9cc,  $d9ed,  $e98e,  $f9af,  $8948,  $9969,  $a90a,  $b92b,„    $5af5,  $4ad4,  $7ab7,  $6a96,  $1a71,  $0a50,  $3a33,  $2a12,„    $dbfd,  $cbdc,  $fbbf,  $eb9e,  $9b79,  $8b58,  $bb3b,  $ab1a,„    $6ca6,  $7c87,  $4ce4,  $5cc5,  $2c22,  $3c03,  $0c60,  $1c41,„    $edae,  $fd8f,  $cdec,  $ddcd,  $ad2a,  $bd0b,  $8d68,  $9d49,„    $7e97,  $6eb6,  $5ed5,  $4ef4,  $3e13,  $2e32,  $1e51,  $0e70,„    $ff9f,  $efbe,  $dfdd,  $cffc,  $bf1b,  $af3a,  $9f59,  $8f78,„    $9188,  $81a9,  $b1ca,  $a1eb,  $d10c,  $c12d,  $f14e,  $e16f,„    $1080,  $00a1,  $30c2,  $20e3,  $5004,  $4025,  $7046,  $6067,„    $83b9,  $9398,  $a3fb,  $b3da,  $c33d,  $d31c,  $e37f,  $f35e,„    $02b1,  $1290,  $22f3,  $32d2,  $4235,  $5214,  $6277,  $7256,„    $b5ea,  $a5cb,  $95a8,  $8589,  $f56e,  $e54f,  $d52c,  $c50d,„    $34e2,  $24c3,  $14a0,  $0481,  $7466,  $6447,  $5424,  $4405,„    $a7db,  $b7fa,  $8799,  $97b8,  $e75f,  $f77e,  $c71d,  $d73c,„    $26d3,  $36f2,  $0691,  $16b0,  $6657,  $7676,  $4615,  $5634,„    $d94c,  $c96d,  $f90e,  $e92f,  $99c8,  $89e9,  $b98a,  $a9ab,„    $5844,  $4865,  $7806,  $6827,  $18c0,  $08e1,  $3882,  $28a3,„    $cb7d,  $db5c,  $eb3f,  $fb1e,  $8bf9,  $9bd8,  $abbb,  $bb9a,„    $4a75,  $5a54,  $6a37,  $7a16,  $0af1,  $1ad0,  $2ab3,  $3a92,„    $fd2e,  $ed0f,  $dd6c,  $cd4d,  $bdaa,  $ad8b,  $9de8,  $8dc9,„    $7c26,  $6c07,  $5c64,  $4c45,  $3ca2,  $2c83,  $1ce0,  $0cc1,„    $ef1f,  $ff3e,  $cf5d,  $df7c,  $af9b,  $bfba,  $8fd9,  $9ff8,„    $6e17,  $7e36,  $4e55,  $5e74,  $2e93,  $3eb2,  $0ed1,  $1ef0„  );„„implementation„„  function UpdateChecksum(CurByte : Byte; CheckSum : Word) : Word;„    {-Returns an updated checksum}„  begin„    UpdateCheckSum := CheckSum + CurByte;„  end;„„  function UpdateCrc(CurByte : Byte; CurCrc : Word) : Word;„    {-Returns an updated CRC16}„  begin„    UpdateCrc := CrcTable[((CurCrc shr 8) and 255)] xor„                 (CurCrc shl 8) xor CurByte;„  end;„„ FUNCTION UPDateCrcReverse (curByte : BYTE; CurCRC : WORD) : WORD;„ BEGIN { Updatecrcreverse .. need to be reversed for YMODEM,XMODEM }„    UpDateCRCReverse := (Curcrc SHL 8) XOR ( CRCtable [ (curcrc SHR 8) XOR curByte] );„ END;„„  function UpdateCrcKermit(CurByte : Byte; CurCrc : Word) : Word;„    {-Returns an updated Crc16 (kermit style)}„  var„    I : Integer;„    Temp : Integer;„  begin„    for I := 0 to 7 do begin„      Temp := CurCrc xor CurByte;„      CurCrc := CurCrc shr 1;„      if Odd(Temp) then„        CurCrc := CurCrc xor $8408;„      CurByte := CurByte shr 1;„    end;„    UpdateCrcKermit := CurCrc;„  end;„„BEGIN  { initialize CRC32 table }„  Crc32TableOfs := Ofs(Crc32Table);„END.     6      05-28-9313:35ALL                      SWAG SUPPORT TEAM        32 Bit CRC               IMPORT              42     N0[ {„> I was kind of hoping to be ushered toward a File name I could locate„> which would do what I need.  (Produce 32 bit CRC's that are compatible„> With PKZIP's output).„„  I snagged this of this echo sometime ago.  It does CRC32„ using only TP With the help of a precalculated table.„ It does procduce CRC32 values that are the same as PKZIP and ARJ.„„--------------------- Unit CRC32C.PAS 8<-----------------------„{ Modified from a version posted on the Pascal echo by Floor„  A.C. Naaijkens (note introduction of a Constant and a„  Function and making the Array a Constant outside of„  crc32() which should improve speed a lot; further„  references made to a C version in a File of Snippets from the„(112 min left), (H)elp, More?   C Echo marked as "Copyright (C) 1986 Gary S. Brown" (mostly to„  compare the large Arrays, which proved to be identical), and to„  "File verification using CRC" by Mark R. Nelson in Dr. Dobbs'„  Journal, May 1992.  The latter provided the final piece of„  crucial information.  Use: 1) Create a LongInt Variable For the„  CRC value; 2) Initialize this With CRCSeed; 3) Build the„  CRC Byte-by-Byte With CRC32(); 4) Finish With CRCend()„  (this was the part I found in Nelson).  The result is a CRC„  value identical to that calculated by PKZip and ARJ.„}„Unit CRC32c;„Interface„  Const„    CRCSeed = $ffffffff;„    CRC32tab : Array[0..255] of LongInt = („      $00000000, $77073096, $ee0e612c, $990951ba, $076dc419, $706af48f,„      $e963a535, $9e6495a3, $0edb8832, $79dcb8a4, $e0d5e91e, $97d2d988,„      $09b64c2b, $7eb17cbd, $e7b82d07, $90bf1d91, $1db71064, $6ab020f2,„      $f3b97148, $84be41de, $1adad47d, $6ddde4eb, $f4d4b551, $83d385c7,„      $136c9856, $646ba8c0, $fd62f97a, $8a65c9ec, $14015c4f, $63066cd9,„      $fa0f3d63, $8d080df5, $3b6e20c8, $4c69105e, $d56041e4, $a2677172,„      $3c03e4d1, $4b04d447, $d20d85fd, $a50ab56b, $35b5a8fa, $42b2986c,„      $dbbbc9d6, $acbcf940, $32d86ce3, $45df5c75, $dcd60dcf, $abd13d59,„      $26d930ac, $51de003a, $c8d75180, $bfd06116, $21b4f4b5, $56b3c423,„      $cfba9599, $b8bda50f, $2802b89e, $5f058808, $c60cd9b2, $b10be924,„      $2f6f7c87, $58684c11, $c1611dab, $b6662d3d, $76dc4190, $01db7106,„      $98d220bc, $efd5102a, $71b18589, $06b6b51f, $9fbfe4a5, $e8b8d433,„      $7807c9a2, $0f00f934, $9609a88e, $e10e9818, $7f6a0dbb, $086d3d2d,„      $91646c97, $e6635c01, $6b6b51f4, $1c6c6162, $856530d8, $f262004e,„      $6c0695ed, $1b01a57b, $8208f4c1, $f50fc457, $65b0d9c6, $12b7e950,„      $8bbeb8ea, $fcb9887c, $62dd1ddf, $15da2d49, $8cd37cf3, $fbd44c65,„      $4db26158, $3ab551ce, $a3bc0074, $d4bb30e2, $4adfa541, $3dd895d7,„      $a4d1c46d, $d3d6f4fb, $4369e96a, $346ed9fc, $ad678846, $da60b8d0,„      $44042d73, $33031de5, $aa0a4c5f, $dd0d7cc9, $5005713c, $270241aa,„      $be0b1010, $c90c2086, $5768b525, $206f85b3, $b966d409, $ce61e49f,„      $5edef90e, $29d9c998, $b0d09822, $c7d7a8b4, $59b33d17, $2eb40d81,„      $b7bd5c3b, $c0ba6cad, $edb88320, $9abfb3b6, $03b6e20c, $74b1d29a,„      $ead54739, $9dd277af, $04db2615, $73dc1683, $e3630b12, $94643b84,„      $0d6d6a3e, $7a6a5aa8, $e40ecf0b, $9309ff9d, $0a00ae27, $7d079eb1,„      $f00f9344, $8708a3d2, $1e01f268, $6906c2fe, $f762575d, $806567cb,„      $196c3671, $6e6b06e7, $fed41b76, $89d32be0, $10da7a5a, $67dd4acc,„      $f9b9df6f, $8ebeeff9, $17b7be43, $60b08ed5, $d6d6a3e8, $a1d1937e,„      $38d8c2c4, $4fdff252, $d1bb67f1, $a6bc5767, $3fb506dd, $48b2364b,„      $d80d2bda, $af0a1b4c, $36034af6, $41047a60, $df60efc3, $a867df55,„      $316e8eef, $4669be79, $cb61b38c, $bc66831a, $256fd2a0, $5268e236,„      $cc0c7795, $bb0b4703, $220216b9, $5505262f, $c5ba3bbe, $b2bd0b28,„      $2bb45a92, $5cb36a04, $c2d7ffa7, $b5d0cf31, $2cd99e8b, $5bdeae1d,„      $9b64c2b0, $ec63f226, $756aa39c, $026d930a, $9c0906a9, $eb0e363f,„      $72076785, $05005713, $95bf4a82, $e2b87a14, $7bb12bae, $0cb61b38,„      $92d28e9b, $e5d5be0d, $7cdcefb7, $0bdbdf21, $86d3d2d4, $f1d4e242,„      $68ddb3f8, $1fda836e, $81be16cd, $f6b9265b, $6fb077e1, $18b74777,„      $88085ae6, $ff0f6a70, $66063bca, $11010b5c, $8f659eff, $f862ae69,„      $616bffd3, $166ccf45, $a00ae278, $d70dd2ee, $4e048354, $3903b3c2,„      $a7672661, $d06016f7, $4969474d, $3e6e77db, $aed16a4a, $d9d65adc,„      $40df0b66, $37d83bf0, $a9bcae53, $debb9ec5, $47b2cf7f, $30b5ffe9,„      $bdbdf21c, $cabac28a, $53b39330, $24b4a3a6, $bad03605, $cdd70693,„      $54de5729, $23d967bf, $b3667a2e, $c4614ab8, $5d681b02, $2a6f2b94,„      $b40bbe37, $c30c8ea1, $5a05df1b, $2d02ef8d  );„Function CRC32(value: Byte; crc: LongInt) : LongInt;„Function CRCend( crc : LongInt ) : LongInt ;„„Implementation„„Function  CRC32(value: Byte; crc: LongInt) : LongInt;„begin„  CRC32 := CRC32tab[Byte(crc xor LongInt(value))] xor„           ((crc shr 8) and $00ffffff);„end;„„Function CRCend( crc : LongInt ): LongInt;„begin„  CRCend := (crc xor CRCSeed);„end;„„end.„„{„Now to use it...„„With a LongInt Variable, say vCRC32, first seed it„  vCRC32 := CRCSeed;„Then go Byte-by-Byte thorugh to calculate:„  For P := 1 to Size DO„    vCRC32 := CRC32(Bytes[P], vCRC32);„„  Then finish it off With CRCend„„    vCRC32 := CRCend(vCRC32);„„  You should be able to Write your own Dec2Hex Function =)„}„                                                                                        7      05-28-9313:35ALL                      SWAG SUPPORT TEAM        File CRC Routines        IMPORT              81     N0ç_ {„Author: FLOOR A.C. NAAIJKENS„„Part of The ECO Library II:„}„„Unit Eco_CRC;„„Interface„„Function __CRC32(Value: Byte; CRC : LongInt) : LongInt;„Function __CRC16(Value: Byte; CRC : Word)    : Word;„„Implementation„„Function  __crc32(value: Byte; crc: LongInt): LongInt;„Const„  crc32_table : Array[0..255] of LongInt = („    $00000000, $77073096, $ee0e612c, $990951ba, $076dc419, $706af48f,„    $e963a535, $9e6495a3, $0edb8832, $79dcb8a4, $e0d5e91e, $97d2d988,„    $09b64c2b, $7eb17cbd, $e7b82d07, $90bf1d91, $1db71064, $6ab020f2,„    $f3b97148, $84be41de, $1adad47d, $6ddde4eb, $f4d4b551, $83d385c7,„    $136c9856, $646ba8c0, $fd62f97a, $8a65c9ec, $14015c4f, $63066cd9,„    $fa0f3d63, $8d080df5, $3b6e20c8, $4c69105e, $d56041e4, $a2677172,„    $3c03e4d1, $4b04d447, $d20d85fd, $a50ab56b, $35b5a8fa, $42b2986c,„    $dbbbc9d6, $acbcf940, $32d86ce3, $45df5c75, $dcd60dcf, $abd13d59,„    $26d930ac, $51de003a, $c8d75180, $bfd06116, $21b4f4b5, $56b3c423,„    $cfba9599, $b8bda50f, $2802b89e, $5f058808, $c60cd9b2, $b10be924,„    $2f6f7c87, $58684c11, $c1611dab, $b6662d3d, $76dc4190, $01db7106,„    $98d220bc, $efd5102a, $71b18589, $06b6b51f, $9fbfe4a5, $e8b8d433,„    $7807c9a2, $0f00f934, $9609a88e, $e10e9818, $7f6a0dbb, $086d3d2d,„    $91646c97, $e6635c01, $6b6b51f4, $1c6c6162, $856530d8, $f262004e,„    $6c0695ed, $1b01a57b, $8208f4c1, $f50fc457, $65b0d9c6, $12b7e950,„    $8bbeb8ea, $fcb9887c, $62dd1ddf, $15da2d49, $8cd37cf3, $fbd44c65,„    $4db26158, $3ab551ce, $a3bc0074, $d4bb30e2, $4adfa541, $3dd895d7,„    $a4d1c46d, $d3d6f4fb, $4369e96a, $346ed9fc, $ad678846, $da60b8d0,„    $44042d73, $33031de5, $aa0a4c5f, $dd0d7cc9, $5005713c, $270241aa,„    $be0b1010, $c90c2086, $5768b525, $206f85b3, $b966d409, $ce61e49f,„    $5edef90e, $29d9c998, $b0d09822, $c7d7a8b4, $59b33d17, $2eb40d81,„    $b7bd5c3b, $c0ba6cad, $edb88320, $9abfb3b6, $03b6e20c, $74b1d29a,„    $ead54739, $9dd277af, $04db2615, $73dc1683, $e3630b12, $94643b84,„    $0d6d6a3e, $7a6a5aa8, $e40ecf0b, $9309ff9d, $0a00ae27, $7d079eb1,„    $f00f9344, $8708a3d2, $1e01f268, $6906c2fe, $f762575d, $806567cb,„    $196c3671, $6e6b06e7, $fed41b76, $89d32be0, $10da7a5a, $67dd4acc,„    $f9b9df6f, $8ebeeff9, $17b7be43, $60b08ed5, $d6d6a3e8, $a1d1937e,„    $38d8c2c4, $4fdff252, $d1bb67f1, $a6bc5767, $3fb506dd, $48b2364b,„    $d80d2bda, $af0a1b4c, $36034af6, $41047a60, $df60efc3, $a867df55,„    $316e8eef, $4669be79, $cb61b38c, $bc66831a, $256fd2a0, $5268e236,„    $cc0c7795, $bb0b4703, $220216b9, $5505262f, $c5ba3bbe, $b2bd0b28,„    $2bb45a92, $5cb36a04, $c2d7ffa7, $b5d0cf31, $2cd99e8b, $5bdeae1d,„    $9b64c2b0, $ec63f226, $756aa39c, $026d930a, $9c0906a9, $eb0e363f,„    $72076785, $05005713, $95bf4a82, $e2b87a14, $7bb12bae, $0cb61b38,„    $92d28e9b, $e5d5be0d, $7cdcefb7, $0bdbdf21, $86d3d2d4, $f1d4e242,„    $68ddb3f8, $1fda836e, $81be16cd, $f6b9265b, $6fb077e1, $18b74777,„    $88085ae6, $ff0f6a70, $66063bca, $11010b5c, $8f659eff, $f862ae69,„    $616bffd3, $166ccf45, $a00ae278, $d70dd2ee, $4e048354, $3903b3c2,„    $a7672661, $d06016f7, $4969474d, $3e6e77db, $aed16a4a, $d9d65adc,„    $40df0b66, $37d83bf0, $a9bcae53, $debb9ec5, $47b2cf7f, $30b5ffe9,„    $bdbdf21c, $cabac28a, $53b39330, $24b4a3a6, $bad03605, $cdd70693,„    $54de5729, $23d967bf, $b3667a2e, $c4614ab8, $5d681b02, $2a6f2b94,„    $b40bbe37, $c30c8ea1, $5a05df1b, $2d02ef8d„  );„„begin„  if crc = 0 then„    crc := $ffffffff; { must be set high to start With }„  __crc32 := crc32_table[Byte(crc xor LongInt(value))] xor„             ((crc shr 8) and $00ffffff);„end;„„„„Function  __crc16(value: Byte; crc: Word): Word;„Const„  crc16_table : Array[0..255] of Word = („     $0000,  $1021,  $2042,  $3063,  $4084,  $50a5,  $60c6,  $70e7,„     $8108,  $9129,  $a14a,  $b16b,  $c18c,  $d1ad,  $e1ce,  $f1ef,„     $1231,  $0210,  $3273,  $2252,  $52b5,  $4294,  $72f7,  $62d6,„     $9339,  $8318,  $b37b,  $a35a,  $d3bd,  $c39c,  $f3ff,  $e3de,„     $2462,  $3443,  $0420,  $1401,  $64e6,  $74c7,  $44a4,  $5485,„     $a56a,  $b54b,  $8528,  $9509,  $e5ee,  $f5cf,  $c5ac,  $d58d,„     $3653,  $2672,  $1611,  $0630,  $76d7,  $66f6,  $5695,  $46b4,„     $b75b,  $a77a,  $9719,  $8738,  $f7df,  $e7fe,  $d79d,  $c7bc,„     $48c4,  $58e5,  $6886,  $78a7,  $0840,  $1861,  $2802,  $3823,„     $c9cc,  $d9ed,  $e98e,  $f9af,  $8948,  $9969,  $a90a,  $b92b,„     $5af5,  $4ad4,  $7ab7,  $6a96,  $1a71,  $0a50,  $3a33,  $2a12,„     $dbfd,  $cbdc,  $fbbf,  $eb9e,  $9b79,  $8b58,  $bb3b,  $ab1a,„     $6ca6,  $7c87,  $4ce4,  $5cc5,  $2c22,  $3c03,  $0c60,  $1c41,„     $edae,  $fd8f,  $cdec,  $ddcd,  $ad2a,  $bd0b,  $8d68,  $9d49,„     $7e97,  $6eb6,  $5ed5,  $4ef4,  $3e13,  $2e32,  $1e51,  $0e70,„     $ff9f,  $efbe,  $dfdd,  $cffc,  $bf1b,  $af3a,  $9f59,  $8f78,„     $9188,  $81a9,  $b1ca,  $a1eb,  $d10c,  $c12d,  $f14e,  $e16f,„     $1080,  $00a1,  $30c2,  $20e3,  $5004,  $4025,  $7046,  $6067,„     $83b9,  $9398,  $a3fb,  $b3da,  $c33d,  $d31c,  $e37f,  $f35e,„     $02b1,  $1290,  $22f3,  $32d2,  $4235,  $5214,  $6277,  $7256,„     $b5ea,  $a5cb,  $95a8,  $8589,  $f56e,  $e54f,  $d52c,  $c50d,„     $34e2,  $24c3,  $14a0,  $0481,  $7466,  $6447,  $5424,  $4405,„     $a7db,  $b7fa,  $8799,  $97b8,  $e75f,  $f77e,  $c71d,  $d73c,„     $26d3,  $36f2,  $0691,  $16b0,  $6657,  $7676,  $4615,  $5634,„     $d94c,  $c96d,  $f90e,  $e92f,  $99c8,  $89e9,  $b98a,  $a9ab,„     $5844,  $4865,  $7806,  $6827,  $18c0,  $08e1,  $3882,  $28a3,„     $cb7d,  $db5c,  $eb3f,  $fb1e,  $8bf9,  $9bd8,  $abbb,  $bb9a,„     $4a75,  $5a54,  $6a37,  $7a16,  $0af1,  $1ad0,  $2ab3,  $3a92,„     $fd2e,  $ed0f,  $dd6c,  $cd4d,  $bdaa,  $ad8b,  $9de8,  $8dc9,„     $7c26,  $6c07,  $5c64,  $4c45,  $3ca2,  $2c83,  $1ce0,  $0cc1,„     $ef1f,  $ff3e,  $cf5d,  $df7c,  $af9b,  $bfba,  $8fd9,  $9ff8,„     $6e17,  $7e36,  $4e55,  $5e74,  $2e93,  $3eb2,  $0ed1,  $1ef0„   );„„begin„  __crc16 := crc16_table[((crc shr 8) and 255)] xor„             (crc shl 8) xor value;„end;„„„„end.„„{==========================================================================}„{==========================================================================}„{==========================================================================}„„CRC.PAS„{$M 65520, 0, 655360}„Uses„  Crt, Dos,„  eco_lib;„„Var„  take32,„  take16      : Boolean;„  sourcepath,„  source      : String;„  numFiles, i : Word;„  srec        : SearchRec;„  filar       : Array[1..1024] of ^SearchRec;„„„„Function convert32(fname: String; fsize: LongInt; x1, x2, y: Byte): String;„Const„  bufsize = 32768;„Type„  fbuf = Array[1..bufsize] of Byte;„Var„  i       :    Word;„  source  :    File;„  bread   :    Word;„  Filebuf :   ^fbuf;„  crc, tr : LongInt;„  nr      :    Real;„„begin„  crc := $ffffffff;„  tr := 0;„  new(Filebuf);„  assign(source, fname);„  reset(source, 1);„  GotoXY(x1, y);„  Write(__rep(x2-x1-3, '∞'));„  Write('  ', fname);„  Repeat„    blockread(source, Filebuf^, bufsize, bread);„    tr := tr + bread;„    nr := tr/fsize;„    nr := nr * (x2-x1-3);„    GotoXY(x1, y);„    Write(__rep(trunc(nr), '€'));„    For i := 1 to bread do„      crc := __crc32(Filebuf^[i], crc);„  Until (bread = 0);„  close(source);„  GotoXY(x1, y);„  dispose(Filebuf);„  Write(fname:12, '  ', fsize:7, ' Bytes.  HEX-CRC/32: ',__tohexstr(crc, 4));„  clreol; convert32 := '';„end;„„Function convert16(fname: String; fsize: LongInt; x1, x2, y: Byte): String;„Const„  bufsize = 32768;„Type„  fbuf = Array[1..bufsize] of Byte;„Var„  i       :    Word;„  source  :    File;„  bread   :    Word;„  Filebuf :   ^fbuf;„  crc, tr : LongInt;„  nr      :    Real;„„begin„  crc := $0000;„  tr := 0;„  new(Filebuf);„  assign(source, fname);„  reset(source, 1);„  GotoXY(x1, y);„  Write(__rep(x2-x1-3, '∞'));„  Write('  ', fname);„  Repeat„    blockread(source, Filebuf^, bufsize, bread);„    tr := tr + bread;„    nr := tr/fsize;„    nr := nr * (x2-x1-3);„    GotoXY(x1, y);„    Write(__rep(trunc(nr), '€'));„    For i := 1 to bread do„      crc := __crc16(Filebuf^[i], crc);„  Until (bread = 0);„  close(source);„  GotoXY(x1, y);„  dispose(Filebuf);„  Write(fname:12, '  ', fsize:7, ' Bytes.  HEX-CRC/16: ', __tohexstr(crc, 2));„  clreol;„  convert16 := '';„end;„„„„Function convert16_32(fname:String; fsize: LongInt; x1, x2, y: Byte):String;„Const„  bufsize = 32768;„Type„  fbuf = Array[1..bufsize] of Byte;„Var„  i       :    Word;„  source  :    File;„  bread   :    Word;„  Filebuf :   ^fbuf;„  crc,„  crc32,„  tr      : LongInt;„  nr      :    Real;„„begin„  crc := $0000;„  tr := 0;„  crc32 := $ffffffff;„  new(Filebuf);„  assign(source, fname);„  reset(source, 1);„  GotoXY(x1, y);„  Write(__rep(x2-x1-3, '∞'));„  Write('  ', fname);„  Repeat„    blockread(source, Filebuf^, bufsize, bread);„    tr := tr + bread;„    nr := tr/fsize;„    nr := nr * (x2-x1-3);„    GotoXY(x1, y);„    Write(__rep(trunc(nr), '€'));„    For i := 1 to bread do begin„      crc := __crc16(Filebuf^[i], crc);„      crc32 := __crc32(Filebuf^[i], crc32);„    end;„  Until (bread = 0);„  close(source);„  GotoXY(x1, y);„  dispose(Filebuf);„  Write(fname:12, '  ', fsize:7,' Bytes.  HEX-CRC/16: ', __tohexstr(crc, 2),„        ' 32: ', __tohexstr(crc32, 4));„  clreol;„  convert16_32 := '';„end;„„„„„{main}„begin„  source := fexpand(paramstr(1));„  take32 := False;„  take16 := False;„  if paramstr(2) = '/32' then„    take32 := True;„  if paramstr(2) = '/16' then„    take16 := True;„  numFiles := 0;„  findfirst(source, anyFile, srec);„  While Doserror=0 do„  begin„    if not (((srec.attr and directory) > 0) or ((srec.attr and volumeid) > 0)„             and (srec.size > 0)) then„    begin„      inc(numFiles);„      new(filar[numFiles]);„      filar[numFiles]^ := srec;„      filar[numFiles]^.name := __up(filar[numFiles]^.name);„    end; findnext(srec);„  end;„  Writeln(numFiles, ' File(s) found.');„„  For i := 1 to numFiles do„    if take32 then„      Writeln(convert32(sourcepath + filar[i]^.name, filar[i]^.size,„              5, 35, WhereY))„      else„      if take16 then„        Writeln(convert16(sourcepath + filar[i]^.name, filar[i]^.size,„                5, 35, WhereY))„      else„        Writeln(convert16_32(sourcepath + filar[i]^.name, filar[i]^.size,„                5, 35, WhereY));„end.„„„„                                                                                                             8      05-28-9313:35ALL                      SWAG SUPPORT TEAM        File MODS With CRC Check IMPORT              62     N0ö {$X+}„Unit selfmod;„„ { Author Trevor J Carlsen - released into the public domain 1991            }„ {        PO Box 568                                                         }„ {        Port Hedland                                                       } „ {        Western Australia 6721                                             }„ {        Voice +61 91 73 2026  Data +61 91 73  2569                         }„ {        FidoNet 3:690/644                                                  }„ { Allows a Program to self modify a Typed Constant in the .exe File.  It    }„ { also perForms an automatic checksum Type .exe File integrity check.       }„ { A LongInt value is added to the end of the exe File.  This can be read by }„ { a separate configuration Program to enable it to determine the start of   }„ { the Programs configuration data area.  to use this the configuration      }„ { Typed Constant should be added immediately following the declaration of   }„ { ExeData.                                                                  }„ „ { Where this Unit is used, it should always be the FIRST Unit listed in the }„ { Uses declaration area of the main Program.                                }„ „ { Requires Dos 3.3 or later.  Program must not be used With PKLite or LZExe }„ { or any similar exe File Compression Programs. It may also cause           }„ { difficulties on a network or virus detection Programs.                    }„ „ { The stack size needed is at least 9,000 Bytes.                            }„ „Interface„„Uses„  globals;„„Type„  ExeDataType    = Record„                     IDStr      : str7;„                     UserName   : str35;„                     FirstTime  : Boolean;„                     NumbExecs  : shortint;„                     Hsize      : Word;„                     ExeSize    : LongInt;„                     CheckSum   : LongInt;„                     StartConst : LongInt;„                     RegCode    : LongInt;„                   end;„Const„  ExeData : ExeDataType = (IDStr     : 'ID-AREA';„                           UserName  : '';„                           FirstTime : True;„                           NumbExecs : -1;„                           Hsize     : 0;„                           ExeSize   : 0;„                           CheckSum  : 0;„                           StartConst: 0;„                           RegCode   : 0);„„„{$I p:\prog\freeload.inc} { Creates CodeStr that MUST match RegStr }„„{$I p:\prog\registed.inc} { Creates CodeChkStr that MUST hash to RegCode}„„Const„  mark  : Byte = 0;„„Var„  first : Boolean;„„Procedure Hash(p : Pointer; numb : Byte; Var result: LongInt);„„Function Write2Exec(Var data; size: Word): Boolean;„„Implementation„„„Procedure Hash(p : Pointer; numb : Byte; Var result: LongInt);„  { When originally called numb must be equal to sizeof    }„  { whatever p is pointing at.  if that is a String numb   }„  { should be equal to length(the_String) and p should be  }        „  { ptr(seg(the_String),ofs(the_String)+1)                 }„  Var„    temp,„    w    : LongInt;„    x    : Byte;„„  begin„    temp := LongInt(p^);  RandSeed := temp;„    For x := 0 to (numb - 4) do begin„      w := random(maxint) * random(maxint) * random(maxint);„      temp := ((temp shr random(16)) shl random(16)) +„                w + MemL[seg(p^):ofs(p^)+x];„    end;„    result := result xor temp;„  end;  { Hash }„„„Procedure InitConstants;„  Var„    f           : File;„    tbuff       : Array[0..1] of Word;„  „  Function GetCheckSum : LongInt;  „    { PerForms a checksum calculation on the exe File }„    Var„      finished  : Boolean;„      x,„      CSum      : LongInt;„      BytesRead : Word;„      buffer    : Array[0..4095] of Word;„    begin„      {$I-}„      seek(f,0);„      finished := False;  CSum := 0;  x := 0;„      BlockRead(f,buffer,sizeof(buffer),BytesRead);„      While not finished do begin             { do the checksum calculations }„        Repeat         { Until File has been read up to start of config area }„          inc(CSum,buffer[x mod 4096]);„          inc(x);„          finished := ((x shl 1) >= ExeData.StartConst); „        Until ((x mod 4096) = 0) or finished;„        if not finished then                { data area has not been reached }„          BlockRead(f,buffer,sizeof(buffer),BytesRead);          „      end;„      GetCheckSum := CSum;„    end; { GetCheckSum }„    „      „  begin„    assign(f, ParamStr(0));„    {$I-} Reset(f,1);„    With ExeData do begin„      first := FirstTime;„      if FirstTime and (Ioresult = 0) then begin„        Seek(f,2);                   { this location has the executable size }„        BlockRead(f,tbuff,4);„        ExeSize := tbuff[0]+(pred(tbuff[1]) shl 9);„        seek(f,8);                                    {  get the header size }„        BlockRead(f,hsize,2);„        FirstTime := False;„        StartConst := LongInt(hsize+Seg(ExeData)-PrefixSeg) shl 4 + „                      ofs(ExeData) - 256;„        CheckSum := GetCheckSum;„        Seek(f,StartConst);„        BlockWrite(f,ExeData,sizeof(ExeData));„        seek(f,FileSize(f));„        BlockWrite(f,StartConst,4);„      end„      else„        if GetCheckSum <> CheckSum then begin„          Writeln('File has been tampered with.  Checksum incorrect');„          halt;„        end;„    end;  { With }    „    Close(f); {$I+}„    if Ioresult <> 0 then begin„      Writeln('Unable to initialise Program');„      halt;„    end;  „  end; { InitConstants }„„„Function Write2Exec(Var data; size: Word): Boolean;„ { Writes a new Typed Constant into the executable File after first checking }„ { that it is safe to do so.  It does this by ensuring that the IDString is  }„ { at the File offset expected.                                              }„  Const„    FName : str40 = '';„  Var„     f          : File;„     st         : str8;„     BytesRead  : Word;„  begin„    if UseCfg then begin„      if length(FName) = 0 then begin„        TempStr    := ParamStr(0);„        TempStrLen := pos('.',TempStr) - 2;„        FName      := TempStr + 'ˇ.ˇ ˇ';„        {                        ≥ ≥≥≥                                       }„        {                        ≥ ≥≥¿ƒƒƒƒØØ #255                            }„        {                        ≥ ≥¿ƒƒƒƒƒØØ #32                             }„        {                        ≥ ¿ƒƒƒƒƒƒØØ #255                            }„        {                        ¿ƒƒƒƒƒƒƒƒØØ #255                            }„        { Using the above File name For the configuration File makes the     }„        { deletion of the File difficult For the average user.               }„      end; { if length }„      assign(f, FName);„      if exist(FName) then begin„        {$I-}„        reset(f,1);„        if first then begin„          first := False;„          BlockRead(f, ExeData, ofs(mark)-ofs(ExeData),BytesRead)„        end else„          BlockWrite(f,data,size);„      end else begin„        reWrite(f,1);„        BlockWrite(f,Data,size);„      end;„      close(f);„      {$I+}„      Write2Exec := Ioresult = 0;„    end else begin„      assign(f, ParamStr(0));„      {$I-} Reset(f,1);„      Seek(f,LongInt(ExeData.Hsize+Seg(ExeData)-PrefixSeg) shl 4„                     + ofs(ExeData)- 256);„      BlockRead(f,st,9);„      if st = ExeData.IDStr then { all Ok to proceed } begin„        Seek(f,LongInt(ExeData.Hsize+Seg(data)-PrefixSeg) shl 4„                       + ofs(data)- 256);„        BlockWrite(f,data,size);„        Close(f); {$I+}„        Write2Exec := Ioresult = 0;„      end else„        Write2Exec := False;„    end;„  end; { Write2Exec }„  „begin„  first :=  True;„  if not UseCfg then„    InitConstants„  else„    Write2Exec(ExeData,ofs(mark)-ofs(ExeData));„end.„                                                                           9      08-27-9320:34ALL                      GUY MCLOUGLIN            16 Bit CRC               IMPORT              13     N0q¢ {„GUY MCLOUGHLIN„„>I wanted to ask you... would you happen to know how a CRC Check-sum„>works? Everytime I go to look this up in a book I see a bunch of„>stuff about X^7 + X^12 + X^17..... (and on and on) but nothing that„>actually says "Here's what the code looks like" ... just a bunch of„>non-sensical bull...Would you happen to know the algorithm that is„>used?„„  ...Greg Vigneault is much better at this stuff than I am. I„  usually know "why" something works, but not always "how". <g>„  The basic idea is that the data is treated as input to a specific„  polynomial equation (ie: X^32 + X^26 + X^23 + X^22 + X^16 + X^12),„  the result of this is then divided by a specific prime number, and„  the remainder left over is the CRC value. I know that this is„  easier said than understood, but that's the gist of it.„„  ...if a single bit of a chunk of data is changed, the chances„  are very good that a CRC check number would catch this change.„  It's not 100 percent guaranteed, but something more like 99.97„  percent, so CRCs are not an entirely bulletproof check. Here's„  a standard Pascal Implementation of a CRC-16 routine:„}„„Function CRC16(InString: String) : Word;„Var„  CRC     : Word;„  Index1,„  Index2  : Byte;„begin„  CRC := 0;„  For Index1 := 1 to length(S) do„  begin„    CRC := (CRC xor (ord(InString[Index1]) SHL 8));„    For Index2 := 1 to 8 do„      if ((CRC and $8000) <> 0) then„        CRC := ((CRC SHL 1) xor $1021)„      else„        CRC := (CRC SHL 1)„  end;„  CRC16 := (CRC and $FFFF)„end;„„           10     08-27-9320:34ALL                      SAM LEVENTER             16 & 32 BIT CRC          IMPORT              12     N0V {„SAM LEVENTER„„>    I'm not quite sure how CRC's work.  I have routines For calculating both„> 16-bit and 32-bit CRC values, however, they seem to be only For one Byte.„> How would I go about calculating the 16-bit CRC of an entire File?„„  CRCs are CYCLIC redundancy codes.  That means that you cycle through the„entire File, ORing it With the old CRC.„„Just call updateCRC in the below Unit.„„This Program is donated to the Public„Domain by MarshallSoft Computing, Inc.„It is provided as an example of the use„of the Personal Communications Library.„}„„Unit mycrc16;„„Interface„„Function UpdateCRC(crc:Word;data:Byte):Word;„„Implementation„„Const„  POLY = $1021;„„Var„  CRCtable : Array [0..255] of Word;„„{ compute updated CRC }„Function  UpdateCRC(crc : Word; data : Byte) : Word;„begin„  UpDateCRC := (crc SHL 8) xor (CRCtable[(crc SHR 8) xor data]);„end;„„{ initialize CRC table }„Procedure InitCRC;„Var„  i : Integer;„„  { calculate CRC table entry }„  Function CalcTable(data, genpoly, accum : Word) : Word;„  Var„    i : Word;„  begin„    data := data SHL 8;„    For i := 8 downto 1 do„    begin„      if ((data xor accum) and ($8000 <> 0)) then„        accum := (accum SHL 1) xor genpoly„      else„        accum := accum SHL 1;„      data := data SHL 1;„    end;„    CalcTable := accum;„  end;„„begin„  For i := 0 to 255 do„    CRCtable[i] := CalcTable(i, POLY, 0);„end;„„begin„  InitCRC;„end.„  11     08-27-9321:48ALL                      SEAN PALMER              Quick CRC Methods        IMPORT              12     N0g {„SEAN PALMER„„Here are some that make their tables on the fly (to save echo space)„„I believe crc should be inited to 0 at start„„This CRC-16 is not identical to the one used by the Xmodem and Zmodem„File transfer protocols. The polynomial is the same„(X^16+X^12+X^5+X^0 or 0x8408) but the bit-ordering is the opposite,„and preconditioning and postconditioning is used as in 32-bit CRCs.„This method is also used by the European version of X.25.„}„„Var„  crc16table : Array [Byte] of Word;„„Procedure makeCRC16table;„Var„  crc : Word;„  i,n : Byte;„begin„  For i := 0 to 255 do„  begin„    crc := i;„    For n := 1 to 8 do„      if odd(crc) then„        crc := (crc shr 1) xor $8408„      else„        crc := crc shr 1;„„    crc16table[i] := crc;„  end;„end;„„Function updateCRC16(c : Byte; crc : Word) : Word;„begin„  updateCRC16 := crc16table[lo(crc) xor c] xor hi(crc);„end;„„{this is the same crc used For zModem crc32}„„Var„  crc32table : Array [Byte] of LongInt;„„Procedure makeCRC32table;„Var„  crc : LongInt;„  i,n : Byte;„begin„  For i := 0 to 255 do„  begin„    crc := i;„    For n := 1 to 8 do„      if odd(crc) then„        crc := (crc shr 1) xor $EDB88320„      else„        crc := crc shr 1;„„    crc32table[i] := crc;„  end;„end;„„Function updateCRC32(c : Byte; crc : LongInt) : LongInt;„begin„  updateCRC32 := crc32table[lo(crc) xor c] xor (crc shr 8);„end;„                                 12     08-27-9322:13ALL                      SEAN PALMER              XORSUM CRC Method        IMPORT              11     N0≥S {„SEAN PALMER„„>> (more than I thought I would have).  There were 190 collisions„>> out of 572 names.„„>The solution would be to use a better hashing algorythm, simply„>adding up the ascii characters is not unique enough.  You best„>approach would be to generate a CRC value for your hashing table„>rather then the checksum approach.„„Or try this xorsum method (my own invention, have to plug for it... 8)„„Lots faster than a crc with no table, with similar results.„„NOT compatible with a crc.„„This xorsum algorithm is hereby standardized and if anyone wants to use„it you should make sure your xorsum routines give the same results.„}„„function XorSum16(var data; size : word; prevSum : word) : word; assembler;„asm„  push ds„  lds  si, data„  mov  cx, size„  mov  bx, prevSum„  mov  dx, $ABCD„  cld„  jcxz @X„ @L:„  lodsb„  rol  bx, 1„  xor  bx, dx„  xor  bl, al„  loop @L„ @X:„  mov  ax, bx„  pop  ds„end;„„{ to use on a string, for instance: }„„const„  s : string = 'this is a test';„„begin„  writeln(xorsum16(s, length(s) + 1, 0));„end.„{„send 0 as prevSum if you're not accumulating a result...otherwise send„the result from the previous buffer.„}„„                                                                                                                           13     11-02-9305:24ALL                      ROBERT E. SWART          File Checksum            IMPORT              21     N0yÇ {„Program/utility which can be used to check the 'sorted' File and the data„File. It produces the Byte CheckSum of the Files (which must be identical),„and can check the sortorder of the File (when given the option -s)...„}„{$A+,B-,D-,F-,G+,I-,L-,N-,O-,R-,S+,V-,X-}„{$M 16384,0,655360}„{ Here is the Program CHECKSUM that you can run to check the master data„  File For TeeCee's String sorting contest. if you have a slow machine I„  suggest you set the Program running and go to bed!! :-)„„  Code size: 5952 Bytes„  Data size:  924 Bytes„  .EXE size: 6304 Bytes„}„Uses„  Crt;„„Const„  Version = 'CheckSum 1.0 (c) 1992 DwarFools & Consultancy, '+„                                  'by drs. Robert E. Swart'#13#10;„  Usage   = 'Usage: CheckSum dataFile [-s]'#13#10 +„   '       Options: -s to check the sortorder of the Strings'#13#10;„  MaxStr  = 30;„  Error     : LongInt = 0;„  Records   : LongInt = 0;„  CheckSum  : Byte = 0;     { Byte CheckSum of all Bytes in data File xor'ed }„  Sortorder : Boolean = False; { Assume option -s is not given }„„Var„  Str      : String[MaxStr];„  len      : Byte Absolute Str;„  ByteStr  : Array [0..MaxStr] of Byte Absolute Str;„  PrevStr,„  UpperStr : String[MaxStr];„  f        : File;„  i        : Integer;„„begin„  Writeln(Version);„  if ParamCount = 0 then„  begin„    Writeln(Usage);„    Halt;„  end;„„  assign(f, ParamStr(1)); { Change this to your chosen File name }„  reset(f, 1);„  if Ioresult <> 0 then„  begin„    Writeln('Error: could not open ', ParamStr(1));„    Writeln(Usage);„    Halt(1);„  end;„„  if (ParamCount = 2) and ((ParamStr(2) = '-s') or (ParamStr(2) = '-S')) then„      Sortorder := True;„„  Writeln('Strings x 1000 checked:');„  While not eof(f) do„  begin„    BlockRead(f, len, 1);„    BlockRead(f, Str[1], len);„    For i := 0 to len do„      CheckSum := CheckSum xor ByteStr[i];„„    if Sortorder then„    begin„      UpperStr[0] := Str[0];„      For i := 1 to len do„        UpperStr[i] := UpCase(Str[i]);„      if Records > 0 then„      begin„        if PrevStr > UpperStr then„        begin„          Inc(Error);„          Writeln;„          Writeln('Error: ',PrevStr,' > ',UpperStr);„        end;„        PrevStr := UpperStr;„      end;„    end;„    Inc(Records);„    if (Records mod 1000) = 0 then„    begin„      GotoXY(1, WhereY);„      Write(Records div 1000:3);„    end;„  end;„  close(f);„  Writeln;„  Write(Records,' Strings checked, ');„  if Sortorder then„    Writeln(Error, ' Errors found, ');„  Writeln('Byte CheckSum = ', CheckSum);„end.„                                  14     11-02-9316:14ALL                      HELGE HELGESEN           CheckSums in BASM        IMPORT              7      N0[‰ (* ===========================================================================„Date: 09-29-93 (11:16)„From: HELGE HELGESEN„Subj: Checksums?„„       How does one compute simple checksums? For example for a byte„       sequence $8A $05 $7E $1C, what would the checksum be? Where„       could I get some info on this?„„Here's one that simply adds each byte together and sends back the„result:„===========================================================================*)„„function MakeCheckSum(p: pointer; length: word): byte; assembler;„asm„  cld„  push ds„  xor  ah, ah„  mov  cx, length„  jcxz @x„  lds  si, p„@1:„  lodsb„  add  ah, al„  loop @1„@x:„  pop  ds„  mov  al, ah„end;„„So you call this like this:„„x:=MakeCheckSum(@myvar, length_of_var);„„                  15     05-25-9408:03ALL                      DON PAULSEN              Fast 16bit CRC           SWAG9405            17     N0   „{„RE:     SWAG submission„        This 16-bit CRC function is compatible with those used in Chuck„        Forsberg's X-modem protocol.  It's very fast, because I unrolled„        the "for (i = 0; i < 8; ++i)" loop.  If a 32-bit CRC is not„        necessary, this is a great alternative because of its speed and„        small size.„„„„{==============================================================}„FUNCTION Crc16 (var buffer; size, seed: word): word; assembler;„„{ Set size parameter to 0 to process 64K.  If processing only one buffer, set„  seed parameter to 0 -- otherwise set to result from previous calculation.„  C code translated by Don Paulsen. }„„(* This routine is a translation of the following C code by Chuck Forsberg.„   The added "seed" parameter allows for finding the CRC value of data spanning„   multiple buffers.  The innermost loop has been unrolled at a cost of 32„   bytes in code, but the speed increase is nearly two-fold.„„     int    Crc16 (ptr, count)„     char   *ptr;„     int    count;„„     {   int crc, i;„„         crc = 0;„         while (--count >= 0) {„            crc = crc ^ (int)*ptr++ << 8;„            for (i = 0; i < 8; ++i)„                if (crc & 0x8000)„                    crc = crc << 1 ^ 0x1021;„                else„                    crc = crc << 1;„          }„         return (crc & 0xFFFF);„     }„*)„„ASM„    les     di, buffer„    mov     dx, size„    mov     ax, seed„    mov     si, 1021h„@next:„    xor     bl, bl„    mov     bh, es:[di]„    xor     ax, bx„„    shl  ax, 1;    jnc  @noXor1;    xor  ax, si„@noXor1:„    shl  ax, 1;    jnc  @noXor2;    xor  ax, si„@noXor2:„    shl  ax, 1;    jnc  @noXor3;    xor  ax, si„@noXor3:„    shl  ax, 1;    jnc  @noXor4;    xor  ax, si„@noXor4:„    shl  ax, 1;    jnc  @noXor5;    xor  ax, si„@noXor5:„    shl  ax, 1;    jnc  @noXor6;    xor  ax, si„@noXor6:„    shl  ax, 1;    jnc  @noXor7;    xor  ax, si„@noXor7:„    shl  ax, 1;    jnc  @noXor8;    xor  ax, si„@noXor8:„„    inc     di„    dec     dx„    jnz     @next„END;„„               16     05-26-9406:16ALL                      DAVID DUNSON             Normalize CRC CalculationSWAG9405            7      N0   „{„From what I gather from these two routines, in order to "Normalize" a crc„value, you must reverse the order of the four bytes in the value.„„Example: crc value =  $01020304„         normalized = $04030201„„Am I correct in assuming this?„„If so, the two procedures above fail to perform that task, so here is a BASM„routine that I have tested and works perfectly.„}„„Procedure Normalize(Var crc: LongInt); Assembler;„ASM„     LES   DI, crc„     MOV   AX, WORD PTR ES:[DI]„     MOV   BX, WORD PTR ES:[DI + 2]„     XCHG  AH, AL„     XCHG  BH, BL„     MOV   WORD PTR ES:[DI + 2], AX„     MOV   WORD PTR ES:[DI], BX„End;„„Please forward a copy of your response to Serge Paquin who wrote the original„request for CRC routines.„                                           