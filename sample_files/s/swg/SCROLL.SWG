SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00016         SCREEN SCROLLING ROUTINES                                         1      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SCROLL1.PAS              IMPORT              14     Bµ=° {„>It's just a Fileviewer, I'm working on. I just want to be able to„>scroll the File up, down, etc.„}„„Program ScrollDemo;„Uses„  Crt;„Type„  UpDown = (Up, Down);„  { Scroll Text screen up or down. }„„Procedure Scroll({input } Direction : UpDown;„                          Lines2Scroll,„                          Rowtop,„                          RowBot,„                          ColStart,„                          ColStop,„                          FillAttr : Byte);„begin„  if (Direction = Up) then„  Asm„    mov ah, 06h„    mov al, Lines2Scroll„    mov bh, FillAttr„    mov ch, Rowtop„    mov cl, ColStart„    mov dh, RowBot„    mov dl, ColStop„    int 10h„  end„  else„  Asm„    mov ah, 07h„    mov al, Lines2Scroll„    mov bh, FillAttr„    mov ch, Rowtop„    mov cl, ColStart„    mov dh, RowBot„    mov dl, ColStop„    int 10h„  end„end; { Scroll }„„{ Pause For a key press. }„Procedure Pause;„Var„  chTemp : Char;„begin„  While KeyPressed do„    chTemp := ReadKey;„  Repeat Until(KeyPressed)„end; { Pause }„„Var„  Index : Byte;„  stTemp : String[80];„begin„  ClrScr;„  { Display 24 lines of Text. }„  For Index := 1 to 24 do„    begin„      stTemp[0] := #80;„      fillChar(stTemp[1], length(stTemp), (Index + 64));„      Write(stTemp)„    end;„  { Pause For a key press. }„  Pause;„  { Scroll Text down by 1 line. Use the Crt's Textattr }„  { Variable as the Text color to fill with. }„  Scroll(Down, 1, 0, 24, 0, 79, Textattr);„  { Pause For a key press. }„  Pause;„  { Scroll Text up by 1 line. Use the Crt's Textattr }„  { Variable as the Text color to fill with. }„  Scroll(Up, 1, 0, 24, 0, 79, Textattr);„  { Pause For a key press. }„  Pause„end.„  2      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SCROLL2.PAS              IMPORT              53     BµY8 Program Scroll;„Uses„  Crt, Dos;„Const„  Null       = #0;„  UpArrow    = #72;„  LeftArrow  = #75;„  RightArrow = #77;„  DownArrow  = #80;„  PageUp     = #73;„  PageDown   = #81;„  ESC        = #27;„„Type„  StrPtr = ^LineBuffer;„„  LineBuffer = Record„    Line   : String[255];„    Next   : StrPtr;„    Prev   : StrPtr;„    Up23   : StrPtr;„    Down23 : StrPtr;„  end;„Var„  F       : Text;„  First,„  Last,„  Prev,„  Current : StrPtr;„  Line    : Byte;„  Row     : Byte;„„Function PadString( S : String ) : String;„Var„  X : Byte;„begin„  if ord(S[0]) > 79 then S[0]:=Chr(80);„  For X := (Length(S) + 1) to 79 Do„    S[X] := ' ';„  S[0] := Chr(79);„  PadString := S;„end;„„Procedure Normal;„begin„  TextColor(15);„  TextBackGround(0);„end;„„Procedure HighLite;„begin„  TextColor(10);„  TextBackGround(7);„end;„„Procedure AddString;„Var„  S : String;„„begin„  if First = Nil then„  begin„    Line := 1;„    New(Current);„    Current^.Prev   := Nil;„    Current^.Next   := Nil;„    Current^.Up23   := Nil;„    Current^.Down23 := Nil;„    ReadLn(F, S);„    Current^.Line   := S;„    Last  := Current;„    First := Current;„  end„  else„  begin„    Prev := Current;„    New(Current);„    Current^.Prev:=Prev;„    Current^.Next:=Nil;„    ReadLn(F,Current^.Line);„    if Line = 23 then„    begin„      Current^.Up23 := First;„      First^.Down23 := Current;„      Current^.Down23:= Nil;„    end„    else„    begin„      if Line > 23 then„      begin„        Current^.Up23 := Prev^.Up23^.Next;„        Current^.Up23^.Down23 := Current;„        Current^.Down23:=Nil;„      end„      else„      begin„        Current^.Up23:=Nil;„        Current^.Down23:=Nil;„      end;„    end;„    Prev^.Next:=Current;„    Last:=Current;„    if Line<=60 then„      Line:=Line + 1;„  end;„end;„„Procedure DrawScreen( This : StrPtr);„Var„  TRow : Byte;„begin„  TRow:=1;„  While TRow<=23 Do„   begin„     GotoXY(1,TRow);„     Write(PadString(This^.Line));„     This:=This^.Next;„     TRow:=TRow + 1;„   end;„end;„„Procedure Scrolling;„Var„  InKey : Char;„begin„  While (MemAvail>272) and (not Eof(F)) Do AddString;„  if not Eof(F) then„   begin„     GotoXY(1,1);„     TextColor(10);„     Write('Entire File not Loaded');„   end;„  Current:=First;„  Window(1,1,1,79);„  ClrScr;„  HighLite;„  GotoXY(1,1);„  Write(PadString(ParamStr(1)));„  Window(2,1,24,80);„  Normal;„  DrawScreen(First);„  Row:=1;„  Window(2,1,25,80);„  While InKey<>#27 Do„  begin„    InKey:=ReadKey;„    Case InKey of„      Null :„      begin„        InKey:=ReadKey;„        Case InKey of„          UpArrow :„          begin„            if Current^.Prev = Nil then„            begin„              Sound(2000);„              Delay(50);„              NoSound;„            end„            else„            begin„              if Row = 1 then„              begin„                GotoXY(1,1);„                Normal;„                Write(PadString(Current^.Line));„                GotoXY(1,1);„                InsLine;„                Current:=Current^.Prev;„                HighLite;„                Write(PadString(Current^.Line));„              end„              else„              begin„                GotoXY(1,Row);„                Normal;„                Write(PadString(Current^.Line));„                Row:=Row - 1;„                GotoXY(1,Row);„                HighLite;„                Current:=Current^.Prev;„                Write(PadString(Current^.Line));„              end;„            end;„          end;„„          DownArrow :„          begin„            if Current^.Next = Nil then„            begin„              Sound(2000);„              Delay(50);„              NoSound;„            end„            else„            begin„              if Row = 23 then„              begin„                GotoXY(1,23);„                Normal;„                Write(PadString(Current^.Line));„                GotoXY(1,1);„                DelLine;„                GotoXY(1,23);„                Current:=Current^.Next;„                HighLite;„                Write(PadString(Current^.Line));„              end„              else„              begin„                GotoXY(1,Row);„                Normal;„                Write(PadString(Current^.Line));„                Row:=Row + 1;„                GotoXY(1,Row);„                HighLite;„                Current:=Current^.Next;„                Write(PadString(Current^.Line));„              end;„            end;„          end;„„          PageDown :„           begin„            if (Row = 23) and (Current = Last) then„            begin„              Sound(2000);„              Delay(50);„              NoSound;„            end„            else„            begin„              Normal;„              if Current^.Down23 = Nil then„              begin„                Current:=Last;„                DrawScreen(Last^.Up23);„                Row:=23;„                GotoXY(1,Row);„                HighLite;„                Write(PadString(Current^.Line));„              end„              else„              begin„                Current:=Current^.Down23^.Next;„                DrawScreen(Current^.Up23);„                Row:=23;„                GotoXY(1,Row);„                HighLite;„                Write(PadString(Current^.Line));„              end;„            end;„          end;„„          PageUp :„          begin„            if (Row = 23) and (Current^.Up23 = Last) then„            begin„              Sound(2000);„              Delay(50);„              NoSound;„            end„            else„            begin„              Normal;„              if Current^.Up23 = Nil then„              begin„                Current:=First;„                DrawScreen(First);„                Row:=1;„                GotoXY(1,Row);„                HighLite;„                Write(PadString(First^.Line));„              end„              else„              begin„                Current:=Current^.Up23^.Prev;„                DrawScreen(Current);„                Row:=1;„                GotoXY(1,Row);„                HighLite;„                Write(PadString(Current^.Line));„              end;„            end;„          end;„        else„        begin„          Sound(2000);„          Delay(50);„          NoSound;„        end;„„        end;„      end;„„    else„    begin„      Sound(2000);„      Delay(50);„      NoSound;„    end;„„    end;„  end;„end;„„begin„  if ParamCount < 1 then„  begin„    WriteLn('Invalid Number of Parameters!!!');„    Halt(1);„  end;„  Assign(F, Paramstr(1));„  Reset(F);„  Current:=Nil;„  First:=Nil;„  Scrolling;„  GotoXY(1, 23);„  WriteLn;„  WriteLn;„end.„„                                                                            3      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SCROLL3.PAS              IMPORT              33     BµlÙ {„ Here is some demo code showing how to use Smooth.Obj.  It offers„ vertical and horizontal smooth scrolling in Text or Graphics modes.„„ NOTE:      Requires Smooth.Obj (see below)   EGA & VGA ONLY !!!!„„ REQUIRES:  Smooth.Obj  Run the debug script through DEBUG to create„            Smooth.Obj.  The NEXT message has the debug script.„„ ALSO:      Until last week, I'd never seen a line of Pascal code.„            So ForGIVE the rough edges of this code:  bear in mind„            the Complete novice status of its author <!!G!!>           }„„Uses Crt;„„{ NOTE:  SmoothScroll is a MEDIUM MODEL Asm/OBJ For use in„         **either** Pascal or most flavors of modern BASIC.„„         It expects parameters to be passed by reference!  We handle„         that here by not including Var, then passing Ofs(parameter).„„         Don't know if this is appropriate, but it works. Comments?   }„„{$F+} Procedure SmoothScroll(Row, Column: Integer); external; {$F-}„{$L Smooth.Obj}„„Var„   Row, Col, Speed, WhichWay : Integer;„   Ch : Char;„   s  : String [60];„„begin„   TextColor (14); TextBackground (0); ClrScr;„„   GotoXY (25,4);  Write ('Press <Escape> to move on.');„„   ch := 'A';„   For Row := 10 to 24 do„       begin„         FillChar (s, Sizeof(s), ch);„         s[0] := #60;  Inc (ch);„         GotoXY (10, Row); Write (s);„       end;„„   Speed := 1;                         { Change Speed!  See notes. }„„   {The higher the Speed, the faster the scroll.„        Use Speed = 1 For subtle scrolling.„        Try Speed = 5 (10 in Graphics) For very fast scrolling.„        Try Speed = 10+ (25 in gfx) to see some **Real shaking**.„„        Even in Text mode here, Row and Column use GraphICS MODE„        pixel coordinates (ie., begin w/ 0,0).   }„„   {================================= demo vertical smooth scrolling}„   Row := 0; Col := 0;„   WhichWay := Speed;                   { start by going up }„„   Repeat                               { press any key to end demo }„      GotoXY (2,10);  Write (Row, ' ');„      SmoothScroll(ofs(Row), ofs(Col));„      Row := Row + WhichWay;„„      if (Row > 150) or (Row < 2) then  { try 400 here }„         WhichWay := WhichWay * -1;     { reverse direction }„„      if Row < 1 then Row := 1;„„   Until KeyPressed;„„   ch := ReadKey; Row := 0; Col := 0;„   SmoothScroll ( ofs(Row), ofs(Col) ); { return to normal (sort of) }„„   {================================= demo horizontal smooth scrolling}„   Row := 0; Col := 0;„   WhichWay := Speed;                   { start by going left }„„   Repeat                               { press any key to end demo }„      GotoXY (38,3); Write (Col, ' ');„      SmoothScroll(ofs(Row), ofs(Col));„      Col := Col + WhichWay;„„      if (Col > 65) or (Col < 0) then   { try 300 here }„         WhichWay := WhichWay * -1;     { reverse direction }„      if Col < 0 then Col := 0;„   Until KeyPressed;„„   Row := 0; Col := 0; SmoothScroll(ofs(Row), ofs(Col));„end.„„{ Capture the following to a File (eg. S.Scr).„ then:    DEBUG < S.SCR.„„ Debug will create SMOOTH.OBJ.„„ N SMOOTH.OBJ„ E 0100 80 0E 00 0C 73 6D 74 68 73 63 72 6C 2E 61 73 6D„ E 0110 87 96 27 00 00 06 44 47 52 4F 55 50 0D 53 4D 54„ E 0120 48 53 43 52 4C 5F 54 45 58 54 04 44 41 54 41 04„ E 0130 43 4F 44 45 05 5F 44 41 54 41 90 98 07 00 48 89„ E 0140 00 03 05 01 87 98 07 00 48 00 00 06 04 01 0E 9A„ E 0150 04 00 02 FF 02 5F 90 13 00 00 01 0C 53 4D 4F 4F„ E 0160 54 48 53 43 52 4F 4C 4C 00 00 00 A7 88 04 00 00„ E 0170 A2 01 D1 A0 8D 00 01 00 00 55 8B EC 06 56 33 C0„ E 0180 8E C0 8B 76 08 8B 04 33 D2 26 8B 1E 85 04 F7 F3„ E 0190 8B D8 8B CA 26 A1 4A 04 D0 E4 F7 E3 8B 76 06 8B„ E 01A0 1C D1 EB D1 EB D1 EB 03 D8 26 8B 16 63 04 83 C2„ E 01B0 06 EC EB 00 A8 08 74 F9 EC EB 00 A8 08 75 F9 26„ E 01C0 8B 16 63 04 B0 0D EE 42 8A C3 EE 4A B0 0C EE 42„ E 01D0 8A C7 EE 4A 83 C2 06 EC EB 00 A8 08 74 F9 83 EA„ E 01E0 06 B0 08 EE 8A C1 42 EE 83 C2 05 EC BA C0 03 B0„ E 01F0 33 EE 8B 76 06 8B 04 24 07 EE 5E 07 8B E5 5D CA„ E 0200 04 00 F5 8A 02 00 00 74„ RCX„ 0108„ W„ Q„„'========  end of Debug Script ========„}„„                                      4      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SCROLL4.PAS              IMPORT              12     Bµ˜h {> I need to be able to scroll the Text display in my File viewer,„> both left and right, to allowing reading of lines that extend past„> column 80.„„UnFortunately there's no way to scroll horizontally by BIOS or by another„service Function. You have to implement it on your own. Here are two Procedures„that I use in my Programs (in Case they must scroll left or right ;-)):„}„„{$ifNDEF VER70}„Const„  Seg0040   = $0040;„  SegB000   = $B000;„  SegB800   = $B800;„{$endif}„„Type„  PageType  = Array [1..50,1..80] of Word;„„Var„  Screen    : ^PageType;„  VideoMode : ^Byte;„„Procedure ScrollRight(X1,Y1,X2,Y2,Attr : Byte);„Var„  Y      : Byte;„  Attrib : Word;„begin„  Attrib := Word(Attr SHL 8);„  Y      := Y1-1;„  Repeat„    Inc(Y);„    Move(Screen^[Y,X1],Screen^[Y,X1+1],(X2-X1)*2);„    Screen^[Y,X1] := Attrib+32;„  Until Y=Y2;„end;„„Procedure ScrollLeft(X1,Y1,X2,Y2,Attr : Byte);„Var„  Y      : Byte;„  Attrib : Word;„begin„  Attrib := Word(Attr SHL 8);„  Y      := Y1-1;„  Repeat„    Inc(Y);„    Move(Screen^[Y,X1+1],Screen^[Y,X1],(X2-X1)*2);„    Screen^[Y,X2] := Attrib+32;„  Until Y=Y2;„end;„„begin„  VideoMode := Ptr(Seg0040,$0049);„  if VideoMode^=7 then„    Screen := Ptr(SegB000,$0000)„  else„    Screen := Ptr(SegB800,$0000);„end.„„{„X1, Y1, X2 and Y2 are the coordinates of the Windows to be scrolled. Attr is„the color of the vertical line that occurs after scrolling. ;-)„}„                  5      06-08-9308:17ALL                      LOU DUCHEZ               Write w/ Scroll Control  IMPORT              33     BµÖö (*„===========================================================================„ BBS: Canada Remote Systems„Date: 06-01-93 (06:21)             Number: 24456„From: LOU DUCHEZ                   Refer#: NONE„  To: MICHAEL DEAKINS               Recvd: NO  „Subj: ANSI, BATCH FILE EXEC'ING      Conf: (1221) F-PASCAL„---------------------------------------------------------------------------„MD>I have two questions. First, How can I display ANSI files from a Pascal„MD>program by using the CON driver (read: ANSI.SYS) instead of going to the„MD>trouble of writing a terminal emulator, and still remain„MD>window-relative? I used TP5.5's WRITE procedure to write to a file„MD>assigned to the CON device instead of the CRT unit's standard OutPut,„MD>but this obliterated my status line at the bottom of the screen when the„MD>ANSI file scrolled. Is there an easy way to write to the CON device„MD>while remaining window-relative without having to modify ANSI.SYS or„MD>write a terminal emulation procedure?„MD> My second question: How can I call a batch file from within a Pascal„MD>program and pass %1-%9 parameters to it? I'm aware of the EXEC„MD>procedure, but doesn't that only work on executables?„„Second question first: you're right about EXEC calling only executables.„So try calling "COMMAND.COM" as your program, and give it parameters of„"/C " plus the batch file name plus whatever arguments you intend to pass.„(That tells the system to run a single command out of DOS.)  Look up„ParamCount and ParamStr() to see how Pascal uses command-line parameters.„„First question second: you know, I addressed this problem just yesterday„trying to write a program.  I concluded that, if you're going to bypass„CRT, you need to do a lot of "manual" work yourself to keep a window„going.  Let me show you the tools I devised:„*)„„„{---PROCEDURE ATSCROLL: SCROLLS A SCREEN REGION UP OR DOWN (negative or„   positive number in LINESDOWN, respectively) }„„procedure atscroll(x1, y1, x2, y2: byte; linesdown: integer);„var tmpbyte, intbyte, clearattrib: byte;„begin„  if linesdown <> 0 then begin„    clearattrib := foxfore + foxback shl 4;„    x1 := x1 - 1;„    y1 := y1 - 1;„    x2 := x2 - 1;„    y2 := y2 - 1;„    if linesdown > 0 then intbyte := $07 else intbyte := $06;„    tmpbyte := abs(linesdown);„    asm„      mov ah, intbyte„      mov al, tmpbyte„      mov bh, clearattrib„      mov ch, y1„      mov cl, x1„      mov dh, y2„      mov dl, x2„      int 10h„      end;„    end;„  end;„„„„{---FUNCTION YPOS: Returns the line the cursor is on.  I wrote it because„   I don't always trust WHEREY (or WHEREX): they report, for example, the„   cursor position relative to a text window.  So I had it lying around,„   and I opted to use it in my routines.                                 }„„function ypos: byte;„var tmpbyt: byte;„begin„  asm„    mov ah, 03h„    mov bh, 0„    int 10h„    mov tmpbyt, dh„    end;„  ypos := tmpbyt + 1;„  end;„„„„{--- PROCEDURE WRITEANDFIXOVERHANG: I use it in place of WRITELN in my„    program: before writing a line of text, it checks if there's room„    at the bottom of the screen.  If not, it scrolls the screen up„    before writing.  Keep in mind that this program is bent on preserving„    the top three or four screen lines, not the bottom lines. }„„procedure writeandfixoverhang(strin: string);„const scrollat: byte = 24;„var overhang: byte;„begin„  if ypos >= scrollat then begin„    overhang := ypos - scrollat + 1;„    atscroll(0, 4 + overhang, 0, 80, 25, -overhang);„    movecursor(1, ypos - overhang);„    end;„  writeln(strin);„  end;„„{„So assuming your text lines don't get too long (line longer than 160 chars),„these routines will keep the top of your screen from getting eaten.  If you„want to preserve space at the bottom of the screen instead (or both top and„bottom), change WRITEANDFIXOVERHANG.„„BTW, if there are any compiling problems, let me know.  I took out all the„stuff that applied specifically to my application -- I might have stupidly„changed something you need ... }„                                                                   6      11-02-9306:14ALL                      BERNIE PALLEK            Quick Scroller           IMPORT              17     Bµ   {„BERNIE PALLEK„„>Would anyone happen to know how I can use the ASCII Characters„>while in Video mode $13 (320x200x256)? Or better yet, make a message„>scroll across the screen like in them neat intros and demos..„„The easiest way to do it is to set DirectVideo to False (if you are using„the Crt Unit).  This disables direct Writes to the screen, meaning that„the BIOS does screen writing, and the BIOS works in just about every„screen mode.  Then, you can just use Write and WriteLn to display Text„Characters (I think GotoXY will even work).  As For scrolling...„Since mode 13h ($13) has linearly addressed video memory (just a run„of 64,000 contiguous Bytes), do something like this:„„this is untested, but it might actually work  :')„}„„Uses„  Crt;„Const„  msgRow = 23;„  waitTime = 1; { adjust suit your CPU speed }„  myMessage : String = 'This is a test message.  It should be more ' +„        'than 40 Characters long so the scrolling can be demonstrated.';„Var„  sx, xpos : Byte;„„Procedure MoveCharsLeft;„Var„  curLine : Word;„begin„  { shift the row left 1 pixel }„  For curLine := (msgRow * 8) to (msgRow * 8) + 7 DO„    Move(Mem[$A000 : curLine * 320 + 1], Mem[$A000 : curLine * 320], 319);„  { clear the trailing pixels }„  For curLine := (msgRow * 8) to (msgRow * 8) + 7 DO„    Mem[$A000 : curLine * 320 + 319] := 0;„end;„„begin„  Asm„    MOV AX, $13„    INT $10„  end;„  DirectVideo := False;„  GotoXY(1, msgRow + 1);„  Write(Copy(myMessage, 1, 40));„  { 'myMessage' must be a String With a Length > 40 }„  For xpos := 41 to Length(myMessage) do„  begin„    For sx := 0 to 7 do„    begin„      MoveCharsLeft;„      Delay(waitTime);„    end;„    GotoXY(40, msgRow + 1);„    Write(myMessage[xpos]);„  end;„  Asm„    MOV AX, $3„    INT $10„  end;„end.„„{„This may not be very efficiently coded.  As well, it could benefit from„an Assembler version.  But it should at least demonstrate a technique„you can learn from.  }„„                                                                                                                  7      11-02-9306:14ALL                      DANIEL JOHN LEE PARNELL  Scrolling Demo           IMPORT              71     Bµ   {„S921878@MINYOS.XX.RMIT.OZ.AU, Daniel John Lee Parnell„„ I have received several requests for the source code to the„scrolly demo I posted to this group.  Sorry about posting a binary.  I„didn't know it was not allowed on this group.  Anyway the following is the„source code to the scrolly.  It is not a unit.  It uses one 286„instruction so it wont work on an XT :(„}„„{$G+}„program ColorBars;„„uses„  DOS, CRT;„„const„  maxBars  = 7;„  maxStars = 100;„  maxLines = 7;„  m : array [1..maxLines] of string =„     ('Welcome to my first scrolly demo on the PC.    It was written using ',„      'Turbo Pascal 6.0 on the 7th of October 1993.  This program took me ',„      'about 2 hours to write and I had a lot of fun writing it!         ',„      'I suppose I''d better put in some greets I guess...............',„      'Greetings go to      Robyn       Adam       Rowan      Mandy       ',„      '   Weng       Speed      Shane      Iceberg Inc.       And anybody ',„      'else out there whom I have forgotten about......         ');„„var„  colors   : array [0..768] of byte;„  rMsk,„  gMsk,„  bMsk     : array [0..255] of byte;„  y, dy, s : array [1..maxBars]  of integer;„  sx, sy,„  sdx      : array [1..maxStars] of integer;„  tx, ty   : array [0..640]      of integer;„  dot      : integer;„  ticks    : word;„  scrly    : array [0..360] of integer;„  mpos,„  mlen     : integer;„„procedure SetMode(m : integer);   { Set video mode }„var„  regs : registers;„begin„  regs.ax := m;„  intr($10, regs);„end;„„procedure WaitRetrace;          { Wait for vertical retrace }„begin„  repeat { Nothing } until (Port[$03da] and 8) <> 0;„end;„„procedure WaitNotRetrace;       { Wait for not vertical retrace }„begin„  repeat { Nothing } until (Port[$03da] and 8) <> 8;„end;„„procedure InitScreen;           { Sets up the colored bars }„var„  i, j : integer;„begin„  for i := 0 to 199 do„    for j := 0 to 319 do„      mem[$a000 : i * 320 + j] := i;„end;„„procedure InitColors;           { Zeros the first 200 colors }„var„  i : integer;„begin„  for i := 0 to 199 * 3 do„    colors[i] := 0;„end;„„procedure SetColors; assembler;   { Loads the colors into the regs }„asm„ @ntrace:                { Wait for not retrace }„  mov  dx, $03da„  in   al, dx„  test al, 8„  jnz  @vtrace„„ @vtrace:                { Now wait for retrace }„  mov  dx, $03da„  in   al, dx„  test al, 8„  jz   @vtrace„„  mov  dx, $03c8          { Start changeing colors from color # 1 }„  mov  al, 1„  out  dx, al„„  inc  dx                { Make DX point to the color register }„  mov  cx, 199*3          { The number of bytes to put into the color register }„  mov  si, offset colors  { Load the address of the color array }„  rep  outsb             { Now change the colors }„end;„„procedure CalcBars;     { Calculate the color bars }„var„  i, j, k : integer;„begin„  for i := 0 to 199 * 3 do  { Zero all the colors }„    colors[i] := 0;„„  for i := 1 to maxBars do { Now process each bar in turn }„  begin„    y[i] := y[i] + dy[i];  { Move the bar }„    if (y[i] < 4) or (y[i] > 190) then  { Has it hit the top or the bottom? }„    begin„      dy[i] := -dy[i];              { Yes, so make it bounce }„      y[i]  := y[i] + dy[i];„    end;„„  for j := (y[i] - s[i]) to (y[i] + s[i]) do  { Now update the color array }„  begin„    if j < y[i] then       { Calculate the intensity }„      k := 63 - (y[i] - j) * 4„    else„      k := 63 - (j - y[i]) * 4;„„    if j > 0 then          { If it is a valid color change it }„    begin„      colors[j * 3]     := (colors[j * 3]   + (k and rMsk[i]));   { Do red }„      colors[j * 3 + 1] := (colors[j * 3 + 1] + (k and gMsk[i])); { Do green }„      colors[j * 3 + 2] := (colors[j * 3 + 2] + (k and bMsk[i])); { Do blue }„    end;„    end;„  end;„end;„„procedure InitBars;     { Set up the bars randomly }„var„  i : integer;„begin„  for i := 1 to MaxBars do„  begin„    y[i] := random(150)+4;       { Starting pos }„    s[i] := random(6)+4;         { Size }„„    rMsk[i] := random(2)*255;    { Red mask }„    gMsk[i] := random(2)*255;    { Green mask }„    bMsk[i] := random(2)*255;    { Blue mask }„„    repeat                     { Calc direction }„      dy[i] := random(6) - 3;„    until dy[i] <> 0;„  end;„end;„„procedure InitStars;            { Set up the stars }„var„  i : integer;„begin„  port[$03c8] := $f8;                     { Change the colors for stars }„  for i := 7 downto 0 do„  begin„    port[$03c9] := 63 - (i shl 2);„    port[$03c9] := 63 - (i shl 2);„    port[$03c9] := 63 - (i shl 2);„  end;„„  for i := 1 to maxStars do„  begin„    sx[i]  := random(320);               { Choose  X pos }„    sy[i]  := random(200);               {         Y pos }„    sdx[i] := 1 shl random(3);          {         Speed }„  end;„end;„„procedure InitScroll;   { Initialize the scrolly }„const„  k = 3.141 / 180;„var„  i : integer;„begin„  mlen := 0;                      { Calc length of scroll text }„  for i := 1 to maxLines do„   mlen := mlen + length(m[i]);„„  for i := 0 to 640 do            { Zero all the star positions }„    tx[i] := -1;„„  for i := 0 to 360 do            { Calculate the scroll path }„    scrly[i] := round(100 + 50 * sin(i * k));„end;„„procedure UpdateStars;          { Draw the stars }„var„  i, ad : integer;„begin„  for i := 1 to maxStars do„  begin„    ad := sx[i] + sy[i] * 320;              { Calc star address in video ram }„    mem[$a000 : ad] := sy[i];             { Unplot old star pos }„    sx[i] := sx[i] + sdx[i];              { Calc new star pos }„„    if sx[i] > 319 then                 { Is it past the end of the screen? }„    begin„      sy[i] := random(200);           { Yes, generate a new star }„      sx[i] := 0;„      sdx[i] := 1 shl random(3);„      ad := sx[i] + sy[i] * 320;„    end;„    mem[$a000:ad + sdx[i]] := $f7 + (sdx[i]) * 2;„  end;„end;„„function msg(var i : integer) : char;     { Get a char from the scroll text }„var„  j, t, p : integer;„begin„  if i > mlen then                { Is I longer then the text? }„    i := 1;„„  j := 0;                         { Find which line it is in }„  t := 0;„  repeat„    inc(j);„    t := t + length(m[j]);„  until i<t;„„  p := i - t + length(m[j]);          { Calculate position in line }„„  if p > 0 then„    msg := m[j][p]„  else„    msg := chr(0);„  inc(i);                       { Increment text position }„end;„„procedure NextChar;             { Create nex character in scroll text }„var„  ad   : word;„  i, j,„  q, c : integer;„begin„  c := ord(msg(mpos));            { Get the char }„„  ad := $fa6e + (c * 8);              { Calc address of character image in ROM }„  for i := 0 to 7 do„  begin„    q := mem[$f000 : ad + i];       { Get a byte of the image }„    for j := 0 to 7 do„    begin„      if odd(q) then        { Is bit 0 set? }„      begin„        tx[dot] := 320 + (7 - j) * 4;   { If so add a dot to the list }„        ty[dot] := i * 4;„        inc(dot);„        if dot > 640 then„          dot := 0;„      end;„      q := q shr 1;           { Shift the byte one pos to the right }„    end;„  end;„end;„„procedure DisplayScroll;        { Display scrolly and update dot positions }„var„  i  : integer;„  ad : word;„begin„  if (ticks mod 32) = 0 then      { Is it time for the next char? }„    NextChar;„„  for i := 0 to 640 do„    if tx[i] > 0 then             { Is this dot being used? }„    begin„      if tx[i] < 320 then         { Is it on the screen? }„      begin„        ad := tx[i] + (ty[i] + scrly[tx[i]]) * 320;  { Calc old position }„        mem[$a000:ad] := ty[i] + scrly[tx[i]];   { Clear old dot }„      end;„„      dec(tx[i]);                              { Move dot to the left }„      ad := tx[i] + (ty[i] + scrly[tx[i]]) * 320;      { Calc new position }„„      if (tx[i] > 0) and (tx[i] < 320) then        { Is it on the screen? }„        mem[$a000:ad] := $ff - (ty[i] shr 2);      { Plot new dot }„„    end;„end;„„begin„  randseed := 4845267;            { Set up the random seed   }„  SetMode($13);                 { Go to 320*200*256 mode   }„  InitColors;                   { Blank the color array    }„  SetColors;                    { Set the colors to black  }„  InitScreen;                   { Set up the colored bars  }„  InitBars;                     { Set up the bar positions }„  InitStars;                    { Set up the stars         }„  InitScroll;                   { Set up the scrolly       }„  dot  := 0;                       { Set the dot counter to 0 }„  mpos := 1;                      { Set up the text pos      }„„  repeat„    CalcBars;                   { Calculate the color bars   }„    DisplayScroll;              { Display the scrolly text   }„    UpdateStars;                { Update & display the stars }„    SetColors;                  { Set the colors             }„    inc(ticks);                 { Update the tick counter    }„  until KeyPressed;„„  SetMode(3);                   { Return to text mode }„end.„                                                                    8      01-27-9412:15ALL                      BAS VAN GAALEN           BIG Scroller - NEAT!     IMPORT              11     Bµ   {„I'm not sure if there're people who are still searching for a _big_ scroll„(meaning bigger than just one line). If so, here's some source:„„{ --- cut here --- }„„program Simple_Old_TextScroll;„„uses crt;„const Sseg : word = $b800; Hi = 17; Txt : string = 'Hello world...      ';„var Fseg,Fofs : word; I,Cur,Idx,Line,BitPos : byte;„„procedure Getfont; assembler; asm„  mov ax,1130h; mov bh,3; int 10h; mov Fseg,es; mov Fofs,bp; end;„„procedure Retrace; assembler; asm„  mov dx,3dah;„  @l1: in al,dx; test al,8; jnz @l1;„  @l2: in al,dx; test al,8; jz @l2; end;„„begin„  GetFont;„  Idx := 1;„  repeat„    Cur := ord(Txt[Idx]);„    for BitPos := 0 to 7 do begin„      for Line := 0 to 7 do begin„        if ((mem[Fseg:Fofs+Cur*8+Line] shl BitPos) and 128) <> 0 then„          mem[Sseg:158+(Line+Hi)*160] := 219„        else„          mem[Sseg:158+(Line+Hi)*160] := 32;„      end;„      Retrace;„      for Line := 0 to 7 do„        for I := 0 to 78 do„          mem[Sseg:(Line+Hi)*160+I+I] := mem[Sseg:(Line+Hi)*160+I+I+2];„„    end;„    Idx := 1+Idx mod length(Txt);„  until keypressed;„end.„„{ --- cut here --- }„„Keep in mind this thing expects a VGA card with the textmemory at $b800.„„                                                                                            9      01-27-9412:15ALL                      BAS VAN GAALEN           Sinus Scroll             IMPORT              20     Bµ   {„> but you can use Pascal to do things like this:„}„program SinusScroll;„const„  GSeg = $a000;„  Sofs = 140; Samp = 40; Slen = 255;„  Size = 2; Curve = 3;„  Xmax = 279 div Size; Ymax = 7;„  ScrSpd = -1;„  ScrText : string =„    ' Hai world... This looks a bit like the scroll of the second part'+„    ' of Future Crew''s Unreal demo (part one)...     It''s not filled'+„    ' but it sure looks nicer (imho)...                               ';„type SinArray = array[0..Slen] of word;„var Stab : SinArray; Fseg,Fofs : word;„„procedure CalcSinus; var I : word; begin„  for I := 0 to Slen do Stab[I] := round(sin(I*4*pi/Slen)*Samp)+Sofs; end;„„procedure GetFont; assembler; asm„  mov ax,1130h; mov bh,1; int 10h; mov Fseg,es; mov Fofs,bp; end;„„procedure SetGraphics(Mode : word); assembler; asm„  mov ax,Mode; int 10h end;„„function keypressed : boolean; assembler; asm„  mov ah,0bh; int 21h; and al,0feh; end;„„procedure Scroll;„type„  ScrArray = array[0..Xmax,0..Ymax] of byte;„  PosArray = array[0..Xmax,0..Ymax] of word;„var„  PosTab : PosArray;„  BitMap : ScrArray;„  X,I,SinIdx : word;„  Y,ScrIdx,CurChar : byte;„begin„  fillchar(BitMap,sizeof(BitMap),0);„  fillchar(PosTab,sizeof(PosTab),0);„  ScrIdx := 1; SinIdx := 0;„  repeat„    Curchar := ord(ScrText[ScrIdx]);„    inc(ScrIdx); if ScrIdx = length(ScrText) then ScrIdx := 1;„    for I := 0 to 7 do begin„      move(BitMap[1,0],BitMap[0,0],(Ymax+1)*Xmax);„      for Y := 0 to Ymax do„        if ((mem[Fseg:Fofs+8*CurChar+Y] shl I) and 128) <> 0 then„          BitMap[Xmax,Y] := ((ScrIdx+Y-I) mod 70)+32 else BitMap[Xmax,Y] := 0;„      while (port[$3da] and 8) <> 0 do;„      while (port[$3da] and 8) = 0 do;„      for X := 0 to Xmax do„        for Y := 0 to Ymax do begin„          mem[GSeg:PosTab[X,Y]] := 0;„          PosTab[X,Y] := (Size*Y+STab[(SinIdx+X+Curve*Y) mod„                      SLen])*320+Size*X+STab[(X+Y) mod SLen]-SOfs;„          mem[GSeg:PosTab[X,Y]] := BitMap[X,Y];„        end;„      SinIdx := (SinIdx+ScrSpd) mod SLen;„    end;„  until keypressed;„end;„„begin„  CalcSinus;„  GetFont;„  SetGraphics($13);„  Scroll;„  SetGraphics(3);„end.„„{ --- and again --- }„„The prior 'release' was a bit buggy indeed (as I expected). So here's a„better working version. It's smaller too. Not only thanx to the„variable-size. Have fun!„„Btw: 'keypressed' was taken from Sean Palmers' GhostEd. The rest, of course,„by me! ;-)„                                         10     01-27-9412:21ALL                      ERIC MILLER              Multi-Line Scroll        IMPORT              12     Bµ   {„> Last month this routine for scrolling text across the screen was„> posted in this echo.  It's a great routine but would the author of the„> routine please describe how to place the scrolling text on any of the„> 25 vertical lines, how to change the background color...the foreground„> color I found. Also, can this routine place the text between two„> points on the screen without writing over the extreme left and right„> sides?„„This should be what you're looking for.  I sort exapnded on the„old code, but instead of using Mem for direct writes I set a„screen structure over the text screen instead...makes it easier„to understand.      }„„PROGRAM NewScroll;„Uses Crt;„„TYPE„  TCell = RECORD C: Char; A: Byte; END;„  TScreen = array[1..25, 1..80] of TCell;„„CONST„  Row: byte = 15;„  Col1: byte = 10;„  Col2: byte = 70;„  Attr: byte = $4F; { bwhite / red }„  Txt: string = 'Hello world....         ';„„VAR„  Scr: TScreen ABSOLUTE $B800:0;„  I, J: Byte;„BEGIN„  I := 1;„  REPEAT„    while (port[$3da] and 8) <> 0 do;  { wait retrace }„    while (port[$3da] and 8) = 0 do;„    FOR J := Col1 TO (Col2-1) DO„      Scr[Row, J] := Scr[Row, J+1];  { shift cell left }„    Scr[Row, Col2].C := Txt[I];      { add new cell }„    Scr[Row, Col2].A := Attr;„    I := 1 + (I MOD Length(Txt));„  UNTIL Keypressed;„„END.„„                                                                                               11     01-27-9412:21ALL                      THORSTEN BARTH           Screen Info - Scrolling  IMPORT              9      Bµ   {„> I need help with a scroller for the textmode (25x80)...I ran into some„> trouble..:(.. The major problem is that it has to quite fast, so my choise„> was to make the scroller using Mem [VidSeg....] and Move but I just don't„> seem to get it right... So if anybody out there has got a scroller for the„> textmode please post it... Nevermind if it's not so fast, it might help„> anyway„„I tested the single line scroller, and it worked. (Delayed 50 instead of 10)„(make the constant a string to compile it).„„Now a simple scroll command for the entire screen (up)„}„Move(Mem[Vidseg,160],Mem[Vidseg,0],3840);     or just writeln„{„entire screen(down)„}„Move(Mem[Vidseg,0],Mem[Vidseg,160],3840);„{„entire screen(left)„}„Move(Mem[Vidseg,2],Mem[Vidseg,0],3998);„{„then write all characters that are new in the right column„„entire screen(right)„}„Move(Mem[VidSeg,0],Mem[VidSeg,2],3998);„{„then write all characters in new left column„}„                                                                                          12     01-27-9412:22ALL                      DAVID DAHL               Smooth Text Scroll       IMPORT              63     Bµ   {„> Does anybody know if it is possible to accomplish a smooth-text scroller„> (like in the old c64 dayz) in text mode? If so, please let me know and„„> Well, it's impossible, you'll have to switch to a graphic mode.„„        No, it's possible in text mode... it's just a pain in the„arse.  I know of two ways.  The first is to use an alternate„character set (the EGA can have 2 on screen at once, the VGA can„have 4).  You use one character set as normal text, and use the„other as a pseudo-graphics window.  Put the text you need to„scroll in the window and move (copy) it a pixel at a time.  The„second way is to use the 8253 timer to time the scanline.  When„the scanline gets to the portion of the screen you want, turn off„v-retrace, set v-retrace on the next scan line, and set the„horizontal pel pan to the value you need for your smooth pan.„When the card gets to the line that the v-retrace would occur, it„resets the pan but doesn't retrace because you turned it off.„After this, reset the registers you changed back to their default„values so the card builds the screen correctly.  This is done on„EVERY screen build.  Needless to say, the pseudo-graphics window„version is easier so that's the one I used to program the example„that follows.„}„„Program SmoothTextScrollExample1;„„{==============================================„„       Smooth Scroll In Text Mode Example„           Programmed by David Dahl„                   12/21/93„   This program and source are PUBLIC DOMAIN„„ ----------------------------------------------„„   This example uses a second font to scroll„   the text.  The font definition is changed„   to make the text scroll.  This program„   requires VGA.„„ ==============================================}„„Uses  CRT;„„Type  FontDefType = Array[0..255, 0..31] of Byte;„„Var   ScrollText : String;„„      FontDef    : FontDefType;„„Procedure SetCharWidthTo8; Assembler;„Asm„   { Change To 640 Horz Res }„   MOV DX, $3CC„   IN  AL, DX„   AND AL, Not(4 OR 8)„   MOV DX, $3C2„   OUT DX, AL„„   { Turn Off Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 0„   OUT DX, AL„„   { Reset Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„„   { Switch To 8 Pixel Wide Fonts }„   MOV DX, $3C4„   MOV AL, 1„   OUT DX, AL„   MOV DX, $3C5„   IN  AL, DX„   OR  AL, 1„   OUT DX, AL„„   { Turn Off Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 0„   OUT DX, AL„„   { Reset Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„„   { Center Screen }„   MOV DX, $3DA„   IN  AL, DX„   MOV DX, $3C0„   MOV AL, $13 OR 32„   OUT DX, AL„   MOV AL, 0„   OUT DX, AL„End;„„Procedure WriteScrollTextCharacters(Row : Byte);„Var Counter : Word;„Begin„     { Set Fonts 0 & 1 }„     ASM„        MOV BL, 4„        MOV AX, $1103„        INT $10„     END;„„     { Write Characters }„     For Counter := 0 to 79 do„     Begin„          { Set Characters }„„          MEM[$B800:(80*2)*Row+(Counter*2)]   := Counter;„          { Set Attribute To Secondary Font }„          MEM[$B800:(80*2)*Row+(Counter*2)+1] :=„             MEM[$B800:(80*2)*Row+(Counter*2)+1] OR 8;„„     End;„„End;„„Procedure FlushKeyBoardBuffer;„Var Key : Char;„Begin„     While KeyPressed do„           Key := ReadKey;„End;„„Procedure SetAccessToFontMemory; Assembler;„ASM„   { Turn Off Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 1„   OUT DX, AL„„   { Reset Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„„   { Change From Odd/Even Addressing to Linear }„   MOV DX, $3C4„   MOV AL, 4„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 7„   OUT DX, AL„„   { Switch Write Access To Plane 2 }„   MOV DX, $3C4„   MOV AL, 2„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 4„   OUT DX, AL„„   { Set Read Map Reg To Plane 2 }„   MOV DX, $3CE„   MOV AL, 4„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 2„   OUT DX, AL„„   { Set Graphics Mode Reg }„   MOV DX, $3CE„   MOV AL, 5„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 0„   OUT DX, AL„„   { Set Misc. Reg }„   MOV DX, $3CE„   MOV AL, 6„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 12„   OUT DX, AL„End;„„Procedure SetAccessToTextMemory; Assembler;„ASM„   { Turn Off Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 1„   OUT DX, AL„„   { Reset Sequence Controller }„   MOV DX, $3C4„   MOV AL, 0„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„„   { Change To Odd/Even Addressing }„   MOV DX, $3C4„   MOV AL, 4„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3„   OUT DX, AL„„   { Switch Write Access }„   MOV DX, $3C4„   MOV AL, 2„   OUT DX, AL„   MOV DX, $3C5„   MOV AL, 3  {?}„   OUT DX, AL„„   { Set Read Map Reg }„   MOV DX, $3CE„   MOV AL, 4„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 0„   OUT DX, AL„„   { Set Graphics Mode Reg }„   MOV DX, $3CE„   MOV AL, 5„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, $10„   OUT DX, AL„„   { Set Misc. Reg }„   MOV DX, $3CE„   MOV AL, 6„   OUT DX, AL„   MOV DX, $3CF„   MOV AL, 14„   OUT DX, AL„End;„„Procedure MakeFontDefTable;„Var  CounterX,„     CounterY  : Word;„Begin„     SetAccessToFontMemory;„„     For CounterY := 0 to 255 do„         For CounterX := 0 to 31 do„             FontDef[CounterY, CounterX] :=„                 MEM[$B800:(CounterY * 32)+CounterX];„„     SetAccessToTextMemory;„End;„„Procedure ClearSecondFontMemory;„Var Counter : Word;„Begin„     SetAccessToFontMemory;„„     For Counter := 0 to 32 * 256 do„         MEM[$B800:$4000 + Counter] := 0;„„     SetAccessToTextMemory;„End;„„Procedure ScrollMessage;„Const CharCol  : Integer = 8;„      Counter  : Byte = 1;„      COUNTERY : Byte = 0;„      PWRTbl   : Array [0..7] of Byte = (1,2,4,8,16,32,64,128);„Begin„     SetAccessToFontMemory;„„     ASM„        { Wait For Retrace }„        MOV DX, $3DA„        @RT:„         IN   AL, DX„         TEST AL, 8„        JZ @RT„„        { Scroll Text One Pixel To The Left }„        MOV AX, $B800 + ($4000 / 16)„        MOV ES, AX„        MOV CX, 32„        @Row:„         MOV DI, (79 * 32) - 1„         ADD DI, CX„         SHL byte ptr ES:[DI], 1„         PUSHF„         SUB DI, 32„         POPF„         PUSH CX„         MOV CX, 79„         @Chrs:„          RCL byte ptr ES:[DI], 1„          PUSHF„          SUB DI, 32„          POPF„         Loop @Chrs„         POP CX„        Loop @Row„     END;„„     If CharCol < 0„     Then„„     Begin„          CharCol := 7;„          Inc(Counter);„     End„     Else„         Dec(CharCol);„„     If Counter > Length(ScrollText)„     Then„         Counter := 1;„„     { Write New Column Of Pixels }„     For CounterY := 0 to 31 do„     MEM[$B800:$4000 + (79 * 32) + CounterY] :=„         MEM[$B800:$4000 + (79 * 32) + CounterY] OR„          ((FontDef[Ord(ScrollText[Counter]), CounterY] AND PwrTbl[CharCol])„            SHR CharCol);„„     SetAccessToTextMemory;„End;„„Procedure TurnCursorOff; Assembler;„ASM„   MOV DX, $3D4„   MOV AL, $0A„   OUT DX, AL„   MOV DX, $3D5„   IN  AL, DX„   OR  AL, 32„   OUT DX, AL„End;„„Procedure TurnCursorOn; Assembler;„ASM„   MOV DX, $3D4„   MOV AL, $0A„   OUT DX, AL„   MOV DX, $3D5„   IN  AL, DX„   AND AL, Not(32)„   OUT DX, AL„End;„„Begin„     TextMode (C80);„     TurnCursorOff;„     SetCharWidthTo8;„     MakeFontDefTable;„     ClearSecondFontMemory;„     TextColor(Red);„     ClrScr;„„     ScrollText := 'This program is one example of how a smooth '+„                   'scroll can be done in text mode.            ';„„     WriteScrollTextCharacters(10);„„     TextColor(Blue);„     GoToXY (26,10);„     Write  ('Text Mode Smooth Scroll Example');„     GoToXY (34,11);„     Write  ('By David Dahl');„„     FlushKeyBoardBuffer;„„     Repeat„           ScrollMessage;„     Until Keypressed;„„     FlushKeyboardBuffer;„„     TextMode (C80);„     TurnCursorOn;„End.„    13     01-27-9412:22ALL                      JOHN BECK                Smooth Scroll with Asm   IMPORT              117    Bµ   {„;„; Adapted from Programmer's Guide to PC & PS/2 Video Systems (1-55615-103-9)„;„; Routine written by Richard Wilton„;„;„; Name:         ScreenOrigin„;„; Function:     Set screen origin on EGA and VGA.„;„; Caller:       Pascal:„;„;                       ScreenOrigin(x,y : integer);„;„;                       x,y                (* pixel x,y coordinates *)„;„„; Pascal calling convention„„ARGx            EQU     word ptr [bp+8] ; stack frame addressing„ARGy            EQU     word ptr [bp+6]„„;„; C calling convention„;„; ARGx            EQU     word ptr [bp+4]„; ARGy            EQU     word ptr [bp+6]„„CRT_MODE        EQU     49h             ; addresses in video BIOS data area„ADDR_6845       EQU     63h„POINTS          EQU     85h„BIOS_FLAGS      EQU     89h„„„DGROUP          GROUP   _DATA„„„_TEXT           SEGMENT byte public 'CODE'„                ASSUME  cs:_TEXT,ds:DGROUP„„                PUBLIC  ScreenOrigin„ScreenOrigin    PROC    far„„                push    bp              ; preserve caller registers„                mov     bp,sp„                push    si„                push    di„„                mov     ax,40h„                mov     es,ax           ; ES -> video BIOS data area„                mov     cl,es:[CRT_MODE]„„                mov     ax,ARGx         ; AX := pixel x-coordinate„                mov     bx,ARGy         ; BX := pixel y-coordinate„„                cmp     cl,7„                ja      L01             ; jump if graphics mode„„                je      L02             ; jump if monochrome alpha„                test    byte ptr es:[BIOS_FLAGS],1„                jnz     L02             ; jump if VGA„                jmp     short L03„„; setup for graphics modes (8 pixels per byte)„„L01:„                mov     cx,8            ; CL := 8 (displayed pixels per byte)„                                        ; CH := 0„                div     cl              ; AH := bit offset in byte„                                        ; AL := byte offset in pixel row„                mov     cl,ah           ; CL := bit offset (for Horiz Pel Pan)„                xor     ah,ah„                xchg    ax,bx           ; AX := Y„                                        ; BX := byte offset in pixel row„„                mul     word ptr BytesPerRow„                                        ; AX := byte offset of start of row„                jmp     short L05„„; setup for VGA alphanumeric modes and EGA monochrome alphanumeric mode„;   (9 pixels per byte)„„L02:                                    ; routine for alpha modes„                mov     cx,9            ; CL := 9 (displayed pixels per byte)„                                        ; CH := 0„                div     cl              ; AH := bit offset in byte„                                        ; AL := byte offset in pixel row„                dec     ah              ; AH := -1, 0-7„                jns     L04             ; jump if bit offset 0-7„                mov     ah,8            ; AH := 8„                jmp     short L04„„; setup for EGA color alphanumeric modes (8 pixels per byte)„„L03:„                mov     cx,8            ; CL := 8 (displayed pixels per byte)„                                        ; CH := 0„                div     cl              ; AH := bit offset in byte„                                        ; AL := byte offset in pixel row„L04:„                mov     cl,ah           ; CL := value for Horiz Pel Pan reg„                xor     ah,ah„                xchg    ax,bx           ; AX := y„                                        ; BX := byte offset in row„                div     byte ptr es:[POINTS] ; AL := character row„                                             ; AH := scan line in char matrix„                xchg    ah,ch           ; AX := character row„                                        ; CH := scan line (value for Preset„                                        ;       Row Scan register)„                mul     word ptr BytesPerRow ; AX := byte offset of char row„                shr     ax,1            ; AX := word offset of character row„L05:„                call    SetOrigin„„                pop     di              ; restore registers and exit„                pop     si„                mov     sp,bp„                pop     bp„„                ret     4„„ScreenOrigin    ENDP„„SetOrigin       PROC    near            ; Caller: AX = offset of character row„                                        ;         BX = byte offset within row„                                        ;         CH = Preset Row Scan value„                                        ;         CL = Horizontal Pel Pan value„„                add     bx,ax           ; BX := buffer offset„„                mov     dx,es:[ADDR_6845] ; CRTC I/O port (3B4h or 3D4h)„                add     dl,6            ; video status port (3BAh or 3DAh)„„; update Start Address High and Low registers„„L20:„                in      al,dx           ; wait for start of vertical retrace„                test    al,8„                jz      L20„„L21:„                in      al,dx           ; wait for end of vertical retrace„                test    al,8„                jnz     L21„„                cli                     ; disable interrupts„                sub     dl,6            ; DX := 3B4h or 3D4h„„                mov     ah,bh           ; AH := value for Start Address High„                mov     al,0Ch          ; AL := Start Address High reg number„                out     dx,ax           ; update this register„„                mov     ah,bl           ; AH := value for Start Address Low„                inc     al              ; AL := Start Address Low reg number„                out     dx,ax           ; update this register„                sti                     ; enable interrupts„„                add     dl,6            ; DX := video status port„L22:„                in      al,dx           ; wait for start of vertical retrace„                test    al,8„                jz      L22„„                cli                     ; disable interrupts„„                sub     dl,6            ; DX := 3B4h or 3D4h„                mov     ah,ch           ; AH := value for Preset Row Scan reg„                mov     al,8            ; AL := Preset Row Scan reg number„                out     dx,ax           ; update this register„„                mov     dl,0C0h         ; DX := 3C0h (Attribute Controller„port)„                mov     al,13h OR 20h   ; AL bit 0-4 := Horiz Pel Pan reg„number„                                        ; AL bit 5   := 1„                out     dx,al           ; write Attribute Controller Address„reg„                                        ;   (The Attribute Controller address„                                        ;    flip-flop.)„                mov     al,cl           ; AL := value for Horiz Pel Pan reg„                out     dx,al           ; update this register„„                sti                     ; enable interrupts„                ret„„SetOrigin       ENDP„„_TEXT           ENDS„„„_DATA           SEGMENT word public 'DATA'„„                EXTRN   BytesPerRow : word  ; bytes per pixel row„„_DATA           ENDS„„                END„„}„{$A+,B-,D+,E+,F+,G-,I+,L+,N-,O+,P+,Q+,R+,S+,T-,V+,X+,Y+}„{$M 65520,0,655360}„„(****************************************************************************)„ {                                                                          }„ { MODULE       : SCROLL                                                    }„ {                                                                          }„ { DESCRIPTION  : Generic unit for perform smooth scrolling.                }„ {                                                                          }„ { AUTHOR       : John M. Beck                                              }„ {                                                                          }„ { MODIFICATIONS: None                                                      }„ {                                                                          }„ { HISTORY      : 29-Dec-1993  Coded.                                       }„ {                                                                          }„(****************************************************************************)„„unit scroll;„„interface„„const„   charwidth  = 8;„   charheight = 14;  { depends on adapter }„„var„   screenseg    : word;„   bytesperrow  : word;„„function getvideomode : byte;„„procedure smoothscroll;„„procedure gotoxy (x,y : byte);„procedure wherexy(var x,y : byte);„„procedure cursoroff;„procedure setcursor(top,bot : byte);„procedure getcursor(var top,bot : byte);„„procedure clearline(line : word);„procedure setvideomode(mode : byte);„procedure panscreen(x0,y0,x1,y1 : integer);„„implementation„„{$L SCRORG.OBJ}„„{„;„; Name:         ScreenOrigin„;„; Function:     Set screen origin on EGA and VGA.„;„; Caller:       Pascal:„;„;                       procedure ScreenOrigin(x,y : integer);„;„;                       x,y               (* pixel x,y coordinates *)„;„}„„procedure screenorigin(x,y : integer);  external;„„function getvideomode : byte; assembler;„   asm„      mov  ax,0F00h„      int  10h„   end;„„procedure cursoroff; assembler;„   asm„      mov  cx,2000h„      mov  ah,1„      int  10h„   end;„„procedure gotoxy(x,y : byte); assembler;„   asm„      mov  ah,2„      xor  bx,bx„      mov  dl,x„      dec  dl„      mov  dh,y„      dec  dh„      int  10h„   end;„„procedure wherexy(var x,y : byte); assembler;„   asm„      mov  ax,0300h„      xor  bx,bx„      int  10h„      xchg dx,ax„      les  di,x„      stosb„      mov  al,ah„      les  di,y„      stosb„   end;„„procedure setvideomode(mode : byte); assembler;„   asm„      mov  ah,00„      mov  al,mode„      int  10h„   end;„„procedure setcursor(top,bot : byte); assembler;„   asm„      mov  ax,0100h„      mov  ch,top„      mov  cl,bot„      int  10h„   end;„„procedure getcursor(var top,bot : byte); assembler;„   asm„      mov  ax,0300h„      xor  bx,bx„      int  10h„      xchg cx,ax„      les  di,bot„      stosb„      mov  al,ah„      les  di,top„      stosb„   end;„„procedure clearline(line : word); assembler;„   asm„      mov   ax,screenseg     { ; AX := screen segment              }„      mov   es,ax            { ; ES := AX                          }„„      mov   ax,bytesperrow   { ; AX := # chars per row * 2         }„      push  ax               { ; preserve this value               }„      mov   cx,line          { ; CX := Line                        }„      dec   cx               { ; CX-- (zero based)                 }„      mul   cx               { ; AX := bytesperrow * 25            }„      mov   di,ax            { ; ES:DI -> 25th line                }„      pop   cx               { ; CX := bytesperrow                 }„      shr   cx,1             { ; CX := CX / 2 (word moves)         }„      mov   ax,1824          { ; AH := 7 (white on black)          }„                             { ; AL := 32 (space)                  }„      rep   stosw            { ; clear line                        }„   end;„„procedure panscreen(x0,y0,x1,y1 : integer);„{„   Routine originally in Microsoft C by Richard Wilton„}„   var„      i,j   : integer;„      xinc,„      yinc  : integer;„   begin„      i := x0; j := y0;„„      if (x0 < x1) then„         xinc := 1„      else„         xinc := -1;„„      if (y0 < y1) then„         yinc := 1„      else„         yinc := -1;„„      while (i <> x1) or (j <> y1) do„         begin„            if i <> x1 then inc(i,xinc);„            if j <> y1 then inc(j,yinc);„            screenorigin(i,j);„         end;„   end;„„procedure smoothscroll;„{„   Smooth scrolls one line up and puts cursor on bottom line.„}„   var„      top,bot : byte;„„   begin„      clearline(26);               { blank 26th line             }„      panscreen(0,0,0,charheight); { smooth scroll one line down }„      screenorigin(0,0);           { restore screen origin       }„„      asm„         push  ds               { ; preserve data segment             }„„         mov   ax,screenseg     { ; AX := 0B000h or 0B800             }„„         mov   ds,ax            { ; DS := screen segment              }„         mov   si,160           { ; SI := offset of (0,1)             }„                                { ; DS:SI -> (0,1) of video buffer    }„„         mov   es,ax            { ; ES := screen segment              }„         xor   di,di            { ; DI := offset of (0,0)             }„„         mov   cx,1920          { ; CX := bytesperrow * 24 / 2        }„„         rep   movsw            { ; move screen one line up           }„„         pop   ds               { ; restore data segment              }„      end;„„      getcursor(top,bot);  { save cursor settings  }„      clearline(25);       { blank new bottom line }„      gotoxy(1,25);        { goto last line        }„   end;„„begin„   if getvideomode = 7 then„      screenseg := $B000„   else„      screenseg := $B800;„„   bytesperrow := 80*2;        { 80 bytes for text and attributes }„end.„„{$A+,B-,D+,E+,F+,G-,I+,L+,N-,O+,P+,Q+,R+,S+,T-,V+,X+,Y+}„{$M 65520,0,655360}„„(****************************************************************************)„ {                                                                          }„ { PROGRAM      : PANTEST                                                   }„ {                                                                          }„ { DESCRIPTION  : Tests the scroll unit.                                    }„ {                                                                          }„ { AUTHOR       : John M. Beck                                              }„ {                                                                          }„ { MODIFICATIONS: None                                                      }„ {                                                                          }„ { HISTORY      : 29-Dec-1993  Coded.                                       }„ {                                                                          }„(****************************************************************************)„„program pantest;„„uses crt, scroll;„„var„   count : byte;„„begin„   clrscr;„   gotoxy(1,1);„   textattr := (black shl 4) or lightgray;„   for count := 1 to 24 do writeln('Hello ',count);„„   write('Press any key to smooth scroll up one line ... ');„   readkey;„„   smoothscroll;„„   write('Press any key to pan demonstration ... ');„   readkey;„„   clrscr;„   gotoxy(65,25);„   textattr := (black shl 4) or lightgreen;„   write('... Groovy ...');„   panscreen(0,0,65 * charwidth,25 * charheight);„   panscreen(65 * charwidth,25 * charheight,0,0);„   gotoxy(1,25);„   textattr := (black shl 4) or lightblue;„   write('Any key to exit ... ');„   readkey;„end.„„                14     01-27-9412:24ALL                      ELAD NACHMAN             Vertical Graphics ScrolliIMPORT              7      Bµ   {„> I've got all kinds of routines by now, from fire to plasma, etc.„> But what I need is a screen in graphics mode 13h (or mode-x),„> where text scrolls from the bottom of the screen to the top of„> the screen.„„The address is a000:0000 -  now all you should do is:„}„x : array[1..320] of byte;„asm„mov ax,$a000„mov es,ax„mov ds,ax„cld„mov cx,160„xor si,si„mov di,offset x[1]„rep movsw„mov si,320„xor di,di„mov cx,160*199„rep movsw„mov si,offset x[1]„mov di,320*199„mov cx,160„rep movsw„end;„„{„That should do it - A simple move operation.„Note: This will only scroll one line. I think it's fast enough - although I„tested it on a 386-dx40. The drawback of it is that you get this nasty line on„the screen.„}                                                           15     01-27-9413:33ALL                      GREG ESTABROOKS          EGA/VGA Slider           IMPORT              11     Bµ   Program VGASLIDE; {requirements TP6 or higher + register-compatible VGA}„„„uses CRT,grstuff;„„var„  t,slide:word;„  ch:char;„„Procedure VgaBase(Xscroll,Yscroll:integer);„  var dum:byte;„ Begin„  Dec(SLIDE,(Xscroll+320*Yscroll));   { slide scrolling state         }„  Port[$03d4]:=13;                    { LO register of VGAMEM offset  }„  Port[$03d5]:=(SLIDE shr 2) and $FF; { use 8 bits:  [9..2]           }„  Port[$03d4]:=12;                    { HI register of VGAMEM offset  }„  Port[$03d5]:= SLIDE shr 10;         { use 6 bits   [16..10]         }„  Dum:=Port[$03DA];                   { reset to input by dummy read  }„  Port[$03C0]:=$20 or $13;            { smooth pan = register $13     }„  Port[$03C0]:=(SLIDE and 3) Shl 1;   { use bits [1..0], make it 0-2-4-6„}„ End;„„„BEGIN {main}„„  setvidmode($13);„  SLIDE:=0;„„  { draw a quick test pattern directly to video memory }„  For T:= 0 to 63999 do MEM[$A000:T]:=(T mod (317 + T div 10000)) and„255;„„  repeat„   Vgabase(-1,-1);  { scroll smoothly in UPPER LEFT direction }„   Delay(14);„  until Keypressed;„  ch:=Readkey;„„  repeat„   Vgabase( 1, 1);  { scroll smoothly in LOWER RIGHT direction }„   Delay(14);„  until Keypressed;„  ch:=Readkey;„  setvidmode($3);„„END.„                                                   16     02-05-9407:57ALL                      BERNIE PALLEK            Tweaked Text Scroll      IMPORT              18     Bµ   „program heavily_tweaked_textscroll;„uses crt;„const sseg : word = $b800; hi = 16; grd = 3; wideness = 1;„  grade : string = '.:|X#';„  txt : string = 'This simple old text scroll is really getting tweaked!'„               + '      In fact, it''s not so simple anymore...         ';„„var fseg, fofs : word; idx : word; i, cur, line, bitpos : byte;„    jcol : byte; ch : char; widecount : byte;„„procedure getfont; assembler; asm„  mov ax,1130h; mov bh,3; int 10h; mov fseg,es; mov fofs,bp; end;„„procedure retrace; assembler; asm„  mov dx,3dah;„  @l1: in al,dx; test al,8; jnz @l1;„  @l2: in al,dx; test al,8; jz @l2; end;„„procedure moverowleft(startingrow : word); assembler;„asm  { sorry, I had to smush it a bit }„  push  ds;  push  es  { do I really need to save es? }„  mov   ax,$b800;  mov   es,ax;  mov   ds,ax;  mov   cx,0003„  @@MoveByte:„    add   cx,startingrow;  mov   di,cx;       mov   al,[es:di]„    sub   cx,startingrow;  sub   cx,2;        add   cx,startingrow„    mov   si,cx;           mov   [ds:si],al;  sub   cx,startingrow„    add   cx,4;            cmp   cx,160„  jl    @@MoveByte„  pop   es;  pop   ds„end;„„„begin„  getfont; textattr := 15; clrscr;„  fillchar(mem[$b800:0],4000,0);„  for idx := hi to (hi+7) do for jcol := 0 to length(grade)-1 do begin„    for i := grd*jcol to 79-(grd*jcol) do„      mem[sseg:idx*160+i*2] := Ord(grade[jcol+1]);„  end;„  idx := 1; jcol := 15;„  repeat„    cur := ord(txt[idx]);„    inc(jcol); if (jcol > 15) then jcol := 1;„    bitpos := 0;„    repeat„      for widecount := 1 to wideness do begin„        for line := 0 to 7 do begin„          (* jcol := random(14) + 1; *)„          if ((mem[fseg:fofs+cur*8+line] shl bitpos) and 128) <> 0 then„            mem[sseg:158+(line+hi)*160+1] := jcol„          else„            mem[sseg:158+(line+hi)*160+1] := 0;„        end;„        retrace;„        for line := 0 to 7 do moverowleft((line+hi)*160);„      end;„      inc(bitpos);„    until (bitpos > 7) or keypressed;„    if not keypressed then idx := 1 + idx mod length(txt);„  until keypressed;„  while keypressed do ch := readkey;„  textattr := 7; clrscr;„end.„„                                                     