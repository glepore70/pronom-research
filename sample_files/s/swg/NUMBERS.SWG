SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00049         BITWISE TRANSLATIONS ROUTINES                                     1      05-28-9313:53ALL                      SWAG SUPPORT TEAM        BITS1.PAS                IMPORT              14     û8¡ {„ Sean Palmer„„> What if I want to just access a bit?  Say I have a Byte, to store„> Various access levels (if it does/doesn't have this, that, or the„> other).  How can I„„> 1)  Access, say, bit 4?„> 2)  Give, say, bit 4, a value of 1?„„> I have a simple routine that does "GetBit:= Value SHR 1;" to return„> a value, but how can I *SET* a value?  And is the above a good„> method? I only have TP5.5, so I can't do the Asm keyWord (yet..).„„You COULD use TP sets to do it...„}„„Type„  tByte = set of 0..7;„Var„  b : Byte;„„{to get:„  Write('Bit 0 is ',Boolean(0 in tByte(b)));„„to set:„  tByte(b):=tByte(b)+[1,3,4]-[0,2];„}„„Type„  bitNum = 0..7;„  bit    = 0..1;„„Function getBit(b : Byte; n : bitNum) : bit;„begin„  getBit := bit(odd(b shr n));„end;„„Function setBit( b : Byte; n : bitNum) : Byte;„begin„  setBit := b or (1 shl n);„end;„„Function clrBit(b : Byte; n : bitNum) : Byte;„begin„  clrBit := b and hi($FEFF shl n);„end;„„{„ OR.....using Inline() code  (the fastest)„ These are untested but I'm getting fairly good at assembling by hand...8)„}„„Function getBit(b : Byte; n : bitNum) : bit;„Inline(„  $59/      {pop cx}„  $58/      {pop ax}„  $D2/$E8/  {shr al,cl}„  $24/$01); {and al,1}„„Function setBit(b : Byte; n : bitNum) : Byte;„Inline(„  $59/      {pop cx}„  $58/      {pop ax}„  $B3/$01/  {mov bl,1}„  $D2/$E3/  {shl bl,cl}„  $0A/$C3); {or al,bl}„„Function clrBit(b : Byte; n : bitNum) : Byte;„Inline(„  $59/      {pop cx}„  $58/      {pop ax}„  $B3/$FE/  {mov bl,$FE}„  $D2/$C3/  {rol bl,cl}„  $22/$C3); {or al,bl}„                                                                                                                                2      05-28-9313:53ALL                      SWAG SUPPORT TEAM        BITS2.PAS                IMPORT              25     û8!5 {„ROB GREEN„„> What if I want to just access a bit?  Say I have a Byte, to store„> Various access levels (if it does/doesn't have this, that, or the„> other).  How can I„> 1)  Access, say, bit 4?„> 2)  Give, say, bit 4, a value of 1?„„Heres a Procedure i wrote to handle all that.  if you need speed, then„i suggest to manually check each bit, rather than use the Procedures.„„(these Procedures are based on 1, not 0.  thus each Byte is like so:„87654321   instead of 76543210.  to change to 0 base, change the Array to„[0..31] instead of [1..32].)„„to set a bit: (b is an Integer Type, BIT is which bit to set„   b:=b or BIT;   ex: b:=b or 128  (set bit 8)„„to clear a bit:„   b:=b and not BIT;  ex:b:=b and not 8;  (clears bit 4)„„to check a bit:„   if b and BIT<>0 then..  ex:if b and 64 then..  (check bit 7)„}„„Const„{ Used to convert the Bit value to the actual corresponding number }„   bit : Array[1..32] of LongInt =„       (1, 2, 4, 8, $10, $20, $40, $80, $100, $200, $400, $800, $1000, $2000,„        $4000, $8000, $10000, $20000, $40000, $80000, $100000, $200000,„        $400000, $800000, $1000000, $2000000, $4000000, $8000000, $10000000,„        $20000000, $40000000, $80000000);„„{b is which bit to set(1-32), size is the size of temp.„Use  SIZEOF(TEMP) to get the value, and temp is the actuall Integer based„number„returns True if bit set, False if not}„„Function checkbit(b : Byte; size : Byte; Var temp) : Boolean; {1-32}„Var„  c : Boolean;„begin„   c:=False;„   Case size of„     1 : c := Byte(temp) and bit[b] <> 0;     {Byte,shortint}„     2 : c := Word(temp) and bit[b] <> 0;     {Word,Integer}„     4 : c := LongInt(temp) and bit[b] <> 0;  {LongInt}„     else„       Writeln('Invalid size');„   end;„   checkbit := c;„end;„„{b,size,and temp same as above.  if onoff =True the bit will be set,„else the bit will be cleared}„„Procedure setbit(b : Byte; onoff : Boolean; size : Byte; Var temp); {1-32}„begin„   if onoff then„   Case size of„     1 : Byte(temp) := Byte(temp) or bit[b];        {Byte}„     2 : Word(temp) := Word(temp) or bit[b];        {Word}„     4 : LongInt(temp) := LongInt(Temp) or bit[b];  {LongInt}„     else„       Writeln('Invalid size');„   end„   else„   Case size of„     1 : Byte(temp) := Byte(temp) and not bit[b];   {Byte}„     2 : Word(temp) := Word(temp) and not bit[b];   {Word}„     4 : LongInt(temp) := LongInt(Temp) and not bit[b];{LongInt}„     else„       Writeln('Invalid size');„   end;„end;„„{this is a sample test Program i wrote For you to see how to use the„stuff above}„„Var„  i : LongInt;„  j : Byte;„begin„   i := 0;„   setbit(4,True,sizeof(i),i);  {8}„   Writeln(i);„   setbit(9,True,sizeof(i),i);  {256+8 = 264}„   Writeln(i);„   setbit(9,False,sizeof(i),i); {8}„   Writeln(i);„   setbit(20,True,sizeof(i),i); { $80000+8 = $80008}„   Writeln(i);„   For i := 65550 to 65575 do„   begin„     Write(i : 8, ' = ');„     For j := 32 downto 1 do {to print right}„       if checkbit(j, sizeof(i), i) then„         Write('1')„       else„         Write('0');„     Writeln;„   end;„end.„                       3      05-28-9313:53ALL                      SWAG SUPPORT TEAM        BIT_GET.PAS              IMPORT              3      û8•' { You can use multiplies of 2 like: }„„Function Find_Bit(B, c : Byte) : Byte;„{c is the position c=0 far right c=7 far left„returns 0 or 1}„begin„ if b MOD (b shl c) = 0 then Find_Bit := 0„  else Find_Bit := 1„end;„„                                        4      05-28-9313:53ALL                      SWAG SUPPORT TEAM        BIT_ROT1.PAS             IMPORT              8      û8Ö– The commands you need to rotate a Byte/Word are:„„ROR, ROL, RCR, RCL.„ROR ==> Rotates the bits the number of times specified, so that the„        rightmost bits are rotated into the leftmost bits.  NO BITS„        ARE LOST.  ROL is the same thing in the opposite direction.„„RCR ==> Practically the same as the ROR/ROL instruction, but it rotates„        the bit into the carry, and the carry bit is rotated into the„        leftmost bit of the Byte/Word.  {Rotate right through carry}„        RCL is the same in the other direction.„„The format For each of ROR,ROL,RCR,RCL,SHR,SHL is„„  [Instruction]  <Destination>  <Shift Count>„„To reWrite your original code:„„Asm„  Mov  AL, ByteVar„  Ror  AL, 1„  Mov  ByteVar, AL„end„„The above would rotate the bits in the Variable ByteVar by one to the right.„                                                                                              5      05-28-9313:53ALL                      CHRIS PRIEDE             Rotate Bits LEFT/RIGHT   IMPORT              14     û8G  > I made a Program in Turbo-Pascal that rotates the bits in one Byte so I can„> encrypt/decrypt a File, however the routine is slow. I then made the same„> Program in turbo-C using _RotLeft and _RotRight, the speed of execution was„> Really faster than Turbo-Pascal. Does anybody know of a way to rotate the„> bits of one Byte in turbo-Pascal and FAST !!!!„„„        Since 80xxx CPUs have bit rotate instructions (ROL, ROR), it would„be a shame to use some clumsy HLL Construct. BTW, I'm sure _RotLeft and„_RotRight use rotate instructions too, possibly insert them Inline. If„you are using TP 6.0+, try something like this:„„{ to rotate left }„Function RotLeft(B, Count: Byte): Byte; Assembler;„Asm„  mov   al, B„  mov   cl, Count„  rol   al, cl„end;„„{ to rotate right }„Function RotRight(B, Count: Byte): Byte; Assembler;„Asm„  mov   al, B„  mov   cl, Count„  ror   al, cl„end;„„„        Of course, if you need to do this in only a few places it would„be better not to define Functions, but insert Asm blocks in your code„directly.„„        The fastest Pascal way to rotate Byte would be something like„this:„„Function RotLeft(B, Count: Byte): Byte;„Var„  W : Word;„  A : Array[0..1] of Byte Absolute W;„begin„  A[0] := B;„  A[1] := B;„  W := W shl Count;„  RotLeft := A[1];„end;„„        To rotate right With this method, you would shift right and„return A[0]. I would like to think this is as fast as it gets in TP„without assembly, but one can never be sure <g>. Anyway, I recommend„the assembly solution over this one, it is faster and more elegant.„                                                                                                           6      05-28-9313:53ALL                      SWAG SUPPORT TEAM        BIT_ROT3.PAS             IMPORT              5      û8™ {„SEAN PALMER„}„„Function rolW(b : Word; n : Byte) : Word; Assembler;„Asm„  mov ax, b„  mov cl, n„  rol ax, cl„end;„„Function rolB(b, n : Byte) : Byte; Assembler;„Asm„  mov al, b„  mov cl, n„  rol al, cl„end;„„Function rolW1(b : Word) : Word; Assembler;„Asm„  mov ax, b„  rol ax, 1„end;„„{ These would be better off as Inline Functions, such as... }„„Function IrolW1(b : Word) : Word;„Inline(„  $58/          {pop ax}„  $D1/$C0);     {rol ax,1}„„{ because no Function call is generated. }„„                      7      05-28-9313:53ALL                      SWAG SUPPORT TEAM        BYT2REAL.PAS             IMPORT              5      û8Ä, Type„  bsingle = Array [0..3] of Byte;„„{ converts Microsoft 4 Bytes single to TP Real }„„Function msb_to_Real (b : bsingle) : Real;„Var„  pReal : Real;„  r     : Array [0..5] of Byte Absolute pReal;„begin„  r [0] := b [3];„  r [1] := 0;„  r [2] := 0;„  move (b [0], r [3], 3);„  msb_to_Real := pReal;„end; { Function msb_to_Real }„„{„Another Turbo Pascal routine to convert Microsoft single to TP LongInt„„index := ((mssingle and not $ff000000) or $00800000) shr (24 -„((mssingle shr 24) and $7f)) - 1;„}„      8      05-28-9313:53ALL                      SWAG SUPPORT TEAM        BYTE2BIN.PAS             IMPORT              7      û8"a {„Byte to Binary...„}„„Type„  String8 = String[8];„„„Function Byte2Bin(byTemp : Byte) : String8;„Var„  Count : Integer;„begin„  Byte2Bin[0] := #8;„  For Count := 0 to 7 do„    Byte2Bin[8 - Count] := Char(((byTemp shr Count) and 1) + ord('0'));„end;„„Function Byte2BinAsm(byTemp : Byte) : String8; Assembler;„Asm„  push    ds„  les     di,@result„  mov     ah,byTemp„  mov     cl,8„  mov     al,cl„  stosb„@loop:„  mov     al,24„  add     ah,ah„  adc     al,al„  stosb„  loop    @loop„  pop     ds„end;„„begin„  Writeln;„  Writeln('10 in Binary = ',Byte2Bin(10));„  Writeln;„  Writeln('The same thing With assembly code: ',Byte2BinAsm(10));„  Writeln;„  Readln;„end.                                                                                                       9      05-28-9313:53ALL                      SWAG SUPPORT TEAM        BYTEINFO.PAS             IMPORT              57     û8©¿ {„>Also, how would I simply read each bit?„}„{ Test if a bit is set. }„Function IsBitSet(Var INByte : Byte; Bit2Test : Byte) : Boolean;„begin„  if (Bit2Test in [0..7]) then„    IsBitSet := ((INByte and (1 shl Bit2Test)) <> 0)„  else„    Writeln('ERROR! Bit to check is out of range!');„end; { IsBitSet. }„„{„>How on earth can I manipulate an individual bit?„„...One method is to use the bit-operators:  AND, OR, XOR, NOT„}„„{ Manipulate an individual BIT within a single Byte. }„Procedure SetBit(Bit2Change : Byte; TurnOn : Boolean; Var INByte : Byte);„begin„  if Bit2Change in [0..7] then„  begin„    if TurnOn then„      INByte := INByte or (1 shl Bit2Change)„    else„      INByte := INByte and NOT(1 shl Bit2Change);„  end;„end; { SetBit. }„„{„>...but I'm not sure exactly what the shifting is doing.„}„„    { Check if the bit is to be turned on or off. }„    If TurnOn then„„    {„      SHL 1 (which has a bit map of 0000 0001) to the bit„      position we want to turn-on.„„        ie: 1 SHL 4 = bit-map of 0001 0000„„      ...Then use a "logical OR" to set this bit.„„      ie: Decimal:     2      or      16     =    18„          Binary : 0000 0010  or  0001 0000  = 0001 0010„    }„„      INByte := INByte or (1 shl Bit2Change)„    else„„    {„      Else turn-off bit.„„      SHL 1 (which has a bit map of 0000 0001) to the bit„      position we want to turn-off.„„         ie: 1 SHL 4 = bit-map of 0001 0000„„       ...Then use a "logical NOT" to flip all the bits.„„       ie: Decimal:  not (   16    ) =      239„           Binary :  not (0001 0000) =  (1110 1111)„„       ...Than use a "logical AND" to turn-off the bit.„„       ie: Decimal:     255     and     239    = 239„           Binary :  1111 1111  and  1110 1111 = 1110 1111„    }„„     INByte := INByte and NOT(1 shl Bit2Change);„„{„>Also, how can you assign a Byte (InByte) a Boolean value (OR/AND/NOT)„„  or / xor / and / not are "logical" bit operators, that can be use on„  "scalar" Types. (They also Function in the same manner For "Boolean"„  logic.)„„>If I have, say 16 bits in one Byte, the interrupt list says that for„>instance the BIOS calls (INT 11), AX is returned With the values. It„>says that the bits from 9-11 tell how many serial portss there are.„>How do I read 3 bits?„„  To modify the two routines I posted wo work With 16 bit Variables,„  you'll need to change:„„     INByte : Byte;  --->  INWord : Word;„„  ...Also:„„     in [0..7]  --->  in [0..15]„„  ...If you don't want to use the IsBitSet Function listed above„  (modified to accept 16-bit Word values) you could do the following„  to check if bits  9, 10, 11 are set in a 16-bit value:„„  The following is the correct code For reading bits 9, 10, 11„  of the 16-bit Variable "AX_Value" :„„      Port_Count :=  ((AX_Value and $E00) SHR 9);„„    NOTE: Bit-map For $E00 = 0000 1110 0000 0000„„  ...If you've got a copy of Tom Swan's "Mastering Turbo Pascal",„  check the section on "logical operators".„„„{„>Var Regs : Registers;„>begin„>  Intr($11,Regs);„>  Writeln(Regs.AX);„>end.„„>How do I manipulate that to read each bit (or multiple bits like„>the number of serial ports installed (bits 9-11) ?„}„„Uses„  Dos;„„Var„  Port_Count : Byte;„  Regs       : Registers;„„begin„  Intr($11, Regs);„  Port_Count := ((Regs.AX and $E00) SHR 9);„  Writeln('Number of serial-ports = ', Port_Count)„end.„{„NOTE: The hex value of $E00 is equivalent to a 16-bit value with„      only bits 9, 10, 11 set to a binary 1. The SHR 9 shifts the„      top Byte of the 16-bit value, to the lower Byte position.„}„{„>Is $E00 the same as $0E00 (ie, can you just omit leading zeros)?„„Yeah, it's up to you if you want to use the leading zeros or not.„„The SHR 9 comes in because once the value has been "AND'd" with„$E00, the 3 bits (9, 10, 11) must be placed at bit positions:„0, 1, 2  ...to correctly read their value.„„For example, say bits 9 and 11 were set, but not bit 10. If we„"AND" this With $E00, the result is $A00.„„1011 1010 0111 1110  and  0000 1110 0000 0000  =  0000 1010 0000 0000„       ^ ^„(bits 9,11 are set)  and  (      $E00       )  =  $A00„...Taking the result of $A00, and shifting it right 9 bit positions„„         $A00         SHR 9  =           5„„ 0000 1010 0000 0000  SHR 9  =  0000 0000 0000 0101„„...Which evalutates to 5. (ie: 5 serial ports)„}„„„„„„„„„„{„Get Equipment Bit-Map„---------------------„„         AH       AL„      76543210 76543210„AX =  ppxgrrrx ffvvmmci„„...„...„rrr = # of RS232 ports installed„...„...„„ (* reports the number of RS232 ports installed *)„Function NumRS232 : Byte;„Var Regs : Registers;                 (* Uses Dos *)„begin„  Intr($11,Regs);„  NumRS232 := (AH and $0E) shr 1;„end;„„„...When you call Int $11, it will return the number of RS232 ports installed„in bits 1-3 in register AH.„„For example if AH = 01001110 , you can mask out the bits you *don't* want„by using AND, like this:„„              01001110      <---  AH„        and   00001110      <---- mask $0E„        ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„              00001110      <---- after masking„„„Then shift the bits to the right With SHR,„„              00001110      <---- after masking„         SHR         1      <---- shift-right one bit position„         ƒƒƒƒƒƒƒƒƒƒƒƒƒ„              00000111      <---- result you want„}„„{„-> How do I know to use $4 For the third bit?  Suppose I want to read„-> the fifth bit. Do I simply use b := b or $6?„„    Binary is a number system just like decimal.  Let me explain.„First, consider the number "123" in decimal.  What this means,„literally, is„„1*(10^2) + 2*(10^1) + 3*(10^0), which is 100 + 20 + 3.„„    Binary works just the same, however instead of a 10, a 2 is used as„the base.  So the number "1011" means„„1*(2^3) + 0*(2^2) + 1*(2^1) + 1*(2^0), or 8+0+2+1, or 11.„„     This should make it clear why if you wish to set the nth bit to„True, you simply use a number equal to 2^(n-1).  (The -1 is there„because you probably count from 1, whereas the powers of two, as you may„note, start at 0.)„„-> b or (1 SHL 2) Would mean that b := 1 (True) if b is already equal to„-> one (1) and/OR the bit two (2) to the left is one (1) ???„„    Aha.  You are not familiar With bitwise or operations.  When one„attempts to or two non-Boolean values (Integers), instead of doing a„logical or as you are familiar with, each individual BIT is or'd.  I.E.„imagine a Variables A and B had the following values:„„a := 1100 (binary);„b := 1010 (binary);„„then, a or b would be equal to 1110 (binary);  Notice that each bit of a„has been or'd With the corresponding bit of b?  The same goes For and.„Here's an example.„„a := 1100 (binary);„b := 1010 (binary);„„a and b would be equal to 1000;„„I hope this clears up the confusion.  And just to be sure, I'm going to„briefly show a SHL and SHR operation to make sure you know.  Consider„the number„„a := 10100 (binary);„„This being the number, A SHL 2 would be equal to 1010000 (binary) --„notice that it has been "shifted to the left" by 2 bits.„„A SHR 1 would be 1010 (binary), which is a shifted to the right by 2„bits.„}„„                                                                                                                         10     05-28-9313:53ALL                      SWAG SUPPORT TEAM        DEC2BIN1.PAS             IMPORT              6      û8Q≤ {„>  I need to transfer decimal into binary using TURBO PASCAL.„>  One way to do this is to use the basic algorithm, dividing„>  by 2 over and over again. if the remainder is zero the„>  bit is a 0, else the bit is a 1.„>„>  However, I was wondering if there is another way to convert„>  from decimal to binary using PASCAL. Any ideas?„„As an 8-bit (ie. upto 255) example...„}„„  Function dec2bin(b:Byte) : String;„  Var bin : String[8];„      i,a : Byte;„  begin„   a:=2;„   For i:=8 downto 1 do„    begin„     if (b and a)=a then bin[i]:='1'„                    else bin[i]:='0';„     a:=a*2;„    end;„    dec2bin:=bin;„  end;„„          11     05-28-9313:53ALL                      SWAG SUPPORT TEAM        DEC2BIN2.PAS             IMPORT              7      û8ûä { True so here is another version of the process that returns a String : }„„Program Dec2BinRec;„„Type„  Str32 = String[32];„„Function Dec2BinStr(aNumber : LongInt) : Str32;„„  Function Bit(aBit : Byte) : Char;„  (* return either Char '0' or Char '1' *)„  begin„    if aBit = 0 then„      Bit := '0'„    else„      Bit := '1'„  end;„„begin„  If aNumber = 0 Then„    Dec2BinStr := ''   (* done With recursion ?*)„  else                                (* convert high bits + last bit *)„    Dec2BinStr := Dec2BinStr(ANumber Div 2) + Bit(aNumber Mod 2);„end;„„Var„  L : LongInt;„begin„  Repeat„    Readln (L);„    If L <> 0 then„      Writeln(Dec2BinStr(L));„  Until (L = 0)„end.„                                                                                            12     05-28-9313:53ALL                      SWAG SUPPORT TEAM        HEX2BIN1.PAS             IMPORT              22     û8/ Function Hex2Bin (B : Byte) : String;„„Var„  Temp : String [8];„  Pos, Mask : Byte;„„begin„  Temp := '00000000';„  Pos := 8;„  Mask := 1;„  While (Pos > 0) Do„    begin„      if (B and Mask)„        then„          Temp [Pos] := '1';„      Dec (Pos);„      Mask := 2 * Mask;„    end;„  Hex2Bin := Temp;„end;„„„„„„„„Function Hex2Bin( HexByte:Byte ):String; External; {$L HEX2Bin.OBJ}„Var i : Integer;„begin„  For i := $00 to $0F do WriteLn( Hex2Bin(i) );„end.„(*********************************************************************)„„ The Assembly source ...„„;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;„code        segment Byte 'CODE'     ; HEX2Bin.Asm„            assume  cs:code„; Function Hex2Bin( HexByte :Byte ) :String;„String      equ     dWord ptr [bp+6]„HexByte     equ     [bp+4]„            public  Hex2Bin„Hex2Bin     proc    Near            ; link into main TP Program„            push    bp              ; preserve„            mov     bp,sp           ; stack frame„            les     di, String      ; result String Pointer„            cld                     ; Forward scan„            mov     cx,8            ; 8 bits in a Byte„            mov     al,cl           ; to set„            stosb                   ; binary String length„            mov     ah, HexByte     ; get the hex Byte„    h2b:    xor     al,al           ; cheap zero„            rol     ax,1            ; high bit to low bit„            or      al,'0'          ; make it ascii„            stosb                   ; put it in String„            loop    h2b             ; get all 8 bits„            pop     bp              ; restore„            ret     2               ; purge stack & return„Hex2Bin     endp„code        ends„            end„;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;„„ Here's the assembled OBJ File ...„„ Put all of this remaining message in a Text File named HEX2Bin.SCR,„ then Type "DEBUG < HEX2Bin.SCR" (no quotes) to create HEX2Bin.ARC;„ then extract HEX2Bin.OBJ using PKUNPAK or PAK ...„ ---------------------------- DEBUG script ----------------------------„ N HEX2Bin.ARC„ E 0100 1A 02 48 45 58 32 42 49 4E 2E 4F 42 4A 00 5E 65 00 00 00 4A 19„ E 0115 13 22 60 F2 65 00 00 00 80 0D 00 0B 68 65 78 32 62 69 6E 2E 41„ E 012A 53 4D A9 96 07 00 00 04 43 4F 44 45 44 98 07 00 20 1D 00 02 02„ E 013F 01 1F 90 0E 00 00 01 07 48 45 58 32 42 49 4E 00 00 00 6A 88 04„ E 0154 00 00 A2 01 D1 A0 21 00 01 00 00 55 8B EC C4 7E 06 FC B9 08 00„ E 0169 8A C1 AA 8A 66 04 32 C0 D1 C0 0C 30 AA E2 F7 5D C2 02 00 21 8A„ E 017E 02 00 00 74 1A 00„ Rcx„ 0084„ W„ Q„ ----------------------------------------------------------gbug-1.0b--„                13     05-28-9313:53ALL                      SWAG SUPPORT TEAM        HEXCONV.PAS              IMPORT              7      û8x« Var„  n    : Word;„  long : LongInt;„„Function Byte2Hex(numb : Byte): String;       { Converts Byte to hex String }„  Const„    HexChars : Array[0..15] of Char = '0123456789ABCDEF';„  begin„    Byte2Hex[0] := #2;„    Byte2Hex[1] := HexChars[numb shr  4];„    Byte2Hex[2] := HexChars[numb and 15];„  end; { Byte2Hex }„„Function Numb2Hex(numb: Word): String;        { Converts Word to hex String.}„  begin„    Numb2Hex := Byte2Hex(hi(numb))+Byte2Hex(lo(numb));„  end; { Numb2Hex }„„Function Long2Hex(L: LongInt): String;     { Converts LongInt to hex String }„  begin„    Long2Hex := Numb2Hex(L shr 16) + Numb2Hex(L);„  end; { Long2Hex }„„„begin„  long := 65536;„  n    := 256;„  Writeln(Long2Hex(long));„  Writeln(Numb2Hex(n));„end.„                                    14     05-28-9313:53ALL                      SWAG SUPPORT TEAM        HEXINFO.PAS              IMPORT              13     û8Ë¢ > I am learning Pascal and don't understand something.  How does the„> following Function make a Word into Hex:„„ It's Really doing two things, it's converting a binary value„ into ascii, and from decimal to hex.  Let's start With the„ calling or main part of the Program.  You're taking a 2 Byte„ Word and breaking it up into 4 nibbles of 4 bits each.  Each of„ these nibbles is displayed as a Single hex Character 0-F.„„                                   Hex Representation XXXX„                                                      ||||„HexStr := HexStr + Translate(Hi(W) shr 4); -----------||||„HexStr := HexStr + Translate(Hi(W) and 15);------------|||„HexStr := HexStr + Translate(Lo(W) shr 4); -------------||„HexStr := HexStr + Translate(Lo(W) and 15);--------------|„„„Now the translate Function simply converts the decimal value of„the 4-bit nibble into an ascii hex value.  if you look at an„ascii Chart you will see how this is done:„„'0' = 48   '5' = 53    'A' = 65„'1' = 49   '6' = 54    'B' = 66„'2' = 50   '7' = 55    'C' = 67„'3' = 51   '8' = 56    'D' = 68„'4' = 52   '9' = 57    'E' = 69„                       'F' = 70„„„As you can see it easy For 0-9, you just add 48 to the value and„it's converted, but when you go to convert 10 to A, you need to„use a different offset, so For values above 9 you add 55.„„Function Translate(B : Byte) : Char;„  begin„  if B < 10 then„    Translate := Chr(B + 48)„  else„    Translate := Chr(B + 55);„  end;„                                                                        15     05-28-9313:53ALL                      SWAG SUPPORT TEAM        RANDOM1.PAS              IMPORT              15     û8{ {Another method to acComplish this (which only requires an order of n„itterations is to generate an Array initialized from 2 to 1000 and then„randomize that Array.  For your 400 numbers, just take 400 values in the„new sequence (starting at the index of your lowest number). You can do„that as follows:„}„„Const MaxNumber = 2000;„Type SeqArray = Array [1..MaxNumber] of Integer;„„{================================================================}„Procedure RandomizeSeq (first, last: Integer; Var iseq: SeqArray);„{================================================================}„„Var           i, iran,„           temp, imax : Integer;„                    r : Real;„{„  Operation:  A random number within the range 1..last is generated„  on each pass and the upper limit of the random number generated is„  decreased by 1.  The value stored at the highest index of the last„  pass is moved to the location of the last number selected.„„  Parameters:„    first = lowest number in sequence.„     last = highest number in sequence.„     iseq = Sequence Array„}„begin„   { initialize sequence Array }„   For i := first to last do iseq[i] := i;„   Randomize;„   { randomize the sorted Array }„   For imax := last downto first do begin„      { get a random number between 0 and 1 and scale up to„        an Integer in the range of first to last }„      r := random;„      iran := Trunc(r*imax) + first;„      { replace With value at highest index }„      temp := iseq[iran];„      iseq[iran] := iseq[imax];„      iseq[imax] := temp„   end;„end;„„{ Example of generating 20 random numbers from 2 to 100: }„„Var i : Integer;„    a : SeqArray;„begin„   RandomizeSeq(2,100,a);„   For i := 2 to 21 do Write(a[i]:3); Writeln;„end.„                                                                       16     05-28-9313:53ALL                      SWAG SUPPORT TEAM        RANDOM2.PAS              IMPORT              18     û8¿| { MR> I have started playing With Borland Turbo Pascal 7.0 and I have a„ MR> problem. The Random routine is not the same as the one in TP 6.0.„ MR> Using the same RandSeed, they generate different series of numbers.„ MR> I have a couple of applications that depend upon the number series„ MR> generated by the TP 6.0 version. Can anyone supply me With the„ MR> algorithm used in the TP 6.0 Random routine? or maybe point me in„ MR> the right direction? I want to Construct my own TP 7 Random routine„ MR> that will behave as the one in TP 6.„„The way both generators work is to update System.Randseed, then calculate the„new random value from that one.  There have been several different ways to„calculate the value; I think TP 6 is different from TP 5.5, and TP 7 is„different again.  The update algorithm has been pretty Constant.„„As I recall, you can simulate the TP 6 Random(N) Function in TP 7 as follows:„}„Function TP6Random(N:Word):Word;„Var„  junk : Word;„  myrandseed : Record„  lo, hi : Word„  end Absolute system.randseed;„begin„  junk := Random(0);   { Update Randseed }„  TP6Random := myrandseed.hi mod N;„end;„„{„You might want to keep the following around in Case the update algorithm gets„changed sometime in the future:„„Demonstration Program to show how the TP 6.0 random number generator„updates System.Randseed.  Allows the seed to be cycled backwards. }„„Procedure CycleRandseed(cycles:Integer);„{ For cycles > 0, mimics cycles calls to the TP random number generator.„  For cycles < 0, backs it up the given number of calls. }„Var„  i : Integer;„begin„  if cycles > 0 then„    For i := 1 to cycles do„      system.randseed := system.randseed*134775813 + 1„  else„    For i := -1 downto cycles do„      system.randseed := (system.randseed-1)*(-649090867);„end;„„Var„  i : Integer;„begin„  randomize;„  Writeln('Forwards:');„  For i:=1 to 5 do„    Writeln(random);„  Writeln('Backwards:');„  For i:=1 to 5 do„  begin„    CycleRandseed(-1);    { Back to previous value }„    Writeln(random);      { Show it }„    CycleRandseed(-1);    { Back up over it again }„  end;„end.„                                                                                  17     05-28-9313:53ALL                      SWAG SUPPORT TEAM        REALFRMT.PAS             IMPORT              8      û8∏≤ {„  I recently came across the need For a way to dynamically Format„  Real Variables For output - I came out With the following. (You„  people following the Compiler thread may want this to make your„  Compiler output pretty)„„  The routine checks to see how big the exponent is; if it's bigger„  than 1E7 or smaller than 1E-7, an unFormatted conversion is made.„  if the number is less than 1E7 and greater than 1E-7, then a„  Formatted String is created. to make the output prettier, trailing„  zeros, periods and leading spaces are deleted.„}„„Function FormatReal(r:Real):String;„Var„  s :String;„„begin„  if ((r>1E-7) and (r<1E7))then„    Str(r:12:12, s)„  else„    Str(r, s);„„  While s[ord(s[0])]='0' do„    Delete(s, ord(s[0]), 1);„  While (s[1]=' ') do„    Delete(s, 1, 1);„  if s[ord(s[0])]='.' then„    Delete(s, ord(s[0]), 1);„„  FormatReal := s;„end;„                                 18     05-28-9313:53ALL                      SWAG SUPPORT TEAM        REVERSE.PAS              IMPORT              7      û8≤† {„ a problem.  I am asked to find the reverse of a positive Integer.  For„ example the reverse of 123 is 321 or the reverse of 1331 is 1331.„ My teacher said that we should use div and MOD.„}„„Var„  X, Y: Integer;„„begin„  X := PositiveInteger;„  Y := 0;„„  While X > 0 do„  begin„    Y := (Y * 10) + (X mod 10);„    X := X div 10;„  end;„„{„The result will be in Y.  Just so you do learn something of use out of this: It„is a fact that the difference between two transposed (reversed) numbers will be„evenly divisible by 9. This can be of help if you are doing something„accounting related and are trying to figure out why your numbers don't jive. if„the amount you are out is evenly divisible by 9, it is most likely a„transposing error.„}„                          19     05-28-9313:53ALL                      SWAG SUPPORT TEAM        ROMAN1.PAS               IMPORT              19     û8Z {„˙    Subject: Word to Roman Numeral„„  OK, here is my second attempt, With error checking and all. Thanks to„Terry Moore <T.Moore@massey.ac.nz> For encouraging me. The last Function„also contained a couple of errors. This one is errorchecked.„}„„Function RomantoArabic(Roman : String) : Integer;„{ Converts a Roman number to its Integer representation }„{ Returns -1 if anything is wrong }„„  Function Valueof(ch : Char) : Integer;„  begin„    Case ch of„      'I' : Valueof:=1;„      'V' : Valueof:=5;„      'X' : Valueof:=10;„      'L' : Valueof:=50;„      'C' : Valueof:=100;„      'D' : Valueof:=500;„      'M' : Valueof:=1000;„      else Valueof:=-1;„    end;„  end;   { Valueof }„„  Function AFive(ch : Char) : Boolean; { Returns True if ch = 5,50,500 }„  begin„    AFive:=ch in ['V','L','D'];„  end;   { AFive }„„Var„  Position : Byte;„  TheValue, CurrentValue : Integer;„  HighestPreviousValue : Integer;„begin„  Position:=Length(Roman); { Initialize all Variables }„  TheValue:=0;„  HighestPreviousValue:=Valueof(Roman [Position]);„  While Position > 0 do„  begin„    CurrentValue:=Valueof(Roman [Position]);„    if CurrentValue<0 then„    begin„      RomantoArabic:=-1;„      Exit;„    end;„    if CurrentValue >= HighestPreviousValue then„    begin„      TheValue:=TheValue+CurrentValue;„      HighestPreviousValue:=CurrentValue;„    end„    else„    begin { if the digit precedes something larger }„      if AFive(Roman [Position]) then„      begin„	      RomantoArabic:=-1; { A five digit can't precede anything }„	      Exit;„      end;„      if HighestPreviousValue div CurrentValue > 10 then„      begin„	      RomantoArabic:=-1; { e.g. 'XM', 'IC', 'XD'... }„	      Exit;„      end;„      TheValue:=TheValue-CurrentValue;„    end;„    Dec(Position);„  end;„  RomantoArabic:=TheValue;„end;   { RomantoArabic }„„begin„  Writeln('XXIV = ', RomantoArabic('XXIV'));„  Writeln('DXIV = ', RomantoArabic('DXIV'));„  Writeln('CXIV = ', RomantoArabic('CXIV'));„  Writeln('MIXC = ', RomantoArabic('MIXC'));„  Writeln('MXCIX = ', RomantoArabic('MXCIX'));„  Writeln('LXVIII = ', RomantoArabic('LXVIII'));„  Writeln('MCCXXIV = ', RomantoArabic('MCCXXIV'));„  Writeln('MMCXLVI = ', RomantoArabic('MMCXLVI'));„  Readln;„end.                                                                              20     05-28-9313:53ALL                      SWAG SUPPORT TEAM        ROMAN2.PAS               IMPORT              10     û8· {„>Anyone know of how to make a Program that will convert any„>Integer entered into roman numeral Format?„}„„Program Roman_Numeral_Test;„„Type„  st_4 = String[4];„  st_15 = String[15];„  star_4 = Array[0..3] of st_4;„  star_10 = Array[0..9] of st_4;„„Const„  Wunz : star_10 = ('', 'I', 'II', 'III', 'IV',„                    'V', 'VI', 'VII', 'VIII', 'IX');„„  Tenz : star_10 = ('', 'X', 'XX', 'XXX', 'XL',„                    'L', 'LX', 'LXX', 'LXXX', 'XC');„„  Hunz : star_10 = ('', 'C', 'CC', 'CCC', 'CD',„                    'D', 'DC', 'DCC', 'DCCC', 'CM');„„  Thouz : star_4 = ('', 'M', 'MM', 'MMM');„„„Function Dec2Roman(wo_in : Word) : st_15;„begin„  Dec2Roman := Thouz[(wo_in div 1000)] +„               Hunz[((wo_in mod 1000) div 100)] +„               Tenz[(((wo_in mod 1000) mod 100) div 10)] +„               Wunz[(((wo_in mod 1000) mod 100) mod 10)]„end;„„Var„  wo_Temp : Word;„„begin„  Writeln;„  Write(' Enter number to be converted to roman-numeral equivalent: ');„  readln(wo_Temp);„  if (wo_Temp > 3999) then„    wo_Temp := 3999;„  Writeln;„  Writeln(' Roman-numeral equivalent of ', wo_Temp, ' = ', Dec2Roman(wo_Temp))„end.„„        21     05-28-9313:53ALL                      SWAG SUPPORT TEAM        SHLSHR.PAS               IMPORT              24     û85M { INFO ON SHR and SHL }„„> (5 Shl 2) + 5 which is: (5 x 4) + 5„> So, 10 * 10 would be (10 Shl 3) + (10 Shl 1)„„This looks good but, can it be done With Variables (So I can use„numbers other than 5 & 5)?„„ Yes, just keep in mind that each shift leftward Doubles the value...„„        p SHL 1  =  p * 2„        p SHL 2  =  p * 4„        p SHL 3  =  p * 8„        p SHL 4  =  p * 16„        ...„„ (likewise, each shift rightward halves the value).„„ Also keep in mind that the maximum amount you can shift is the„ number of bits in the Variable.  Bytes are 8 bits, Words and„ Integers are 16 bits, and LongInts are 32 bits.  if you shift„ a Variable its full bit size, or more, it will be 0 (zero).„„ For example: if p is a Byte, then p SHR 8 = 0.„„{  Use Shr/Shl to multiply/divide, rather than the operators„  How do you (or anybody) do this?   For example, how would I do 5 * 5?„}„{*******************************************************************}„ Program DemoShifts;„ Var     Number, Result  : Word;„ begin„    {   Calculate 5 * 5, without using multiplication ...           }„„    Number := 5;                    { original value                }„    Result := Number SHL 2;         { now Result = 4 * Number       }„    Result := Result + Number;      { 4*Number + Number = 5*Number  }„„    WriteLn( '5 * 5 = ', Result );  { because seeing is believing   }„„ end {DemoShifts}.„{*******************************************************************}„„ But TP seems sometimes to do the 'shift vs. MUL optimization' itself,„ this being bad if Compiling For a 386/486 CPU.„ A "* 2" would always result in a SHL instruction ( unless Real„ arithmetic was used ;-> ).„„ Ok, I understand that part.  if x shr 4 = x/4  (and the remainder is„ dropped) then I Really understand it.  Does it? Do I?„„No.  x shl 0 = x„     x shl 1 = x/(2^1) = x/2„     x shl 2 = x/(2^2) = x/4„     x shl 3 = x/(2^3) = x/8„     x shl 4 = x/(2^4) = x/16„„Just as:„     x shr 0 = x„     x shr 1 = x*(2^1) = 2x„     x shr 2 = x*(2^2) = 4x„     x shr 3 = x*(2^3) = 8x„     x shr 4 = x*(2^4) = 16x„„So now you can see how and why the Compiler substitutes a "shr 1" For "* 2".„„ > PD> So, 10 * 10 would be: (10 shl 3) + 20„ >„ > MC> not quite:„ > MC> (10 Shl 3)+(10 Shl 1)s, I'm back! (3:634/384.6)„ >„ > Why?  wouldn't the second one take an additional instruction (shl)?„„Well yes, but 8086 instructions weren't created equal.  PerForming two„shifts and the add to combine them will (on a 286 or lesser) less time„overall than doing even one MUL.„„The 386/486 has streamlined the MUL instruction so that it takes much less„time, and can often Compete With the shift/add approach.  Which to use?„Well, I'd stick With the shift/add approach, since if you're writing one„Program For both XTs and 386s, the XT will be acceptable, and so will the„386.  Using the MUL; True, 386 perFormance will be better, but your XT„perFormance will suffer quite a bit.„                        22     05-28-9313:53ALL                      SWAG SUPPORT TEAM        SWAPNUMS.PAS             IMPORT              5      û8Bâ {„>Is there a way (using bit manipulations such as AND, OR, XOR) to„>swap to Variables without making a 3rd temporary Variable?„>„„If the two Variables are numbers, and the following operations„won't overflow the limitations of the Type, then yes, you can„do it like this:„}„Var„   A, B : Integer;„„begin„   A := 5;„   B := 3;„„   A := A + B;„   B := A - B;„   A := A - B;„„   { which is„„   A := 5 + 3 (8)„   B := 8 - 3 (5)„   A := 8 - 5 (3)„„   A = 3„   B = 5 }„„end;                                           23     05-28-9313:53ALL                      SWAG SUPPORT TEAM        TP6RAND.PAS              IMPORT              12     û8¿ {„Borland changed the Random() algorithm between TP6 and TP/BP7.  The Unit„below provides the TP6 Random Function in its Integer flavour.  (The„Randomize Procedure wasn't changed.)„„{ *  Turbo Pascal Runtime Library Version 6.0     * ;„  *  Random Number Generator                      * ;„  *                                               * ;„  *  Copyright (C) 1988,92 Borland International  * }„„Unit TP6Rand;„„Interface„„Function Random(Max: Integer): Integer;„„Implementation„„Const„  { Scaling Constant}„  ConstM31 = LongInt(-31);„  { Multiplication factor}„  Factor: Word = $8405;„„„Function NextRand: LongInt; Assembler;„{„  Compute next random number„  New := 8088405H * Old + 1„  Out  DX:AX = Next random number„}„Asm„  MOV  AX,RandSeed.Word[0]„  MOV  BX,RandSeed.Word[2]„  MOV  CX,AX„  MUL  Factor.Word[0]     { New = Old.w0 * 8405H }„  SHL  CX,1               { New.w2 += Old.w0 * 808H }„  SHL  CX,1„  SHL  CX,1„  ADD  CH,CL„  ADD  DX,CX„  ADD  DX,BX              { New.w2 += Old.w2 * 8405H }„  SHL  BX,1„  SHL  BX,1„  ADD  DX,BX„  ADD  DH,BL„  MOV  CL,5„  SHL  BX,CL„  ADD  DH,BL„  ADD  AX,1      { New += 1 }„  ADC  DX,0„  MOV  RandSeed.Word[0],AX„  MOV  RandSeed.Word[2],DX„end;„„Function Random(Max: Integer): Integer; Assembler;„Asm„ CALL  NextRand„ xor   AX,AX„ MOV   BX,Max.Word[0]„ or    BX,BX„ JE    @@1„ XCHG  AX,DX„ div   BX„ XCHG  AX,DX„@@1:„end;„„end.„                               24     05-28-9313:53ALL                      SWAG SUPPORT TEAM        WORD2HEX.PAS             IMPORT              67     û8ä‘ {„> How does the following Function make a Word into Hex:„„ - Dissection:„}„„Type„  Str4 : String[4];„„Function WordtoHex(W : Word) : St4„Var„  HexStr : St4;„„  Function Translate(B : Byte) : Char;„„  { This Function takes a number from 0 to 15 and makes it into a hex digit.}„„  begin„    if B < 10 then„    { if it's 0..9 }„      Translate := Chr(B + 48)„  { These statements use math on Characters... ascii 48 is '0'.„    Could have been written: Translate := Chr(B + ord('0')) }„    else„      Translate := Chr(B + 55);„  { This one is For letters A~F. ascii 55 isn't anything, but if you add„    $A (10) to 55 you get 65, which is the ascii code For 'A'„    This could have been written: Translate := Chr(B + ord('A')-$A); }„  end;„„begin„  HexStr := ' ';„  HexStr := HexStr + Translate(Hi(W) shr 4);„  { Hi(W) takes the high Byte of Word W.„    shr 4 means the same as divide by 16...„    What they're Really doing here is taking each nibble of the hex Word„    and isolating it, translating it to hex, and adding it to the String. }„  HexStr := HexStr + Translate(Hi(W) and 15);„  HexStr := HexStr + Translate(Lo(W) shr 4);„  HexStr := HexStr + Translate(Lo(W) and 15);„  WordtoHex := HexStr;„end;„{„> I am learning Pascal and don't understand something.  How„> does the following Function make a Word into Hex:„„It doesn't, at least not as present! But if you changes two things, maybe„spelling-errors, it will work. This is a bit hard to explain and grasp, because„it involves operations at a less abstract level than the one that you usually„work on in TP. Remember, when a number is stored in memory, it's stored binary,„hexadecimal notion is just For making it easier For man to read. I don't know„if you know how to Write and read binary- and hexadecimal-numbers, in Case you„don't know it's all here...„„On PC, a Word, in the range 0 to 65535, has 16 bits. A Word written in binary„notion For this reason contains 16 digits, 0's or 1's! But a Word written in„hexadecimal notion contains 4 digits. Simple math tells us that one digit in„hex-notion is equal to four digits binary. Four digits binary gives 16„combinations (2^4). ThereFore, each hexadecimal digit must be able to contain„values from decimal 0-decimal 15, _in one digit_! Our normal digits, 0-9, isn't„sufficient For this, we must use 6 other digits. The designers of this system„choosed A-F as the extra digits. This means, in hex the digits are 0, 1, 2, 3,„4, 5, 6, 7, 8, 9, A, B, C, D, E and F. Hanging on?„„>    Function WordtoHex(W : Word) : St4„„Compile-time error: You must have a semicolon after the Function header-line.„„>    Var„>        HexStr : St4;„„>        Function Translate(B : Byte) : Char;„>        begin„>           if B < 10„>               then„>                   Translate := Chr(B + 48)„>               else„>                   Translate := Chr(B + 55);„>        end;„„This is clearer as:„„  if b < 10„    then Translate := Chr(b+ord('0'))„    else Translate := Chr(b+ord('A')-10);„„Think about the first Case, when b < 10, if b were 0, the expression would be„'0' plus 0, '0'!. if b were 1, it's '0' plus 1, '1'!. This works because in the„ASCII-table the numbers are sequential ordered. But '0' plus 10 would be ':',„because it happens to be after the numbers.„„then, when we want 'A'-'F, we would need to start from 'A'. But we can't add 10„to 'A' For getting 'A' and 11 For getting 'B' and that like. First we must make„the value relative 'A'. Because the values that we're working on here is in the„range 10 to 15, we can decrease it With 10 and get 0 to 5. then is OK to use„them relative 'A'. As beFore, 'A' plus 0 is 'A', 'A' plus 1 is 'B', and so on.„„However, this routine has no safety check, it will gladly return 'G' For 16,„because 'A'+6 is 'G'. It doesn't care if the value is within hexadecimal range„or not (numbers bigger than 15 can't be turned into one hex digit, they need„more digits). But here it's OK, because the routine is local to WordtoHex that„will never pass anything else than 0 to 15.„„>    begin„>        HexStr := ' ';„„Logical error: You must initalize HexStr to an empty String, '', if not it will„consist of a space and three hex digits, not four. A hex-Word String is„Composed of four hexadeciamal-digits. Because you have declared the String as a„Variable of the Type St4 and St4 only allows four Chars, exactly what is needed„For a hexWord-String, the last one added will be discarded if you have a space„at the beginning, filling up one position.„„>        HexStr := HexStr + Translate(Hi(W) shr 4);„>        HexStr := HexStr + Translate(Hi(W) and 15);„>        HexStr := HexStr + Translate(Lo(W) shr 4);„>        HexStr := HexStr + Translate(Lo(W) and 15);„>        WordtoHex := HexStr;„>    end;„„It would be easier to read if the 'and'-value were in hex-notation, $000F. See„below For explanation why. However, this part requires some understanding of„the bits. It's probably best show With an example. Let's say, our number W is„$1234.„„$1234 is written 0001 0010 0011 0100 in binary. Each hex-digit corresponds to a„four-group binary digits.„„˛) The binary number 0001 is 0*(2^3) + 0*(2^2) + 0*(2^1) + 1*(2^0). It gives„0+0+0+1=1 in decimal.„„˛) The binary number 0101 is 0*(2^3) + 1*(2^2) + 0*(2^1) + 1*(2^0). It gives„0+4+0+1=5 in decimal.„„˛ The _decimal_ number 1101 is 1*(10^3) + 1*(10^2) + 0*(10^1) + 1*(10^0). It„gives 1000+100+0+1=1011! As you can see, the only difference between the„decimal and the binary and the hexadecimal system is the base-power. True, the„hex-system Uses strange digits For us used to decimal, but For the ones used to„binary, 2-9 is equally strange...„„Like our decimal system, in hex and binary, it's unnescessary to include„leading zeros, i. e. $0001 = $1 (of course you can't remove trailing zeroes,„decimal 1000 certainly isn't equal to decimal 1...). But you will note that I„sometimes include these leading zeroes, just because it looks good (?). and„writing binary number 1000 0000 is like writing 10000 in decimal as 10,000;„it's only For easy reading, but the Compiler won't allow it.„„However, I hope you grasp a least something of my extremly bad explanation :-(,„or maybe you know it beFore?! Now, let's look at the things that happens when„the above statements are executed and w = $1234 (0001 0010 0011 0100).„„Hi returns the upper 8 bits of the Word, in this Case 0001 0010; Lo returns the„lower bits (!), 0011 0100. The above code Uses 'and' and 'shr', a breif„explanation of them will probably be nescessary (oh no :-)).„„˛ and, when not used as a Boolean operator, Uses two binary numbers and, For„each bit, tests them. if _both_ bits are set (equal to 1) the resuling bit is„set to 1, if any or both of them is cleared (equal to 0) the result is 0. This„means:„„„  0001 0010   Hi(w)                     0011 0100   Lo(w)„  0000 1111   and With 15 or $000F      0000 1111   and With 15 or $000F„  ---------                             ---------„  0000 0010   0010 binary = 2 hex       0000 0100   0100 binary = 4 hex„„This was the second and first statement, and out you get the second and first„number! When we pass them to Translate, we get back '2' and '4'.„„˛ shr, only For binary operations, shifts the bits to the right. The bits that„passes over the right side is lost, and the ones that move on left side is„replaced by zeroes. The bits shifts as many times as the value after the„shr-keyWord, here 4 times. Like this:„„  00010010   Hi(w)                     00110100   Lo(w)„  --------             shr 4           --------„  00001001        after one shift      00011010„  00000100        after two shifts     00001101„  00000010       after three shifts    00000110„  00000001       after four shifts     00000011„„Now we got binary 0001 and binary 0011, in hex $1 and $3. The first and third„statement, and the first and third number! The String to return is digit1 +„digit2 + digit3 + digit4, exactly what we want.„„Hmm... Now I haven't told you anything about the binary or, xor, not and„shl-keyWords... But I think this message is quiet long as it is, without that.„But if you want more info or a better explanation, only drop me a msg here.„„Happy hacking /Jake 930225 17.35 (started writing last night)„PS. There may be some errors, I haven't proof-read the Text or my math. then,„please correct me, anybody.„}                                                                                                                         25     08-27-9320:03ALL                      SEAN PALMER              Handling Numbers in ASM  IMPORT              9      û8H { SEAN PALMER„„I've been playing around with the AAM instruction and came up with some„things you guys might find useful...„„Strings as function results are WIERD with the inline Assembler. 8)„}„„function div10(b : byte) : byte; assembler;„asm„  mov al, b„  aam„  mov al, ah„end;„„function mod10(b : byte) : byte; assembler;„asm„  mov al, b„  aam„end;„„type„  str2 = string[2];„  str8 = string[8];„„function toStr2(b : byte) : str2; assembler;„asm {only call with b=0~99}„  les  di, @RESULT„  cld„  mov  al, 2„  stosb„  mov  al, b„  aam„  xchg ah, al„  add  ax, $3030„  stosw„end;„„{makes date string in MM/DD/YY format from m,d,y}„function toDateStr(m,d,y:byte):str8;assembler;asm {only call with m,d,y=0~99}„  les  di, @RESULT„  cld„  mov  al, 8„  stosb„  mov  al, m„  aam„  xchg ah, al„  add  ax, $3030„  stosw„  mov  al, '/'„  stosb„  mov  al, d„  aam„  xchg ah, al„  add  ax, $3030„  stosw„  mov  al, '/'„  stosb„  mov  al, y„  aam„  xchg ah, al„  add  ax, $3030„  stosw„end;„„„                                         26     08-27-9321:39ALL                      TREVOR CARLSON           MS to IEEE Numbers       IMPORT              9      û8U» {„Trevor Carlson„„> Does anyone have source examples of how to convert an MSBIN to a„> LongInt Type Variable?„}„„Type„  MKS = Array [0..3] of Byte;„„Function MStoIEEE(Var MS) : Real;„{ Converts a 4 Byte Microsoft format single precision Real Variable as„  used in earlier versions of QuickBASIC and GW-BASIC to IEEE 6 Byte Real }„Var„  m    : MKS Absolute MS;„  r    : Real;„  ieee : Array [0..5] of Byte Absolute r;„begin„  FillChar(r, sizeof(r), 0);„  ieee[0] := m[3];„  ieee[3] := m[0];„  ieee[4] := m[1];„  ieee[5] := m[2];„  MStoieee := r;„end;  { MStoIEEE }„„„Function IEEEtoMS(ie : Real) : LongInt;„{ LongInt Type used only For convenience of Typecasting. Note that this will„  only be effective where the accuracy required can be obtained in the 23„  bits that are available With the MKS Type. }„Var„  ms    : MKS;„  ieee  : Array [0..5] of Byte Absolute ie;„begin„  ms[3] := ieee[0];„  ms[0] := ieee[3];„  ms[1] := ieee[4];„  ms[2] := ieee[5];„  IEEEtoMS := LongInt(ms);„end; { IEEEtoMS }„                          27     09-26-9309:31ALL                      MARTIN RICHARDSON        Get HIGH order of WORD   IMPORT              7      û8"„ {*****************************************************************************„ * Function ...... wHi()„ * Purpose ....... Return the High order word from a longint (double word)„ * Parameters .... n          LONGINT to retrieve high word from„ * Returns ....... High word from n„ * Notes ......... HI only returns the HIgh byte from a word.  I needed„ *                 something that returned the high WORD from a LONGINT.„ * Author ........ Martin Richardson„ * Date .......... October 9, 1992„ *****************************************************************************}„FUNCTION wHi( n: LONGINT ): WORD; ASSEMBLER;„ASM„   MOV  AX, WORD PTR n[2]„END;„„                                                                                                              28     09-26-9309:31ALL                      MARTIN RICHARDSON        Get Low Order of WORD    IMPORT              7      û8"„ {*****************************************************************************„ * Function ...... wLo()„ * Purpose ....... Return the low order word from a longint (double word)„ * Parameters .... n          LONGINT to retrieve low word from„ * Returns ....... Low word from n„ * Notes ......... LO only returns the LOw byte from a word.  I needed„ *                 something that returned the low WORD from a LONGINT.„ * Author ........ Martin Richardson„ * Date .......... October 9, 1992„ *****************************************************************************}„FUNCTION wLo( n: LONGINT ): WORD; ASSEMBLER;„ASM„   MOV  AX, WORD PTR n[0]„END;„„                                                                                                                   29     09-26-9310:53ALL                      KENT BRIGGS              Random Number Generator  IMPORT              8      û8Pí (*„From: KENT BRIGGS                  Refer#: NONE„Subj: TP 7.0 RANDOM GENERATOR        Conf: (1221) F-PASCAL„*)„„const„  rseed: longint = 0;„„procedure randomize67;      {TP 6.0 & 7.0 seed generator}„begin„  reg.ah:=$2c;„  msdos(reg);    {get time: ch=hour,cl=min,dh=sec,dl=sec/100}„  rseed:=reg.dx;„  rseed:=(rseed shl 16) or reg.cx;„end;„„function rand_word6(x: word): word;    {TP 6.0 RNG: word}„begin„  rseed:=rseed*134775813+1;„  rand_word6:=(rseed shr 16) mod x;„end;„„function rand_word7(x: word): word;    {TP 7.0 RNG: word}„begin„  rseed:=rseed*134775813+1;„  rand_word7:=((rseed shr 16)*x+((rseed and $ffff)*x shr 16)) shr 16;„end;„„function rand_real67: real;    {TP 6.0 & 7.0 RNG: real}„begin„  rseed:=rseed*134775813+1;„  if rseed<0 then rand_real67:=rseed/4294967296.0+1.0 else„  rand_real67:=rseed/4294967296.0;„end;„                                                               30     10-28-9311:31ALL                      J.P. RITCHEY             MSBIN to IEEE            IMPORT              70     û8±Ï {===========================================================================„Date: 10-09-93 (23:23)„From: J.P. Ritchey„Subj: MSBIN to IEEE„---------------------------------------------------------------------------„GE>         Does anyone have any code for Converting MSBIN format„GE>         numbers into IEEE?  }„„{$A-,B-,D-,E+,F-,I-,L-,N+,O-,R-,S-,V-}„unit BFLOAT;„(*„            MicroSoft Binary Float to IEEE format Conversion„                    Copyright (c) 1989 J.P. Ritchey„                            Version 1.0„„         This software is released to the public domain.  Though„         tested, there could be some errors.  Any reports of bugs„         discovered would be appreciated. Send reports to„                 Pat Ritchey     Compuserve ID 72537,2420„*)„interface„„type„  bfloat4 = record„    { M'Soft single precision }„    mantissa : array[5..7] of byte;„    exponent : byte;„    end;„„  Bfloat8 = record„    { M'Soft double precision }„    mantissa : array[1..7] of byte;„    exponent : byte;„    end;„„„Function Bfloat4toExtended(d : bfloat4) : extended;„Function Bfloat8toExtended(d : Bfloat8): extended;„„{ These routines will convert a MicroSoft Binary Floating point„  number to IEEE extended format.  The extended is large enough„  to store any M'Soft single or double number, so no over/underflow„  problems are encountered.  The Mantissa of an extended is large enough„  to hold a BFloatx mantissa, so no truncation is required.„„  The result can be returned to TP single and double variables and„  TP will handle the conversion.  Note that Over/Underflow can occur„  with these types. }„„Function HexExt(ep:extended) : string;„„{ A routine to return the hex representation of an IEEE extended variable„  Left in from debugging, you may find it useful }„„Function ExtendedtoBfloat4(ep : extended; var b : bfloat4) : boolean;„Function ExtendedtoBfloat8(ep : extended; var b : Bfloat8) : boolean;„„{ These routines are the reverse of the above, that is they convert„  TP extended => M'Soft format.  You can use TP singles and doubles„  as the first parameter and TP will do the conversion to extended„  for you.„„  The Function result returns True if the conversion was succesful,„  and False if not (because of overflow).„„  Since an extended can have an exponent that will not fit„  in the M'Soft format Over/Underflow is handled in the following„  manner:„    Overflow:  Set the Bfloatx to 0 and return a False result.„    Underflow: Set the BFloatx to 0 and return a True Result.„„  No rounding is done on the mantissa.  It is simply truncated to„  fit. }„„„Function BFloat4toReal(b:bfloat4) : Real;„Function BFloat8toReal(b:bfloat8) : Real;„„{ These routines will convert a MicroSoft Binary Floating point„  number to Turbo real format.  The real is large enough„  to store any M'Soft single or double Exponent, so no over/underflow„  problems are encountered.  The Mantissa of an real is large enough„  to hold a BFloat4 mantissa, so no truncation is required.  The„  BFloat8 mantissa is truncated (from 7 bytes to 5 bytes) }„„Function RealtoBFloat4(rp: real; var b:bfloat4) : Boolean;„Function RealtoBFloat8(rp : real; var b:bfloat8) : Boolean;„„{ These routines do the reverse of the above.  No Over/Underflow can„  occur, but truncation of the mantissa can occur„  when converting Real to Bfloat4 (5 bytes to 3 bytes).„„  The function always returns True, and is structured this way to„  function similar to the IEEE formats }„„implementation„type„  IEEEExtended = record„     Case integer of„     0 : (Mantissa : array[0..7] of byte;„          Exponent : word);„     1 : (e : extended);„     end;„„  TurboReal = record„     Case integer of„     0 : (Exponent : byte;„          Mantissa : array[3..7] of byte);„     1 : (r : real);„     end;„„Function HexExt(ep:extended) : string;„var„ e : IEEEExtended absolute ep;„ i : integer;„ s : string;„ Function Hex(b:byte) : string;„  const hc : array[0..15] of char = '0123456789ABCDEF';„  begin„  Hex := hc[b shr 4]+hc[b and 15];„  end;„begin„  s := hex(hi(e.exponent))+hex(lo(e.exponent))+' ';„  for i := 7 downto 0 do s := s+hex(e.mantissa[i]);„HexExt := s;„end;„„Function NullMantissa(e : IEEEextended) : boolean;„var„ i : integer;„begin„NullMantissa := False;„for i := 0 to 7 do if e.mantissa[i] <> 0 then exit;„NullMantissa := true;„end;„„Procedure ShiftLeftMantissa(var e);„{ A routine to shift the 8 byte mantissa left one bit }„inline(„{0101} $F8/          {   CLC                        }„{0102} $5F/          {   POP    DI                  }„{0103} $07/          {   POP    ES                  }„{0104} $B9/$04/$00/  {   MOV    CX,0004             }„{0107} $26/$D1/$15/  {   RCL    Word Ptr ES:[DI],1  }„{010A} $47/          {   INC    DI                  }„{010B} $47/          {   INC    DI                  }„{010C} $E2/$F9       {   LOOP   0107                }„);„„Procedure Normalize(var e : IEEEextended);„{ Normalize takes an extended and insures that the "i" bit is„  set to 1 since M'Soft assumes a 1 is there. An extended has„  a value of 0.0 if the mantissa is zero, so the first check.„  The exponent also has to be kept from wrapping from 0 to $FFFF„  so the "if e.exponent = 0" check.  If it gets this small„  for the routines that call it, there would be underflow and 0„  would be returned.„}„var„ exp : word;„„begin„exp := e.exponent and $7FFF; { mask out sign }„if NullMantissa(e) then„   begin„   E.exponent := 0;„   exit„   end;„while e.mantissa[7] < 128 do„   begin„   ShiftLeftMantissa(e);„   dec(exp);„   if exp = 0 then exit;„   end;„e.exponent := (e.exponent and $8000) or exp;  { restore sign }„end;„„Function Bfloat8toExtended(d : Bfloat8) : extended;„var„  i : integer;„  e : IEEEExtended;„begin„  fillchar(e,sizeof(e),0);„  Bfloat8toExtended := 0.0;„  if d.exponent = 0 then exit;„  { if the bfloat exponent is 0 the mantissa is ignored and„    the value reurned is 0.0 }„  e.exponent := d.exponent - 129 + 16383;„  { bfloat is biased by 129, extended by 16383„    This creates the correct exponent }„  if d.mantissa[7] > 127 then„     { if the sign bit in bfloat is 1 then set the sign bit in the extended }„     e.exponent := e.exponent or $8000;„  move(d.Mantissa[1],e.mantissa[1],6);„  e.mantissa[7] := $80 or (d.mantissa[7] and $7F);„  { bfloat assumes 1.fffffff, so supply it for extended }„  Bfloat8toExtended := e.e;„end;„„Function Bfloat4toExtended(d : bfloat4) : extended;„var„  i : integer;„  e : IEEEExtended;„begin„  fillchar(e,sizeof(e),0);„  Bfloat4toExtended := 0.0;„  if d.exponent = 0 then exit;„  e.exponent := integer(d.exponent - 129) + 16383;„  if d.mantissa[7] > 127 then„     e.exponent := e.exponent or $8000;„  move(d.Mantissa[5],e.mantissa[5],2);„  e.mantissa[7] := $80 or (d.mantissa[7] and $7F);„  Bfloat4toExtended := e.e;„end;„„Function ExtendedtoBfloat8(ep : extended; var b : Bfloat8) : boolean;„var„  e : IEEEextended absolute ep;„  exp : integer;„  sign : byte;„begin„FillChar(b,Sizeof(b),0);„ExtendedtoBfloat8 := true; { assume success }„Normalize(e);„if e.exponent = 0 then exit;„sign := byte(e.exponent > 32767) shl 7;„exp := (e.exponent and $7FFF) - 16383 + 129;„if exp < 0 then exp := 0; { underflow }„if exp > 255 then { overflow }„   begin„   ExtendedtoBfloat8 := false;„   exit;„   end;„b.exponent := exp;„move(e.mantissa[1],b.mantissa[1],7);„b.mantissa[7] := (b.mantissa[7] and $7F) or sign;„end;„„Function ExtendedtoBfloat4(ep : extended; var b : Bfloat4) : boolean;„var„  e : IEEEextended absolute ep;„  exp : integer;„  sign : byte;„begin„FillChar(b,Sizeof(b),0);„ExtendedtoBfloat4 := true; { assume success }„Normalize(e);„if e.exponent = 0 then exit;„sign := byte(e.exponent > 32767) shl 7;„exp := (e.exponent and $7FFF) - 16383 + 129;„if exp < 0 then exp := 0; { underflow }„if exp > 255 then { overflow }„   begin„   ExtendedtoBfloat4 := false;„   exit;„   end;„b.exponent := exp;„move(e.mantissa[5],b.mantissa[5],3);„b.mantissa[7] := (b.mantissa[7] and $7F) or sign;„end;„„Function BFloat4toReal(b:bfloat4) : Real;„var„ r : TurboReal;„begin„  fillchar(r,sizeof(r),0);„  r.exponent := b.exponent;„  move(b.mantissa[5],r.mantissa[5],3);„  Bfloat4toReal := r.r;„end;„„Function BFloat8toReal(b:bfloat8) : Real;„var„ r : TurboReal;„begin„  fillchar(r,sizeof(r),0);„  r.exponent := b.exponent;„  move(b.mantissa[3],r.mantissa[3],5);„  Bfloat8toReal := r.r;„end;„„Function RealtoBFloat4(rp: real; var b:bfloat4) : Boolean;„var„ r : TurboReal absolute rp;„begin„  fillchar(b,sizeof(b),0);„  b.exponent := r.exponent;„  move(r.mantissa[5],b.mantissa[5],3);„  RealtoBfloat4 := true;„end;„„Function RealtoBFloat8(rp : real; var b:bfloat8) : Boolean;„var„ r : TurboReal absolute rp;„begin„  fillchar(b,sizeof(b),0);„  b.exponent := r.exponent;„  move(r.mantissa[3],b.mantissa[3],5);„  RealtoBfloat8 := true;„end;„„end.„                                                 31     10-28-9311:32ALL                      GREG VIGNEAULT           Verify ISBN Numbers      IMPORT              17     û8Ñ {===========================================================================„Date: 09-22-93 (20:14)„From: GREG VIGNEAULT„Subj: Pascal ISBN verification„„ Here's a snippet of TP code for the free SWAG archives. It verifies„ ISBN numbers, via the embedded checksum ... }„„(********************************************************************)„(* Turbo/Quick/StonyBrook Pascal source file: ISBN.PAS  v1.0 GSV    *)„(* Verify any International Standard Book Number (ISBN) ...         *)„„PROGRAM checkISBN;„„CONST TAB = #9;                       { ASCII horizontal tab         }„      LF  = #10;                      { ASCII line feed              }„„VAR ISBNstr : STRING[16];„    loopc, ISBNlen, M, chksm : BYTE;„„BEGIN {checkISBN}„„  WriteLn (LF,TAB,'ISBN Check v1.0 Copyright 1993 Greg Vigneault',LF);„„  IF ( ParamCount <> 1 ) THEN BEGIN   { we want just one input parm  }„    WriteLn ( TAB, 'Usage: ISBN <ISBN#>', LF );„    Halt(1);„  END; {IF}„„  ISBNstr := ParamStr (1);            { get the ISBN number          }„  Write ( TAB, 'Checking ISBN# ', ISBNstr, ' ...' );„  { eliminate any non-digit characters from the ISBN string...       }„  ISBNlen := 0;„  FOR loopc := 1 TO ORD ( ISBNstr[0] ) DO„    IF ( ISBNstr[ loopc ] IN ['0'..'9'] ) THEN BEGIN„      INC ( ISBNlen );„      ISBNstr[ ISBNlen ] := ISBNstr[ loopc ];„  END; {IF & FOR}„  { an 'X' at the end of the ISBN affects the result...              }„  IF ( ISBNstr[ ORD ( ISBNstr[0] ) ] IN ['X','x'] ) THEN„    M := 10„  ELSE„    M := ORD ( ISBNstr[ ISBNlen ] ) - 48;„  ISBNstr[0] := CHR ( ISBNlen );          { new ISBN string length   }„  WriteLn ( 'reduced ISBN = ', ISBNstr );  WriteLn;„  chksm := 0;                             { initialize checksum      }„  FOR loopc := 1 TO ISBNlen-1 DO„    INC (chksm, ( ORD ( ISBNstr[ loopc ] ) - 48 ) * loopc );„  Write ( TAB, 'ISBN ' );„  IF ( ( chksm MOD 11 ) = M ) THEN„    WriteLn ( 'is okay.' )„  ELSE„    WriteLn ( 'error!',#7 );„„END {checkISBN}.                      (* Not for commercial retail. *)„                                   32     11-02-9305:00ALL                      CHRIS QUARTETTI          Setting/Getting BITS     IMPORT              21     û8∑ {„CHRIS QUARTETTI„„>Is there an easy way to create a 1-bit or 2-bit data structure.  For„>example, a 2-bit Type that can hold 4 possible values.  For that matter,„>is there a hard way? <g>  Thanks very much -Greg„„   I suppose this would qualify For the hard way-- not too flexible, but it„works. It would be a bit easier to do this if you wanted a bunch of the same„size Variables (ie 4 4 bit Variables, or an Array of 4*x 4 bit Variables).„FWIW I used BP7 here, but TP6 and up will work. Also, it need not be Object„oriented.„}„„Type„  bitf = Object                                                                                  { split 'bits' into bitfields }„    bits : Word;                         { 16 bits total }„„    Function  get : Word;„„    Procedure set1(value : Word);        { this will be 2 bits }„    Function  get1 : Word;„„    Procedure set2(value : Word);        { this will be 13 bits }„    Function  get2 : Word;„„    Procedure set3(value : Word);        { this will be 1 bit }„    Function  get3 : Word;„  end;„„Function bitf.get : Word;„begin„  get := bits;„end;„„Procedure bitf.set1(value : Word);„{ Set the value of the first bitfield }„Const„  valmask  : Word = $C000;  { 11000000 00000000 }„  bitsmask : Word = $3FFF;  { 00111111 11111111 }„begin„  value := value shl 14 and valmask;„  bits  := value + (bits and bitsmask);„end;„„Function bitf.get1 : Word;„{ Get the value of the first bitfield }„begin„  get1 := bits shr 14;„end;„„Procedure bitf.set2(value : Word);„{ Set the value of the second bitfield }„Const„  valmask  : Word = $3FFE;  { 00111111 11111110 }„  bitsmask : Word = $C001;  { 11000000 00000001 }„begin„  value := (value shl 1) and valmask;„  bits  := value + (bits and bitsmask);„end;„„Function bitf.get2 : Word;„{ Get the value of the second bitfield }„Const„  valmask : Word = $3FFE;   { 00111111 11111110 }„begin„  get2 := (bits and valmask) shr 1;„end;„„Procedure bitf.set3(value : Word);„{ Set the value of the third bitfield }„Const„  valmask  : Word = $0001;  { 00000000 00000001 }„  bitsmask : Word = $FFFE;  { 11111111 11111110 }„begin„  value := value and valmask;„  bits  := value + (bits and bitsmask);„end;„„Function bitf.get3 : Word;„{ Get the value of the third bitfield }„Const„  valmask : Word = $0001;  { 00000000 00000001 }„begin„  get3 := bits and valmask;„end;„„Var„  x : bitf;„„begin„  x.set1(3);        { set all to maximum values }„  x.set2(8191);„  x.set3(1);„  Writeln(x.get1, ', ', x.get2, ', ', x.get3, ', ', x.get);„end.„                                                             33     11-02-9305:01ALL                      ROBERT ROTHENBURG        More Get/Set Bits        IMPORT              21     û8Uı {„Robert Rothenburg„„Here's some routines I wrote while playing around with some compression„algorithms.  Since they're written in Pascal, they're probably not too„fast but they work.„„„Of course they're need some tweaking.„}„(* NoFrills Bit-Input/Output Routines                        *)„(* Insert "n" bits of data into a Buffer or Pull "n" bits of *)„(* data from a buffer.  Useful for Compression routines      *)„„„unit BitIO;„„interface„„const„  BufferSize = 32767;        (* Adjust as appropriate *)„„type„  Buffer  = array [0..BufferSize] of byte;„  BufPtr  = ^Buffer;„  BuffRec = record  (* This was used for I/O by some *)„    Block : BufPtr; (* other units involved with the *)„    Size,           (* compression stuff. Not so     *)„    Ptr   : word;   (* Important?                    *)„    Loc   : byte„  end;„„var„  InBuffer,„  OutBuffer : BuffRec;„  InFile,„  OutFile   : file;„„procedure InitBuffer(var x : BuffRec);        (* Initialize a buffer *)„procedure GetBits(var b : word; num : byte);  (* Get num bits from   *)„                                              (* InBuffer            *)„procedure PutBits(b : word; num : byte);      (* Put num bits into   *)„                                              (* OutBuffer           *)„function Log2(x : word) : byte;               (* Self-explanatory... *)„„implementation„„const„  Power : array [1..17] of longint =„    (1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536);„„procedure InitBuffer(var x : BuffRec);„begin„  with x do„  begin„    Loc  := 8;„    Ptr  := 0;„    Size := 0;„    New(Block);„    FillChar(Block^, BufferSize, #0);„  end;„end;„„procedure GetBits(var b : word; num : byte);„var„  Size : word;„begin„  with InBuffer do„  begin„    b := 0;„    repeat„      b := (b SHL 1);„      if (Block^[Ptr] AND Power[Loc]) <> 0 then„        b := b OR 1;„      dec(Loc);„      if Loc = 0 then„      begin„        Loc := 8;„        inc(Ptr);„      end;„      dec(num);„    until (num = 0);„  end;„end;„„procedure PutBits(b : word; num : byte);„var„  i : byte;„begin„  with OutBuffer do„  repeat„    if Loc = 0 then„    begin„      inc(Ptr);„      Loc := 8;„    end;„    if (b AND Power[num]) <> 0 then„    begin„      Block^[Ptr] := Block^[Ptr] OR Power[Loc];„      dec(Loc);„    end„    else„      dec(Loc);„    dec(num)„  until num = 0;„  OutBuffer.Size := succ(OutBuffer.Ptr);„end;„„function Log2(x : word) : byte;„var„  i : byte;„begin„  i := 17;„  while x<Power[i] do„    dec(i);„  Log2 := i;„end;„„end.„                                                        34     11-02-9305:14ALL                      LOU DUCHEZ               Convert Number to HEX    IMPORT              22     û84≈ {„LOU DUCHEZ„„>does andbody know an easy way to convert a Byte value from it's Integer„> notation to hex notatation?„„Well, thank you For this message.  It finally got me off my keister (sp?) to„Write a "decimal-to-hex" converter -- a project I'd been meaning to do, but„never got around to.  (Technically, since I was in a seated position, I„remained on my keister the whole time, but you know what I mean).  Actually,„the following is not just "decimal-to-hex" -- it's decimal-to-any-base-from-„2-to-36-converter (because base 1 and below doesn't make sense, and after„base 36 I run out of alphabet to represent "digits").  Here is NUBASE:„}„„„Function nubase(numin : LongInt; base, numplaces : Byte) : String;„Var„  tmpstr    : String;„  remainder : Byte;„  negatize  : Boolean;„begin„  negatize := (numin < 0);              { Record if it's a negative number }„  if negatize then„    numin := abs(numin);                { convert to positive For calcs }„  tmpstr[0] := Char(numplaces);         { set length of the output String }„„  While numplaces > 0 do„  begin                                 { Loop: fills each space in String }„    remainder := numin mod base;        { get next "digit" (under new base) }„    if remainder > 9 then„      tmpstr[numplaces] := Char(remainder + 64 - 9)   { convert to letter }„     else„      tmpstr[numplaces] := Char(remainder + 48);      { use number as is }„    numin := numin div base;            { reduce dividend For next "pass" }„    numplaces := numplaces - 1;         { go to "next" position in String }„  end;                                  { end of loop }„„  { The following: if we've run out of room on the String, or if it's a„    negative number and there's not enough space For the "minus" sign,„    convert the output String to all asterisks. }„„  if (numin <> 0) or (negatize and (tmpstr[1] <> '0')) then„    For numplaces := 1 to Byte(tmpstr[0]) do„      tmpstr[numplaces] := '*';„„  { add minus sign }„„  if negatize and (tmpstr[1] = '0') then„    tmpstr[1] := '-';„„  nubase := tmpstr;„end;„„„{„Feed it the number to convert, the base to convert into, and the number of„spaces you want For it.  Leading zeros will be provided.  Example: to„convert 111 into hex (base 16)  and give 4 digits of answer, you could say:„„Writeln(nubase(111, 16, 4))„„and it'd Write out:„„006F„„This routine does handle negative numbers too.  if you don't give it enough„"space" in the third parameter you pass, it'll return all asterisks.  For„laughs, try converting the number 111 into base 10 and giving it 5 digits„of answer.  You'll get:„„00111  (predictably enough)„}                                                                          35     11-02-9305:52ALL                      GREG VIGNEAULT           LongInt to HEX           IMPORT              11     û8ÜÆ {„GREG VIGNEAULT„„> So to assign the File I will need the HEX in String format.„}„„Type„  String8 = String[8];„„Var„  MyStr : String8;„  ALong : LongInt;„„{ convert a LongInt value to an 8-Character String, using hex digits  }„{ (using all 8 Chars will allow correct order in a sorted directory)  }„„Procedure LongToHex(AnyLong : LongInt; Var HexString : String8);„Var„  ch    : Char;„  Index : Byte;„begin„  HexString := '00000000';                  { default to zero   }„  Index := Length(HexString);               { String length     }„  While AnyLong <> 0 do„  begin                                     { loop 'til done    }„    ch := Chr(48 + Byte(AnyLong) and $0F);  { 0..9 -> '0'..'9'  }„    if ch > '9' then„      Inc(ch, 7);                           { 10..15 -> 'A'..'F'}„    HexString[Index] := ch;                 { insert Char       }„    Dec(Index);                             { adjust chr Index  }„    AnyLong := AnyLong SHR 4;               { For next nibble   }„  end;„end;„„begin„  ALong := $12345678;                       { a LongInt value   }„  LongToHex(ALong, MyStr);                  { convert to hex str}„  WriteLn;„  WriteLn('$', MyStr);                      { display the String}„  WriteLn;„end.„                                                        36     11-21-9309:24ALL                      GREG VIGNEAULT           Base Notation            IMPORT              21     û8t« „{ How about a procedure that will display any integer in any base„ notation from 2 to 16?  The following example displays the values„ 0 through 15 in binary (base 2), octal (base 8), decimal (base 10)„ and hexadecimal (base 16) notations ... }„„(********************************************************************)„PROGRAM BaseX;                      (* compiler: Turbo Pascal v4.0+ *)„                                    (* Nov.14.93 Greg Vigneault     *)„(*------------------------------------------------------------------*)„(* Display any INTEGER in any base notation from 2 to 16...         *)„(*                                                                  *)„(*    number base 2  = binary notation       (digits 0,1)           *)„(*    number base 8  = octal notation        (digits 0..7)          *)„(*    number base 10 = decimal notation      (digits 0..9)          *)„(*    number base 16 = hexadecimal notation  (digits 0..9,A..F)     *)„„PROCEDURE DisplayInteger (AnyInteger :INTEGER; NumberBase :BYTE);„  CONST DataSize = 16;  (* bit-size of an INTEGER *)„  VAR   Index : INTEGER;„        Digit : ARRAY [1..DataSize] OF CHAR;„  BEGIN„    IF (NumberBase > 1) AND (NumberBase < 17) THEN BEGIN„      Index := 0;„      REPEAT„        INC (Index);„        Digit [Index] := CHR(AnyInteger MOD NumberBase + ORD('0'));„        IF (Digit [Index] > '9') THEN INC (Digit [Index],7);„        AnyInteger := AnyInteger DIV NumberBase;„      UNTIL (AnyInteger = 0) OR (Index = DataSize);„      WHILE (Index > 0) DO BEGIN„        Write (Digit [Index]);„        DEC (Index);„      END; {WHILE Index}„    END; {IF NumberBase}„  END {DisplayInteger};„„(*------------------------------------------------------------------*)„(*  to test the DisplayInteger procedure...                         *)„„VAR Base, Number : INTEGER;„„BEGIN„      FOR Base := 2 TO 16 DO„        CASE Base OF„          2,8,10,16 : BEGIN„                        WriteLn;„                        CASE Base OF„                          2  : Write ('Binary : ');„                          8  : Write ('Octal  : ');„                          10 : Write ('Decimal: ');„                          16 : Write ('Hex    : ');„                        END; {CASE}„                        FOR Number := 0 TO 15 DO BEGIN„                          DisplayInteger (Number, Base);„                          Write (' ');„                        END; {FOR}„                      END;„        END; {CASE}„      WriteLn;„„END {BaseX}.„                                                                           37     11-21-9309:25ALL                      SWAG SUPPORT TEAM        Bit Handler              IMPORT              44     û8Wp UNIT Bits;„(**) INTERFACE (**)„TYPE„  bbit = 0..7;„  wbit = 0..15;„  lbit = 0..31;„„  PROCEDURE SetBitB(VAR B : Byte; bit : bbit);„  PROCEDURE ClearBitB(VAR B : Byte; bit : bbit);„  PROCEDURE ToggleBitB(VAR B : Byte; bit : bbit);„  FUNCTION BitSetB(B : Byte; bit : bbit) : Boolean;„  FUNCTION BitClearB(B : Byte; bit : bbit) : Boolean;„„  PROCEDURE SetBitW(VAR W : Word; bit : wbit);„  PROCEDURE ClearBitW(VAR W : Word; bit : wbit);„  PROCEDURE ToggleBitW(VAR W : Word; bit : wbit);„  FUNCTION BitSetW(W : Word; bit : wbit) : Boolean;„  FUNCTION BitClearW(W : Word; bit : wbit) : Boolean;„„  PROCEDURE SetBitL(VAR L : LongInt; bit : lbit);„  PROCEDURE ClearBitL(VAR L : LongInt; bit : lbit);„  PROCEDURE ToggleBitL(VAR L : LongInt; bit : lbit);„  FUNCTION BitSetL(L : LongInt; bit : lbit) : Boolean;„  FUNCTION BitClearL(L : LongInt; bit : lbit) : Boolean;„„(**) IMPLEMENTATION (**)„  PROCEDURE SetBitB(VAR B : Byte; bit : bbit);„              Assembler;„  ASM„    MOV CL, bit„    MOV BL, 1„    SHL BL, CL      {BL contains 2-to-the-bit}„    LES DI, B„    OR ES:[DI], BL  {OR turns on bit}„  END;„„  PROCEDURE ClearBitB(VAR B : Byte; bit : bbit);„              Assembler;„  ASM„    MOV CL, bit„    MOV BL, 1„    SHL BL, CL      {BL contains 2-to-the-bit}„    NOT BL„    LES DI, B„    AND ES:[DI], BL {AND of NOT BL turns off bit}„  END;„„  PROCEDURE ToggleBitB(VAR B : Byte; bit : bbit);„              Assembler;„  ASM„    MOV CL, bit„    MOV BL, 1„    SHL BL, CL      {BL contains 2-to-the-bit}„    LES DI, B„    XOR ES:[DI], BL {XOR toggles bit}„  END;„„  FUNCTION BitSetB(B : Byte; bit : bbit) : Boolean;„             Assembler;„  ASM„    MOV CL, bit„    MOV BL, 1„    SHL BL, CL      {BL contains 2-to-the-bit}„    MOV AL, 0       {set result to FALSE}„    TEST B, BL„    JZ @No„    INC AL          {set result to TRUE}„    @No:„  END;„„  FUNCTION BitClearB(B : Byte; bit : bbit) : Boolean;„             Assembler;„  ASM„    MOV CL, bit„    MOV BL, 1„    SHL BL, CL      {BL contains 2-to-the-bit}„    MOV AL, 0       {set result to FALSE}„    TEST B, BL„    JNZ @No„    INC AL          {set result to TRUE}„    @No:„  END;„„  PROCEDURE SetBitW(VAR W : Word; bit : wbit);„              Assembler;„  ASM„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    LES DI, W„    OR ES:[DI], BX  {OR turns on bit}„  END;„„  PROCEDURE ClearBitW(VAR W : Word; bit : wbit);„              Assembler;„  ASM„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    NOT BX„    LES DI, W„    AND ES:[DI], BX {AND of NOT BX turns off bit}„  END;„„  PROCEDURE ToggleBitW(VAR W : Word; bit : wbit);„              Assembler;„  ASM„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    LES DI, W„    XOR ES:[DI], BX {XOR toggles bit}„  END;„„  FUNCTION BitSetW(W : Word; bit : wbit) : Boolean;„             Assembler;„  ASM„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    MOV AL, 0       {set result to FALSE}„    TEST W, BX„    JZ @No„    INC AL          {set result to TRUE}„    @No:„  END;„„  FUNCTION BitClearW(W : Word; bit : wbit) : Boolean;„             Assembler;„  ASM„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    MOV AL, 0       {set result to FALSE}„    TEST W, BX„    JNZ @No„    INC AL          {set result to TRUE}„    @No:„  END;„„  PROCEDURE SetBitL(VAR L : LongInt; bit : lbit);„              Assembler;„  ASM„    LES DI, L„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    JZ @TopWord     {if zero, use high word}„    OR ES:[DI], BX  {OR turns on bit}„    JMP @Finish„    @TopWord:„    SUB CL, 16„    MOV BX, 1„    SHL BX, CL„    OR ES:[DI+2], BX„    @Finish:„  END;„„  PROCEDURE ClearBitL(VAR L : LongInt; bit : lbit);„              Assembler;„  ASM„    LES DI, L„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    JZ @TopWord     {if zero, use high word}„    NOT BX„    AND ES:[DI], BX {AND of NOT BX turns off bit}„    JMP @Finish„    @TopWord:„    SUB CL, 16„    MOV BX, 1„    SHL BX, CL„    NOT BX„    AND ES:[DI+2], BX„    @Finish:„  END;„„  PROCEDURE ToggleBitL(VAR L : LongInt; bit : lbit);„              Assembler;„  ASM„    LES DI, L„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    JZ @TopWord     {if zero, use high word}„    XOR ES:[DI], BX {XOR toggles bit}„    JMP @Finish„    @TopWord:„    SUB CL, 16„    MOV BX, 1„    SHL BX, CL„    XOR ES:[DI+2], BX„    @Finish:„  END;„„  FUNCTION BitSetL(L : LongInt; bit : lbit) : Boolean;„             Assembler;„  ASM„    MOV AL, 0       {set result to FALSE}„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    JZ @TopWord     {if zero, use high word}„    TEST Word(L), BX„    JMP @Finish„    @TopWord:„    SUB CL, 16„    MOV BX, 1„    SHL BX, CL„    TEST Word(L+2), BX„    @Finish:„    JZ @No„    INC AL          {set result to TRUE}„    @No:„  END;„„  FUNCTION BitClearL(L : LongInt; bit : lbit) : Boolean;„             Assembler;„  ASM„    MOV AL, 0       {set result to FALSE}„    MOV CL, bit„    MOV BX, 1„    SHL BX, CL      {BX contains 2-to-the-bit}„    JZ @TopWord     {if zero, use high word}„    TEST Word(L), BX„    JMP @Finish„    @TopWord:„    SUB CL, 16„    MOV BX, 1„    SHL BX, CL„    TEST Word(L+2), BX„    @Finish:„    JNZ @No„    INC AL          {set result to TRUE}„    @No:„  END;„END.„                                                                      38     11-21-9309:36ALL                      SWAG SUPPORT TEAM        HILO Bit Operators       IMPORT              12     û8î` UNIT HiLo;„(**) INTERFACE (**)„  FUNCTION SwapN(B : Byte) : Byte;„  FUNCTION HiN(B : Byte) : Byte;„  FUNCTION LoN(B : Byte) : Byte;„„  FUNCTION SwapW(L : LongInt) : LongInt;„  FUNCTION HiW(L : LongInt) : Word;„  FUNCTION LoW(L : LongInt) : Word;„„  FUNCTION WordFromB(H, L : Byte) : Word;„  FUNCTION LongFromW(H, L : Word) : LongInt;„„(**) IMPLEMENTATION (**)„  FUNCTION SwapN(B : Byte) : Byte; Assembler;„  ASM„    MOV AL, B         {byte in AL}„    MOV AH, AL        {now in AH too}„    MOV CL, 4         {set up to shift by 4}„    SHL AL, CL        {AL has low nibble -> high}„    SHR AH, CL        {AH has high nibble -> low}„    ADD AL, AH        {combine them}„  END;„„  FUNCTION HiN(B : Byte) : Byte; Assembler;„  ASM„    MOV AL, B„    MOV CL, 4„    SHR AL, CL„  END;„„  FUNCTION LoN(B : Byte) : Byte; Assembler;„  ASM„    MOV AL, B„    AND AL, 0Fh„  END;„„  FUNCTION SwapW(L : LongInt) : LongInt; Assembler;„  ASM„    MOV AX, Word(L+2)„    MOV DX, Word(L)„  END;„„  FUNCTION HiW(L : LongInt) : Word; Assembler;„  ASM„    MOV AX, Word(L+2)„  END;„„  FUNCTION LoW(L : LongInt) : Word; Assembler;„  ASM„    MOV AX, Word(L);„  END;„„  FUNCTION WordFromB(H, L : Byte) : Word; Assembler;„  ASM„    MOV AH, H„    MOV AL, L„  END;„„  FUNCTION LongFromW(H, L : Word) : LongInt; Assembler;„  ASM„    MOV DX, H„    MOV AX, L„  END;„END.                                                                           39     01-27-9411:56ALL                      DJ MURDOCH               Complex Numbers          IMPORT              11     û8  {„>A>overlooked. No Pascal compiler that I know of (including Turbo) can return„>A>a complex value (i.e., a record or an array) from a FUNCTION. In order for„>„>Hmm...never tried this before. Anyway, the sollution is quite simple:„>just have the megaword-variable public, and pass it to the procedure.„„Returning function values by setting a public variable is pretty dangerous -„what if your function calls another that uses the same public to return its„value?  In this case, it's not necessary, since there's a trick to let TP„return complex numbers:„}„„type„  Float = Double;„  TComplex = string[2*sizeof(float)];„  { Complex number.  Not a true string:  the values are stored in binary„    format within it. }„„  TCmplx = record   { The internal storage format for TComplex }„    len : byte;„    r,i : float;„  end;„„function Re(z:TComplex):float;„begin„  Re := TCmplx(z).r;„end;„„function Im(z:TComplex):float;„begin„  Im := TCmplx(z).i;„end;„„function Complex(x,y:float):TComplex;„{ Convert x + iy to complex number. }„var„  result : TCmplx;„begin„  with result do„  begin„    len := 2*sizeof(float);„    r := x;„    i := y;„  end;„  Complex := TComplex(result);„end;„„{You can use these to build up lots of functions returning TComplex types.}„                            40     01-27-9412:19ALL                      HARRY BAECKER            Random Numbers           IMPORT              7      û8ãU {„> I would also like some possible suggestions on a good random generator„> function or Procedure that is easy to understand.„}„„„{ Given }„„var Seed; {among your globals}„„{ You could try seeding it with: }„„Procedure Randomise;„„var„   hour, min, sec, sex100: word;„   root: Longint;„„begin„„   GetTime(hour,min,sec,sec100); {from Dos or WinDos unit}„   root := hour shr 1;„   root := root * sec * sec100;„   root := root shr 16;„   Seed := LoWord(root);   {needs WinAPI unit}„end;„„{And to get a "random" integer in the range 0 to N - 1: }„„function Random(Target: Integer): Integer;„„var„   work: Longint;„„begin„   work := Seed * Seed;„   work := work shr 16;„   Seed := LoWord(work);„   Random := Seed mod Target;„end;„„                                         41     02-05-9407:56ALL                      FRANK BITTERLICH         Setting BITS             IMPORT              7      û8   {„ >   This would seem like something simple but can„ > someone explain how to„ >   calculate what is included in the following„ > statement once I have read„ >   the variable:„Looks like a user record of some BBS system or so...„„Or did you want to know how to check / set the bits? }„„FUNCTION GetBit (v, BitNumber: BYTE): BOOLEAN;„   BEGIN„      IF (v AND (1 SHL BitNumber))<>0 THEN„         GetBit:=TRUE„      ELSE„         GetBit:=FALSE;„   END;     {Returns TRUE if specified bit is set }„„PROCEDURE SetBit (VAR v: Byte; BitNumber: Byte; SetReset: BOOLEAN);„   BEGIN„      IF SetReset THEN„         v:=v OR (1 SHL BitNumber)„      ELSE„         v:=v AND NOT (1 SHL BitNumber);„   END;„„                                                                            42     02-09-9407:25ALL                      DON PAULSEN              Setting Bit Flags in ASM IMPORT              64     û8   (*„Date:   02-05-95„From:   DON PAULSEN„„„        This unit provides routines to manipulate individual bits„        in memory, including test, set, clear, and toggle.  You may„        also count the number of bits set with NumFlagsSet, and get„        a "picture" of them with the function FlagString.„„        All the routines are in the interface section to provide„        complete low-level control of your own data space used for„        flags.  Usually the oFlags object will be most convenient.„        Just initialize the object with the number of flags required,„        and it will allocate sufficient memory on the heap and clear„        them to zero.„*)„„„UNIT DpFlags;„„{$A+,B-,D-,E-,F-,G-,I-,L-,N-,O-,R-,S-,V-,X-}„{$IFDEF VER70} {$P-,Q-,T-,Y-} {$ENDIF}„„(*„    File(s)         DPFLAGS.PAS„    Unit(s)         None„    Compiler        Turbo Pascal v6.0+„    Author          Don Paulsen„    v1.00 Date       7-01-92„    Last Change     11-12-93„    Version         1.11„*)„„{ Flags are numbered from left to right (low memory to high memory),„  starting with 0, to a maximum of 65520.  If the flags object isn't used,„  use the System.FillChar routine to set or clear all the flags at once.„  The memory for storing the flags can be allocated in the data segment„  or on the heap.„„  Here are two methods for declaring an array for the flags (not needed if„  the oFlags object is used):„„    CONST„       cMaxFlagNumber = 50;„       cNumberOfFlags = 51;„„    VAR„       flags_A : array [0..(cMaxFlagNumber div 8)] of byte;„       flags_B : array [0..(cNumberOfFlags - 1) div 8] of byte;„„  Note that since the first flag is flag 0, cNumberOfFlags is always 1 greater„  than cMaxFlagNumber. }„„„INTERFACE„„PROCEDURE SetFlag     (var flags; flagNum : word);„PROCEDURE ClearFlag   (var flags; flagNum : word);„PROCEDURE ToggleFlag  (var flags; flagNum : word);„FUNCTION  FlagIsSet   (var flags; flagNum : word): boolean;„FUNCTION  NumFlagsSet (var flags; numFlags: word): word;„FUNCTION  FlagString  (var flags; numFlags: word): string;„„TYPE„    tFlags = ^oFlags;„    oFlags = OBJECT„               CONSTRUCTOR Init (numberOfFlags: word);„               PROCEDURE   ClearAllFlags;„               PROCEDURE   SetAllFlags;„               PROCEDURE   SetFlag    (flagNum: word);„               PROCEDURE   ClearFlag  (flagNum: word);„               PROCEDURE   ToggleFlag (flagNum: word);„               FUNCTION    FlagIsSet  (flagNum: word): boolean;„               FUNCTION    NumFlagsSet : word;„               FUNCTION    FlagString  : string;„               DESTRUCTOR  Done;„             PRIVATE„                flags    : pointer;„                numFlags : word;„             END;„„„IMPLEMENTATION„„{=======================================================}„PROCEDURE SetFlag (var flags; flagNum: word); assembler;„„ASM„    les     di, flags„    mov     cx, flagNum„    mov     bx, cx„    shr     bx, 1„    shr     bx, 1„    shr     bx, 1„    and     cl, 7„    mov     al, 80h„    shr     al, cl„    or      es:[di][bx], al„END;„„{=========================================================}„PROCEDURE ClearFlag (var flags; flagNum: word); assembler;„„ASM„    les     di, flags„    mov     cx, flagNum„    mov     bx, cx„    shr     bx, 1„    shr     bx, 1„    shr     bx, 1„    and     cl, 7„    mov     al, 7Fh„    ror     al, cl„    and     es:[di][bx], al„END;„„{==========================================================}„PROCEDURE ToggleFlag (var flags; flagNum: word); assembler;„„ASM„    les     di, flags„    mov     cx, flagNum„    mov     bx, cx„    shr     bx, 1„    shr     bx, 1„    shr     bx, 1„    and     cl, 7„    mov     al, 80h„    shr     al, cl„    xor     es:[di][bx], al„END;„„{=================================================================}„FUNCTION FlagIsSet (var flags; flagNum: word): boolean; assembler;„„ASM„    les     di, flags„    mov     cx, flagNum„    mov     bx, cx„    shr     bx, 1„    shr     bx, 1„    shr     bx, 1„    and     cl, 7„    inc     cx„    mov     al, es:[di][bx]„    rol     al, cl„    and     al, 1„@done:„END;„„{=================================================================}„FUNCTION NumFlagsSet (var flags; numFlags: word): word; assembler;„„ASM„    push    ds„    cld„    lds     si, flags„    xor     bx, bx„    mov     cx, numFlags„    mov     dx, cx„    xor     di, di„    shr     cx, 1„    shr     cx, 1„    shr     cx, 1„    jcxz    @remainder„@byte8:„    lodsb„    shl     al, 1;  adc     bx, di„    shl     al, 1;  adc     bx, di„    shl     al, 1;  adc     bx, di„    shl     al, 1;  adc     bx, di„    shl     al, 1;  adc     bx, di„    shl     al, 1;  adc     bx, di„    shl     al, 1;  adc     bx, di„    shl     al, 1;  adc     bx, di„    loop    @byte8„@remainder:„    mov     cx, dx„    and     cx, 7„    jz      @done„    lodsb„@bit:„    shl     al, 1„    adc     bx, di„    loop    @bit„@done:„    mov     ax, bx„    pop     ds„END;„„{==================================================================}„FUNCTION FlagString (var flags; numFlags: word): string; assembler;„„{ Returns a string of 0's & 1's showing the flags.  Note that at most 255„  flags can shown in a string.  Returns nul if numFlags is 0 or greater„  than 255. }„„ASM„    push    ds„    cld„    lds     si, flags„    les     di, @result„    mov     cx, numflags„    or      ch, ch„    jz      @ok„    xor     cx, cx„@ok:„    mov     al, cl„    stosb                   { length of string }„    jcxz    @done„    mov     dx, cx„    push    dx              { save number of flags }„    mov     ah, '0'„    shr     dl, 1„    shr     dl, 1„    shr     dl, 1„    jz      @remainder„@byte8:                     { do 8 bits at a time }„    lodsb„    mov     bl, al„    mov     cl, 8„@bit8:„    mov     al, ah          { ah = '0' }„    shl     bl, 1„    adc     al, dh          { dh = 0 }„    stosb„    loop    @bit8„    dec     dl„    jnz     @byte8„„@remainder:                 { do remaining (numFlags mod 8) bits }„    pop     dx„    mov     cx, dx„    and     cl, 7           { 0 <= cx <= 7 (number of flags in partial byte) }„    jz      @done„    lodsb                   { last byte containing flags  }„    mov     bl, al„@bit:„    mov     al, ah          { ah = '0' }„    shl     bl, 1„    adc     al, dh          { dh = 0 }„    stosb„    loop    @bit„@done:„    pop     ds„END;„„{=============================================}„CONSTRUCTOR oFlags.Init (numberOfFlags: word);„„BEGIN„    if numberOfFlags > 65520 then FAIL;„    numFlags:= numberOfFlags;„    GetMem (flags, (numFlags + 7) div 8);„    if flags = nil then FAIL;„END;„„{==============================}„PROCEDURE oFlags.ClearAllFlags;„„BEGIN„    FillChar (flags^, (numFlags + 7) div 8, #0);„END;„„{============================}„PROCEDURE oFlags.SetAllFlags;„„BEGIN„    FillChar (flags^, (numFlags + 7) div 8, #1);„END;„„{========================================}„PROCEDURE oFlags.SetFlag (flagNum: word);„„BEGIN„    DpFlags.SetFlag (flags^, flagNum);„END;„„{==========================================}„PROCEDURE oFlags.ClearFlag (flagNum: word);„„BEGIN„    DpFlags.ClearFlag (flags^, flagNum);„END;„„{===========================================}„PROCEDURE oFlags.ToggleFlag (flagNum: word);„„BEGIN„    DpFlags.ToggleFlag (flags^, flagNum);„END;„„{==================================================}„FUNCTION oFlags.FlagIsSet (flagNum: word): boolean;„„BEGIN„    FlagIsSet:= DpFlags.FlagIsSet (flags^, flagNum);„END;„„{=================================}„FUNCTION oFlags.NumFlagsSet: word;„„BEGIN„    NumFlagsSet:= DpFlags.NumFlagsSet (flags^, numFlags);„END;„„{==================================}„FUNCTION oFlags.FlagString: string;„„VAR„    w : word;„„BEGIN„    w:= numFlags;„    if w > 255 then w:= 255;„    FlagString:= DpFlags.FlagString (flags^, w);„END;„„{======================}„DESTRUCTOR oFlags.Done;„„BEGIN„    if flags <> nil then FreeMem (flags, (numFlags + 7) div 8);„END;„„END.        { Unit DpFlags }„„                                                                                                                            43     02-09-9407:25ALL                      GAYLE DAVIS              Hex String to LONGINT    IMPORT              16     û8   „{  You've probably seen a lot of code to convert a number to HEX.„   Here is one that will take a hex String and covert it back to a number„„   The conversion is back to type LONGINT, so you can covert to WORDS or„   BYTES by simply declaring your whatever varible you want }„„{$V-}„USES CRT;„„VAR„    A   : LONGINT;„    B   : WORD;„    C   : BYTE;„    D   : WORD;„„{ ---------------------------------------------------------------------- }„„FUNCTION HexToLong(S : STRING) : LONGINT;„„    FUNCTION ANumBin (B : STRING) : LONGINT; Assembler;„    ASM„      LES DI, B„      XOR CH, CH„      MOV CL, ES : [DI]„      ADD DI, CX„      MOV AX, 0„      MOV DX, 0„      MOV BX, 1„      MOV SI, 0„      @LOOP :„        CMP BYTE PTR ES : [DI], '1'„        JNE @NotOne„          ADD AX, BX   {add power to accum}„          ADC DX, SI„        @NotOne :„        SHL SI, 1      {double power}„        SHL BX, 1„        ADC SI, 0„        DEC DI„      LOOP @LOOP„    END;„„CONST„  HexDigits : ARRAY [0..15] OF CHAR = '0123456789ABCDEF';„  Legal     : SET OF Char = ['$','0'..'9','A'..'F'];„  BinNibbles : ARRAY [0..15] OF ARRAY [0..3] OF CHAR = („    '0000', '0001', '0010', '0011',„    '0100', '0101', '0110', '0111',„    '1000', '1001', '1010', '1011',„    '1100', '1101', '1110', '1111');„„VAR I : BYTE;„    O : STRING;„„BEGIN„O := '';„HexToLong := 0;       { Returns zero if illegal characters found }„IF S = '' THEN EXIT;„FOR I := 1 TO LENGTH(S) DO„    BEGIN„    IF NOT (S[i] in LEGAL) THEN EXIT;„    O := O + binNibbles[PRED(POS(S[i],Hexdigits))];„    END;„HexToLong := ANumBin(O)„END;„„{ ---------------------------------------------------------------------- }„„BEGIN„ClrScr;„A   := HexToLong('$02F8');„B   := HexToLong('$0DFF');„C   := HexToLong('$00FF');   { The biggest byte there is !! }„D   := HexToLong('');   { this is ILLEGAL !! .. D will be ZERO }„WriteLn(A,' ',B,' ',C,' ',D);„END.                                      44     05-25-9408:00ALL                      MIKE ANTTILA             writing bits..           SWAG9405            8      û8   {„ MT>   Could someone please tell me how to write to/read from a particular„ MT>  bit in a number?  Do you have to break the number down into binary„ MT>  or is there some function somewhere that I haven't found yet?„„Here's some procs I wrote that should help you out:„}„„Procedure SetBit(Var Number : Byte; Bit : Byte);„ „ Begin„  Number := Number OR (1 SHL Bit);„ End;„ „Procedure ClearBit(Var Number : Byte; Bit : Byte);„ „ Begin„  Number := Number AND NOT (1 SHL Bit);„ End;„ „Function ReadBit(Number, Bit : Byte) : Boolean;„ „ Begin„  ReadBit := (Number AND (1 SHL Bit)) <> 0;„ End;„{„OK, provided you know binary, this should be pretty simple to implement.  The„bits are of course numbered 7-0.  SetBit sets a given bit to 1, ClearBit sets a„given bit to 0, and ReadBit returns TRUE if 1, FALSE if 0.  Anyway, hope that„helps...„„                                      PsychoMan.„}„       45     05-25-9408:08ALL                      VARIOUS                  Improved Decimal To BinarSWAG9405            7      û8   „{Convert a Decimal to a String - Maximum number of bits = 16}„„Function Dec2Bin (D: Word; No_Bits: Byte): String;„Var A   : Word;„    L   : Byte;„    S   : String;„Begin„   S := '';„   A := Trunc (Exp ((No_Bits-1)*Ln (2)));„   For L := No_Bits downto 1 do„   Begin„      A := A div 2;„      If (D AND A)=A then S := S+'1' else S := S+'0';„   End;„   Dec2Bin := S;„End;„„(*------------------------------------------------------*)„Function BinStr(num:word;bits:byte):string; assembler;„ASM„      PUSHF„      LES  DI, @Result„      XOR  CH, CH„      MOV  CL, bits„      MOV  ES:[DI], CL„      JCXZ @@3„      ADD  DI, CX„      MOV  BX, num„      STD„@@1:  MOV  AL, BL„      AND  AL, $01„      OR   AL, $30„      STOSB„      SHR  BX, 1„      LOOP @@1„@@3:  POPF„End;„„    46     05-25-9408:15ALL                      MAYNARD PHILBROOK        Reading on bit of an inteSWAG9405            10     û8   {„ SK> 12345 --------------- Longinteger of the value 12345„ SK> ^^^^^„ SK> |||||„ SK> ||||+----------------- Integer value 5„ SK> ||||„ SK> |||+------------------ Integer value 4„ SK> |||„ SK> ||+------------------- Integer value 3„ SK> ||„ SK> |+-------------------- Integer value 2„ SK> |„ SK> +--------------------- Integer value 1„„ SK> I tried using the procedure of geting the MOD of a number then div the„ SK> number out. It works fine until you get a number like„ SK> 10,100,1000,100000, etc....„ SK> Please help...„ not sure what your asking but have you  can use SHR, SHL, OR ect to fetch„ single bits..........„}„function getbitstate( bitpos:byte; lint:longint):boolean;„ begin„  asm„   mov @result, 00; { clear bolean first }„   cmp bitpos, 16„   jg  @higher;„   mov bx, lint;„@yup:„   test bx, bitpos;„   jnz @yes;„   jmp @done;„@higher:„   mov bx,lint+2;„   jmp @yup;„@yes:„   inc @result, 1;          { adjust bolean return }„@done:„  end;„end;„„_____ to use it ____„„Begin„ if getbitstate(8, $80) then Write(' Yup, it's on ');„end;„                                                                                                       47     05-25-9408:21ALL                      EDWIN GROOTHUIS          RIP                      SWAG9405            12     û8   {„ AE> numbersystem... When you want to create something in RIP you„ AE> first need to write some calculator to translate normal numbers„ AE> to RIP codes...„„It's not that difficult, you know how to convert hex -> normal and„normal -> hex? Well, then you also can convert mega -> normal and normal„-> mega„„little idea:„}„„function word2mega(w:word):string;„const    table:array[0..35] of char='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';„var      s:string;„begin„  s:='';„  while w>0 do„  begin„    s:=table[w mod 36]+s;„    w:=w div 36;„  end;„  while length(s)<4 do s:='0'+s;„  word2mega:=s;„end;„„function mega2word(s:string):word;„var      w:word;„begin„  w:=0;„  if length(s)<5 then„    while s<>'' do„    begin„      if s[1]>'9' then„        w:=w*36+ord(s[1])-ord('A')+10„      else„        w:=w*36+ord(s[1])-ord('0');„      delete(s,1,1);„    end;„  mega2word:=w;„end;„„„var    n:word;„        s:string;„begin„  s:=paramstr(1);„  for n:=1 to length(s) do„    s[n]:=upcase(s[n]);„  writeln('mega2word: ',mega2word(s));„  val(s,n,n);„  writeln('word2mega: ',word2mega(n));„end.„„converts a meganum to a word and a word to a meganum in one program!„(Just one program so I don't have to think in which way it has to be„converted)„„mega 12<cr> gives„mega2word: 38„word2mega: 0C„„mega 1C<cr> gives„mega2word: 48„word2mega: 00„„                                                                                   48     05-25-9408:21ALL                      JASON KING               RIP Mega Numbers         SWAG9405            14     û8   „{„You're right about that... The only thin why I found it difficult, is„because TP (or any other language) doesn't support the MenaNum itself..„Some other thing is that when you're creating a file, you need to use„two windows, and constantly convert the numbers... But for the source,„thanks, I'll look it over... Is it Ok with you when I place it in the„download of my BBS..? I havn't seen any DEC<>MEGA program yet...„„Try this...„}„„Function MegaToDec(Num: String) : LongInt; {Converts String MEGA to Dec}„Const MegaNum : Set of Char = ['0'..'9','A'..'Z']; {assume UC}„„Var HoldNum,„    TempVal : LongInt;„    CharPos : Byte; {Position of Character}„„    Function ToThirtySix(Ex: Byte) : Longint; {Raises to power of 36}„    Var Times: Byte;„        HoldPower: LongInt;„„    Begin„        HoldPower:=0;„        If Ex=0 then begin„           ToThirtySix:=1;„           End;„        For Times:=1 to Ex do HoldPower:=HoldPower*36;„        ToThirtySix:=HoldPower;„    End;„„   Function ConvertVal(Ch: Char) : Byte;„   Var Temp : Char;„   Begin„        Temp:=Ch;„        Upcase(Temp);„        If Ord(Ch)>47 and Ord(Ch)<58 then ConvertVal:=Ord(Ch)-48;„                {Converts if 0..9}„        If Ord(Ch)>64 and Ord(Ch)<91 then ConvertVal:=Ord(Ch)-55;„   End;„„   Begin„        HoldNum:=0;„        For CharPos:=Length(Num) downto 1 do„            HoldNum:=HoldNum+ConverVal(Num[CharPos])*„                ToThirtysix(CharPos-1);„        MegaToDec:=HoldNum;„   End;„„Note: this is untested, but it should work... try values of 10 Mega „(should by 36 dec) or 2Z (should be 107 dec I think)... Tell me how it„works...„                                                  49     05-26-9406:16ALL                      DAVID DUNSON             Binary and Hexidecimal   SWAG9405            16     û8   {„I've seen requests for these two procedures several times, and finally got„around to writing them in ASM.„„{ ------- CUT HERE ------- }„„(* Hex converts a number (num) to Hexadecimal.                      *)„(*    num  is the number to convert                                 *)„(*    nib  is the number of Hexadecimal digits to return            *)„(* Example: Hex(31, 4) returns '001F'                               *)„„Function Hex(num: Word; nib: Byte): String; Assembler;„ASM„      PUSHF„      LES  DI, @Result„      XOR  CH, CH„      MOV  CL, nib„      MOV  ES:[DI], CL„      JCXZ @@3„      ADD  DI, CX„      MOV  BX, num„      STD„@@1:  MOV  AL, BL„      AND  AL, $0F„      OR   AL, $30„      CMP  AL, $3A„      JB   @@2„      ADD  AL, $07„@@2:  STOSB„      SHR  BX, 1„      SHR  BX, 1„      SHR  BX, 1„      SHR  BX, 1„      LOOP @@1„@@3:  POPF„End;„„„(* Binary converts a number (num) to Binary.                        *)„(*    num  is the number to convert                                 *)„(*    bits is the number of Binary digits to return                 *)„(* Example: Binary(31, 16) returns '0000000000011111'               *)„„Function Binary(num: Word; bits: Byte): String; Assembler;„ASM„      PUSHF„      LES  DI, @Result„      XOR  CH, CH„      MOV  CL, bits„      MOV  ES:[DI], CL„      JCXZ @@3„      ADD  DI, CX„      MOV  BX, num„      STD„@@1:  MOV  AL, BL„      AND  AL, $01„      OR   AL, $30„      STOSB„      SHR  BX, 1„      LOOP @@1„@@3:  POPF„End;„„{ ------- CUT HERE ------- }„„These procedures are fully optomized to my knowledge and have been tested„against normal Pascal routines that perform the same functions.  Test results„returned that Hex performed aprox. 2.14 times faster than it's Pascal„equivilent, and Binary performed aprox. 14 times faster than it's Pascal„equivilent.„„Enjoy!„David„                                                                                   