SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00010         SCREEN SAVING ROUTINES                                            1      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE1.PAS                IMPORT              12          { ----------------------------------- 1 -------------------------------- }„{„> Does anyone know of an easy way to remember the current screen and„> then put back when a Program is finished?  What I mean is before the„> Program clears the screen or Writes to it or whatever, to store the„> current screen so that it can be restored to how it was before a Program„> is run?„„ Well you could try directly reading from memory and saving it into some kind„of buffer like this...„}„„Var Buffer : Array[1..4000] of Byte;„„Procedure Save_Screen;„begin„  Move(Mem[$B800:0000],Buffer,4000);„end;„„Procedure Restore_Screen;„begin„  Move(Buffer,Mem[$B800:0000],4000);„end;„„{„You must save the screen in a 4K Array and then put it back when„the Program is done.„}„„„„{ ----------------------------------- 2 -------------------------------- }„Type„   AScreen = Array[1..4000] of Byte;„Var„   P : ^AScreen;    {Pointer to the Array}„   Scr : AScreen;„„Procedure SaveScreen;„begin„  P := Ptr($B800,$0); {Point to video memory}„  Move(P^,Scr,4000);  {Move the screen into the Array}„end;  {Run this proc at the beginning of the Program}„„Procedure RestoreScreen;„begin„  Move(Scr,MEm[$B800 : 0], 4000); {Move the saved screen to video mem}„end; {Call this at the end of your Program}„„{„This should do the job of saving the original screen and then restoring it when„your Program is done„}„                                  2      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE2.PAS                IMPORT              17          {„> Does anyone know of an easy way to remember the current„> screen and then put it back when a Program is finished?„„Here's one way to do it:„}„„Program SaveScr;„„Uses„  Crt, Dos;„„Const„  vidseg : Word = $B800;„  ismono : Boolean = False;„„Type„  Windowrec = Array [0..4003] of„  Byte;„„Var„  NewWindow : Windowrec;„  c : Char;„„Procedure checkvidseg;„begin„  if (mem [$0000 : $0449] = 7) then„     vidseg := $B000„  else„     vidseg := $B800;„  ismono := (vidseg = $B000);„end;„„Procedure savescreen (Var wind : Windowrec;„  TLX, TLY, BRX, BRY : Integer);„Var x, y, i : Integer;„begin„  checkvidseg;„  wind [4000] := TLX;„  wind [4001] := TLY;„  wind [4002] := BRX;„  wind [4003] := BRY;„  i := 0;„  For y := TLY to BRY Do„    For x := TLX to BRX Do„    begin„      InLine ($FA);„      wind [i] := mem [vidseg : (160 * (y - 1) + 2 * (x - 1) ) ];„      wind [i + 1] := mem [vidseg : (160 * (y - 1) + 2 * (x - 1) ) + 1];„      InLine ($FB);„      Inc (i, 2);„    end;„end;„„Procedure setWindow (Var wind : Windowrec; TLX, TLY, BRX, BRY : Integer);„Var„  i : Integer;„begin„  savescreen (wind, TLX, TLY, BRX, BRY);„  Window (TLX, TLY, BRX, BRY);„  ClrScr;„end;„„Procedure removeWindow (wind : Windowrec);„Var TLX, TLY, BRX, BRY, x, y, i : Integer;„begin„  checkvidseg;„  Window (1, 1, 80, 25);„  TLX := wind [4000];„  TLY := wind [4001];„  BRX := wind [4002];„  BRY := wind [4003];„  i := 0;„  For y := TLY to BRY Do„    For x := TLX to BRX Do„    begin„      InLine ($FA);„      mem [vidseg : (160 * (y - 1) + 2 * (x - 1) ) ] := wind [i];„      mem [vidseg : (160 * (y - 1) + 2 * (x - 1) ) + 1] := wind [i + 1];„      InLine ($FB);„      Inc (i, 2);„    end;„end;„„begin„  TextColor(Yellow);„  GotoXY(1,24);„  Write('Press A Key to Save and Clear Screen...');„  ReadKey;„  setWindow (NewWindow, 1, 1, 80, 25);„  GotoXY(1, 12);„  Write ('Press a key to restore original screen...');„  ReadKey;„  removeWindow (NewWindow);„  GotoXY (1, 24);„  Write('Restored!!!');„  ReadKey;„end.„                                                                   3      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE3.PAS                IMPORT              10          >---------< How to save/restore the whole screen >----------„{$X+}„Uses Crt;„„Type PScreenBuf = ^TScreenBuf;„     TScreenBuf = Array [1..2000] of Word;„„Var ScreenBuf: PScreenBuf;   { Pointer to actual video ram }„    Scr:       TScreenBuf;   { buffer For screen storage   }„    VideoPort: Word Absolute 0:$463;  { the video port adr }„    i:         Byte;         { :-) you'll always find it   }„                             { in Programs like this :-)   }„begin„  if VideoPort = $3D4 then„    ScreenBuf := Ptr ($B800,0)        { oh, it's color :-) }„  else„    ScreenBuf := Ptr ($B000,0);          { oh no, mono :-( }„„  Scr := ScreenBuf^;                   {*** SAVE SCREEN ***}„„  if ReadKey=#0 then ReadKey;           { wait For any key }„  For i:=1 to 60 do„    Writeln ('Hello guys out there...');  { DESTROY SCREEN }„  if ReadKey=#0 then ReadKey;           { wait For any key }„„  ScreenBuf^ := Scr;                {*** REStoRE SCREEN ***}„„  if ReadKey=#0 then ReadKey;           { wait For any key }„end.„>-----------------< Yes! Even tested! >---------------------„                                                                            4      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE4.PAS                IMPORT              15          {„I couldn't find your original message, but you could use this code fragment to„save and restore a Text-mode screen.„}„„(* global Vars *)„Var„   vidSeg : Word;„   oldScr : Array[0..3999] of Byte;„„Function GetVidSeg : Word;„Var„   mode : Byte;„   seg  : Word;„begin„     seg := 0;„     mode := Mem[0 : $449];„     if (mode = 7) then seg := $B000;„     if (mode <= 3) then seg := $B800;„     if (mode in [4..6]) or (mode > 7) then begin„        (* the Program is not in the correct Text mode *)„        Halt(1);  (* return errorlevel of 1 *)„     end;„     GetVidSeg := seg;„end;„„(* main Program *)„begin„     vidSeg := GetVidSeg;„     Move(Mem[vidSeg : 0], oldScr[0], SizeOf(oldScr));„     (* the above line copies 4000 Bytes starting at $B000 : 0 For mono.„        or $B800 For colour into the Array 'oldScr' *)„     ClrScr;„     WriteLn('Press ENTER to restore the screen...');„     Readln;„     Move(oldScr[0], Mem[vidSeg : 0], SizeOf(oldScr));„     (* the above line copies the Array to video memory to restore the„        old screen *)„end.„„{„As you can see, video memory starts at offset 0 of either of two segments.  If„the computer is colour, Text screen memory starts at $B800 : 0000 and if the„computer is mono/herc, it starts at $B000 : 0000.  It is 4000 Bytes long.  Why?„ Because there are 2000 Characters on the screen (80 x 25), and each Character„gets a colour attribute (foreground, background, (non)blinking).  The top-left„Character, at row 1, column 1, is [vidSeg] : 0, and the next Byte,[vidSeg] : 1,„is the attribute For the Character, so the memory is laid out like this:„„(offset 0) Char, attr, Char, attr, Char, attr.......Char, attr (offset 3999)„}                                                                                                                   5      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE5.PAS                IMPORT              17          {„>show some help Text or something, and then make it disappear„>without erasing the Text that the Window overlapped.  In other„>Words, there will be a screen full of Text, the Window would open„>up over some Text display whatever message, and disappear, leaving„„The Text you see displayed on the screen can be captured to a Variable„and subsequently restored through direct screen reads/Writes.  Video„memory is located (on most systems) at $B800 For color and $B000 on„monochrome adapters.  Each screen location consists of two Bytes: 1) the„Foreground/background color of the location, and 2) the Character at the„location.„„The following Program Writes a screen full of 'Text', captures this„screen to a Variable (VidScreen), Writes over top of the current screen,„then restores original screen stored in VidScreen.„}„Program OverLap;„Uses Crt;„„Const„  VidSeg = $B800;     {..$B000 For monochrome}„„Type„  VidArray = Array[1..2000] of Word;„„Var„  VidScreen : VidArray;„  x : Integer;„„„Procedure SetScreenColor(back,Fore : Integer);„begin„  TextBackGround(back);„  TextColor(Fore);„end;„„„begin„  SetScreenColor(4,2);                   {.. green on red }„  ClrScr;„  For x := 1 to 25 do„    begin                                {..Write original screen }„    GotoXY(1,x);„    Write('Text Text Text Text Text Text Text Text Text Text Text '+„           'Text Text Text Text Text');„    end;„  readln;                                {..press enter to cont. }„„  For x := 1 to 2000 do                  {..store current screen in }„    VidScreen[x] := MemW[VidSeg:x];      {  VidScreen Array }„„  SetScreenColor(7,0);                   {..black on white }„  GotoXY(38,11);„  WriteLn('HELP');                       {..Write help Text, or }„  GotoXY(38,12);                         {  whatever... }„  WriteLn('HELP');„  GotoXY(38,13);„  WriteLn('HELP');„  readln;                                {..press enter to cont. }„„  For x := 1 to 2000 do                  {..restore VidScreen Array }„    MemW[VidSeg:x] := VidScreen[x];„  readln;„end.„    6      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE6.PAS                IMPORT              11          {„> I need to be able to create a screen then load it into Video Memory.„> Then load it on to the screen... Does anyone have any routines to do„> this??? Thanks...„„      Try the following codes„}„Program VidRAMStuff;„Uses„  Crt;„Const„  ScreenHeight = 25;„  ScreenWidth = 80;„Type„  OneChar = Record„    Character : Char;„    Attribute : Byte;„    end;„  RAMBuffer = Array [1..ScreenHeight, 1..ScreenWidth] of OneChar;„  RAMBufPtr = ^RAMBuffer;„Var„  RowLoop, ColLoop : Byte;„  DataFile : Text;„  VideoRAM : RAMBufPtr;„„begin„  If (LastMode = 7) { means that the system is monochrome }„    Then„      VideoRAM := Ptr ($B000, $0000) { Segment:Offset address }„    Else„      VideoRAM := Ptr ($B800, $0000);„  Assign (DataFile, 'TESTING.TXT');„  ReWrite (DataFile);„  For RowLoop := 1 to ScreenHeight Do„    begin„      For ColLoop := 1 to ScreenWidth Do„        Write (DataFile, VideoRAM^ [RowLoop, ColLoop].Character);„      WriteLn (DataFile);„    end;„  Close (DataFile);„  {************************ File Saved *****************************}„  {* Just add your own code to read in the data File and loaded it *}„  {* back to the screen and you're all set!                        *}„  {*****************************************************************}„end.„„                   7      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE7.PAS                IMPORT              5           {„well.. if you don't mind it not being in assembly, i can help..„BTW: your 19?? Byte Array wouldn't store the whole screen.. barely half of„it. the color Text screen is 4000 Bytes. 2000 Characters + 2000 attributes„of those Characters.„}„Type„  screen = Array[1..4000] of Byte;„Var„  scr : screen Absolute $b800:0000; (* or $B000:0000 For Mono *)„  scrf : File of screen;„begin„  assign(scrf,paramstr(1)); (* or Whatever Filename *)„  reWrite(scrf);„  Write(scrf,scr);„  close(scrf);„end.„„                     8      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE8.PAS                IMPORT              18          {> Basically all I'm asking For are SaveScreen and„> RestoreScreen Procedures. Procedures capable of just„> partial screen saves and restores would be even better,„> but anything will do!  :-)„}„Program SaveScr;„„Uses„  Crt,„  Dos;„„Const„  vidseg : Word = $B800;„  ismono : Boolean = False;„„Type„  Windowrec = Array [0..4003] Of„  Byte;„„Var„  NewWindow : Windowrec;„  c : Char;„„Procedure checkvidseg;„begin„  If (mem [$0000 : $0449] = 7) Then„     vidseg := $B000„  Else„     vidseg := $B800;„  ismono := (vidseg = $B000);„end;„„Procedure savescreen (Var wind : Windowrec;„  TLX, TLY, BRX, BRY : Integer);„Var x, y, i : Integer;„begin„  checkvidseg;„  wind [4000] := TLX;„  wind [4001] := TLY;„  wind [4002] := BRX;„  wind [4003] := BRY;„  i := 0;„  For y := TLY To BRY Do„      For x := TLX To BRX Do„          begin„          InLine ($FA);„          wind [i] := mem [vidseg : (160 * (y - 1) + 2 * (x - 1) ) ];„          wind [i + 1] := mem [vidseg : (160 * (y - 1) + 2 * (x - 1) ) + 1];„          InLine ($FB);„          Inc (i, 2);„          end;„end;„„Procedure setWindow (Var wind : Windowrec;„  TLX, TLY, BRX, BRY : Integer);„Var i : Integer;„begin„  savescreen (wind, TLX, TLY, BRX, BRY);„  Window (TLX, TLY, BRX, BRY);„  ClrScr;„end;„„Procedure removeWindow (wind : Windowrec);„Var TLX, TLY, BRX, BRY, x, y, i : Integer;„begin„  checkvidseg;„  Window (1, 1, 80, 25);„  TLX := wind [4000];„  TLY := wind [4001];„  BRX := wind [4002];„  BRY := wind [4003];„  i := 0;„  For y := TLY To BRY Do„      For x := TLX To BRX Do„          begin„          InLine ($FA);„          mem [vidseg : (160 * (y - 1) + 2 * (x - 1) ) ] := wind [i];„          mem [vidseg : (160 * (y - 1) + 2 * (x - 1) ) + 1] := wind [i + 1];„          InLine ($FB);„          Inc (i, 2);„          end;„end;„„begin„  setWindow (NewWindow, 1, 1, 80, 25);„  GotoXY(1, 12);„  Write ('Press a key to restore original screen...');„  Repeat„  Until KeyPressed;„  c := ReadKey;„  removeWindow (NewWindow);„  GotoXY (1, 24);„end.„„{„You can set the size of the Window to whatever you want, and save/restore as„many Windows as you have memory available.„}                                                      9      05-28-9313:56ALL                      SWAG SUPPORT TEAM        SAVE9.PAS                IMPORT              27          {„> Basically all I'm asking For are SaveScreen and RestoreScreen Procedures.„> Procedures capable of just partial screen saves and restores would be„> even better, but anything will do!  :-)„}„„Unit ScrUnit;„„Interface„„Const„  MaxPages  = 20;„Type„  PageType  = Array [1..50,1..80] Of Word;„  PageArray = Array [1..MaxPages] Of ^PageType;„Var„  Screen    : ^PageType;„  ScrPages  : PageArray;„  PageInMem : Array [1..MaxPages] Of Boolean;„  VideoMode : ^Byte;„  UseDisk   : Boolean;„„Procedure InitPages(Pages : Byte);„Procedure DeInitPages;„Procedure StoreScreen(Page : Byte);„Procedure RestoreScreen(Page : Byte);„„Implementation„{$IFNDEF VER70}„Const Seg0040      = $0040;„      SegB000      = $B000;„      SegB800      = $B800;„{$endIF}„„Var„  MPages       : Byte;„  SaveExitProc : Pointer;„„Function FStr(Num : LongInt) : String;„Var Dummy : String;„begin„  Str(Num,Dummy);„  FStr := Dummy;„end;„„Procedure InitPages;„Var„  Loop : Byte;„begin„  If Pages>MaxPages Then„    Pages := MaxPages;„  For Loop:=1 To Pages Do„  If (MaxAvail>=SizeOf(PageType)) And (Not UseDisk) Then„  begin„    PageInMem[Loop] := True;„    GetMem(ScrPages[Loop],SizeOf(PageType));„  end„  Else„  begin„    PageInMem[Loop] := False;„    ScrPages[Loop]  := NIL;„  end;„  MPages := Pages;„end;„„Procedure DeInitPages;„Var Loop : Byte;„begin„  If MPages>0 Then„    For Loop:=MPages DownTo 1 Do„      If PageInMem[Loop] Then„      begin„        Release(ScrPages[Loop]);„        PageInMem[Loop] := False;„      end;„  MPages := 0;„end;„„Procedure StoreScreen;„Var„  F : File Of PageType;„begin„  If Page<=MPages Then„  begin„    If PageInMem[Page] Then„      Move(Screen^,ScrPages[Page]^,SizeOf(PageType))„    Else„    begin„      Assign(F,'SCR'+FStr(Page)+'.$$$');„      ReWrite(F);„      If IOResult=0 Then„      begin„        Write(F,Screen^);„        Close(F);„      end;„    end;„  end;„end;„„Procedure RestoreScreen;„Var„  F : File Of PageType;„begin„  If Page<=MPages Then„  begin„    If PageInMem[Page] Then„      Move(ScrPages[Page]^,Screen^,SizeOf(PageType))„    Else„    begin„      Assign(F,'SCR'+FStr(Page)+'.$$$');„      Reset(F);„      If IOResult=0 Then„      begin„        Read(F,Screen^);„        Close(F);„      end;„    end;„  end;„end;„„{$F+}„Procedure ScreenExitProc;„Var„  Loop : Byte;„  F    : File;„begin„  ExitProc := SaveExitProc;„  If MPages>0 Then„    For Loop:=1 To MPages Do„    begin„      Assign(F,'SCR'+FStr(Loop)+'.$$$');„      Erase(F);„      If IOResult<>0 Then;„    end;„end;„{$F-}„„begin„  VideoMode := Ptr(Seg0040,$0049);„  If VideoMode^=7 Then„    Screen := Ptr(SegB000,$0000)„  Else„    Screen := Ptr(SegB800,$0000);„  MPages := 0;„  UseDisk := False;„  SaveExitProc := ExitProc;„  ExitProc := @ScreenExitProc;„end.„„(*„This simple Unit is able to store up to 20 screens. If there is enough free„heap all screens are stored to heap which is Really fast. If there is not„enough free heap or UseDisk=True all screens are stored virtually to disk. This„method isn't very fast, of course, but it helps you to save heap.„„Use this Unit as follows:„„Program ThisIsMyProgram;„Uses Screen;„begin„  InitPages(5);        { initialize 5 pages }„  {...}                { this is on you }„end.„*)„                                                                                                                              10     08-27-9321:54ALL                      SEAN PALMER              Graphic Screen Capture   IMPORT              13     R   {„> Does anyone have any code that will go tsr and dump the pixel colors in a„> 320.256. whatever that mode is into a Text File in the format 200,5,0,0,0,4,„> etc?  just list every pixel followed by a comma?„„The TSR part would be the hard part, the writing the screen to a File„would be easy.„„I wrote this little prog just now, not incredibly great but might„actually work and probably will do the job...„„Be careful as it doesn't check For Dos reentrancy and you might hang„your computer if you try to capture a screen While Dos is doing„something else...„„by Sean Palmer,„public domain„}„„Program capture;„Uses„  Dos;„„Procedure WriteScrn2File;„Var„  f    : Text;„  x, y : Word;„begin„  assign(f,'CAPTURE.SCR');„  reWrite(f);„  For y := 0 to 199 do„    For x := 0 to 319 do„    begin„      Write(f, mem[$A000 : y * 320 + x], ',');„      if x mod 20 = 0 then„        Writeln(f);  {new line every 20 pixels}„    end;„  close(f);„end;„„Var„  oldIntVec : Procedure;„„{you need to put a Real check For Dos activity here}„„Function DosActive : Boolean;„begin„  DosActive := False;„end; {assume no and keep fingers crossed! 8)}„„Procedure keyHandler; interrupt;„begin„  if port[$60] = 114 then     {if print-screen pressed}„    if not DosActive then {better not press While Dos is doing something}„      WriteScrn2File;„  oldIntVec;  {call old handler}„end;„„begin„  getIntVec(9, @oldIntVec);„  setIntVec(9, @newIntVec);„  keep(0);  {go TSR}„end.„                                                                                           