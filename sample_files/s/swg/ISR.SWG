SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00008         ISR HANDLING ROUTINES                                             1      05-28-9313:49ALL                      SWAG SUPPORT TEAM        CLOCK.PAS                IMPORT              21          {$M 2000, 0, 0}                         {  When writing TSR's you have to   }„Program Clock;                          {  use the $M directive             }„Uses Dos;„„ Var„   oldint: Procedure;„„Procedure Write2scr (s: String; color, x, y: Byte);„ Var„   counter1,„   counter2: Byte;„ begin                                             { In TSR's you always }„    counter1 := 2 * (x + y * 80);                  { need to use direct  }„    For counter2 := 1 to ord(s[0]) do              { screen Writes.      }„     begin                                         {                     }„      mem [$b800: counter1] := ord(s[counter2]);„      inc (counter1);„      mem [$b800: counter1] := color;„      inc (counter1);„     end;  {do}„„ end;      {Write2SCR}„„{$F+}                   { All Procedures will now be Far Procedures }„„Procedure int_Hook; interrupt;„Var„   hour,                { Where the Hour will be stored }„   min: Word;           { "  "  " " minute "          " }„   hS,                  { Where STR Hour will be stored }„   MS: String[2];       {       STR Min                 }„begin„     hour := memW[$0000:$046e];„     min := (memW[$0000:$046c] div 18) div 60;„„{ The above 2 lines of code give the hour & minute.. How?? The first„  memory location gives the hour thats easy, but the minutes are a„  little more tricky... The interrupt i'm gonna hook into is int 8„  ... it is called approximately 18.2 times/second. When its called,„  it increments 0000:046c hex. When it overflows, it inc's 0000:046e„  (which is the hour in 24 hr Format) so, dividing by 18 would give„  us the approximate second in the hour, div'ding by 60 then gives„  the hour                                                              }„„     if hour > 12 then dec(hour, 12);           { Converts from 24 hr Format }„     str(min, MS);„     str(hour, HS);„     Write2scr (HS, 9, 77 - ord(hs[0]), 0);     { Writes to screen }„     Write2scr (MS, 12, 78, 0);„     Write2scr (':',10, 77, 0);„     Inline ($9c);                              { Push the flags ( you have }„     oldint;                                    { to do this beFore any int }„                                                { call like this            }„end;   {inT_HOOK}„„{$F-}                                           { No more Far Procedures }„„begin„  getintvec (8, @oldint);                       { Hooks the interrupt }„  setintvec (8, addr(int_hook));„  keep (0);                                     { Makes it stay resident }„end.„„                                                         2      05-28-9313:49ALL                      SWAG SUPPORT TEAM        DELAYHK.PAS              IMPORT              10          {„REYNIR STEFANSSON„„> I need a Procedure in the form of:„> Type DelayHook = Function : Boolean;„> Procedure DelayIt(S : Word; Hook : DelayHook);„„> What it needs to do is keep calling the hook Function Until it returns„> True or the number of 1/100th's of seconds, S, is up.„„> Any ideas?  I know how to call the Hook Function, but I am concerned With„> how to go about keeping up With the time Without using the Crt.Delay„> Procedure. I am using this to play a tune (with Sound and NoSound) through„> the speaker and quit when the user presses a key.  The tune is read from„> a Text File of unknown length.  HELP!„„{ More or less outta my head... }„„Uses„  Dos;„„Type„  Reg       : Registers;„  DelayHook : Function : Boolean;„„{„   This proc Uses the AT BIOS' Wait Function: INT 15h, FUNC 86h. It's„   called With a LongInt in CX:DX. Its resolution is ca. 1 microsecond.„}„„Procedure DelayIt(S : Word; Hook : DelayHook);„Var„  dly : LongInt;„  bdy : Boolean;„begin„  Repeat„    Reg.AH := $86;„    Reg.CX := 0;„    Reg.DX := 10000; { Wait 0.01 sec. }„    Intr($15, Reg);„  Until Hook;„end;„                                                            3      05-28-9313:49ALL                      SWAG SUPPORT TEAM        ISRDEMO.PAS              IMPORT              23          {„It can make sense to Write Method-ISR's. Two examples:„„1. Implementation of a timer-IRQ-triggered eventQueue (a body of such an„Object I append to this mail).„„2. Objects For serial-IO. You can have up to 8 or 16 serial channels (with„special hardware). The priciples of encapsulation and instances suggests„an OOPS-solution! Why not including the ISR-Routine into the Object?„I'm not happy about the intentional misunderstandings to your request„in this area :-|„„However, the next 2K are my act of revenge to your repliers: :-D„(Gentlemen: No flames please, I know that the demo itself makes no sense„and procedural Programming For such a simple output would be easier„and shorter!!! All I want to show, is a toRSO of an OOPS-solution For ISR's.)„}„„Program isrDemo;„{$F+,S-}„Uses„    Crt,Dos;„Type„    timerObj  =    Object„                        saveInt,„                        myjob     :    Pointer;„                        stopped   :    Boolean;„                        Constructor Init(job:Pointer);„                        Destructor  DeInit;„                        PRIVATE„                        Procedure   timerInt;„                   end;„Const„    timerSelf :    Pointer   =    NIL;„„Constructor timerObj.Init(job:Pointer);„begin„    if timerSelf<>NIL then FAIL;            { only one instance in this demo }„    timerSelf:=@self;„    myjob:=job;„    stopped:=False;„    getintvec($1C,saveInt);„    setintvec($1C,@timerObj.timerInt);„end;„„Destructor timerObj.DeInit;„begin„    setintvec($1C,saveint); timerSelf:=NIL;„end;„„Procedure timerObj.timerInt; Assembler;„Label„    _10;„Asm„    pop  bp                           { Compiler inserts PUSH BP - restore it }„    push ax„    push bx„    push cx„    push dx„    push si„    push di„    push ds„    push es„    push bp„    mov  al,20h                        { send EOI }„    out  20h,al„    sti„„    mov  bp,sp„    mov  ax,SEG @DATA„    mov  ds,ax„    les  di,[offset timerSelf]         { only one instance in this demo! }„    cmp  es:[di+stopped],0             { prevents IRQ-overruns           }„    jne  _10„    inc  es:[di+stopped]„    call dWord ptr es:[di+offset myjob]; { no test of NIL implemented    }„    les  di,[offset timerSelf]„    dec  es:[di+stopped]„„   _10:„    call dWord ptr es:[di+saveInt]     { call original inT-Proc }„    mov  sp,bp„    pop  bp„    pop  es„    pop  ds„    pop  di„    pop  si„    pop  dx„    pop  cx„    pop  bx„    pop  ax„    iret„end;„(*********************** DemoShell **************************)„Var„    timer     :    timerObj;„„Procedure helloHerb;„begin„    Write('.');„end;„„begin„    if timer.Init(@helloHerb) then„    begin„         Delay(5000);„         timer.DeInit;„    end;„end.„„                                                                                                          4      05-28-9313:49ALL                      SWAG SUPPORT TEAM        ISRDEMO1.PAS             IMPORT              12          {„≥- Also, is there anyway of making "HOT-KEYS" without using ReadKey f≥„≥  CharS?  I want it For Integers or can I have CharS as a RANdoM #? ≥„≥  PROBLEMO!                                                         ≥„„> Unless you want to Write an ISR (initiate and stay resident) routine   ≥„> that traps keyboard interrupts and either preprocesses them or passes  ≥„> them on to your routine, ReadKey is the only way. (Writing an ISR      ≥„> is not a simple task.)                                                 ≥„„Actualy it is not that difficult in pascal:„}„Uses„  Dos;„„Const„  end_eks : Boolean = False;„„Var„  IntVec  : Pointer;„„Procedure Keybd; Interrupt;„Var„  Key : Byte;„begin„  Asm„    cli„  end;„  Key := Port[$60];„„  Case Key of„    1   : end_eks := True;„    57  : Writeln(' You have pressed Space');„    75  : Writeln(' Left Arrow');„    77  : Writeln(' Right Arrow');„    203,„    205 : Writeln(' You have released an Arrow key');„  end;„„  if not end_eks then„  Asm„    mov ah,0ch„    int 21h„    call IntVec  { Call original int 9 handler }„  end;„  { port[$20]:=$20} { if you dont call the original handler„                      you need to uncomment this }„end;„„begin„  GetIntVec($09,Intvec);„  SetIntVec($09,@Keybd);„  Writeln(' Press <ESC> to end Program ');„„  Repeat Until end_eks;„„  SetIntVec($09,IntVec);„„  Writeln(' Program terminatet');„„end.                               5      05-28-9313:49ALL                      SWAG SUPPORT TEAM        ISRINFO.PAS              IMPORT              17          { What is an ISR?? Are there several things you have to know to create„ one in Pascal?? Thanks.„„        ISR stands For interrupt service routine (I think; Hey, I„        just remember the abbriveation) :) But what it does is„        changes an interrupt vector to the address of a routine„        of yours then, your routine calls the actual interrupt code.„„        In the next message, I'll post some heavily commented code„        that is a time TSR, But what is a TSR? Just a resident„        ISR. (By the way, The TSR screws up Blue Wave when resident)„„        ---=== Extremely simplified version of how an ISR works ===---„„        Assuming you know what an interrupt is (You called it a hardware„        command) ... When you call an interrupt (TP: Intr, Asm: int) the„        CPU stops what its doing and calls up a routine at a certain„        memory address (Which is called the interrupt's vector). You„        can get the address of the routine by using GETinTVEC. Now„        if you have this code„}„          Uses Dos;„          Var„             the_inTERRUPT: Procedure;„          begin„             getintvec (--Interrupt num--, @the_inTERRUPT);„          end.„{„        it will store the vector of the interrupt into @the_interrupt„        (if you dont know what a Pointer is, go back to the manual and„        read the section on them)„        So, Everytime you call the_inTERRUPT it will actually call what„        ever interrupt you made the_interrupt point to. on the same„        note SETinTVEC (--int num--, @your_Routine) will set it where„        when ever you call that interrupt it will execute your routine.„„        What the ISR does is gets the vector of the interrupt you„        want to 'Latch' onto, puts it into a Procedure (As shown„        above) then, Uses SETinTVEC to set the ISR routine inside„        that interrupt. The ISR routine then calls the Procedure„        that points to the old interrupt.„}                                                                                                        6      05-28-9313:49ALL                      SWAG SUPPORT TEAM        MYCHECK.PAS              IMPORT              31          {$ifDEF VER70}„{$A+,B-,D+,E-,F-,G+,I-,L+,N-,O-,P-,Q-,R-,S+,T-,V-,X+}„{$else}„{$A+,B-,D-,E-,F-,G+,I-,L-,N-,O-,R-,S+,V-,X-}„{$endif}„{$DEFinE COLor}„Unit MyCheck;„{„  Version: 2.0 (8 jan 1993).„„             TeeCee     Bob Swart  Saved:„  Code size: 514 Bytes  472 Bytes  42 Bytes„  Data size:  32 Bytes   32 Bytes   0 Bytes„„  Here is the $1C ISR that I will add (unless you wish to do that).„„  Some changes were made, which resulted in less code and data size, a„  little more speed, and display of the progress Variable on screen is„  made 'ticking' each second by changing the colour from white on blue„  to gray on blue and back With each update.„  Also, the Variable Test8086 is set to 0 when the ISR in entered, and„  reset to the value Save8086 (initialized at startup) on Exit. Hereby„  we elimiate potential BTP7 problems With using LongInts in ISRs, and„  not saving Extended Registers properly.„}„Interface„„Var progress: LongInt Absolute $0040:$00F0;„„Implementation„{ Everything is private to this Unit }„Uses Dos;„„Const„  Line      = 0;    { Change as required For position of display on screen }„  Column    = 72;                                 { top left corner is 0,0 }„  ScreenPos = (line * 80 * 2) + (column * 2);„  Colour: Byte = $1F;                                 { White/Gray on Blue }„„Type„  TimeStr = Array[0..15] of Char;„  TimePtr = ^TimeStr;„„Var„  {$ifDEF COLor}„  Time: TimeStr Absolute $B800:ScreenPos;  { Assume colour display adaptor }„  {$else}„  Time: TimeStr Absolute $B000:ScreenPos; { otherwise mono display adaptor }„  {$endif}„  OldInt1C: Pointer;„  ExitSave: Pointer;„  Save8086: Byte;„„„{$F+}„Procedure Int1CISR; Interrupt;„{ This will be called every clock tick by hardware interrupt $08 }„Const DisplayTickCount = 20;„      TickCount: LongInt = DisplayTickCount;„      HexChars: Array[$0..$F] of Char = '0123456789ABCDEF';„Var HexA: Array[0..3] of Byte Absolute progress;„begin„  {$ifDEF VER70}„  Test8086 := 0;„  {$endif}„  Asm„    cli„  end;„  inc(TickCount);„  if TickCount > DisplayTickCount then { ticks to update the display }„  begin„    TickCount := 0;        { equality check and assignment faster than mod }„            { The following statements actually display the on-screen time }„    Colour := Colour xor $08;        { Swap between white and gray on blue }„    FillChar(Time[1],Sizeof(Time)-1,Colour);„    Time[00] := HexChars[HexA[3] SHR 4];„    Time[02] := HexChars[HexA[3] and $F];„    Time[04] := HexChars[HexA[2] SHR 4];„    Time[06] := HexChars[HexA[2] and $F];„    Time[08] := HexChars[HexA[1] SHR 4];„    Time[10] := HexChars[HexA[1] and $F];„    Time[12] := HexChars[HexA[0] SHR 4];„    Time[14] := HexChars[HexA[0] and $F]„  end { if TickCount > DisplayTickCount };„  Asm„    sti„    pushf                                  { push flags to set up For IRET }„    call  OldInt1C                              { Call old ISR entry point }„  end;„  {$ifDEF VER70}„  Test8086 := Save8086„  {$endif}„end {Int1CISR};„{$F-}„„„Procedure ClockExitProc; Far;„{ This Procedure is VERY important as you have hooked the timer interrupt  }„{ and thereFore if this is omitted when the Unit is terminated your        }„{ system will crash in an unpredictable and possibly damaging way.         }„begin„  ExitProc := ExitSave;„  SetIntVec($1C,OldInt1C);               { This "unhooks" the timer vector }„end {ClockExitProc};„„„begin„  progress := 0;„  {$ifDEF VER70}„  Save8086 := Test8086;„  {$endif}„  ExitSave := ExitProc;                          { Save old Exit Procedure }„  ExitProc := @ClockExitProc;                 { Setup a new Exit Procedure }„  GetIntVec($1C,OldInt1C);              { Get old timer vector and save it }„  SetIntVec($1C,@Int1CISR);   { Hook the timer vector to the new Procedure }„end.„                                                                        7      05-28-9313:49ALL                      SWAG SUPPORT TEAM        RUNINBCK.PAS             IMPORT              10          {„> How do you have a Procedure running Constantly While others things are„> happening??„„Well, to have them run at the exact same time isn't possible. You can swap„back and forth pretty quick though. The basic idea is that when the„computer is idle (waiting For a key, displaying a Text File, etc) you have„it jump to your routine.„}„Program Test1;„(* This will wait For a key and display the time *)„Uses„  Dos, Crt;„„Procedure WriteTime;„Var„  CurX,„  CurY,„  CurA  : Byte;„  H, M,„  S, MS : Word;„begin„  CurX := WhereX;„  CurY := WhereY;„  CurA := TextAttr;„  TextColor(7);„  GotoXy(60, 1);„  GetTime(H, M, S, MS);„  Write(H, ':', M, ':', S, '.', MS);„  TextAttr := CurA;„  GotoXy(CurX, CurY);„end;„„{ Uncomment this For Keyboard IDLE Demo }„Var Ch : Char;„    Done : Boolean;„begin„  Repeat„    Repeat„      WriteTime„    Until KeyPressed;„    Ch := ReadKey;„    Done := (Ch = #27);„  Until Done;„end.„„{ Uncomment this For TextFile IDLE Demo }„{„Var T : Text;„    Ts : String;„begin„  Assign(T,'BBS.NFO');„  Reset(T);„  While Not Eof(T) Do begin„    ReadLn(T,Ts);„    WriteTime;„    WriteLn(Ts);„  end;„  Close(T);„end.„}                        8      05-28-9313:49ALL                      SWAG SUPPORT TEAM        WATCHDOG.PAS             IMPORT              24           BC> I have the desire to create a Type of "watch dog" Procedure For a Program„ BC> I am writing. It has become increasingly attractive For me to create this„ BC> Procedure to activate at certain times every hour - i.e. at 15 past and 45„ BC> past the hour.„„Perhaps if you insert this code into your Program. It works With the ISR 1C„called by the timerinterrupt 8 periodically. For testing reasons it calls the„batchFile at 15 and 45 seconds. Change finally the line "if(s=15) or (s=45)" to„"if (m=15) or (m=45)" to test the minutes.„„Code written in TP6.0 :„„{$M 16384,0,16384} (*Adjust to your requirements*)„Uses Dos,Crt;„„Const„  WDTryTime = 18; (*18 ticks = about every second*)„  BatchFileName = 'woufwouf.bat'; (*BatchFile to start*) <<<your BatchFilename„Var„  WDCount : Integer;„  WDBusy,WdEvent : Boolean;„  WDSave1c,WDSaveExit: Pointer;„  DosReentrant : ^Byte;„  IntVec : Array[0..255] of Pointer Absolute 0:0;„„Procedure STI;„Inline($FB);„„Procedure CLI;„Inline($FA);„„(*Do not use Turbo-Pascal I/O Routines in here.*)„(*Be also sure not to use GetTime/Date at the same time as this routine*)„„Procedure WatchDog;interrupt;„Var h,m,s,c : Word;„begin„  if not WDBusy then„  begin„    WDBusy:=True;„    inc(WDCount);„    if DosReentrant^=0 then      (*No Dos op's in work ?*)„      if WDCount>=WdTryTime then (*Test only every second to prevent*)„      begin                      (*big loss in perFormance.        *)„        WDCount:=0;„        GetTime(h,m,s,c);              (*Get Time*)„„here>>> if(s=15) or (s=45) then (*Call on 15 minutes and 45 minutes*)„„        begin„          Cli;IntVec[$1c]:=WDSave1C;Sti;„          Port[$20]:=$a0;(*Report TimerInt finished to Interrupt-contr.*)„          Port[$20]:=$20;„          SwapVectors;      (*Execute COMMand.COM + batchFile*)„          Exec(GetEnv('COMSPEC'),'/C '+batchFilename);„          SwapVectors;„          Cli;IntVec[$1c]:=@Watchdog;Sti;„          WDEvent:=True;„        end;„      end;„    WDBusy:=False;„  end;„end;„„Procedure WDRemove;„begin„  SetIntVec($1C,WDSave1c); (*Restore old 1c routine*)„  ExitProc:=WDSaveExit;„  Writeln('Exiting Watchdog');„  Halt(Exitcode);„end;„„Procedure WDInstall;„Var Regs:Registers;„begin„  With Regs do„  begin„    ah:=$34;„    MsDos(regs);„    DosReentrant:=ptr(es,bx); (*Get Reentrant Pointer*);„  end;„  WdCount:=0;„  WDBusy:=False;„  WDEvent:=False;„  GetIntVec($1C,WDSave1C); (*Save old 1c routine*)„  SetIntVec($1C,@Watchdog); (*Assign Watchdog to int 1c*)„  WDSaveExit:=ExitProc;„  ExitProc:=@WDRemove;„  Writeln('Watchdog installed');„end;„„Var c:Char;„„begin„  WDInstall;„  Repeat (*Example Main Loop*)„    Write('Hello');„    if WDEvent then  (*Watch sign of Watchdog*)„    begin„      Writeln;Writeln('Event occured');„      WDEvent:=False;„    end;„    Delay(1000);„  Until KeyPressed;„  c:=ReadKey;„end.„                                                                                                                   