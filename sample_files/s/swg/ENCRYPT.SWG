SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00018         FILE & ENCRYPTION ROUTINES                                        1      05-28-9313:40ALL                      SWAG SUPPORT TEAM        CHECKSUM.PAS             IMPORT              15     e√ò% (*„> I finished Programming a Program in turbo pascal 7, and as some shareware„> Programs like RemoteAccess, Fastecho and more i want my Program to use a„> KEY File to know if the Program is registered or not (i will supply a key„> For every sysop according to his bbs name and his name), any examples to„> do such a Procedure?„„You could do like I did in Terminate, make a big KeyFile around 4-8k and„included all kind of checksums calculated on crc-sums and the name etc.„„Calculate the Crc-sums in different ways, use always the GlobalChecksum to find„out if there has been no errors in the File. If error in the global checksum:„„  SetFAttr(keyFile,Archive)      { if the File has been set to readonly }„  Erase(keyFile,archive)„„Ask user to install a new copy of the keyFile.„„Then somebody has changed it or an error has occured.„„The next things is to use a different checksum For each release you make of„your Program, then people will get annoyed over waiting For a new pirate key„and hopefully will send you some money.„The cracker cannot calculate the checksum if you have no code in the Program,„but he can crack the current version, but if you release a new version often,„people will get tired of that and pay. A checksum can be calculated in many„different ways like below:„*)„Var„„  KeyRec : Record„    Crc  : Array[1..100] of LongInt;„    Name : String[80];„    GlobalChecksum;„  end;„„Var„  Sum : LongInt;„  X   : Word;„„begin„  Sum := 0;„  For x := 1 to Sizeof(KeyRec) Do„    Inc(Sum, Mem[Seg(KeyRec) : Seg(KeyRec) + x]);„  { This will add all ascii values to crc, the cracker will prop. find„    this out, but if you then : }„  Dec(Sum,3248967);„  { How should he find out if there is no code in your Program at the }„  { present version }„end.„                           2      05-28-9313:40ALL                      SWAG SUPPORT TEAM        COPYINC.PAS              IMPORT              21     e√·a { COPYINC.PAS    Author: Trevor J Carlsen„                         PO Box 568„                         Port Hedland  6721„                         Western Australia„„„SYNTAX:    copyinc Filename„„where Filename is the name of a Text File you wish to create that will be used„as an include File in a Turbo Pascal Program.„„This Program creates a Text File in the format„„      Const„        RegStr  ='This Program is an unregistered copy';„        CodeStr =„        #125#34#139#139#74#71#94#61#44#78#65#155#158#132#62#136#141#140#84+„        #34#155#63#38#46#89#84#93#57#153#51#83#112#72#36#138#93;„        keyval  = 1234567890;„„The Text File that was used by COPYINC to create the above include File would„have looked like this„„p:\prog\freeload.inc„This Program is an unregistered copy„RegStr  =„CodeStr =„1234567890„„Here is another example.  This was the include File -„„      Const„        ChkStr     : String ='This Program is registered to';„        CodeChkStr : String =„        #32#153#90#34#133#140#42#129#150#50#81#36#83#36#133#154#52#76#75+„        #129#45#93#77#44#83#149#157#71#95#225;„        keyval  = 1234567890;„„and the Text File used by COPYINC -„„p:\prog\registed.inc„This Program is registered toˇ„ChkStr     : String =„CodeChkStr : String =„1234567890„„„The Text File must always consist of five lines that are„ 1.  The name of the include File to be created.„ 2.  The plain Text.„ 3.  The name of the plain Text Constant along With its syntax.„ 4.  The name and syntax of the coded Text Constant.„ 5.  A key value.  Any number in the LongInt range is valid.„„„}„„Uses„  endecode;  { my encryption Unit }„„Const„  hash   = '#';„Var„  f      : Text;„  params : Text;„  keyval : LongInt;„  notice,„  fname,„  CodeStr,„  CodeVar,„  PlainVar: String;„  x      : Word;„„begin„  assign(params,ParamStr(1));„  reset(params);„  readln(params,fname);„  readln(params,notice);„  readln(params,PlainVar);„  readln(params,CodeVar);„  readln(params,keyval);„  CodeStr := EncryptStr(keyval,notice);„  notice := '  '+ PlainVar + #39 + notice + #39#59;„  assign(f,fname);„  reWrite(f);„  Writeln(f,'Const');„  Writeln(f,notice);„  Writeln(f,'  ',CodeVar);„  Write(f,'  ');„  For x := 1 to length(CodeStr) do begin„    if x mod 20 = 0 then begin„      Writeln(f,'+');„      Write(f,'  ');„    end;„    Write(f,'#',ord(CodeStr[x]));„  end;„  Writeln(f,';');„  Writeln(f,'  keyval  = ',keyval,#59);„  Writeln(f);„  close(f);„end.„„                                                                                                                             3      05-28-9313:40ALL                      SWAG SUPPORT TEAM        ENCRYPT.PAS              IMPORT              65     e√‚ {$A+,B-,D-,E+,F-,G+,I+,L-,N-,O-,R-,S-,V-,X+}„{$M 4048,0,131040}„Program encrypt;„„{ Author Trevor J Carlsen - released into the public domain 1992         }„{        PO Box 568                                                      }„{        Port Hedland                                                    }„{        Western Australia 6721                                          }„{        Voice +61 91 73 2026  Data +61 91 73  2569                      }„{        FidoNet 3:690/644                                               }„„{ Syntax: encrypt /p=PassWord /k=KeyFile /f=File                         }„{ Example -                                                              }„{         encrypt /p=billbloggs /k=c:\command.com /f=p:\prog\anyFile.pas }„„{         PassWord can be any alpha-numeric sequence of AT LEAST four    }„{         Characters.                                                    }„„{         KeyFile is the full path of any File on the system that this   }„{         Program runs on.  This File, preferably a large one, must not  }„{         be subject to changes.  This is critical as it is used as a    }„{         pseudo "one time pad" style key and the slightest change will  }„{         render decryption invalid.                                     }„„{         File is the full path of the File to be encrypted or decrypted.}„„{ notes:  Running Encrypt a second time With exactly the same parameters }„{         decrypts an encrypted File.  For total security the keyFile    }„{         can be stored separately on a floppy.  Without this keyFile or }„{         knowledge of its contents it is IMPOSSIBLE to decrypt the      }„{         encrypted File.                                                }„„{         Parameters are Case insensitive and may be in any order and    }„{         may not contain any Dos separator Characters.                  }„„Const„  BufferSize   = 65520;„  Renamed      : Boolean = False;„„Type„  buffer_      = Array[0..BufferSize - 1] of Byte;„  buffptr      = ^buffer_;„  str80        = String[80];„„Var„  OldExitProc  : Pointer;„  KeyFile,„  OldFile,„  NewFile      : File;„  KeyBuffer,„  Buffer       : buffptr;„  KeyFileSize,„  EncFileSize  : LongInt;„  PassWord,„  KFName,„  FFName       : str80;„„Procedure Hash(p : Pointer; numb : Byte; Var result: LongInt);„  { When originally called numb must be equal to sizeof    }„  { whatever p is pointing at.  if that is a String numb   }„  { should be equal to length(the_String) and p should be  }        „  { ptr(seg(the_String),ofs(the_String)+1)                 }„  Var„    temp,„    w    : LongInt;„    x    : Byte;„„  begin„    temp := LongInt(p^);  RandSeed := temp;„    For x := 0 to (numb - 4) do begin„      w := random(maxint) * random(maxint) * random(maxint);„      temp := ((temp shr random(16)) shl random(16)) +„                w + MemL[seg(p^):ofs(p^)+x];„    end;„    result := result xor temp;„  end;  { Hash }„„Procedure NewExitProc; Far;„  { Does the "housekeeping" necessary on Program termination }„  Var code : Integer;„  begin„    ExitProc := OldExitProc;  { Reset Exit Procedure Pointer to original }„    Case ExitCode of„    0: Writeln('Successfully encrypted or decrypted ',FFName);„    1: begin„         Writeln('This Program requires 3 parameters -');„         Writeln('  /pPassWord');„         Writeln('  /kKeyFile (full path and name)');„         Write  ('  /fFile (The full path and name of the File');„         Writeln(' to be processed)');„         Writeln;„         Write  ('These parameters can be in any order, are Case,');„         Writeln(' insensitive, and may not contain any spaces.');„       end;„    2: Writeln('Could not find key File');„    3: Writeln('Could not rename and/or open original File');„    4: Writeln('Could not create encrypted File');„    5: Writeln('I/O error during processing - could not Complete');„    6: Writeln('Insufficient memory available');„    7: begin„         Writeln('Key  File is too small - aborted');„         Writeln;„         Writeln(' Key File must be at least as large as the buffer size ');„         Write  (' or the size of the File to be encrypted, whatever is the');„         Writeln(' smaller.');„       end;„    8: Writeln('PassWord must consist of at least 4 Characters');„    else { any other error }„      Writeln('Aborted With error ',ExitCode);„    end; { Case }„    if Renamed and (ExitCode <> 0) then„      Writeln(#7'WARNinG: original File''s name is now TEMP.$$$');„    {$I-}„    close(KeyFile); Code := Ioresult;„    close(NewFile); Code := Ioresult;„    close(OldFile); Code := Ioresult;„    if ExitCode = 0 then„      Erase(OldFile); Code := Ioresult;„    {$I+}„  end; { NewExitProc }„„„Function Str2UpCase(Var S: String): String;„  { Converts a String S to upper Case.  Valid For English. }„  Var„    x : Byte;„  begin„    Str2UpCase[0] := S[0];„    For x := 1 to length(S) do„      Str2UpCase[x] := UpCase(S[x]);„  end; { Str2UpCase }„„Procedure Initialise;„  Var„    CommandLine : String;„    FPos,FLen,„    KPos,KLen,„    PPos,PLen   : Byte;„„  Procedure  AllocateMemory(Var p: buffptr; size: LongInt);„    begin„      if size < BufferSize then begin„        if MaxAvail < size then halt(6);„        GetMem(p,size);„      end„      else begin„        if MaxAvail < BufferSize then halt(6);„        new(p);„      end;„    end; { AllocateMemory }„„  begin„    FillChar(OldExitProc,404,0);       { Initialise all global Variables }„    FillChar(PassWord,243,32);„    ExitProc    := @NewExitProc;             { Set up new Exit Procedure }„    if ParamCount <> 3 then halt(1);„    CommandLine := String(ptr(PrefixSeg,$80)^)+' '; { Add trailing space }„    CommandLine := Str2UpCase(CommandLine);      { Convert to upper Case }„    PPos        := pos('/P=',CommandLine);     { Find passWord parameter }„    KPos        := pos('/K=',CommandLine);      { Find keyFile parameter }„    FPos        := pos('/F=',CommandLine); { Find Filename For encryption}„    if (PPos = 0) or (KPos = 0) or (FPos = 0) then Halt(1);„    FFName      := copy(CommandLine,FPos+3,80);„    FFName[0]   := chr(pos(' ',FFName)-1);       { Correct String length }„    KFName      := copy(CommandLine,KPos+3,80);„    KFName[0]   := chr(pos(' ',KFName)-1);„    PassWord    := copy(CommandLine,PPos+3,80);„    PassWord[0] := chr(pos(' ',PassWord)-1);„    if length(PassWord) < 4 then halt(8);„    { Create a random seed value based on the passWord }„    Hash(ptr(seg(PassWord),ofs(PassWord)+1),length(PassWord),RandSeed);„    assign(OldFile,FFName);„    {$I-}„    rename(OldFile,'TEMP.$$$');„    if Ioresult <> 0 then„      halt(3)„    else„      renamed := True;„    assign(OldFile,'TEMP.$$$');„    reset(OldFile,1);„    if Ioresult <> 0 then halt(3);„    assign(NewFile,FFName);„    reWrite(NewFile,1);„    if Ioresult <> 0 then halt(4);„    assign(KeyFile,KFName);„    reset(KeyFile,1);„    if Ioresult <> 0 then halt(2);„    EncFileSize := FileSize(OldFile);„    KeyFileSize := FileSize(KeyFile);„    if KeyFileSize > EncFileSize then„      KeyFileSize := EncFileSize;„    if Ioresult <> 0 then halt(5);„    {$I+}„    if (KeyFileSize < BufferSize) and (KeyFileSize < EncFileSize) then„      halt(7);„    AllocateMemory(buffer,EncFileSize);„    AllocateMemory(KeyBuffer,KeyFileSize);„  end; { Initialise }„„Procedure Main;„  Var„    BytesRead : Word;„    finished  : Boolean;„„  Procedure CodeBuffer(number: Word);„    { This is the actual encryption/decryption engine }„    Var x : Word;„    begin„      For x := 0 to number - 1 do„        buffer^[x] := buffer^[x] xor KeyBuffer^[x] xor Random(256);„    end; { CodeBuffer }„„  begin„    {$I-}„    finished := False;„    Repeat„      BlockRead(OldFile,buffer^,BufferSize,BytesRead);„      if Ioresult <> 0 then halt(5);„      if (FilePos(KeyFile) + BytesRead) > KeyFileSize then„        seek(KeyFile,0);„      BlockRead(KeyFile,KeyBuffer^,BytesRead,BytesRead);„      if Ioresult <> 0 then halt(5);„      CodeBuffer(BytesRead);„      finished := BytesRead < BufferSize;„      BlockWrite(NewFile,buffer^,BytesRead);„    Until finished;„  end;  { Main }„„begin„  Initialise;„  Main;„end.„                                                                     4      05-28-9313:40ALL                      SWAG SUPPORT TEAM        ENCRYPT1.PAS             IMPORT              6      e√¡ Function EncryptDecrypt(S : String : K : String) : String;„Var„  I,Q : Integer;„  O   : String[255];„begin„  Q := 1;„  O := "";„  For I := 1 to Length(S) Do„    begin„      O := O + Chr(Ord(S[I]) Xor Ord(K[Q]));„      Inc(Q); If Q > Length(K) Then Q := 1;„    end;„  EncryptDecrypt := O;„end;„„A couple of thoughts on this.„„1. If K is short then the decryption is very easy.„2. The routine would be VERY slow as it is using String concatenation.  It„   would be MUCH faster if the O := "" line was changed to O[0] := S[0] and„   the O := O + ... line was replaced With -„   O[I] := ...„„TeeCee„                                             5      05-28-9313:40ALL                      SWAG SUPPORT TEAM        ENCRYPT2.PAS             IMPORT              10     e√Tw {The following very simple routine will encrypt and decrypt a Text File a line„at a time.  The CR/LF is left unencrypted and the algorithm ensures that no„encrypted Character can be < asciiz 127 *provided that* the Text For encrypting„has no hi-bit Characters.„„Obviously this is just a skeleten example (untested) With no error checking but„it should demonstrate what you need to do. After encrypting Text just reverse„the parameters and run the Program again to decrypt the encrypted Text.„}„Program encrypt_Text;„„Var„  inText,„  outText  : Text;„  st       : String;„„Function ConvertTxt(s: String): String;„  Var x : Byte;„  begin„    ConvertTxt[0] := s[0];„    For x := 1 to length(s) do„      ConvertTxt[x] := chr(ord(s[x]) xor (Random(128) or 128));„  end;  { ConvertTxt }„„begin„  RandSeed  := 1234567;{ set to whatever value you wish - this is your "key" }„  assign(inText,ParamStr(1));„  reset(inText);„  assign(outText,ParamStr(2));„  reWrite(outText);„  While not eof(inText) do begin„    readln(inText,st);„    Writeln(outText,ConvertTxt(st));„  end;„  close(inText);„  close(outText);„end.„                                               6      05-28-9313:40ALL                      SWAG SUPPORT TEAM        ENCRYPT3.PAS             IMPORT              12     e√¿À { JL> I'm writing a Program to set and test passWords. I imagine you saw it in„ JL> PASCAL echo. Well, I want to know if there is an easier way to encrypt a„ JL> File then to assign a different Character to each letter. This is the„ JL> only way that I can think of to do this.„„ JL> 'A':= '^';„ JL> 'B':= 'q';„„What you suggest isn't so much encryption as it is a substitution cypher.  The„following is more of an *encryption*:„}„„Function Crypt(S : String) : String;„(* xor can be used to *toggle* values.  In this Case it is toggling  *)„(* Character of the String based on its postion in the String.  This *)„(* ensures that the mask is always known For the pupose of decoding. *)„  Var„    i : Byte;„  begin„    For i := 1 to Length(S) Do„      S[i] := Char(ord(S[i]) xor i);„    Crypt := S;„  end;„„Var„  TestS : String;„  TestMask : Byte;„„begin„  TestS := 'This is a test 1234567890 !@$%';„  Write('original: ');„  Writeln(TestS);„„  TestS := Crypt(TestS);„  Write('Encrypt : ');„  Writeln(TestS);„„  TestS := Crypt(TestS);„  Write('Decrypt : ');„  Writeln(TestS);„end.„„{Please note that this was a quickie and not fully tested and thereFore„cannot be guaranteed to be perfect.  <grin>  But it ought to give you a„slightly different perspective and help you see alternate approaches to„the problem.„}„                                                                                                  7      05-28-9313:40ALL                      SWAG SUPPORT TEAM        ENCRYPT4.PAS             IMPORT              12     e√i_ { JC> I was wondering what Format you Programmers out there use to make„ JC> registration codes.  I was fooling around With a letter standing For„ JC> another letter but thats too simple.  How can I go about writing„ JC> bullet proof (or at least bullet resistant)  registration codes.  BTW,„ JC> this is not an over the modem Type Program.  if you understand what„ JC> I'm TRYinG to say, I wopuld RealLY appreciate a response.  Thanks a„ JC> lot!!!„}„„„Program RegCode;„„Uses Crt;„„Var„  ch : Char;„  Name : String;„„Function MakeRegCode(S:String): LongInt;„„Var„ I: LongInt;„ B: Byte;„„begin„ I:=0;   { Could make this something else if you want it more random looking }„ For B:=1 to Length(S)„  Do I:=I+ord(S[B]); { Could make it ord(S[B]+SomeValue) to make it more„                interesting }„ MakeRegCode:=I;„end;„„begin„„ Writeln;„ Writeln;„ Write('Enter SysOp Name : ');„ Readln(Name);„ Writeln;„ Writeln('The resultant code was ',MakeRegCode(Name));„ Writeln;„ ch:=ReadKey;„„end.„„„{You can also add a BBS Name or a City or anything else you want. just keep on„adding it to the I Var in the MakeRegCode proc.  to check to see if a reg code„is valid, just Compare the registration code he already has (in a cfg File„comewhere I assume) With the one generated this part of code.  if they match,„then is is a good code... if not... then he didn't register.„}„                                          8      05-28-9313:40ALL                      SWAG SUPPORT TEAM        ENDECODE.PAS             IMPORT              31     e√Ê. Unit endecode;„ { Simple encryption/decryption routines.                  }„„Interface„„Type„  stArray = Array[0..255] of Byte;„„Function Key(Var s): LongInt;„Function EncryptStr(key : LongInt; s: String): String;„Function DecryptStr(key : LongInt; s: String): String;„„Implementation„„Function MakeCodeStr(key : LongInt; Var s): String;„  {--------------------------------------------------------}„  { Creates a "randomly" Constructed String of a similar   }„  { length as the String which is to be encrypted. A       }„  { LongInt key is used to permit "passWord" Type          }„  { encryption. This key may be passed as a literal or     }„  { some passWord used to calculate it. Using this key,    }„  { the last Character of the String to be encrypted and   }„  { the length of the String, a "code String" is produced. }„  { This code String is then xord With the original String }„  { to produce the encrypted String. The last Character    }„  { however must be treated differently so that it can be  }„  { easily decoded in order to reproduce the coded String  }„  { used For decoding. This is done by xoring it With the  }„  { length of the String. to decrypt a String the last     }„  { Character must be decoded first and then the key coded }„  { String produced in order to decrypt each Character.    }„  {--------------------------------------------------------}„„  Var„    x   : Word;„    len : Byte Absolute s;„    st  : Array[0..255] of Byte Absolute s;„„  begin„    RandSeed := (key * len) div st[len];„    {This ensures that no two code Strings will be similar UNLESS they are„     of identical length, have identical last Characters and the same„     key is used.}„    MakeCodeStr[0] := chr(len);„    For x := 1 to len do„      MakeCodeStr[x] := chr(32 + Random(95));„      {Keeping the Character between 32 and 127 ensures that the high bit„       is never set on the original encrypted Character and thereFore allows„       this to be used as flag to indicate that the coded Char was < #32.„       This will then permit the encrypted String to be printed without fear„       of having embedded control codes play havoc With the Printer.}„  end;„„Function Key(Var s): LongInt;„  { Creates a key For seeding the random number generator. st can be a„    passWord }„  Var„    x     : Byte;„    temp  : LongInt;„    c     : Array[1..64] of LongInt Absolute s;„    len   : Byte Absolute s;„  begin„    temp  := 0;„    For x := 1 to len div 4 do„      temp := temp xor c[x];„    Key := Abs(temp);„  end;„„Function EncryptStr(key : LongInt; s: String): String;„  Var„    cnt,x          : Byte;„    len            : Byte Absolute s;„    st             : Array[0..255] of Byte Absolute s;„    CodeStr        : stArray;„    temp           : String Absolute CodeStr;„  begin„    temp           := MakeCodeStr(key,st);„    EncryptStr[0]  := chr(len);„    EncryptStr[len]:= chr(st[len]);„    For x := 1 to len-1 do begin„      cnt := st[x] xor CodeStr[x];„      inc(cnt,128 * ord(cnt < 32));„      EncryptStr[x]:= chr(cnt);„    end;  { For }„    cnt := st[len] xor (len and 127);„    inc(cnt,128 * ord(cnt < 32));„    EncryptStr[len]:= chr(cnt);„  end;„„Function DecryptStr(key : LongInt; s: String): String;„  Var„    cnt,x        : Byte;„    st           : stArray Absolute s;„    len          : Byte Absolute s;„    CodeStr      : stArray;„    temp         : String Absolute CodeStr;„    ch           : Char;„  begin„    cnt          := st[len] and 127;„    st[len]      := cnt xor len;„    temp         := MakeCodeStr(key,st);„    DecryptStr[0]:= chr(len);„    DecryptStr[len]:= chr(st[len]);„    For x := 1 to len-1 do begin„      cnt        := st[x];„      dec(cnt,128 * ord(st[x] > 127));„      DecryptStr[x] := chr(cnt xor CodeStr[x]);„    end;  { For }„  end;„„end.„                                                           9      05-28-9313:40ALL                      SWAG SUPPORT TEAM        HASH.PAS                 IMPORT              28     e√™è Unit Hash;„„{***************************************************************************„ *                                                                         *„ *                     Copyright 1989 Trevor J Carlsen                     *„ *                           All rights reserved                           *„ *                   Rovert Software Consulting Services                   *„ *                                PO Box 568                               *„ *                   Port Hedland Western Australia 6721                   *„ *                 Telephone  (091) 732026 or (091) 732569                 *„ *                                                                         *„ ***************************************************************************}„„Interface„„Uses Strings,„     sundry;„„Function hashcode(st : String; Var nwd : Word): Word;„„Implementation„„Function MakeCodeStr(key : LongInt; st : String): String;„  Var„    x   : Word;„    len : Byte Absolute st;„  begin„    RandSeed := (key * len) div ord(st[len]);„    MakeCodeStr[0] := st[0];„    For x := 1 to len do„      MakeCodeStr[x] := chr(Random(255));„  end;„„Function Key(st: String): LongInt;„  Var„    len    : Byte Absolute st;„    x,y    : Byte;„    temp   : LongInt;„    tempst : Array[0..3] of Byte;„„  Procedure makekey(Var k; Var s : LongInt);„    Var t : LongInt Absolute k;„      rec : Record„              Case Byte of„               1 :(b : LongInt; c : Word);„               2 :(d : Word ; e : LongInt);„               3 :(r : Real);„              end;„    begin„      RandSeed := t;„      rec.r := random;„      s := s xor rec.b xor rec.e;„    end;„„  begin„    temp := 0;„    For x := 1 to len-3 do begin„      For y := 0 to 3 do„        tempst[y] := Byte(st[x + y]);„      makekey(tempst,temp);„    end;„    Key := temp;„  end;„„Function EncryptStr(key : LongInt; st : String): String;„  Var„    len          : Byte Absolute st;„    cnt,x        : Byte;„    temp,CodeStr : String;„  begin„    CodeStr := MakeCodeStr(key,st);„    temp[0] := st[0];„    temp[len] := st[len];„    For x := 1 to len-1 do begin„      cnt := ord(st[x]) xor ord(CodeStr[x]);„      temp[x] := chr(cnt);„      end;„    cnt := ord(st[len]) xor len;„    temp[len] := chr(cnt);„    EncryptStr := temp;„  end;„„Function hashcode(st : String; Var nwd : Word): Word;„  Var k   : LongInt;„      len : Byte Absolute st;„      s   : String;„  begin„    k := key(st) * nwd;„    st := StUpCase(st);„    s := CompressStr(st);„    move(s[1],nwd,2);„    if len < 4 then st := st + '!@#$';„    {-Force String to a minimum length}„    st := EncryptStr(k,st);„    st := EncryptStr(Key(st),st);„    hashcode := key(st) shr 16;„  end;  {hash}„„end.„„„{„> Procedure Hash(p : Pointer; numb : Byte; Var result: LongInt);„„> ... Is this the way that you were referring to storing passWords?„> if so could further explain the usage of this Procedure? Thanx!!„„Yes, but I take issue With the Word "store".  Storing the passWord hash is not„storing the passWord as the passWord cannot be determined by examining the hash„- even if the hash algorithm is known.„„to use the Procedure -„„When the passWord is first created, calculate its hash and store that value„somewhere - either in a File or in the exe.„„then when the passWord is used just -„„  Hash(@passWord,length(passWord),EnteredHash);„  if PwdHash = EnteredHash then PassWord_Entered_is_Correct.„}                                    10     05-28-9313:40ALL                      SWAG SUPPORT TEAM        PASCASE.REP              IMPORT              13     e√`c CHECKSUM.PAS„             Program : 8„           Procedure : 1„             LongInt : 2„                Word : 1„                File : 7„                For  : 3„Made 22 changes to CHECKSUM.PAS in 0.88 seconds.„„COPYINC.PAS„             Program : 6„                Uses : 1„                Unit : 1„               Const : 6„                 Var : 1„              String : 5„             LongInt : 2„                Word : 1„                File : 11„                Text : 10„                For  : 1„Made 45 changes to COPYINC.PAS in 1.04 seconds.„„ENCRYPT.PAS„Made 0 changes to ENCRYPT.PAS in 1.87 seconds.„„ENCRYPT1.PAS„              String : 1„Made 1 changes to ENCRYPT1.PAS in 0.71 seconds.„„ENCRYPT2.PAS„Made 0 changes to ENCRYPT2.PAS in 0.77 seconds.„„ENCRYPT3.PAS„Made 0 changes to ENCRYPT3.PAS in 0.82 seconds.„„ENCRYPT4.PAS„Made 0 changes to ENCRYPT4.PAS in 0.88 seconds.„„ENDECODE.PAS„Made 0 changes to ENDECODE.PAS in 1.15 seconds.„„HASH.PAS„Made 0 changes to HASH.PAS in 1.21 seconds.„„PASSWORD.PAS„Made 0 changes to PASSWORD.PAS in 0.93 seconds.„„PATCHEXE.PAS„Made 0 changes to PATCHEXE.PAS in 0.93 seconds.„„XORCODE.PAS„                xor  : 2„Made 2 changes to XORCODE.PAS in 0.88 seconds.„„„Files Processed  :           12„Bytes Processed  :       30,724„Total Scans      :        1,908„Bytes Scanned    :   58,621,392„Total Changes    :           70„Total Time       :        12.31 Seconds„Bytes Per Second :    4,762,988„                                                                                              11     05-28-9313:40ALL                      SWAG SUPPORT TEAM        PASSWORD.PAS             IMPORT              20     e√x { JL>Help me guys. I'm learning about reading from a File. I am creating a„ JL>Program that will let you set passWord and test a passWord.„„ JL>Also how do you make the screen print a Character like .... instead of a„ JL>Word.  So when you enter in a passWord like in BBS it won't show it?„„------------------------------------X----------------------------------------„}„„Program TestPW;„„{„Programmer      : Chet Kress (FidoNet 1:283/120.4)„Been Tested?    : YES, this has been tested.  It works!„original Date   : 01/01/93„Current Version : v1.0„Language        : Turbo Pascal v7.0„Purpose         : Make a passWord routine„}„„Uses Crt;„„Procedure TestPassWord;„„Const„  DataFile = 'PW.DAT'; {The name of the data File containing the passWord}„  {Just have one line in the PW.DAT File, and use that as the passWord}„„Var„  PassWordFile : Text; {The name assigned to the data File}„  PassCH : Char; {A Character that the user has entered}„  TempPassWord : String; {The temporary passWord from the user}„  ThePW : String; {The Real passWord from the data File}„„begin {TestPassWord}„  Assign (PassWordFile, DataFile);„  Reset (PassWordFile);„  ClrScr;„  TempPassWord := '';„  Write ('Enter passWord: ');„{„  I replaced the Readln With this Repeat..Until loop so you can see the„  "periods" instead of the Characters (like you wanted).  This is a simple„  routine, but it should suffice For what you want it to do.  It has some„  error checking and backspacing is available too.„}„  Repeat„    PassCH :=  ReadKey;„    if (PassCH = #8) and (Length(TempPassWord) > 0) then„      begin„        Delete (TempPassWord, Length(TempPassWord), 1);„        GotoXY (WhereX-1, WhereY);„        Write (' ');„        GotoXY (WhereX-1, WhereY);„      end;„    if (PassCH >= #32) and (PassCH <= #255) then„      begin„        TempPassWord := TempPassWord + PassCH;„        Write ('.');„      end;„  Until (PassCH = #13);„  Writeln;„  Readln (PassWordFile, ThePW);        { <-- You Forgot to add this line }„  if TempPassWord = ThePW then„    begin„      Writeln ('You have received access.');„      Writeln ('Loading Program.');„      { Do whatever else you want to here }„    end„  else„    begin„      Writeln ('Wrong PassWord.');„    end;„  Close (PassWordFile);„end; {TestPassWord}„„begin {Main}„  TestPassWord;„end. {Main}„„                                                                                                                        12     05-28-9313:40ALL                      SWAG SUPPORT TEAM        PATCHEXE.PAS             IMPORT              20     e√ë† { PD> This looks like something I would like to add to my Programs.  My„ PD> question is, how do you modify the .exe from the Program.  I can do the„ PD> encryption but don't know how to store the encrypted passWords in the„ PD> Program's own .exe.  Any help would be appreciated.„}„„Procedure PatchExeFile(ItemAddr:Pointer;itemsize:LongInt);„Var„  FiletoPatch : File;„  HeaderSize  : Word;„  seeksize    : LongInt;„  offset      : Word;„  LDseg       : LongInt;„  ch          : Char;„„begin„  assign(FiletoPatch, paramstr(0));„  reset(FiletoPatch, 1);„  seek(FiletoPatch, 8);„  blockread(Filetopatch, headersize, sizeof(headersize));„  offset := ofs(itemAddr^);„  Ldseg := LongInt(Dseg);„  seeksize := 16 * (LDseg - PrefixSeg + HeaderSize) + offset - 256„    seek(Filetopatch, seeksize);„  blockWrite(Filetopatch, ItemAddr^, ItemSize);„  close(Filetopatch);„end;„„{Call it this way:„}„PatchExeFile(Addr(passWords), sizeof(passWords));„„{note that For this to work, passWords must be a TypeD ConstANT.„So you declare it this way:„}„  PassWords : PassWord_Array =„  („    (PassWord : #247#154#189#209#18#104#143#29; Protected : False),„    .„    .„    .„    (PassWord : #247#154#189#209#18#104#143#29; Protected : False)„  );„„{  PassWord_Array is declard as an Array of PassWord_Record;„„    The above declaration is from my Crypto.inC. I have a Crypto.PAS„Program that generates this File from my Make File so that on each„Compile the encryption is changed and the Array of passWords is stored„with valid encrypted passWords. I used #<AsciiValue> because the„encryption can generate values from Ascii 0 to Ascii 255 and some of„those cause troubles in Strings Constants using "'" as delimeters.„„    As long as you use:„„Const <ConstName> : <ConstType> = <ConstantValue>;„„    You will be sure PatchExe can find it's correct adress in the EXE.„From there on you can read it in your TP Program as usual and store it„using the call to PatchExe I gave up there.„„    BTW, do as I do and generate a new random encryption key on each„run, Re-encrypting everything and writting it back to the exe. This„drives Hackers mad when they try to decypher your encrypted passWords.„„One last note:„    The above PatchExe was written when I used TP 6.0. I haven't checked„    yet if TP 7.0 Uses different mapping of his EXe and it will most„    probably not work on a Protected-mode Compiled EXE.„}„                                               13     05-28-9313:40ALL                      SWAG SUPPORT TEAM        SOUNDEX.PAS              IMPORT              12     e√t {„REYNIR STEFANSSON„„Somebody was saying something about Soundex hashing. Here is my„Implementation of that:„}„„Unit Soundex;„„Interface„„Type„  Sdx4 = String[4];„„Function SoundexOf(WorkStr : String) : Sdx4;„„Implementation„„Var„  Group : Array[0..6] of String[8];„„Function ValidityOf(Letter : Char) : Char;„Var„  Valu, j : Integer;„  Chs     : String[8];„begin„  For Valu := 0 to 6 DO„  begin„    Chs := Group[Valu];„    For j := 1 to Length(Chs) DO„    begin„      if UpCase(Letter) = Chs[j] then„        ValidityOf := Chr(48+Valu);„    end;„  end;„end;„„Function SoundexOf(WorkStr : String) : Sdx4;„Var„  Sndex : Sdx4;„  Oval,„  Valu  : Char;„  i     : Integer;„begin„  Sndex := Copy(WorkStr, 1, 1);„  Oval  := ValidityOf(WorkStr[1]);„  For i := 2 to Length(WorkStr) DO„  begin„    Valu := ValidityOf(WorkStr[i]);„    if (Valu <> '0') and (Valu <> Oval) then„      Sndex := Sndex + Valu;„    Oval := Valu;„  end;„  Sndex := Sndex + '000';„  SoundexOf := Sndex;„end;„„begin„  Group[0] := 'AEHIOUWY';„  Group[1] := 'BFPV';„  Group[2] := 'CGJKQSXZ';„  Group[3] := 'DT';„  Group[4] := 'L';„  Group[5] := 'MN';„  Group[6] := 'R';„end.„„{„A Soundex-String looks like: `G032', one letter and three numbers.„Donald Knuth wrote about Soundexing in his _Art of Computer Programming_„series. I got my information out of Personal ComputerWorld (PCW), which in„turn got it from Knuth.„}„                             14     05-28-9313:40ALL                      SWAG SUPPORT TEAM        XORCODE.PAS              IMPORT              11     e√X4 {„≥ Is if possible For you to post a sample code on how to use xor to„≥ encrypt a File???   I'm shifting ORD value around to do excryptions„≥ and I think your method is better..  So I would like to learn it..„„Sure, here's a simple example that reads a user-entered line and„encrypts it using the xor method.  By XOR-ing it again the line is„decrypted.  This won't keep NSA fooled For more than a few seconds, but„so long as you keep the passWord hidden it should suffice.„}„„„Program Sample;„„Uses„  Crt;„„Const„  PassWord : Array[1..8] of Char = 'Sha Zamm';„„Var„  PassBits : Array[1..8] of Byte Absolute PassWord;„  ALine    : String[80];„  LineBits : Array[0..80] of Byte Absolute ALine;„  I, J, K  : Integer;„begin„  WriteLn('Enter a line of Text to encrypt:');„  ReadLn(ALine);„  J := 0;„  For I := 1 to Length(ALine) Do„  begin„    Inc(J);„    If J > 8 Then„      J := 1;„    LineBits[I] := LineBits[I] xor PassBits[J];„  end;„  WriteLn('Encrypted:  ',ALine);„  J := 0;„  For I := 1 to Length(ALine) Do„  begin„    Inc(J);„    If J > 8 Then„      J := 1;„    LineBits[I] := LineBits[I] xor PassBits[J];„  end;„  WriteLn('Decrypted:  ',ALine);„end.„                                                                                                                             15     05-31-9308:13ALL                      SWAG SUPPORT TEAM        Encode/Decode w/ PasswordIMPORT              116    e√{` (*-----„	Program		: CODE/DECODE„„	File		: Code.Pas„„	Version		: 1.2„„	Author(s)	: Mark Midgley„„	Date„	 (Started)	: April 11, 1990„	Date„	 (Finished)	: , 1990„„	Comment(s)	:„„-----*)„Program Code_and_DeCode;„„„{$IFDEF DEBUG}„	{$D+}		(* Turn Debugging Info **ON** *)„	{$L+}		(* Turn Local Symbols  **ON** *)„	{$R+}		(* Turn Range Checking **ON** *)„	{$S+}		(* Turn Stack Checking **ON** *)„{$ELSE}„	{$D-}		(* Turn Debugging Info **OFF** *)„	{$L-}		(* Turn Local Symbols  **OFF** *)„	{$R-}		(* Turn Range Checking **OFF** *)„	{$S-}		(* Turn Stack Checking **OFF** *)„{$ENDIF}„„Uses„	Crt,„	Dos;„„Const„	BufSize		=	512;„	Version		=	'1.3';„	MaxError    =	7;„„Type„	EDMode			=	(EnCrypt,EnCryptPass,DeCrypt);„	String79		=	String[79];„	FilePaths		=	Array [1..2] Of String79;„	Errors			=	1..(MaxError - 1);„„Procedure WriteXY( X,Y : Byte; S : String79 );„Begin	(* WriteXY *)„	GotoXY(X,Y);„	Write(S);„End;	(* WriteXY *)„„Function UpStr( S : String ) : String;„Var„	X	: Byte;„„Begin	(* UpStr *)„	For X := 1 To Length(S) Do„		S[x] := (UpCase(S[x]) );„	UpStr := S;„End;	(* UpStr *)„„Procedure Center( Y : Byte; S : String; OverWriteMode : Errors );„Var„	X : Byte;„„Begin	(* Center *)„	GotoXY(1,Y);„	Case (OverWriteMode) of„		1	: For X := 2 To 78 Do WriteXY(X,WhereY,' ');„		2	: ClrEOL;„	End;	(* Case *)„	X := ((79 - Length(S)) Div 2);„	If (X <= 0) Then X := 1;„	WriteXY(X,Y,S);„End;	(* Center *)„„Procedure OutError( S : String79; X,OWM : Errors );„Var„	T : String79;„„Begin	(* OutError *)„	GotoXY(1, WhereY);„	Case ( X ) Of„		1	: T := ('Incorrect Number of parameters.');„		2	: T := ('Input file "'+ S +'" not found.');„		3	: T := ('Input and Output files conflict.');„		4	: T := ('User Aborted!');„		5	: T := ('Input file "'+ S +'" is corrupted!');„		6	: If (T = '') Then T := ('DOS Input/Output Failure.')„				Else T := S;„	End;	(* Case *)„	TextColor(LightRed);„	Center(WhereY,T,OWM);„	TextColor(LightGray);„	If (OWM = 1) Then WriteLn;„	WriteLn;„	Halt(x);„End;	(* OutError *)„„Procedure HelpScreen( FullScreen : Boolean );„Begin	(* HelpScreen *)„	TextColor(LightGray);„	GotoXY(1,WhereY);„	WriteLn('               USAGE: CODE [/D|/E|/P] INPUT_FILE OUTPUT_FILE');„	WriteLn('                  Options are: /D Decode File.');„	WriteLn('                               /E Encode File.');„	WriteLn('                               /P Encode with Password.');„	If (Not FullScreen) Then Halt(MaxError);„	WriteLn;„	WriteLn('Description:');„	WriteLn;„	WriteLn('  CODE  encrypts a  DOS  file  to  garbage using  a  randomly  generated  seed');„	WriteLn('  and then back again.  For  more protection, the password  option can be used.');„	WriteLn('  Note:  With no  option, CODE defaults to encode "/E";  Input and Output files');„	WriteLn('  must be different;  the "/P" option will  prompt  for the password  and  echo');„	WriteLn('  dots;  Code does not allow wildcards;  Pressing  ESCape during operation will');„	WriteLn('  abort.  The author  does  not  guarantee  the reliability of this program and');„	WriteLn('  is not responsible for  any data lost.  If you appreciate this program in any');„	WriteLn('  way or value its use then please send $5.00 - $20.00 to:');„	WriteLn;„	TextColor(White);„	WriteLn('                                        Mark "Zing" Midgley');„	WriteLn('                                        843 East 300 South');„	WriteLn('                                        Bountiful Ut, 84010');„	TextColor(LightGray);„	Halt(MaxError);„End; 	(* HelpScreen *)„„Function Shrink( P : PathStr ) : String79;„Var„	D	: DirStr;„	N	: NameStr;„	E	: ExtStr;„„Begin	(* Shrink *)„	FSplit(P,D,N,E);„	Shrink := N + E;„End;	(* Shrink *)„„Procedure GraphIt( Var F1, F2	: File;„				   Var OldX		: Byte;„				   Hour,„				   Min,„				   Sec,„				   Sec100		: Word;„				   BoxSetUp		: Boolean );„Var„	F1Size,„	F2Size	: LongInt;„	Percent,„	X,„	NewX	: Byte;„	H,„	M,„	S,„	S100	: Word;„	A,„	B,„	C,„	D,„	Temp	: String79;„„Begin	(* GraphIt *)„	If (BoxSetUp) Then„	Begin„		Percent := 0;„		OldX := 3;„		GotoXY(1,WhereY);„		WriteLn('…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª');„		WriteLn('∫                                                                             ∫');„		WriteLn('»ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº');„		GotoXY(3,WhereY - 2);„	End Else„	Begin„		GetTime(H,M,S,S100);„		If (Sec100 <= S100) Then Dec(S100,Sec100)„			Else„			Begin„				S100 := (S100 + 100 - Sec100);„				If (S > 0) Then Dec(S);„			End;„		If (Sec <= S) Then Dec(S,Sec)„			Else„			Begin„				S := (S + 60 - Sec);„				If (M > 0) Then Dec(M);„			End;„		If (Min <= M) Then Dec(M,Min)„			Else„			Begin„				M := (M + 60 - Min);„				If (H > 0) Then Dec(H);„			End;„		If (Hour <= H) Then Dec(H,Hour)„			Else H := (H + 12 - Hour);„		Str(H,A);„		Str(M,B);„		Str(S,C);„		Str(S100,D);„		Case (S100) of„			0..9	: D := ('0' + D);„		End;	(* Case *)„		If (M > 0) Then„		Case (S) of„			0..9	: C := ('0' + C);„		End;	(* Case *)„		If (H > 0) Then„		Case (M) of„			0..9	: B := ('0' + B);„		End;	(* Case *)„		If (H = 0) Then„		Begin„			If (M = 0) Then Temp := (Concat(C,'.',D,' sec') )„			Else Temp := (Concat(B,' min ',C,'.',D,' sec') );„		End„		Else If (H = 1) Then Temp := (Concat(A,' hr ',B,' min ',C,'.',D,' sec') )„				Else Temp := (Concat(A,' hrs ',B,' min ',C,'.',D,' sec') );„    	F1Size := FileSize(F1);„		F2Size := FileSize(F2);„		If (F2Size <= F1Size) Then„		Percent := ((F2Size * 100) Div F1Size )„			Else Percent := 100;„		NewX := (((Percent * 76) Div 100) + 2);„		If (NewX < 3) Then NewX := 3;„		For X := OldX To NewX Do WriteXY(X,WhereY,#176);„		OldX := NewX;„		Center(WhereY + 1,(#181 + ' ' + Temp + ' ' + #198),3);„		GotoXY(NewX,WhereY - 1);„	End;„End;	(* GraphIt *)„„Procedure Rm( FileName : String79 );„Var„	F : File;„„Begin	(* Rm *)„	If (FileName = '') Then Exit;„	Assign(F,FileName);„	Erase(F);„End;	(* Rm *)„„Procedure GetStr( Var S : String79; Prompt,FName : String79; Show : Boolean );„Var„	Max,„	Min	: Byte;„	A	: Char;„	X	: Byte;„„Begin	(* GetStr *)„	If (FName = '') Then„	Begin„		Max := 54;„		Min := 0„	End Else„	Begin„		Max := 25;„		Min := 3„	End;„	TextColor(LightGray);„	WriteXY(1,WhereY,Prompt);„	Repeat„		GotoXY(Length(Prompt) + 1,WhereY);„		ClrEOL;„		If (Show) Then WriteXY(Length(Prompt) + 1,WhereY,S)„		Else For X := 1 To Length(S) Do Write(#249);„		A := (ReadKey);„		Case ( A ) of„			#32..#126 :„				If (Length(S) < Max) Then S := S + A„				Else„				Begin„					Sound(100);„					Delay(12);„					NoSound;„				End;„			#8 :„				If (Length(S) > 0) Then„					Delete(S,(Length(S) ), 1);„			#0 :„				A := ReadKey;„			#27:„				Begin„					Rm(FName);„					OutError('',4,2);„				End;„		End;	(* Case *)„	Until (A = #13) And (Length(S) >= Min);„End;	(* GetStr *)„„Function RealFile( St : String79; OWM : Errors ) : Boolean;„Var„	Error : Word;„	F	  : File;„„Begin	(* RealFile *)„	RealFile := False;„	Assign(F,St);„	{$I-}	 	(* Turn Input/Output-Checking Switch Off *)„	Reset(F);	(* Open file. *)„	Error := IOResult;„	{$I+}    	(* Turn Input/Output-Checking Switch On  *)„	If (Error = 0) Then (* File exists. *)„	Begin„		RealFile := True;„		Close(F);„	End Else„{*}		Case (Error) Of„			152	: OutError('Drive Not Ready.',6,OWM);„			3	: OutError('Invalid Drive specification.',6,OWM);„			(* 5  : Directory *)„		End;	(* Case *)„End;	(* RealFile *)„„Procedure CheckError( FileName, Msg : String79 );„Var„	Error : Word;„„Begin	(* CheckError *)„	Error := IOResult;„	If (Error <> 0) Then„	Begin„		If (Error <> 152) And„		   (Error <> 3) Then Rm(FileName)„			Else Msg := ('Drive Not Ready.');„		OutError(Msg,6,1);„	End;„End;	(* CheckError *)„„Procedure CheckAbort( FileName : String79 );„Begin	(* CheckAbort *)„	If (KeyPressed) Then„	If (ReadKey = #27) Then„	Begin„		Rm(FileName);„		OutError('',4,1);„	End;„End;	(* CheckAbort *)„„(*----„	Procedure Encode();„„	Author(s)	:	Mark Midgley„					Louis Zirkel„„	Comments	:	Cool Man...„„----*)„„Procedure EnCode( _File : FilePaths; Protect : Boolean );„Var„	Seed,„	PI,„	Y,„	OldX		: Byte;„	I,„	Increment	: Integer;„	Buf			: Array [1..BufSize] of Char;„	Hour,„	Min,„	Sec,„	Sec100,„	Status		: Word;„	Temp,„	Pass		: String79;„	F1,„	F2			: File;„„Begin	(* EnCode *)„	Pass := '';„    {$I-}„	Assign(F1, _File[1]);	(* input file  *)„	Assign(F2, _File[2]);	(* output file *)„	Reset(F1,1);„	CheckError('','Couldn''t open input file.');„	ReWrite(F2,1);„	CheckError(_File[2],'Couldn''t create output file.');„	Randomize;„	If (Protect) Then„	Begin„		GetStr(Pass,'(3 Char min, 25 Char max) Enter Password: ',_File[2],False);„		Buf[1] := Chr(Random(127) );„		BlockWrite(F2,Buf[1],SizeOf(Buf[1]),Status);„		CheckError(_File[2],'Couldn''t write to output file.');„	End Else„	Begin„		Buf[1] := Chr(Random(127) + 127);„		BlockWrite(F2,Buf[1],SizeOf(Buf[1]),Status);„		CheckError(_File[2],'Couldn''t write to output file.');„	End;„	Seed := Ord(Buf[1]);„	Increment := 1;„	PI := 1;„	Y := 127;„    TextColor(LightGray);„	ClrEOL;„	GetTime(Hour,Min,Sec,Sec100);„	GraphIt(F1,F2,OldX,Hour,Min,Sec,Sec100,True);„	Repeat„		BlockRead(F1, Buf, BufSize, Status);„		CheckError(_File[2],'Couldn''t read input file.');„		CheckAbort(_File[2]);„		GraphIt(F1,F2,OldX,Hour,Min,Sec,Sec100,False);„		For I := 1 To BufSize Do„			Begin„				If (Protect) Then„					Begin„						Buf[I] := Char(Byte(Buf[I]) XOR Byte(Pass[PI]));„						If (PI = Length(Pass)) Then Increment := -1;„						If (PI = 1) Then Increment := 1;„						Inc(PI,Increment);„					End„				Else„					Begin„						Buf[I] := Char(Byte(Buf[I]) XOR Y);„					End;„			End;„		BlockWrite(F2, Buf, Status);„		CheckError(_File[2],'Couldn''t write to output file.');„	Until (Status < BufSize);„	Close(F1);„	CheckError(_File[2],'Couldn''t close input file.');„	Close(F2);„	CheckError(_File[2],'Couldn''t close output file.');„	{$I+}„(* Successful Encryption *)„	TextColor(LightGray);„	Temp := (Shrink(_File[1]) +' Encoded to '+ Shrink(_File[2]));„	If (Protect) Then Temp := (Temp + ' with Password.');„	Center(WhereY,Temp,1);„	GotoXY(1,WhereY + 1);„	WriteLn;„End;	(* EnCode *)„„(*----„	Procedure DeCode();„„	Author(s)	:	Mark Midgley„					Louis Zirkel„„	Comments	:	Cool Man...„„----*)„„Procedure DeCode( _File : FilePaths );„Var„	Seed,„	PI,„	Y,„	OldX		: Byte;„	I,„	Increment	: Integer;„	Buf			: Array [1..BufSize] of Char;„	Hour,„	Min,„	Sec,„	Sec100,„	Status		: Word;„	Temp,„	Pass		: String79;„	F1,„	F2			: File;„„Begin	(* DeCode *)„	Pass := '';„	{$I-}„	Assign(F1, _File[1]);„	Assign(F2, _File[2]);„	Reset(F1,1);„	CheckError('','Couldn''t open input file.');„	ReWrite(F2,1);„	CheckError(_File[2],'Couldn''t create output file.');„	BlockRead(F1,Buf[1],SizeOf(Buf[1]),Status);„	CheckError(_File[2],'Couldn''t read input file.');„	Seed := Ord(Buf[1]);„	If (Buf[1] < #127) Then (* There's a Password *)„		GetStr(Pass,'Enter Password: ',_File[2],False);„	Increment := 1;„	PI := 1;„	Y := 127;„	TextColor(LightGray);„	ClrEOL;„	GetTime(Hour,Min,Sec,Sec100);„	GraphIt(F1,F2,OldX,Hour,Min,Sec,Sec100,True);„	Repeat„		BlockRead(F1, Buf, BufSize, Status);„		CheckError(_File[2],'Couldn''t read input file.');„		GraphIt(F1,F2,OldX,Hour,Min,Sec,Sec100,False);„		CheckAbort(_File[2]);„		For I := 1 To BufSize Do„			Begin„				If (Pass <> '') Then (* There's a Password *)„					Begin„						Buf[I] := Char(Byte(Buf[I]) XOR Byte(Pass[PI]));„						If (PI = Length(Pass)) Then Increment := -1;„						If (PI = 1) Then Increment := 1;„						Inc(PI,Increment);„					End„				Else„					Begin„						Buf[I] := Char(Byte(Buf[I]) XOR Y);„					End;„			End;„		BlockWrite(F2, Buf, Status);„		CheckError(_File[2],'Couldn''t write to output file.');„	Until (Status < BufSize);„	Close(F1);„	CheckError(_File[2],'Couldn''t close input file.');„	Close(F2);„	CheckError(_File[2],'Couldn''t close output file.');„	{$I+}„(* Successful Decryption *)„	Center(WhereY,Shrink(_File[1]) +' Decoded to '+ Shrink(_File[2]),1);„	GotoXY(1,WhereY + 1);„	WriteLn;„End;	(* DeCode *)„„Procedure CheckParameters;„Var„	_File	: FilePaths;„	Temp	: String79;„	Mode	: EDMode;„	OkMode,„	Input1,„	Input2	: Boolean;„	X		: Byte;„„Begin	(* CheckParameters *)„	For X := 1 To 2 Do _File[x] := '';„	Mode := EnCrypt;„	OkMode := False;„	X := 1;„	While (X <= ParamCount) Do„	Begin„		Temp := (UpStr(ParamStr(x) ) );„		If (Pos('?',Temp) > 0) or (Pos('*',Temp) > 0) Then HelpScreen(True);„		If ((Temp[1] = '/') or (Temp[1] = '-')) And„		  (Length(Temp) = 2) And (Not OkMode) Then„		Begin„			Case (Temp[2]) of„				'E'	: Begin„						Mode := EnCrypt;„						OkMode := True;„					  End;„				'D' : Begin„						Mode := DeCrypt;„						OkMode := True;„					  End;„				'P' : Begin„						Mode := EnCryptPass;„						OkMode := True;„					  End;„				'H',„				'?' : HelpScreen(True);„				Else„					OkMode := False;„			End;	(* Case *)„		End Else„		Begin„			If (_File[1] = '') Then _File[1] := Temp Else„			If (_File[2] = '') Then _File[2] := Temp;„		End;„		Inc(x);„	End;„	If (_File[1] = '') Then„	Begin„		GetStr(_File[1],'Enter Input Path/File : ','',True);„		Input1 := True;„		_File[1] := (UpStr(_File[1]) );„	End Else Input1 := False;„	If (_File[2] = '') Then„	Begin„		GetStr(_File[2],'Enter Output Path/File : ','',True);„		Input2 := True;„		_File[2] := (UpStr(_File[2]) );„	End Else Input2 := False;„	If (Pos('?',_File[1]+_File[2]) > 0) or (Pos('*',_File[1]+_File[2]) > 0)„		Then HelpScreen(True);„	If (Not OkMode) And ((Input1) or (Input2)) And„	   (_File[1] <> '') And (_File[2] <> '') Then„	Begin„		WriteXY(1,WhereY,'[E]ncode, Encode with [P]assword, or [D]ecode? ');„		ClrEOL;„		Case (UpCase(ReadKey) ) of„			'E' : Mode := EnCrypt;„			'D' : Mode := DeCrypt;„			'P' : Mode := EnCryptPass;„			#27 : OutError('',4,2);„		End;	(* Case *)„	End Else If (_File[1] = '') or (_File[2] = '') Then HelpScreen(False);„	If ((ParamCount < 2) or (ParamCount > 3)) And„	   (_File[1] = '') And (_File[2] = '') Then OutError('',1,2);„	If (Not(RealFile(_File[1],2) ) ) Then OutError(Shrink(_File[1]),2,2);„	If (RealFile(_File[2],2) ) Then„	Begin„		If (FExpand(_File[1]) = FExpand(_File[2]) ) Then OutError('',3,2);„		TextColor(Red);„		WriteXY(1,WhereY,'Warning! "');„		TextColor(LightRed);„		Write(Shrink(_File[2]) );„		TextColor(Red);„		Write('" already exists...Replace ([Y],N)? ');„		ClrEOL;„		Case (UpCase(ReadKey) ) Of„			'N',#27 : OutError('',4,2);„		End;	(* Case *)„	End;„	If (Mode = EnCryptPass) Then EnCode(_File,True);„	If (Mode = EnCrypt) Then EnCode(_File,False);„	If (Mode = DeCrypt) Then DeCode(_File);„End;	(* CheckParameters *)„„Procedure Main;„Begin	(* Main *)„	CheckBreak := False;„	TextColor(LightGray);„	WriteLn;„	ClrEOL;„	WriteXY(12,WhereY,'DOS file Encrypter v' + Version + ' by ');„	TextColor(LightBlue);„	Write('Zing Merway');„	TextColor(LightGray);„	WriteLn('  CODE/h for Help.');„	WriteLn;„	CheckParameters;„End;	(* Main *)„„Begin	(* Code *)„	Main;„End.	(* Code *)                                                                16     08-27-9320:53ALL                      KEITH TYSINGER           An Encoder for passwords IMPORT              16     e√‚ {„KEITH TYSINGER„„You can make an encoder that will scramble a string(s) that even YOU, the„ programmer couldn't unscramble without a password. They are many different„ ways to scramble a string; just be creative! One way is to swap every„ character with another character ( ex. swap every letter 'A' with the number„ '1') , a better way would use a password to scramble it. Here is a simple„ procedure that requires the password, the string to be scrammbled, and returns„ the scrambled string. The password should not exceed 20 characters in length.„Forget about the messy code; I blame my word processor:„}„„procedure encode(password, instring : string; var outstring : string);„var„  len,„  pcounter,„  scounter : byte;„„begin„  len := length(password) div 2;„  scounter := 1;„  pcounter := 1;„„  repeat„    outstring := outstring + chr(ord(password[pcounter]) +„                             ord(instring[scounter]) + len);„    inc(scounter);„    inc(pcounter);„    if pcounter > length(password) then„      pcounter := 1;„  until scounter > length(instring);„end;„„procedure decode(password, instring : string; var outstring : string);„var„  len,„  pcounter,„  scounter : byte;„„begin„  len := length(password) div 2;„  scounter := 1;„  pcounter := 1;„„  repeat„    outstring := outstring + chr(ord(instring[scounter]) -„                             ord(password[pcounter]) - len);„    inc(scounter);„    inc(pcounter);„    if pcounter > length(password) then„      pcounter := 1;„  until scounter > length(instring);„end;„„var„  password,„  original,„  scrambled,„  descrambled : string;„begin„  original := 'Hello There!';„  password := 'Eat my';„  encode(password, original, scrambled);„  writeln('orig = ', original);„  writeln('scrm = ', scrambled);„  decode(password, scrambled, descrambled);„  writeln('dcod = ', descrambled);„  readln;„end.„„                                                                  17     08-27-9321:35ALL                      SWAG SUPPORT TEAM        RSA Encryption           IMPORT              11     e√l| RSA encryption.„„ The encryption key is:   C = M to the power of e MOD n„„         where C is the encrypted byte(s)„               M is the byte(s) to be encrypted„               n is the product of p and q„               p is a prime number ( theoretically 100 digits long )„               q is a prime number ( theoretically 100 digits long )„               e is a number that  gcd(e,(p-1),(q-1)) = 1„„  The decryption key is:   M = C to the power of d MOD n„„         Where C is the encrypted byte(s)„               M is the original byte(s)„               n is the product of p and q„               p is a prime number ( must be the same as the encrypting one )„               q is a prime number ( "            "           "           " )„               d is the inverse of the modulo   e MOD (p-1)(q-1)„„„As you can see in order to crack the encrypted byte(s) you would need to know„the original prime #'s,  Even with the encryption key it would take a long time„to genetate the correct prime #'s needed....„„an Example...„„           C = M to the power of 13 MOD 2537„„         2537 is the product of 43 and 59.„„   the decryption key is„„           M = C to the power of 937 MOD 2537„„       937 is the inverse of  13 MOD (43 - 1)(59 - 1).„„                               18     05-25-9408:18ALL                      JOHN FREESE              Xor Encryption/DecryptionSWAG9405            96     e√   (* $Header:   A:/vcs/mash.pav   1.0   15 Jul 1991  7:21:38   K_McCoy  $ *)„(****************************************************************************)„ „UNIT MASH;„ „{$IFDEF DOCUMENTATION}„ „(****************************************************************************)„ *  „ *  $Log:   A:/vcs/mash.pav  $„ * „ *    Rev 1.0   15 Jul 1991  7:21:38   K_McCoy„ *    Added encryption unit, cleaned up.„ * „ *  „(****************************************************************************)„ „{$V-}„ „ „                  Mash - The McCoy & Associates File Mangler„ „    Purpose:„„„    General purpose text file encrypter.  Keeps the honest people honest.„    Does simple XOR of text characters with user settable key.  Creates„    a binary file with the extension .CRP containing the encrypted text.„    Binary files will be a little shorter than their ascii counterparts„    as there will be no CR/LF delimiters: only a length byte preceeding„    each "line" of binary characters.  There is a 255 character limit on„    the text files, but no limit on the number of lines (up to the capacity„    of the disk).„ „    Drawbacks:  This is nowhere near as secure as DES algorithm, although„    it is much faster.  This unit won't keep the CIA / KGB out of your„    financial records for long, but it might work on your ex-wife„    and her laywer.„ „    Note:  This unit uses the TPSTRING unit from Turbo Power.  You could„    easily change this to use the OPSTRING unit or write your own„    Trim [trailing blanks] function.„ „    I wrote this for an automated test program to keep unauthorized people„    from changing the test specifications out on the assembly line.„    (You wouldn't want airplanes falling on your head, would you?)„ „    Suggested improvements:„„    Allow other file extensions for input and output files.„    Modify this to work with binary input files.„    Modify the Mangle routine to not reset to the beginning of the key on each„    line of text.„ „    Public Domain, but be nice and give me credit if you use it in your„    own stuff.„ „    _Use at your own risk_  If the KGB de-encrypts your Mangled bowling„    scores, tough!„„    Do an IO redirect of complaints to NUL.  Questions may be sent to:„ „    Kevin McCoy - CompuServe ID# [72470,1233]„    2217 Aspenpark Ct.„    Thousand Oaks, CA 91362-1731„ „ „                                Sample Usage:„USES„    DOS,„    CRT,„    MASH;„VAR„    Strg,„    InName         : STRING;„    M              : Mangler;„BEGIN                             {main}„    ClrScr;„ „    WRITE('Enter name of .CFG file: ');„    READLN(InName);„ „    {I think this came from an old "Man from U.N.C.L.E." episode}„    M.SetSequence('OuR CaRs On IcE');„„    {open the two files}„    IF NOT M.Init(InName, MASHMODE) THEN BEGIN„        WRITELN(M.MashError);„        HALT(1);„    END;„ „    {encrypt the .CFG file}„    IF NOT M.MashFile THEN BEGIN„        WRITELN(M.MashError);„        HALT(1);„    END;„„    {close the files}„    M.Done;„ „    {Open just the encrypted file}„    IF NOT M.Init(InName, UNMASHMODE) THEN BEGIN„        WRITELN(M.MashError);„        HALT(1);„    END;„ „    {read and decrypt each line until EOF}„    WHILE M.Getline(Strg) DO„        WRITELN(Strg);„ „    {close the .CRP file}„    M.Done;„ „END; {of sample program}„ „ „{$ENDIF}„{ The real stuff starts here... }„ „INTERFACE„„TYPE„    MMType         = (MASHMODE, UNMASHMODE, SOURMASH);„ „    Mangler        = OBJECT„                         TFile          : TEXT;„                         BFile          : FILE;„                         LastError      : WORD;„                         FileName       : STRING;„                         InitMode       : MMType;„                         FUNCTION Init(Fname : STRING; Mode : MMType) :„BOOLEAN;„                         FUNCTION Getline(VAR Line : STRING) : BOOLEAN;„                         FUNCTION MashFile : BOOLEAN;„                         FUNCTION  MashError(VAR S : STRING) : BOOLEAN;„                         PROCEDURE SetSequence(Seq : STRING);„                         PROCEDURE Done;„                     END;„ „   „(****************************************************************************)„ „IMPLEMENTATION„„USES„    {.U-}„    TPSTRING„    {.U+}„    ;„ „CONST„    {Default key.  May be reset with the SetSequence method}„    Id             : STRING =„'^%12hY7eujEDZ|R9a341~~#2DBC3fn7mSDVvUY@hbFD`6093fdk79*7a-|-  Q`';„ „    {error number constants}„    INVINAM = 500;„    INVINIT = INVINAM + 1;„    CORRUPT = INVINIT + 1;„ „ „   „(****************************************************************************)„ „    FUNCTION Mangle(L : STRING) : STRING;„        { Low budget encryption / decryption of Line}„    VAR„        I              : INTEGER;„    BEGIN„        FOR I := 1 TO LENGTH(L) DO„            L[I] := CHR(ORD(L[I]) XOR NOT(ORD(Id[I MOD LENGTH(Id) + 1])));„        Mangle := L;„    END;„ „   „(****************************************************************************)„ „    FUNCTION Mangler.Init(Fname : STRING; Mode : MMType) : BOOLEAN;„        {- Gozintas:  Fname = Name (no extension) of the input/output files}„        {             Mode  = MASHMODE / UNMASHMODE (encrypt / decrypt)    }„        {  Gozoutas:  TRUE if everything was OK, FALSE if not              }„    VAR„        InName,„        OutName        : STRING;„    BEGIN„        InitMode := Mode;„        FileName := Fname;„        Init := TRUE;„        IF LENGTH(Trim(Fname)) = 0 THEN BEGIN„            LastError := INVINAM;„            Init := FALSE;„            EXIT;„        END;„        InName := Fname + '.CFG';„        OutName := Fname + '.CRP';„ „        { Open the appropriate file(s) }„ „        IF Mode = MASHMODE THEN BEGIN„            ASSIGN(TFile, InName); {open data files}„            {$I-}„            RESET(TFile);„            {$I+}„            LastError := IORESULT;„            IF LastError <> 0 THEN BEGIN„                {crash if file error}„                Init := FALSE;„                EXIT;„            END;„            ASSIGN(BFile, OutName);„            {$I-}„            REWRITE(BFile, 1);„            {$I+}„            LastError := IORESULT;„            IF LastError <> 0 THEN BEGIN„                {crash if file error}„                Init := FALSE;„                EXIT;„            END;„            Init := TRUE;„        END„        ELSE BEGIN„            ASSIGN(BFile, OutName); {open data files}„            {$I-}„            RESET(BFile, 1);„            {$I+}„            LastError := IORESULT;„            IF LastError <> 0 THEN BEGIN„                {crash if file error}„                Init := FALSE;„                EXIT;„            END;„        END;„    END;„ „   „(****************************************************************************)„ „    FUNCTION Mangler.Getline(VAR Line : STRING) : BOOLEAN;„        {- Read a single line of binary gunk from the MSH file and decrypt it}„        {  Gozintas = Nothing                                                }„        {  Gozoutas:  Line = Decrypted ASCII string                          }„        {             Returns TRUE if everything was OK, FALSE if not        }„    VAR„        Result         : WORD;„    BEGIN„ „        Line := '';„        Getline := FALSE;„ „        IF InitMode <> UNMASHMODE THEN BEGIN„            LastError := INVINIT;„            EXIT;„        END;„ „        BLOCKREAD(BFile, Line[0], 1, Result);„        IF Result <> 1 THEN BEGIN„            LastError := CORRUPT;„            EXIT;„        END;„ „        BLOCKREAD(BFile, Line[1], ORD(Line[0]), Result);„        IF Result = ORD(Line[0]) THEN BEGIN„            Line := Mangle(Line);„            Getline := TRUE;„        END„    END;„ „   „(****************************************************************************)„ „    FUNCTION WTOA(N : WORD; W : INTEGER) : STRING;„    VAR„        Strg           : STRING;„    BEGIN„        STR(N:W, Strg);„        WTOA := Strg;„    END;„ „   „(******************************************************************************)„ „    FUNCTION Mangler.MashError(VAR S : STRING) : BOOLEAN;„        {- return the last error string }„    BEGIN„        {most of these messages are unlikely to occur.  You may remove most }„        {of them to save memory }„„        MashError := TRUE;„        CASE LastError OF„            000 : BEGIN {no error}„                      S := '';„                      MashError := FALSE; „                  END;„            002 : S := 'File not found';„            003 : S := 'Path not found';„            004 : S := 'Too many open files';„            005 : S := 'File access denied';„            006 : S := 'Invalid file handle';„            012 : S := 'Invalid file access code';„            015 : S := 'Invalid drive number';„            016 : S := 'Cannot remove current directory';„            017 : S := 'Cannot rename across drives';„            100 : S := 'Disk read error';„            101 : S := 'Disk write error';„            102 : S := 'File not assigned';„            103 : S := 'File not open';„            104 : S := 'File not open for input';„            105 : S := 'File not open for output';„            150 : S := 'Disk is write-protected';„            151 : S := 'Unknown unit';„            152 : S := 'Drive not ready';„            154 : S := 'CRC error in data';„            156 : S := 'Disk seek error';„            157 : S := 'Unknown media type';„            158 : S := 'Sector not found';„            160 : S := 'Device write fault';„            161 : S := 'Device read fault';„            162 : S := 'Hardware failure';„            203 : S := 'Insufficient memory';„            INVINAM :S := 'Invalid filename';„            INVINIT :S := 'Invalid Mash unit init';„            CORRUPT : S := 'Invalid or corrupt MSH file';„            ELSE„                S := 'Turbo runtime error ' + WTOA(LastError, 4);„        END;„    END;„ „   „(****************************************************************************)„ „    PROCEDURE Mangler.SetSequence(Seq : STRING);„        {- Set the encryption sequence (key) to be something other than the„default   }„        {  Gozintas: A string (the longer the better) containing any characters„in    }„        {  the range of (0-255)  Try to avoid using strings that will be„duplicated   }„        {  in the text to be encrypted.  A match between the key and the text„results }„        {  in strings of $FF characters in the MSH file that make the key„easier to   }„        {  crack by determined hackers                                         „      }„ „    BEGIN„        Id := Seq;„    END;„„   „(****************************************************************************)„ „    FUNCTION Mangler.MashFile : BOOLEAN;„        {- File conversion method.  Encrypts text file specified in Init method„call }„        {  and places encrypted binary junk into the .MSH file                 „     }„        {  Returns TRUE if success, FALSE if not                               „     }„    VAR„        Strg           : STRING;„        Result         : WORD;„    BEGIN„        WHILE (NOT EOF(TFile)) DO BEGIN„            READLN(TFile, Strg);„            WRITELN(Strg);„            Strg := Mangle(Strg);„            BLOCKWRITE(BFile, Strg, ORD(Strg[0]) + 1, Result);„            IF Result <> LENGTH(Strg) + 1 THEN BEGIN„                WRITELN('Problem writing ' + FileName + '.MSH');„                HALT(1);„            END;„        END;                      {while}„ „    END;„ „   „(****************************************************************************)„ „    PROCEDURE Mangler.Done;„        {- Close up shop and boogie method}„    BEGIN„        CLOSE(BFile);„        IF InitMode = MASHMODE THEN„            CLOSE(TFile);„ „        InitMode := SOURMASH;„    END;„ „   „(****************************************************************************)„    {unit initialization}„END.                              {of unit mash}„(****************************************************************************)„(****************************************************************************)„                                                                                                   