SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00019         SEARCH/FIND/REPLACE ROUTINES                                      1      05-28-9313:46ALL                      SWAG SUPPORT TEAM        BMFIND.PAS               IMPORT              27          „  Hi, Andy:„„  ...Here's a demo program of the Boyer-Moore search algorithm.„„  The basic idea is to first create a Boyer-Moore index-table„  for the string you want to search for, and then call the„  BMsearch routine. *Remember* to turn-off "range-checking"„  {$R-} in your finished program, otherwise the BMSearch will„  take 3-4 times longer than it should.„„              (* Public-domain demo of Boyer-Moore search algorithm.  *)„              (* Guy McLoughlin - May 1, 1993.                        *)„program DemoBMSearch;„„              (* Boyer-Moore index-table data definition.             *)„type„  BMTable  = array[0..127] of byte;„„  (***** Create a Boyer-Moore index-table to search with.             *)„  (*                                                                  *)„  procedure Create_BMTable({input }     Pattern : string;„                           {update} var     BMT : BMTable);„  var„    Index : byte;„  begin„    fillchar(BMT, sizeof(BMT), length(Pattern));„    for Index := 1 to length(Pattern) do„      BMT[ord(Pattern[Index])] := (length(Pattern) - Index)„  end;        (* Create_BMTable.                                      *)„„  (***** Boyer-Moore Search function. Returns 0 if string is not      *)„  (*     found. Returns 65,535 if BufferSize is too large.            *)„  (*     ie: Greater than 65,520 bytes.                               *)„  (*                                                                  *)„  function BMsearch({input } var Buffer;„                                 BuffSize : word;„                             var BMT      : BMTable;„                                 Pattern  : string) : {output} word;„  var„    Buffer2 : array[1..65520] of char absolute Buffer;„    Index1,„    Index2,„    PatSize : word;„  begin„    if (BuffSize > 65520)  then„      begin„        BMsearch := $FFFF;„        exit„      end;„    PatSize := length(Pattern);„    Index1 := PatSize;„    Index2 := PatSize;„    repeat„      if (Buffer2[Index1] = Pattern[Index2]) then„        begin„          dec(Index1);„          dec(Index2)„        end„      else„        begin„          if (succ(PatSize - Index2) > (BMT[ord(Buffer2[Index1])])) then„            inc(Index1, succ(PatSize - Index2))„          else„            inc(Index1, BMT[ord(Buffer2[Index1])]);„          Index2 := PatSize„        end;„    until (Index2 < 1) or (Index1 > BuffSize);„    if (Index1 > BuffSize) then„      BMsearch := 0„    else„      BMsearch := succ(Index1)„  end;        (* BMsearch.                                            *)„„type„  arby_64K = array[1..65520] of byte;„„var„  Index   : word;„  st_Temp : string[10];„  Buffer  : ^arby_64K;„  BMT     : BMTable;„„BEGIN„  new(Buffer);„  fillchar(Buffer^, sizeof(Buffer^), 0);„  st_Temp := 'Gumby';„  move(st_Temp[1], Buffer^[65516], length(st_Temp));„  Create_BMTable(st_Temp, BMT);„  Index := BMSearch(Buffer^, sizeof(Buffer^), BMT, st_Temp);„  writeln(st_Temp, ' found at offset ', Index)„END.„                               - Guy„---„ ˛ DeLuxe˝/386 1.25 #5060 ˛„ * Rose Media, Toronto, Canada : 416-733-2285„ * PostLink(tm) v1.04  ROSE (#1047) : RelayNet(tm)„„                                                                                                                                                                                           2      05-28-9313:46ALL                      SWAG SUPPORT TEAM        BMSEARCH.PAS             IMPORT              31          { Default Compiler Directives}„{$S-,R-,V-,I-,N-,B-,F-}„„{$IFNDEF Ver40}„  {Allow overlays}„  {$F+,O-,X+,A-}„{$ENDIF}„„UNIT SEARCH;„„INTERFACE„„function SearchBuffer(var Buffer; BufLength : Word;„                      var Match; MatLength : Word) : Word;„ {-Search through Buffer for Match. BufLength is length of range to search.„   MatLength is length of string to match. Returns number of bytes searched„   to find Match, $FFFF if not found.}„„IMPLEMENTATION„„  function SearchBuffer(var Buffer; BufLength : Word;„                  var Match; MatLength : Word) : Word;„   {-Search through Buffer for Match. BufLength is length of range to search.„     MatLength is length of string to match. Returns number of bytes searched„     to find Match, $FFFF if not found.}„  begin„    inline(„      $1E/                   {PUSH DS                 ;Save DS}„      $FC/                   {CLD                     ;Go forward}„      $C4/$7E/<Buffer/       {LES  DI,[BP+<Buffer]    ;ES:DI => Buffer}„      $89/$FB/               {MOV  BX,DI              ;BX = Ofs(Buffer)}„      $8B/$4E/<BufLength/    {MOV  CX,[BP+<BufLength] ;CX = Length of range to scan}„      $8B/$56/<MatLength/    {MOV  DX,[BP+<MatLength] ;DX = Length of match string}„      $85/$D2/               {TEST DX,DX              ;Length(Match) = 0?}„      $74/$24/               {JZ   Error              ;If so, we're done}„      $C5/$76/<Match/        {LDS  SI,[BP+<Match]     ;DS:SI => Match buffer}„      $AC/                   {LODSB                   ;AL = Match[1]; DS:SI => Match[2]}„      $4A/                   {DEC  DX                 ;DX = MatLength-1}„      $29/$D1/               {SUB  CX,DX              ;CX = BufLength-(MatLength-1)}„      $76/$1B/               {JBE  Error              ;Error if BufLength is less}„                             {;Search for first character in Match}„                             {Next:}„      $F2/$AE/               {REPNE SCASB             ;Search forward for Match[1]}„      $75/$17/               {JNE  Error              ;Done if not found}„      $85/$D2/               {TEST DX,DX              ;If Length = 1 (DX = 0) ...}„      $74/$0C/               {JZ   Found              ; the "string" was found}„                             {;Search for remainder of Match}„      $51/                   {PUSH CX                 ;Save CX}„      $57/                   {PUSH DI                 ;Save DI}„      $56/                   {PUSH SI                 ;Save SI}„      $89/$D1/               {MOV  CX,DX              ;CX = Length(Match) - 1}„      $F3/$A6/               {REPE CMPSB              ;Does rest of string match?}„      $5E/                   {POP  SI                 ;Restore SI}„      $5F/                   {POP  DI                 ;Restore DI}„      $59/                   {POP  CX                 ;Restore CX}„      $75/$EC/               {JNE  Next               ;Try again if no match}„                             {;Calculate number of bytes searched and return}„                             {Found:}„      $4F/                   {DEC  DI                 ;DX = Offset where found}„      $89/$F8/               {MOV  AX,DI              ;AX = Offset where found}„      $29/$D8/               {SUB  AX,BX              ;Subtract starting offset}„      $EB/$03/               {JMP  SHORT SDone        ;Done}„                             {;Match was not found}„                             {Error:}„      $31/$C0/               {XOR  AX,AX              ;Return $FFFF}„      $48/                   {DEC  AX}„                             {SDone:}„      $1F/                    {POP  DS                 ;Restore DS}„      $89/$46/<SearchBuffer); {MOV [BP+<Search],AX     ;Set func result}„  end;„„END.                                                                                                                          3      05-28-9313:46ALL                      SWAG SUPPORT TEAM        BMSRCH.PAS               IMPORT              30          {$A+,B-,D-,E+,F-,I-,L-,N-,O-,R-,S-,V-}„Unit BMSrch;„„Interface„„Type„  Btable = Array[0..255] of Byte;„„Procedure BMMakeTable(Var s; Var t : Btable);„Function BMSearch(Var buff; size : Word; Bt: Btable; Var st): Word;„Function BMSearchUC(Var buff; size : Word; Bt: Btable; Var st): Word;„„Implementation„„Procedure BMMakeTable(Var s; Var t : Btable);„  { Makes a Boyer-Moore search table. s = the search String t = the table }„  Var„    st  : Btable Absolute s;„    slen: Byte Absolute s;„    x   : Byte;„  begin„    FillChar(t,sizeof(t),slen);„    For x := slen downto 1 do„      if (t[st[x]] = slen) then„        t[st[x]] := slen - x„  end;„„Function BMSearch(Var buff; size : Word; Bt: Btable; Var st): Word;„  { Not quite a standard Boyer-Moore algorithm search routine }„  { To use:  pass buff as a dereferenced Pointer to the buffer}„  {          st is the String being searched For              }„  {          size is the size of the buffer                   }„  { If st is not found, returns $ffff                         }„  Var„    buffer : Array[0..65519] of Byte Absolute buff;„    s      : Array[0..255] of Byte Absolute st;„    len    : Byte Absolute st;„    s1     : String Absolute st;„    s2     : String;„    numb,„    x      : Word;„    found  : Boolean;„  begin„    s2[0] := chr(len);       { sets the length to that of the search String }„    found := False;           „    numb := pred(len);„    While (not found) and (numb < (size - len)) do begin„      if buffer[numb] = ord(s1[len]) then { partial match } begin„        if buffer[numb-pred(len)] = ord(s1[1]) then { less partial! } begin„          move(buffer[numb-pred(len)],s2[1],len);„          found := s1 = s2;                   { if = it is a complete match }„          BMSearch := numb - pred(len);       { will stick unless not found }„        end;„        inc(numb);                 { bump by one Char - match is irrelevant }„      end„      else„        inc(numb,Bt[buffer[numb]]);„    end;„    if not found then„      BMSearch := $ffff;„  end;  { BMSearch }„„ „Function BMSearchUC(Var buff; size : Word; Bt: Btable; Var st): Word;„  { Not quite a standard Boyer-Moore algorithm search routine }„  { To use:  pass buff as a dereferenced Pointer to the buffer}„  {          st is the String being searched For              }„  {          size is the size of the buffer                   }„  { If st is not found, returns $ffff                         }„  Var„    buffer : Array[0..65519] of Byte Absolute buff;„    chbuff : Array[0..65519] of Char Absolute buff;„    s      : Array[0..255] of Byte Absolute st;„    len    : Byte Absolute st;„    s1     : String Absolute st;„    s2     : String;„    numb,„    x      : Word;„    found  : Boolean;„  begin„    s2[0] := chr(len);       { sets the length to that of the search String }„    found := False;           „    numb := pred(len);„    While (not found) and (numb < (size - len)) do begin„      if UpCase(chbuff[numb]) = s1[len] then { partial match } begin„        if UpCase(chbuff[numb-pred(len)]) = s1[1] then { less partial! } begin„          move(buffer[numb-pred(len)],s2[1],len);„          For x := 1 to length(s2) do„            s2[x] := UpCase(s2[x]);„          found := s1 = s2;                   { if = it is a complete match }„          BMSearchUC := numb - pred(len);     { will stick unless not found }„        end;„        inc(numb);                 { bump by one Char - match is irrelevant }„      end„      else„        inc(numb,Bt[ord(UpCase(chbuff[numb]))]);„    end;„    if not found then„      BMSearchUC := $ffff;„  end;  { BMSearchUC }„„end.„                                                                                                            4      05-28-9313:46ALL                      SWAG SUPPORT TEAM        BOYER.PAS                IMPORT              29          „              (* Public-domain demo of Boyer-Moore search algorithm.  *)„              (* Guy McLoughlin - May 2, 1993.                        *)„program DemoBMSearch;„„„              (* Boyer-Moore index-table data definition.             *)„type„  BMTable  = array[0..255] of byte;„„„  (***** Create a Boyer-Moore index-table to search with.             *)„  (*                                                                  *)„  procedure Create_BMTable({output} var       BMT : BMTable;„                           {input }       Pattern : string;„                                        ExactCase : boolean);„  var„    Index : byte;„  begin„    fillchar(BMT, sizeof(BMT), length(Pattern));„    if NOT ExactCase then„      for Index := 1 to length(Pattern) do„        Pattern[Index] := upcase(Pattern[Index]);„    for Index := 1 to length(Pattern) do„      BMT[ord(Pattern[Index])] := (length(Pattern) - Index)„  end;        (* Create_BMTable.                                      *)„„„  (***** Boyer-Moore Search function. Returns 0 if string is not      *)„  (*     found. Returns 65,535 if BufferSize is too large.            *)„  (*     ie: Greater than 65,520 bytes.                               *)„  (*                                                                  *)„  function BMsearch({input } var BMT       : BMTable;„                             var Buffer;„                                 BuffSize  : word;„                                 Pattern   : string;„                                 ExactCase : boolean) : {output} word;„  var„    Buffer2 : array[1..65520] of char absolute Buffer;„    Index1,„    Index2,„    PatSize : word;„  begin„    if (BuffSize > 65520)  then„      begin„        BMsearch := $FFFF;„        exit„      end;„    PatSize := length(Pattern);„    if NOT ExactCase then„      begin„        for Index1 := 1 to BuffSize do„          if  (Buffer2[Index1] > #96)„          and (Buffer2[Index1] < #123) then„            dec(Buffer2[Index1], 32);„        for Index1 := 1 to length(Pattern) do„          Pattern[Index1] := upcase(Pattern[Index1])„      end;„    Index1 := PatSize;„    Index2 := PatSize;„    repeat„      if (Buffer2[Index1] = Pattern[Index2]) then„        begin„          dec(Index1);„          dec(Index2)„        end„      else„        begin„          if (succ(PatSize - Index2) > (BMT[ord(Buffer2[Index1])])) then„            inc(Index1, succ(PatSize - Index2))„          else„            inc(Index1, BMT[ord(Buffer2[Index1])]);„          Index2 := PatSize„        end;„    until (Index2 < 1) or (Index1 > BuffSize);„    if (Index1 > BuffSize) then„      BMsearch := 0„    else„      BMsearch := succ(Index1)„  end;        (* BMsearch.                                            *)„„type„  arby_64K = array[1..65520] of byte;„„var„  Index   : word;„  st_Temp : string[20];„  Buffer  : ^arby_64K;„  BMT     : BMTable;„„BEGIN„  new(Buffer);„  fillchar(Buffer^, sizeof(Buffer^), 0);„  st_Temp := 'aBcDeFgHiJkLmNoPqRsT';„  move(st_Temp[1], Buffer^[65501], length(st_Temp));„  st_Temp := 'AbCdEfGhIjKlMnOpQrSt';„  Create_BMTable(BMT, st_Temp, false);„  Index := BMSearch(BMT, Buffer^, sizeof(Buffer^), st_Temp, false);„  writeln(st_Temp, ' found at offset ', Index)„END.„                               - Guy„---„ ˛ DeLuxe˝/386 1.25 #5060 ˛„ * Rose Media, Toronto, Canada : 416-733-2285„ * PostLink(tm) v1.04  ROSE (#1047) : RelayNet(tm)„„                                                                                                                                                                                            5      05-28-9313:46ALL                      SWAG SUPPORT TEAM        CHGE.PAS                 IMPORT              103         Program Chge;„„{ Copyright 1990 Trevor J Carlsen Version 1.06  24-07-90                    }„{ This Program may be used and distributed as if it was in the Public Domain}„{ With the following exceptions:                                            }„{    1.  If you alter it in any way, the copyright notice must not be       }„{        changed.                                                           }„{    2.  If you use code excerpts in your own Programs, due credit must be  }„{        given, along With a copyright notice -                             }„{        "Parts Copyright 1990 Trevor J Carlsen"                            }„{    3.  No Charge may be made For any Program using code from this Program.}„„{ Changes (or deletes) a String in any File. If an .EXE or .COM File then  }„{ the change must be of a similar length inorder to retain the executable  }„{ integrity.                                                               }„„{ If you find this Program useful here is the author's contact address -   }„„{      Trevor J Carlsen                                                    }„{      PO Box 568                                                          }„{      Port Hedland Western Australia 6721                                 }„{      Voice 61 [0]91 72 2026                                              }„{      Data  61 [0]91 72 2569                                              }„„Uses„  BmSrch,„  Dos;„„Const„  space       = #32;„  quote       = #34;„  comma       = #44;„  copyright1  = 'CHGE - version 1.06 Copyright 1989,1990 Trevor Carlsen';„  copyright2  = 'All rights reserved.';„„Var„  dirinfo     : SearchRec; { Dos }„  f           : File;„  FDir        : DirStr;    { Dos }„  mask,„  fname,„  oldstr,„  newstr      : String;„  oldlen      : Byte Absolute oldstr;„  newlen      : Byte Absolute newstr;„  changes     : Word;„  time        : LongInt Absolute $0000:$046C;„  start       : LongInt;„„Function ElapsedTime(start : LongInt): Real;„  begin„    ElapsedTime := (time - start) / 18.2;„  end; { ElapsedTime }„„Procedure ReportError(e : Byte);„begin„  Writeln('CHGE [path]Filename searchstr replacementstr|NUL');„  Writeln(' eg:  CHGE c:\autoexec.bat "color" "colour"');„  Writeln('      CHGE c:\autoexec.bat 12 13,10,13,10,13,10,13,10');„  Writeln('      CHGE c:\wp\test.txt "Trevor" NUL');„  Writeln;„  Writeln('The first example will change every occurrence of the Word "color" to "colour"');„  Writeln('The second will replace every formfeed Character (ascii 12) With 4 sets of');„  Writeln('carriage return/linefeed combinations and the third will delete every');„  Writeln('occurrence of "Trevor"');„  Writeln('The prime requirements are:');„  Writeln('  There MUST always be exactly three space delimiters on the command line -');„  Writeln('  one between the Program name and the Filename, one between the Filename and');„  Writeln('  the search String and another between the search String and the replacement');„  Writeln('  String. Any other spaces may ONLY occur between quote Characters.');„  Writeln('  The Program will not permit you to change the length of an .EXE or .COM File,');„  Writeln('  therefore the replacement String MUST be the same length as the String');„  Writeln('  that it is replacing in these cases.');„  Writeln;„  Writeln('  If using ascii codes, each ascii Character must be separated from another');„  Writeln('  by a comma. The same rule applies to spaces as above - three required - no');„  Writeln('  more - no less. If just deleting the NUL must not be in quotes.');„  halt(e);„end; { ReportError }„„Function StUpCase(Str : String) : String;„Var„  Count : Integer;„begin„  For Count := 1 to Length(Str) do„    Str[Count] := UpCase(Str[Count]);„  StUpCase := Str;„end;„„Procedure ParseCommandLine;„Var„  parstr,                                      { contains the command line }„  temp      : String;„  len       : Byte Absolute parstr;           { the length Byte For parstr }„  tlen      : Byte Absolute temp;               { the length Byte For temp }„  CommaPos,„  QuotePos,„  SpacePos,„  chval     : Byte;„  error     : Integer;„  DName     : NameStr;„  DExt      : ExtStr;„„  Function right(Var s; n : Byte): String;{ Returns the n right portion of s }„  Var„    st : String Absolute s;„    len: Byte Absolute s;„  begin„    if n >= len then„      right := st„    else„      right := copy(st,succ(len)-n,n);„  end; { right }„„begin„  parstr        := String(ptr(PrefixSeg,$80)^);     { Get the command line }„  if parstr[1]   = space then„    delete(parstr,1,1);               { First Character is usually a space }„  SpacePos      := pos(space,parstr);„  if SpacePos    = 0 then                                      { No spaces }„    ReportError(1);„  mask          := StUpCase(copy(parstr,1,pred(SpacePos)));„  FSplit(mask,Fdir,DName,DExt);       { To enable the directory to be kept }„  delete(parstr,1,SpacePos);„  QuotePos      := pos(quote,parstr);„  if QuotePos   <> 0 then begin          { quotes - so must be quoted Text }„    if parstr[1] <> quote then               { so first Char must be quote }„      ReportError(2);„    delete(parstr,1,1);                       { get rid of the first quote }„    QuotePos    := pos(quote,parstr);            { and find the next quote }„„    if QuotePos  = 0 then                    { no more - so it is an error }„      ReportError(3);„    oldstr    := copy(parstr,1,pred(QuotePos));{ search String now defined }„    if parstr[QuotePos+1] <> space then            { must be space between }„      ReportError(1);„    delete(parstr,1,succ(QuotePos));             { the quotes - else error }„    if parstr[1] <> quote then begin                     { may be a delete }„      tlen      := 3;„      move(parstr[1],temp[1],3);„      if temp <> 'NUL' then                              { is not a delete }„        ReportError(4)                  { must be quote after space or NUL }„      else„        newlen  := 0;               { is a delete - so nul the replacement }„    end„    else begin„      delete(parstr,1,1);                           { get rid of the quote }„      QuotePos   := pos(quote,parstr); { find next quote For end of String }„      if QuotePos = 0 then                            { None? - then error }„        ReportError(5);„      newstr := copy(parstr,1,pred(QuotePos));{ Replacement String defined }„    end;„  end„  else begin                                   { must be using ascii codes }„    oldlen       := 0;„    SpacePos     := pos(space,parstr);     { Find end of search Characters }„    if SpacePos   = 0 then                           { No space - so error }„      ReportError(6);„    temp         := copy(parstr,1,SpacePos-1);„    delete(parstr,1,SpacePos);          { get rid of the search Characters }„    CommaPos     := pos(comma,temp);                    { find first comma }„    if CommaPos   = 0 then             { No comma - so only one ascii code }„      CommaPos   := succ(tlen);„    Repeat                                      { create the search String }„      val(copy(temp,1,CommaPos-1),chval,error); { convert to a numeral and }„      if error <> 0 then                   { if there is an error bomb out }„        ReportError(7);„      inc(oldlen);„      oldstr[oldlen] := Char(chval);{ add latest Char to the search String }„      delete(temp,1,CommaPos);„      CommaPos   := pos(comma,temp);„      if CommaPos = 0 then„        CommaPos := succ(tlen);„    Until tlen = 0;„    newlen       := 0;„    CommaPos     := pos(comma,parstr);„    if CommaPos   = 0 then„      CommaPos   := succ(len);„    Repeat                                 { create the replacement String }„      val(copy(parstr,1,pred(CommaPos)),chval,error);„      if error <> 0 then                              { must be ascii code }„        ReportError(8);„      inc(newlen);„      newstr[newlen] := Char(chval);„      delete(parstr,1,CommaPos);„      CommaPos   := pos(comma,parstr);„      if CommaPos = 0 then CommaPos := len+1;„    Until len = 0;„  end; { else }„  if ((right(mask,3) = 'COM') or (right(mask,3) = 'EXE')) and„    (newlen <> oldlen) then„    ReportError(16);„end; { ParseCommandLine }„„Function OpenFile(fn : String): Boolean;„  begin„    assign(f,fn);„    {$I-} reset(f,1); {$I+}„    OpenFile := IOResult = 0;„  end; { OpenFile }„„Procedure CloseFile;„  begin„    {$I-}„    truncate(f);„    Close(f);„    if IOResult <> 0 then;                          { dummy call to IOResult }„    {$I+}„  end; { CloseFile }„„Procedure ChangeFile(Var chge : Word);„  Const„    bufflen     = 65000;                    { This is the limit For BMSearch }„    searchlen   = bufflen - 1000;      { Allow space For extra Characters in }„  Type                                              { the replacement String }„    buffer      = Array[0..pred(bufflen)] of Byte;„    buffptr     = ^buffer;„  Var„    table       : BTable;                         { Boyer-Moore search table }„    old,                                             { Pointer to old buffer }„    nu          : buffptr;                           { Pointer to new buffer }„    count,„    result,„    oldpos,„    newpos      : Word;„    oldfpos,„    newfpos     : LongInt;„    finished    : Boolean;„„  Procedure AllocateMemory(Var p; size : Word);„    Var„      buff : Pointer Absolute p;„    begin„      if MaxAvail >= size then„        GetMem(buff,size)„      else begin„        Writeln('Insufficient memory available.');„        halt(10);„      end;„    end; { AllocateMemory }„„  begin„    oldfpos := 0; newfpos := 0;„    chge := 0;„    AllocateMemory(old,searchlen);„    AllocateMemory(nu,bufflen);      { make room on the heap For the buffers }„    BMMakeTable(oldstr,table);           { Create a Boyer-Moore search table }„    {$I-}„    BlockRead(f,old^,searchlen,result);                    { Fill old buffer }„    oldfpos := FilePos(f);„    {$I+}„    if IOResult <> 0 then begin„      CloseFile; ReportError(11);„    end;„    Repeat„      oldpos := 0; newpos := 0; count := 0;„      finished := (result < searchlen); { if buffer<>full then no more reads }„      Repeat                              { Do a BM search For search String }„        count := BMSearch(old^[oldpos],result-oldpos,table,oldstr);„        if count = $FFFF then begin   { search String not found so copy rest }„          move(old^[oldpos],nu^[newpos],result-oldpos);   { of buffer to new }„          inc(newpos,result-oldpos);  { buffer and update the buffer markers }„          inc(oldpos,result-oldpos);„        end„        else begin                                     { search String found }„          if count <> 0 then begin       { not at position one in the buffer }„            move(old^[oldpos],nu^[newpos],count);{ transfer everything prior }„            inc(oldpos,count);          { to the search String to new buffer }„            inc(newpos,count);               { and update the buffer markers }„          end;„          move(newstr[1],nu^[newpos],newlen);  { copy the replacement String }„          inc(oldpos,oldlen);        { to the new buffer and update the buffer }„          inc(newpos,newlen);                                      { markers }„          inc(chge);„        end;„      Until oldpos >= result;               { keep going Until end of buffer }„      if not finished then begin       { Fill 'er up again For another round }„        {$I-}„        seek(f,oldfpos);„        BlockRead(f,old^,searchlen,result);„        oldfpos := FilePos(f);„        {$I+}„        if IOResult <> 0 then begin„          CloseFile; ReportError(13);„        end; { if IOResult }„      end; { if not finished }„      {$I-}„      seek(f,newfpos);„      BlockWrite(f,nu^,newpos);                   { Write new buffer to File }„      newfpos := FilePos(f);„      {$I+}„      if IOResult <> 0 then begin„        CloseFile; ReportError(12);„      end;„    Until finished;„    FreeMem(old, searchlen); FreeMem(nu,bufflen);„  end;  { ChangeFiles }„„Procedure Find_and_change_all_Files;„  Var„    Filefound : Boolean;„„  Function padstr(ch : Char; len : Byte): String;„  „    Var„      temp : String;„    „    begin„      FillChar(temp[1],len,ch);„      temp[0] := chr(len);„      padstr  := temp;„    end; { padstr }„„  begin„    Filefound := False;„    FindFirst(mask,AnyFile,dirinfo);„    While DosError = 0 do begin„      Filefound := True;„      start := time;„      fname := FDir + dirinfo.name;„      if OpenFile(fname) then begin„        Write(fname,PadStr(space,30-length(fname)),FileSize(f):7,'  ');„        ChangeFile(changes);„        CloseFile;„        if changes = 0 then„          Writeln„        else„          Writeln('Made ',changes,' changes in ',ElapsedTime(start):4:2,' seconds.')„      end„      else„        Writeln('Unable to process ',fname);„      FindNext(dirinfo);„    end; { While DosError = 0 }„    if not Filefound then„      Writeln('No Files found.');„  end; { Find_and_change_all_Files }„„begin { main }„  Writeln(copyright1);„  Writeln(copyright2);„  ParseCommandLine;„  Find_and_change_all_Files;„end.„„                 6      05-28-9313:46ALL                      SWAG SUPPORT TEAM        FINDDATA.PAS             IMPORT              11          {   Following is some code I've thrown together <!>, which has to find a„sequence of 4 Characters in a large buffer - non-Text data.  The buffer„is 4096 Characters, and the sequence(s) I'm searching For could be„anywhere in it, and may be found numerous times. I suspect this code is„pretty inefficient, but I can't think of anything better. (Yep, this is„to work With the ZIP directory at the end of the File...)„   So, I'm looking For a better way to code this process.  I know that„Pos won't work, so this brute-Force is what I came up with.  Anything„better?  Thanks...„}„Const CFHS : String[4] = 'PK'#01#02;  { CENTRAL_File_HEADER_SIGNATURE }„      ECDS : String[4] = 'PK'#05#06; { end_CENTRAL_DIRECtoRY_SIGNATURE }„Var S4     : String[4];„    FOUND  : Boolean;„    QUIT   : Boolean;      { "end" sentinel encountered }„begin„  FETCH_NAME; Assign (F,F1); Reset (F,1); C := 1; HSize := 0;„  FSize := FileSize(F);„  I := FSize-BSize;                   { Compute point to start read }„  Seek (F,I); BlockRead (F,BUFF,BSize,RES); { ZIP central directory }„  S4[0] := #4; C := 0;„  Repeat„    FOUND := False; { search For CENTRAL_File_HEADER_SIGNATURE }„    Repeat„      Inc (C); Move (BUFF[C],S4[1],4); FOUND := S4 = CFHS;„      QUIT := S4 = ECDS;„    Until FOUND or QUIT;„end.  7      05-28-9313:46ALL                      SWAG SUPPORT TEAM        FINDDUPL.PAS             IMPORT              23          {„TRAVIS GRIGGS„„> I have one question For you in return: could you send the current„> source code of your Program, or could you otherwise describe what„> your input Text File Characterizations are (how big can the File be,„> how long can the lines be, do you scan each line, or only taglines,„„Here's the code.  Don't worry about the structure of it.  I know it is bad but„this was a quick and dirty little util I wrote up that I needed.  Have fun With„it and try to speed it up.  And whoever else wants to help have fun!„„I hope this compiles I took out some stuff that would display a little picture„of a sWord and show the version and product name.  I also tried DJ's idea of„the buffer of 65535 but it said the structure was too large. So I used 64512.„}„Uses Crt;„Type„  BBT  = Array[0..64512] of Char;„„Var„  BUFF        : ^BBT;„  TheFile,„  logFile     : Text;„  Looking,„  TempStr     : String[80];„  Numoflines,„  F, J, Point : LongInt;„  Divi, Multi : Real;„„Procedure Stop;„begin„  Close(TheFile);„  Close(LogFile);„  Halt(1);„end;„„Procedure CommandError(Err:  Byte);„begin„  TextColor(10);„  Case Err Of„    2 : WriteLn('You must specify a File on the command line.');„    3 : WriteLn('Can''t find "', ParamStr(1),'"');„    4 : WriteLn('Too many open Files to open ', ParamStr(1));„    5 : WriteLn('Error in reading ', ParamStr(1));„  end; { end total Case }„  WriteLn;„  Halt(1);„end; { end Procedure }„„begin„  if Paramcount < 1 Then„    CommandError(2);„  ClrScr;„  Assign(TheFile,ParamStr(1));„  New(BUFF);„  SetTextBuf(TheFile,BUFF^);„  Assign(LogFile,'FINDDUPE.LOG');„  ReWrite(LogFile);„  Reset(TheFile);„  Case IoResult Of„    2 : CommandError(3);„    4 : CommandError(4);„    3,5..162 : CommandError(5);„  end;„  While not EOF(TheFile) Do„  begin„    Readln(TheFile);„    Inc(Numoflines);„  end;„  Writeln('There are ',Numoflines,' lines in this File.');„  Writeln;„  Writeln('Duplicate lines are being written to FINDDUPE.LOG');„  Writeln;„  Writeln('Press any key to stop the search For duplicate lines');„  Point := 0;„  Reset(TheFile);„  While Point <> Numoflines Do„  begin„    GotoXY(1, 7);„    if Point <> 0 Then„    begin„      Divi  := Point / Numoflines;„      Multi := Divi * 100;„      WriteLn(Multi : 3 : 2, '% Completed');„    end;„    Reset(TheFile);„    if Point <> 0 Then„      For J := 1 to Point Do„        Readln(TheFile);„    Readln(TheFile,Looking);„    Reset(TheFile);„    Inc(Point);„    For F := 1 to Numoflines Do„    begin„      if KeyPressed then„        Stop;„      Readln(TheFile, TempStr);„      if (Point <> F) and (TempStr = Looking) Then„        Writeln(LogFile,Looking);„    end;„  end;„  GotoXY(1, 7);„  Writeln('100.00% Completed');„  Close(TheFile);„  Close(LogFile);„end.„                                                                                  8      05-28-9313:46ALL                      SWAG SUPPORT TEAM        FINDTEXT.PAS             IMPORT              11          {„> I need help on making a Search Procedure in TURBO PASCAL.„> what I want it to do is to open the contents in a Text File„> search For a given String. and diplay that Record or line With that„> given String!!!„„Here is a Program that will search a Text File and display the lines„of Text With the search String in it.„}„„Program Search;„Type„  BigString = String[132];„Var„  FileName: String[14];„  FileVar: Text;„  LineNumber: Integer;„  OneLine, Temporary, SubString: BigString;„„{ Make all Chars in S upper case}„Procedure UpperCase(Var S: BigString);„Var„  I: Integer;„begin„  For I := 1 to Length(S) do„    S[I] := Upcase(S[I]);„end;„„begin„  Write('Search what Text File? ');„  Readln(FileName);„  Assign(FileVar, FileName);„  Repeat„    Writeln;„    Reset(FileVar);„    Write('Search for? (Enter to quit) ');„    Readln(SubString);„    if Length(SubString) > 0 then„    begin„      UpperCase(SubString);„      LineNumber := 0;„      While not Eof(FileVar) do„      begin„        Readln(FileVar, OneLine);„        Inc(LineNumber);„        Temporary := OneLine;„        UpperCase(Temporary);„        if Pos(SubString, Temporary) >0„          Then Writeln(LineNumber:3, ': ', OneLine)„      end„    end„  Until Length(SubString) = 0„end.„                                    9      05-28-9313:46ALL                      SWAG SUPPORT TEAM        NEXTCHAR.PAS             IMPORT              13          {„Duncan Murdoch„„>var„>  TextFile: Text;„>  NextChar: Char;„>...„>begin„>...„>  with TextRec(TextFile) do  NextChar:= Buffer[BufPos];„„Careful!  This is unreliable, because the Buffer could be empty.  You should„check that there's something there, and fill it if not.„„Here's my NextChar routine.  BTW, I don't like the DOS unit's declaration of„TextRec, so I wrote my own.„}„„type„  IOFunc = function(var Source:text): Integer;„  TTextBuf = array[0..127] of char;„  PTextBuf = ^TTextBuf;„  TextRec = record„    Handle: Word;„    Mode: Word;„    BufSize: Word;„    Private: Word;„    BufPos: Word;„    BufEnd: Word;„    BufPtr: PTextBuf;„    OpenFunc: IOFunc;„    InOutFunc: IOFunc;„    FlushFunc: IOFunc;„    CloseFunc: IOFunc;„    UserData: array[1..16] of Byte;„    Name: array[0..79] of Char;„    Buffer: TTextBuf;„  end;„„function NextChar(var Source: text):char;„begin„  NextChar := chr(0);        { This is the default value in case of„                               error }„  with TextRec(Source) do„  begin„    if BufPos >= BufEnd then„      { Buffer empty; need to fill it }„      InOutRes := InOutFunc(Source);   { This sets the System error„                                         variable InOutRes; other than„                                         that, it ignores errors. }„    NextChar := BufPtr^[BufPos]      { A test here of whether a„                                       a character was available„                                       would be a good idea }„  end;„end;„                                        10     05-28-9313:46ALL                      SWAG SUPPORT TEAM        NICECODE.PAS             IMPORT              113         (*„>Does anyone know of a utility Program that will apply some sort of„>reasonable structuring to a pascal source File?„„I'm not sure if it's what you want, but the source For a Pascal„reFormatter, etc, was entered in the Fidonet PASCAL Programming„Competition, and came third (I came second!!).„„As you can see by the File dates, this is a very recent thing and„since it is Nearly too late I toyed With the idea of just keeping it„to myself.  It certainly is not an example of inspired Programming.„But then, I thought, if everyone felt that way you'd have nothing to„chose from and even if this is not a prize winner, mayby someone„else will find it useful.„„So here it is...  not extensively tested, but I couldn't find any„bugs.  Used Pretty to reFormat itself and it still Compiled and„worked.  Anyway, the only possible use is to another Turbo Pascal„Programmer who shouldn't have any difficult modifying to suit„himself.  They'd probably do that anyway since the output represents„my own peculiar notion as to what a readable Format should be.„„'Pretty Printers' date back to the earliest Computer days and„Variations existed For just about any language.  However, I've been„unable to find a current one For Turbo Pascal.„„Here's what this one does:„„Pretty With no parameters generates a syntax message.„„Input is scanned line-by-line, Word-by-Word and Byte-by-Byte.  Any„identifiers recognized as part of TP's language are replaced by„mixed Case (in a style which _I_ like).  Someone else can edit„Constants Borland1 through Borland5 and TP3.  (Why TP3 later.)  The„first one on a line is capitalized anyway.„„A fallout of this is to use selected ones to determine indentation„in increments of 'IndentSpcs' which I arbitrarily set to 3.  Change„if you like. Indentation is incremented whenever one of the„'IndentIDs' appears and decremented With 'UnindentIDs' (surprise!).„„Single indents are also provided For 'SectionIDs' (Const, Type,„Uses, Var) and For 'NestIDs' (Procedure Function) to make these more„visible.  White space is what does it, right?„„On the other hand, no attempt is made to affect white space in the„vertical direction.  Since that generally stays the way you„originate it.„„Any '{', '(' or '''' (Single quote) detected during the line scan„trigger a 'skipit' mode which moves the enclosed stuff directly to„output, unmodified. With one exception.  {Comments} which begin a„line are aligned to the left margin (where I like to see Compiler„directives and one line Procedure/Function explanations).  Other„{Comments} which begin/end on the same line are shifted so the '}'„aligns at the (80th column) right margin.  I think this makes them„more visible than when snuggled up to a semi-colon and getting them„away from the code makes it more legible, too.„„and it did look better originally when it used some of my personal„Units. Hastily modified to stand alone.  There are, no doubt, some„obvious ways the Programming can be improved (you would probably„have used some nice hash tables to look up key Words) but, as I say,„I thought I would be the only one using this and speed in this Case„is not all that important.„„With one exception.  Something I worked up For an earlier„application and may be worth looking at -- 'LowCase'.„„It will Compile With TP4-TP5.5 and probably TP6 (if it still„supports Inline). I included TP3 stuff because some of the old„software I was looking at was written in it.  and it recognizes„Units in a clumsy sort of way.„„Switching to chat mode here.  if you're Really busy, you can skip the„following.„„This thing actually began as a 'Case-converter'.  I was trying to„avoid re-inventing some wheels by re-working some old Pascal source„dating back to the late 70's and 80's.  Upper Case Programs became a„'standard' back in the days when you talked to main frames through a„teleType machine, which has no lower Case.  Sadly, this persisted„long after it was no longer necessary and I find those„all-upper-Case Programs almost unreadable.  That is I can't find„what I'm looking For.  They were making me crazy.  (BTW I suspect„some of this has to do With why Pascal has UpCase but no LoCase.)„„I stole the orginal LowCase included here from someone who had done„the intuitive thing -- first test For 'A', then For 'Z'.  Changing„to an initial test For 'Z' does two things.  A whopping 164 of the„255 possible Characters can be eliminated With just one test and,„since ordinary Text consists of mostly lower Case, these will be„passed over rapidly.„„When you received this you thought, "Who the heck is Art Weller?  I„don't remember him on the Pascal Echo."  Right.  I'm a 'lurker'!„Been reading the echo since beFore it had a moderator.  (Now we have„an excellent one.  Thank you.) I have a machine on a timer which„calls the BBS each morning to read and store several echos which I„read later.  Rarely get inspired enough to call back and enter a„discussion.  Things usually get resolved nicely without me.  I„especially don't want to get involved in such as the 'Goto' wars.„But I monitor the better discussions to enhance my TP skills.„„I'm not Really a Programmer (no Formal training, that is --„Computers hadn't been invented when I was in school!), but an„engineer.  I'm retired from White Sands Missile Range where I was„Chief of Plans and Programs For (mumble, mumble) years.  I„self-taught myself Computers when folks from our Analysis and„Computation Directorate started using jargon on me.  I did that well„enough to later help Write a book For people who wanted to convert„from BASIC to Pascal then after "retiring" was an editor For a small„Computer magazine (68 Micro-Journal).„„In summary, if you think this worth sharing With others I'll be„pleased enough even without a prize.  not even sure it will get„there in time.  Snail-Mail, you know.„*)„„Program Pretty;„{A 'Pretty Printer' For Turbo Pascal Programs}„{  This Program converts Turbo Pascal identifiers in a source code File to„   mixed Case and indents the code.„   Released into Public Domain June, 1992 on an 'AS IS' basis.  Enjoy at your„   own risk.„                                                    Art Weller„                                                    3217 Pagosa Court„                                                    El Paso, Texas  79904„                                                    U. S. A.„                                                    Ph. (915) 755-2516}„„{Uses„   Strings;}„„Const„   IndentSpcs = 3;„„   Borland1 =„   ' Absolute Addr and ArcTan Array Assign AuxInptr AuxOutptr BDos begin Bios '+„   ' BlockRead BlockWrite Boolean Buflen Byte Case Chain Char Chr Close ClrEol '+„   ' ClrScr Color Concat Const Copy Cos Delay Delete DelLine Dispose div do ';„   Borland2 =„   ' Downto Draw else end Eof Eoln Erase Execute Exp External False File '+„   ' FilePos FileSize FillChar Flush For Forward Frac Freemem Function Getmem '+„   ' Goto GotoXY Halt HeapPtr Hi HighVideo HiRes if Implementation in Inline ';„   Borland3 =„   ' Input Insert InsLine Int Integer Interface Intr IOResult KeyPressed '+„   ' Label Length Ln Lo LowVideo Lst Mark MaxAvail Maxint Mem MemAvail Memw Mod '+„   ' Move New Nil NormVideo not Odd of Ofs or Ord Output Overlay Packed ';„   Borland4 =„   ' Pallette Pi Plot Port Pos Pred Procedure Program Ptr Random Randomize Read '+„   ' ReadLn Real Record Release Rename Repeat Reset ReWrite Round Seek Seg Set '+„   ' Shl Shr Sin SizeOf Sound Sqr Sqrt Str String Succ Swap Text then to ';„   Borland5 =„   ' True Trunc Type Unit Until UpCase Uses UsrOutPtr Val Var While Window With '+„   ' Write WriteLn xor ';„   TP3 =„   ' AUX CONinPTR CON CONOUTPTR ConstPTR CrtEXIT CrtinIT ERRorPTR Kbd '+„   ' LStoUTPTR TRM USR USRinPTR ';„„   IndentIDs   = ' begin Case Const Record Repeat Type Uses Var ';„   UnIndentIDs = ' end Until ';„   SectionIDs  = ' Const Type Uses Var ';„   endSection  = ' begin Const Uses Var Function Implementation Interface '+„                 ' Procedure Type Unit ';„   NestIDs     = ' Function Procedure Unit ';„„   IDAlphas    = ['a'..'z', '1'..'0', '_'];„„Var„   Indent,„   endPend,„   Pending,„   UnitFlag       : Boolean;„   NestLevel,„   NestIndent,„   IndentNext,„   IndentNow,„   Pntr, LineNum  : Integer;„   IDs,„   InFile,„   OutFile,„   ProgWrd,„   ProgLine       : String;„   Idents,„   OutID          : Array [1..5] of String;„   f1, f2         : Text;„„Function  LowCase(Ch: Char): Char;„begin„  Inline(„   $8A/$86/>Ch/                          {      mov al,>Ch[bp]   ;Char to check}„   $3C/$5A/                              {      cmp al,'Z'                     }„   $7F/$06/                              {      jg  Done                       }„   $3C/$41/                              {      cmp al,'A'                     }„   $7C/$02/                              {      jl  Done                       }„   $0C/$20/                              {      or al,$20                      }„   $88/$86/>LowCase);                    {Done :mov >LowCase[bp],al            }„end;„„Function LowCaseStr(InStr : String): String;„Var„  i  : Integer;„  len: Byte Absolute InStr;„begin„  LowCaseStr[0] := Chr(len);„  For i := 1 to len do„  LowCaseStr[i] := LowCase(InStr[i]);„end;„„Function  Blanks(Count: Byte): String; {return String of 'Count' spaces}„Var„  Result: String;„begin„  FillChar(Result[1], Count+1, ' ');„  Result[0] := Chr(Count);„  Blanks := Result;„end;„„Procedure StripLeading(Var Str: String);  {remove all leading spaces}„begin„  While (Str[1] = #32) and (length(Str) > 0) do„    Delete(Str,1,1);„end;„„Procedure Initialize;„begin„  IDs := IndentIDs + UnIndentIDs + endSection;„  OutID[1] := Borland1;„  Idents[1] := LowCaseStr(OutID[1]);„  OutID[2] := Borland2;„  Idents[2] := LowCaseStr(OutID[2]);„  OutID[3] := Borland3;„  Idents[3] := LowCaseStr(OutID[3]);„  OutID[4] := Borland4;„  Idents[4] := LowCaseStr(OutID[4]);„  OutID[5] := Borland5 + TP3;„  Idents[5] := LowCaseStr(OutID[5]);„  Pending := False;„  UnitFlag := False;„  IndentNext := 0;„  IndentNow := 0;„  LineNum := 0;„  NestIndent := 0;„  NestLevel := 0;„end;„„Procedure Greeting;„begin„  Writeln;„  Writeln('Pascal Program Indenter');„  Writeln; Writeln;„  Writeln('SYNTAX:  INDENT InputFile OutPutFile');„  Writeln('         INDENT InputFile > OutPut');„  Writeln; Writeln;„  Halt(0);„end;„„Procedure OpenFiles;„begin„  if paramcount <> 0 then„  begin„    InFile := ParamStr(1);„    if (pos('.', InFile) = 0) then„      InFile := InFile + '.pas';„    OutFile := Paramstr(2);„  end„  else„    Greeting;„  Assign(f1, InFile);„  Reset(f1);„  Assign(f2, OutFile);„  ReWrite(f2);„end;„„Procedure GetWord;„Var„  i,„  index,„  TmpPtr,„  WrdPos   : Integer;„„  Procedure DecIndent;„  begin„    if (IndentNext > IndentNow) then   {begin/end on same line}„      Dec(IndentNext)„    else„    if IndentNow > 0 then„      dec(IndentNow);„    IndentNext := IndentNow;    {next line, too}„  end;„„begin„  ProgWrd := ' ';„  TmpPtr := Pntr;„„  While (LowCase(ProgLine[Pntr]) in IDAlphas) {Convert checked For LCase alpha}„        and (Pntr <= length(ProgLine)) do„  begin„    ProgWrd := ProgWrd + LowCase(ProgLine[Pntr]);„    Inc(Pntr);„  end;„„  ProgWrd := ProgWrd+' ';   {surrounded With blanks to make it unique!}„  index := 0;„„  Repeat;     {is it a Turbo Pascal Word?}„    inc(index);„    WrdPos := Pos(ProgWrd, Idents[index]);„  Until (WrdPos <> 0) or (index = 5);„„  if WrdPos <> 0 then   {found a Pascal Word}„  begin„    Move(OutID[index][WrdPos+1], ProgLine[TmpPtr], Length(ProgWrd)-2);„    if TmpPtr = 1 then„      ProgLine[1] := UpCase(ProgLine[1]);„„    if Pos(ProgWrd, IDs) <> 0 then  {only checked if a Pascal Word ^}„    begin„      if Pos(ProgWrd, endSection) <> 0 then  {this includes "SectionIDs"}„      begin                                      {and "NestIDs"}„        if (pos(ProgWrd, NestIDs) <> 0) then„        begin„          if ProgWrd = ' Unit ' then„            UnitFlag := True;„          if not UnitFlag then„            inc(NestLevel);„        end;„        if Pending then„          DecIndent;„        Pending := Pos(ProgWrd, SectionIDs) <> 0;„        if ProgWrd = ' Implementation ' then„          UnitFlag := False;„      end;„      if Pos(ProgWrd, IndentIDs) <> 0 then„        inc(IndentNext); {Indent 1 level}„      if Pos(ProgWrd, UnIndentIDs) <> 0 then„      begin„         DecIndent;   {Unindent 1 level}„         if (IndentNow = 0) and (NestLevel > 0) then„           dec(NestLevel);„      end;„      if NestLevel > 1 then„        NestIndent := 1;„    end;„  end;„end;„„Procedure Convert;„„  Procedure OutLine;„  Var„    Tabs : String[40];„  begin„    Tabs := Blanks((IndentNow+NestIndent) * IndentSpcs);„    if ProgLine[1] = '{' then„      Writeln(f2, ProgLine)„    else„      Writeln(f2, Tabs, ProgLine);„    IndentNow := IndentNext;   { get ready For next line }„    if NestLevel < 2 then„      NestIndent := 0;„  end;„„  Procedure Skipto(SearchChar: Char);„  begin„    Repeat„      if pntr > Length(ProgLine) then„      begin„        OutLine;„        Readln(f1, ProgLine);   {get another line}„        Pntr := 0;„      end;„      Inc(pntr);„    Until (ProgLine[pntr] = SearchChar) or Eof(f1);„  end;„„  Procedure MoveComments;„  Var„    TmpIndent : Integer;„  begin„    if (ProgLine[1] = '{') or (ProgLine[Pntr+1] = '$') then„    begin„      Skipto('}');„      Exit;„    end;„    TmpIndent := (IndentNow+NestIndent) * IndentSpcs;„    While Length(ProgLine) < 80-TmpIndent do„      Insert(' ', ProgLine, Pntr);„    While (pos('}', ProgLine) > 80-TmpIndent) and (pos(' {', ProgLine) > 1) do„    begin„      Delete(ProgLine, Pos(' {', ProgLine), 1);„      Dec(Pntr);„    end;„    Skipto('}');„  end;„„begin„  While not Eof(f1) do„  begin„    Readln(f1, ProgLine);„    StripLeading(ProgLine);„    if Length(ProgLine) = 0 then„      Writeln(f2)„    else„    begin„      Pntr := 1;„      Repeat„        Case LowCase(ProgLine[pntr]) of„          'a'..'z','_'  :  GetWord;„          '{'           :  MoveComments;„          '('           :  Skipto(')');„          #39           :  Skipto(#39)        {Single quote}„        end;„        Inc(pntr)„      Until (pntr >= length(ProgLine));„      OutLine;„    end;„  end;  { While }„  Close(f1); Close(f2);„end;„„begin„  Initialize;„  OpenFiles;„  Convert;„end.„                                                                                                  11     05-28-9313:46ALL                      SWAG SUPPORT TEAM        SEARCH.PAS               IMPORT              101         Program search;                                 „{$A+,B-,D-,E+,F-,I+,L-,N-,O-,R-,S-,V-}„{$M 16384,0,655360}„„„ { Copyright 1990 Trevor J Carlsen Version 1.05  24-07-90                    }„ { This Program may be used and distributed as if it was in the Public Domain}„ { With the following exceptions:                                            }„ {    1.  if you alter it in any way, the copyright notice must not be       }„ {        changed.                                                           }„ {    2.  if you use code excerpts in your own Programs, due credit must be  }„ {        given, along With a copyright notice -                             }„ {        "Parts Copyright 1990 Trevor J Carlsen"                            }„ {    3.  No Charge may be made For any Program using code from this Program.} „„ { SEARCH will scan a File or group of Files and report on all occurrences   }„ { of a particular String or group of Characters. if found the search String }„ { will be displayed along With the 79 Characters preceding it and the 79    }„ { Characters following the line it is in.  Wild cards may be used in the    }„ { Filenames to be searched.                                                 }„ „ { if you find this Program useful here is the author's contact address -    }          „         „ {      Trevor J Carlsen                                                     }          „ {      PO Box 568                                                           }          „ {      Port Hedland Western Australia 6721                                  }          „ {      Voice 61 [0]91 72 2026                                               }          „ {      Data  61 [0]91 72 2569                                               }          „„„ „Uses„  Dos,„  tpString,  { Turbo Power's String handling library.  Procedures and        }„             { Functions used from this Unit are -                           }„             {       BMSearch       THESE ARE in THE SOURCE\MISC DIRECtoRY   }„             {       BMSearchUC                                              }„             {       BMMakeTable                                             }„             {       StUpCase                                                }„  tctimer;   { A little timing routine - not needed if lines (**) removed.   }„  „Const„  bufflen     = 65000;  { Do not increase this buffer size . Ok to decrease. }„  searchlen   = bufflen;„  copyright1  = 'SEARCH - version 1.05 Copyright 1990 Trevor Carlsen';„  copyright2  = 'All rights reserved.';„„Type„  str79       = String[79];„  bufferType  = Array[0..bufflen] of Byte;„  buffptr     = ^bufferType;„„Const„  space       = #32;„  quote       = #34;„  comma       = #44;„  CaseSensitive : Boolean = True;       { default is a Case sensitive search }„Var„  table       : BTable;                           { Boyer-Moore search table }„  buffer      : buffptr;                             { Pointer to new buffer }„  f           : File;„  DisplayStr  : Array[0..3] of str79;„  Filename,„  SrchStr     : String;„  Slen        : Byte Absolute SrchStr;„  „Procedure Asc2Str(Var s, ns; max: Byte);„„  { Converts an Array of asciiz Characters to a turbo String                 }„  { For speed the Variable st is  effectively global and it is thereFore     }„  { vitally important that max is no larger than the ns unTyped parameter    }„  { Failure to ensure this can result in unpredictable Program behaviour     }„  „  Var stArray : Array[0..255] of Byte Absolute s;„      st      : String Absolute ns;„      len     : Byte Absolute st;„      „  begin„    move(stArray[0],st[1],max);„    len := max;„  end; { Asc2Str }„„Procedure ReportError(e : Byte);„  { Displays a simple instruction screen in the event of insufficient        }„  { parameters or certain other errors                                       }„  begin„    Writeln('SYNTAX:');„    Writeln('SEARCH [-c] [path]Filename searchstr');„    Writeln(' eg:  SEARCH c:\comm\telix\salt.doc "color"');„    Writeln(' or');„    Writeln('      SEARCH c:\comm\telix\salt.doc 13,10,13,10,13,10,13,10');„    Writeln(' or');„    Writeln('      SEARCH -c c:\*.* "MicroSoft"');„    Writeln;„    Writeln('if the -c option is used then a Case insensitive search is used.');„    Writeln('When used the -c option must be the first parameter.');„    halt(e);„  end; { ReportError }„„Procedure ParseCommandLine;„  { This Procedure is Really the key to everything as it parses the command  }„  { line to determine what the String being searched For is.  Because the    }„  { wanted String can be entered in literal Form or in ascii codes this will }„  { disect and determine the method used.                                    }„  „  Var„    parstr      : String;                        { contains the command line }„    len         : Byte Absolute parstr;{ will contain the length of cmd line }„    cpos, qpos,„    spos, chval : Byte;„    error       : Integer;„    „  begin { ParseCommandLine}„    parstr    := String(ptr(PrefixSeg,$80)^);         { Get the command line }„    if parstr[1] = space then„      delete(parstr,1,1);  { if the first Character is a space get rid of it }„    spos      := pos(space,parstr);                   { find the first space }„    if spos    = 0 then                   { No spaces which must be an error }„      ReportError(1);   „    „    Filename  := StUpCase(copy(parstr,1,spos-1));  { Filename used as a temp }„    if pos('-C',Filename) = 1 then begin  { Case insensitive search required }„      CaseSensitive := False;„      delete(parstr,1,spos);                   { Get rid of the used portion }„    end; { if pos('-C' }„    spos      := pos(space,parstr);                        { find next space }„    if spos    = 0 then                   { No spaces which must be an error }„      ReportError(1);                     „    Filename  := StUpCase(copy(parstr,1,spos-1));        { Get the File mask }„    delete(parstr,1,spos);                     { Get rid of the used portion }„    „    qpos      := pos(quote,parstr);          { look For the first quote Char }„    if qpos   <> 0 then begin    { quote Char found - so must be quoted Text }„      if parstr[1] <> quote then ReportError(2);  { first Char must be quote }„      delete(parstr,1,1);                       { get rid of the first quote }„      qpos      := pos(quote,parstr);              { and find the next quote }„      if qpos = 0 then ReportError(3);  { no more quotes - so it is an error }„      SrchStr   := copy(parstr,1,qpos-1);        { search String now defined }„    end  { if qpos <> 0 }„    „    else begin                                   { must be using ascii codes }„      Slen      := 0;     „      cpos      := pos(comma,parstr);                     { find first comma }„      if cpos = 0 then cpos := succ(len);{ No comma - so only one ascii code }„      Repeat                                      { create the search String }„        val(copy(parstr,1,pred(cpos)),chval,error);„        if error <> 0 then ReportError(7);   { there is an error so bomb out }„        inc(Slen);„        SrchStr[Slen] := Char(chval);        { add Char to the search String }„        delete(parstr,1,cpos);           { get rid of used portion of parstr }„        cpos  := pos(comma,parstr);                    { find the next comma }„        if cpos = 0 then cpos := succ(len);    { no more commas so last Char }„      Until len = 0;              { Until whole of command line is processed }„    end; { else}„    „    if not CaseSensitive then       { change the Search String to upper Case }„      SrchStr := StUpCase(SrchStr);„  end; { ParseCommandLine }„„Function OpenFile(ofn : String): Boolean;  { open a File For BlockRead/Write }„  Var„    error : Word;„  begin { OpenFile}„    assign(f,ofn);„    {$I-} reset(f,1); {$I+}„    error := Ioresult;„    if error <> 0 then„      Writeln('Cannot open ',ofn);„    OpenFile := error = 0;„  end; { OpenFile }„„Procedure CloseFile;„  begin„    {$I-}„    Close(f);„    if Ioresult <> 0 then;    { don't worry too much if an error occurs here }„    {$I+}„  end; { CloseFile }„„Procedure SearchFile(Var Filename: String);„  { Reads a File into the buffer and then searches that buffer For the wanted}„  { String or Characters.                                                    }„  Var„    x,y,„    count,„    result,„    bufferpos   : Word;„    abspos      : LongInt;„    finished    : Boolean;„    „  begin  { SearchFile}„    BMMakeTable(SrchStr,table);          { Create a Boyer-Moore search table }„    new(buffer);                     { make room on the heap For the buffers }„    {$I-} BlockRead(f,buffer^,searchlen,result); {$I+}  { Fill buffer buffer }„    if Ioresult <> 0 then begin      { error occurred While reading the File }„      CloseFile;„      ReportError(11);„    end; { if Ioresult }„    abspos       := 0;        { Initialise the Absolute File position marker }„    Repeat„      bufferpos      := 0;               { position marker in current buffer }„      count          := 0;               { offset from search starting point }„      finished := (result < searchlen);    { if buffer <> full no more reads }„      „      Repeat                              { Do a BM search For search String }„        if CaseSensitive then                   { do a Case sensitive search }„          count:=BMSearch(buffer^[bufferpos],result-bufferpos,table,SrchStr)„        else                                  { do a Case insensitive search }„          count:=BMSearchUC(buffer^[bufferpos],result-bufferpos,table,SrchStr);„        „        if count <> $FFFF then begin                   { search String found }„          inc(bufferpos,count);        { starting point of SrchStr in buffer }„          DisplayStr[0] := HexL(abspos+bufferpos) +    { hex and decimal pos }„                           Form('  @######',(abspos+bufferpos) * 1.0);„          if bufferpos > 79 then          { there is a line available beFore }„            Asc2Str(buffer^[bufferpos - 79],DisplayStr[1],79)„          else                          { no line available beFore the found }„            DisplayStr[1] := '';               { position so null the String }„          if (bufferpos + 79) < result then       { at least 79 Chars can be }„            Asc2Str(buffer^[bufferpos],DisplayStr[2],79)         { displayed }„          else                         { only display what is left in buffer }„            Asc2Str(buffer^[bufferpos],DisplayStr[2],result - bufferpos);„          if (bufferpos + 158) < result then    { display the line following }„            Asc2Str(buffer^[bufferpos + 79],DisplayStr[3],79)„          else                          { no line following the found String }„            DisplayStr[3] := '';                { so null the display String }„          Writeln;„          Writeln(DisplayStr[0],'   ',Filename);{ display the File locations }„          „          For x := 1 to 3 do begin„            For y := 1 to length(DisplayStr[x]) do{ filter out non-printables}„              if ord(DisplayStr[x][y]) < 32 then DisplayStr[x][y] := '.';„            if length(DisplayStr[x]) <> 0 then   { only display Strings With }„               Writeln(DisplayStr[x]);                       { valid content }„          end; { For x }„          „          inc(bufferpos,Slen);         { no need to check buffer in found st }„        end;  { if count <> $ffff }„        „      Until (bufferpos >= (result-length(SrchStr))) or (count = $ffff);„      „      if not finished then begin       { Fill 'er up again For another round }„        inc(abspos,result - Slen);      { create overlap so no String missed }„        {$I-} seek(f,abspos);„        BlockRead(f,buffer^,searchlen,result); {$I+}„        if Ioresult <> 0 then begin„          CloseFile;„          ReportError(13);„        end;„      end; { if not finished}„    Until finished;„    dispose(buffer);„  end; { SearchFile }„„Procedure SearchForFiles;„  Var„    dirinfo : SearchRec;„    FullName: PathStr;„    DirName : DirStr;„    FName   : NameStr;„    ExtName : ExtStr;„    found   : Boolean;„  begin„    FindFirst(Filename,AnyFile,dirinfo);„    found := DosError = 0;„    if not found then begin„      Writeln('Cannot find ',Filename);„      ReportError(255);„    end;„    FSplit(Filename,DirName,FName,ExtName);„    While found do begin„      if (dirinfo.Attr and 24) = 0 then begin„        FullName := DirName + dirinfo.name;„        if OpenFile(FullName) then begin„          SearchFile(FullName);„          CloseFile;„        end;„      end;„      FindNext(dirinfo);„      found := DosError = 0;„    end;„  end; { SearchForFiles }„„begin { main}„  (**) StartTimer;„  Writeln(copyright1);„  Writeln(copyright2);„  ParseCommandLine;„  SearchForFiles;„  (**) WriteElapsedTime;„end.„„        12     05-28-9313:46ALL                      SWAG SUPPORT TEAM        STRPOS.PAS               IMPORT              23          „  Hi, Andy:„„  ...Just for fun I also threw together a "PosSearch" routine„  that uses the built-in TP "POS" function. It actually performs„  better than I thought it would, as it takes a string longer than„  15 characters before it starts to become slower than the Boyer-„  Moore function I just posted. (ie: PosSearch is faster than the„  Boyer-Moore routine for strings that are smaller than 16 chars)„  Here's a demo program of the "PosSearch" search routine I put„  together. *Remember* to turn-off "range-checking" {$R-} in your„  finished program, otherwise the PosSearch will take longer than„  it should to execute.„„              (* Public-domain Search routine, using the standard TP  *)„              (* POS function. Guy McLoughlin - May 1, 1993.          *)„program DemoPosSearch;„„„  (***** PosSearch function. Returns 0 if string is not found.        *)„  (*     Returns 65,535 if BufferSize is too large.                   *)„  (*     ie: Greater than 65,520 bytes.                               *)„  (*                                                                  *)„  function PosSearch({input } var Buffer;„                                  BuffSize : word;„                                  Pattern  : string) : {output} word;„  type„    arwo_2    = array[1..2] of word;„    arch_255  = array[1..255] of char;„  var„    po_Buffer  : ^arch_255;„    by_Temp,„    by_IncSize : byte;„    wo_Index   : word;„  begin„    if (BuffSize > 65520) then„      begin„        PosSearch := $FFFF;„        exit„      end;„    wo_Index := 0;„    by_IncSize := (255 - pred(length(Pattern)));„    po_Buffer := addr(Buffer);„    repeat„      by_Temp := pos(Pattern, po_Buffer^);„      if (by_Temp = 0) then„        begin„          inc(wo_Index, by_IncSize);„          inc(arwo_2(po_Buffer)[1], by_IncSize)„        end„      else„        inc(wo_Index, by_Temp)„    until (by_Temp <> 0) or (wo_Index > BuffSize);„    if (by_Temp = 0) then„      PosSearch := 0„    else„      PosSearch := wo_Index„  end;        (* PosSearch.                                           *)„„„type„  arby_64K = array[1..65520] of byte;„„var„  Index   : word;„  st_Temp : string[20];„  Buffer  : ^arby_64K;„„BEGIN„  new(Buffer);„  fillchar(Buffer^, sizeof(Buffer^), 0);„  st_Temp := '12345678901234567890';„  move(st_Temp[1], Buffer^[65501], length(st_Temp));„  Index := PosSearch(Buffer^, sizeof(Buffer^), st_Temp);„  writeln(st_Temp, ' found at offset ', Index)„END.„„                               - Guy„---„ ˛ DeLuxe˝/386 1.25 #5060 ˛„ * Rose Media, Toronto, Canada : 416-733-2285„ * PostLink(tm) v1.04  ROSE (#1047) : RelayNet(tm)„„                                                                                                                                                                                                     13     05-28-9313:46ALL                      SWAG SUPPORT TEAM        STSEARCH.PAS             IMPORT              16          ⁄ƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ        Andy Stewart        ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒ∑„≥o≥ Can someone tell/show me how to write a procedure that   ≥o∫„≥o≥ will take a string input and search for it in a textfile ≥o∫„‘ÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕº„{ Simple example for a straight forward search routine }„var„  f    : text;„  buf  : array[0..maxint] of char;„  line : word;„  pattern,s,t : string;„„{ Corrected version of routine from turbo techniques }„function uppercase (strg:string):string; assembler;„ASM„   push     ds„   lds      si,strg„   les      di,@result„   cld„   lodsb„   stosb„   xor      ch,ch„   mov      cl,al„   jcxz     @done„ @more:„   lodsb„   cmp      al,'a'„   jb       @no„   cmp      al,'z'„   ja       @no„   sub      al,20h„ @no:„   stosb„   loop     @more„ @done:„   pop      ds„END;„„{ If you want the above routine in pascal„function uppercase (strg : string) : string;„  var i : integer;„  begin„    for i := 1 to length(strg) do strg[i] := upcase(strg[i]);„    uppercase := strg;„  end;„}„„procedure search4pattern;„  begin„    readln(f,s);„    inc(line);„    t := uppercase(s);„    if pos(pattern,t) > 0„    then writeln(line:5,' ',s);„  end;„„begin„  Line := 0;„  if paramcount < 2 then exit;„  pattern := paramstr(2);„  pattern := uppercase(pattern);„  assign(f,paramstr(1));„  settextbuf(f,buf);„  {$I-} reset(f); {$I+}„  if ioresult = 0„  then begin„         while not eof(f) do search4pattern;„         close(f);„       end„  else writeln('File not found');„end.„---„ ˛ Tags Á Us ˛ Abandon the search for truth: settle on a good fantasy.„ * Suburban Software - Home of King of the Board(tm) - 708-636-6694„ * PostLink(tm) v1.05  SUBSOFT (#715) : RelayNet(tm) Hub„„                                                                                                                                                                                                            14     05-28-9313:46ALL                      SWAG SUPPORT TEAM        SYMTAB1.PAS              IMPORT              69             SYMBOL TABLE„„   All Compilers and interpreters must maintain a data structure„   called the SYMBOL TABLE. This is where all the inFormation about„   the Programs symbols are kept. Maintaining a well-organized„   symbol table is a skill all Compiler Writers must master.„„   As a Compiler parses a source Program, it relies on the symbol„   table to provide inFormation about each identifier (such as„   Variables and Constants) - it must be able to access and update„   inFormation about each identifier and do so quickly - otherwise„   the process is slowed or produces incorrect results.„„   No matter what inFormation is kept, or how the table is organized„   certain operations are fundamental to a symbol tables operation.„„   You ENTER inFormation about about an identifier into the table by„   *creating* and entry.„„   You SEARCH the table to look up an identifier's entry and make„   available the inFormation in that entry.„„   You UPDATE the entry to modify stored inFormation.„„   There can be only one entry per identifier in the symbol table,„   so you must first search the table beFore making a new entry.„„   TABLE ORGANIZATION„„   There are many different ways to handle symbol tables: Arrays,„   linked lists, hash tables...but since the most common operations„   perFormed on a symbol table are searching it For existing entries„   it makes perfect sense to implement it as a BINARY TREE.„„   Each NODE in the TREE contains and entry, and points to two other„   nodes. The *values* of the nodes on the subtree to the left are„   always LESS than the parent node, While the subtree to the right„   is always MORE than the parent. This makes searching sorted„   binary trees very efficient.„„   Inserting new nodes is as easy as searching the tree: if the„   value you want to insert is LESS than the current node, search„   the node to the left. If it is MORE, search the tree to the right.„   Keep doing this recursively Until an empty node is found, then„   insert the value into that node.„„   NITTY-GRITTY„„   Now that we've covered some background on the table, here's a„   recap on the symbol table Type defs. For those that missed them„   in the first message, or didn't save them:„„Type„   sptr = ^String; { useful For minimum-size allocation }„„   DEFN_KEY = (UNDEFINED,„               Const_DEFN, Type_DEFN, Var_DEFN, FIELD_DEFN,„               VALPARM_DEFN, VarPARM_DEFN,„               PROG_DEFN, PROC_DEFN, FUNC_DEFN„              );„„   ROUTINE_KEY = (rkDECLARED, rkForWARD,„                  rkREAD, rkREADLN, rkWrite, rkWriteLN,„                  rkABS, rkARCTAN, rkCHR, rkCOS, rkEOF, rkEOLN,„                  rkEXP, rkLN, rkODD, rkORD, rkPRED, rkROUND,„                  rkSIN, rkSQR, rkSQRT, rkSUCC, rkTRUNC„                 );„„   RTN_BLOCK = Record               {info about routine declarations}„      key              :ROUTINE_KEY;„      parm_count,„      total_parm_size,„      total_local_size :Word;„      parms, locals,„      local_symtab     :SYMTAB_PTR; {symbol tables of routine}„      code_segment     :sptr;       {interpreter}„   end;„„   DTA_BLOCK = Record„      offset     :Word;„      Record_idp :SYMTAB_PTR;„   end;„„   INFO_REC = Record„      Case Byte of„        0:(Constant :VALUE);     { literal value }„        1:(routine  :RTN_BLOCK); { identifier is routine }„        2:(data     :DTA_BLOCK); { identifier is data }„   end;„„   DEFN_REC = Record„      key  :DEFN_KEY; { what is identifier? }„      info :INFO_REC; { stuff about identifier }„   end;„„   SYMTAB_PTR  = ^SYMTAB_NODE;„   SYMTAB_NODE = Record          {actual tree node}„      left, right   :SYMTAB_PTR; {Pointers to left and right subtrees}„      next          :SYMTAB_PTR; {For chaining a node}„      name          :sptr;       {identifier name String}„      level,                     {nesting level}„      co_index      :Integer;    {code Label index}„      defn          :DEFN_REC;   {definition info}„   end; { Record }„„   EXCERCISE #1„„   Implement a symbol table SEARCH routine, and a symbol table ENTER„   routine. Both routines must accept a Pointer to the root of the„   tree, and the name of the identifier you are working With, and„   must return a Pointer to the node that was found in the search„   routine, or enters in the enter routine. If no node was found, or„   entered, the routines must return NIL.„„   The resulting symbol table should be a sorted tree.„„„„≥   Implement a symbol table SEARCH routine, and a symbol table ENTER„≥   routine. Both routines must accept a Pointer to the root of the„≥   tree, and the name of the identifier you are working with, and„≥   must return a Pointer to the node that was found in the search„≥   routine, or enters in the enter routine. If no node was found, or„≥   entered, the routines must return NIL.„≥   The resulting symbol table should be a sorted tree.„„„„Function Enter(root: SymTab_Ptr; PidStr: spstr): SymTab_Ptr;„{ - inserts a new indetifier String PidStr in the symol table. }„{ - nil is returned if duplicate identifier is found.          }„Var„  Ptemp: SymTab_Ptr;„begin„  if (root <> nil) then    { not a terminal node }„    if (PidStr = root^.name) then„      begin„        Enter := nil;„        Exit„      end„    else    { recursive insertion calls to either left or right sub-tree }„      if (PidStr > root^.name) then„        Enter(root^.right, PidStr)„      else„        Enter(root^.left, PidStr)„  else { a terminal node }„    begin„      new(Ptemp);     { create a new tree leaf node }„      Ptemp^.name := PidStr;„      Ptemp^.left := nil;„      Ptemp^.right := nil„    end„end; { Enter }„„„Function Search(root: SymTab_Ptr; PidStr: spstr): SymTab_Ptr;„{ - search For a certain identifier String PidStr in the symbol table. }„{ - returns nil if search faild.                                       }„begin„  While (root <> nil) and (PidStr <> root^.name) do„    if (PidStr > root^.name) then     { search the right sub-tree }„      root := root^.right„    else„      if (PidStr < root^.name) then„        root := root^.left;           { search the left sub-tree  }„   Search := root                     { return the node           }„end;„„{===========================================================================}„„Comment:„     What made you choose BINARY trees over AVL trees?  With binary trees,„     the structure may become degenerate (unbalanced) and, the routines for„     searching and insertion becomes inefficient.„„>Comment:„>     What made you choose BINARY trees over AVL trees?  With binary trees,„>     the structure may become degenerate (unbalanced) and, the routines for„>     searching and insertion becomes inefficient.„„   Glad you could join us!„„   I chose a binary tree because it's simple and easy to Write, also„   a degenerate tree isn't much of a concern, simply because it's„   intended to hold only identifiers and Constants, not every„   statement. :)„„   As long as it sorts the data as it inserts, it will work. This„   isn't, after all, a graduate "course". The intention is to teach„   people how compilers work and show interested parties how to„   understand and Write their own, if they're interested. This is„   YOUR compiler you're writing, if you want to implement an AVL„   tree, go ahead!„„>Function Search(root: SymTab_Ptr; PidStr: spstr): SymTab_Ptr;„„   This works. It's efficient and does the job.„„>Function Enter(root: SymTab_Ptr; PidStr: spstr): SymTab_Ptr;„„>    else    { recursive insertion calls to either left or right sub-tree }„>      if (PidStr > root^.name) then„>        Enter(root^.right, PidStr)„>      else„>        Enter(root^.left, PidStr)„„   Note: recursive calls shouldn't be necessary in this Function.„   You can search the table the same way you did With Search, and„   you don't run the risk of running out of stack space. Procedure„   calls can also be exensive, slowing down the Program too much„   especially if a lot of symbols are searched.„„>  else { a terminal node }„>    begin„>      new(Ptemp);     { create a new tree leaf node }„>      Ptemp^.name := PidStr;„>      Ptemp^.left := nil;„>      Ptemp^.right := nil„>    end„>end; { Enter }„„   Please note that there is a lot of data that will be have to„   added to this section over time, as an identifier could be„   ANYTHING from a ConstANT to a Program identifier.„„   That isn't too important right now, as we're just getting started„   on the symbol table but suggest you add the following lines, for„   use later:„„   Ptemp^.info     := NIL;„   Ptemp^.defn.key := UNDEFINED;„   Ptemp^.level    := 0;     {recursion level}„   Ptemp^.Label_index := 0;  {Label # to be used in code output}„                                                           15     05-28-9313:46ALL                      SWAG SUPPORT TEAM        SYMTAB2.PAS              IMPORT              27          LARRY HADLEY„„   Errata: include an "info" Pointer field in the SYMTAB_NODE„   structure in the previous post.„„   USING THE SYMBOL TABLE - A CROSS REFERENCER„„   A cross-reference is a listing of a Programs identifiers in„   alphabetical order:„„Page 1   hello.pas  April 08 1993  19:03„   1 0: Program hello (output);„   2 0: Var i:Integer;„   3 0: begin„   4 0:    For i := 1 to 10 do„   5 0:    begin„   6 0:       WriteLn('Hello world.');„   7 0:    end;„   8 0: end.„„Cross Reference„---------------„„hello               1„„i                   2    4„„Integer             2„„ouput               1„„Writeln             6„„  As shown above, alongside each identifier's name are the source„  line numbers that contain the identifier. (This is useful for„  tracking where they're used)„„  A cross-referencer reads the source File and looks for„  identifiers, using the scanner you've built previously. The first„  time a particular identifier is found, it is inserted in the„  symbol tree along With it's line number. Subsequent appearances of„  the same identifier update the symbol tree With an additional line„  number appended to the list of line numbers.„„  As soon as the Program is completely scanned, all the identifier„  names and their line numbers are printed.„„  Use the INFO field of SYMTAB_NODE to point to a LINKED LIST of„  line numbers.„„  The main loop should scan For tokens Until it finds a period, or„  Exits With an "Unexpected end of File" error. For each identifier,„  search the symbol table to see if their were any previous„  instances of the identifier. If it is not found, then this must be„  the first time it is used so we can call the "enter" Function to„  create a new node.„„  Then, whether a new node was actually created or not, we call a„  Function to add the line number to the queue of line numbers„  attached to the node's "info" field. Finally, when the scanner„  loop terminates, we call a printing Function which traverses the„  tree from left to right to print the sorted tree - and all the„  line numbers in the linked list attached to each node.„„  Note that a recursive call to itself is probably the easiest way„  to do this, since _all_ the nodes of the tree are being accessed,„  not just one.„„  Types you will need:„„Type„  pLINENUMS = ^LINENUM_NODE;„  LINENUM_NODE = Record„     next     :pLINENUMS;„     line     :Integer;„  end;„„  pLINE_HEADER = ^LINENUM_HDR;„  LINENUM_HDR = Record„     first, last :pLINENUMS;„  end;„„  EXCERCISE #1„„  Write a cross referencer, as above. Text it With an assortment of„  pascal sourceFiles.„„  ADVANCED EXCERCISE„„  Note that the symbol table above converts all identifier names to„  lower case. What would be needed to reWrite the scanner/xref„  Program to preserve case? ReWrite the xref Program to do so. (note„  that Pascal compilers are Case insensitive, so the symbol table -„„  For compatibility - must compare lower case)„„  "BRAIN TEASERS"„„  1. What would be necessary to reWrite the symbol table as a hash„     table?„„  2. If an identifier appears more than once in a line, line„     numbers will appear more than once in the listing. Fix xref to„     recognize duplicate occurences of line numbers in node-lists.„„  -----------------------------------------------------------------„„  Next: Pascal source cruncher.„       16     05-28-9313:46ALL                      SWAG SUPPORT TEAM        TAGLINES.PAS             IMPORT              42          { BOB SWART„„Here it is, all new and much faster. I used an internal binary tree to manage„the taglines. You can store up to the available RAM in taglines:„}„„{$A+,B-,D-,E-,F-,G-,I-,L-,N-,O-,P-,Q-,R-,S+,T-,V-,X-}„{$M 16384,0,655360}„Uses„  Crt;„Type„  TBuffer  = Array[0..$4000] of Char;„„Const„  Title = 'TagLines 0.2 by Bob Swart For Travis Griggs'#13#10;„  Usage = 'Usage: TagLines inFile outFile'#13#10#13#10+„          '       Taglines will remove dupicate lines from inFile.'#13#10+„          '       Resulting Text is placed in outFile.'#13#10;„„  NumLines: LongInt = 0; { total number of lines in InFile }„  NmLdiv80: LongInt = 0; { NumLines div 80, For 'progress' }„  CurrentL: LongInt = 0; { current lineno read from InFile }„„Type„  String80 = String[80];„„  PBinTree = ^TBinTree;„  TBinTree = Record„               Info: String80;„               left,right: PBinTree„             end;„„Var„  InBuf,„  OutBuf   : TBuffer;„  InFile,„  OutFile  : Text;„  TagLine  : String80;„  Root,„  Current,„  Prev     : PBinTree;„  i        : Integer;„  SaveExit : Pointer;„„„Function CompStr(Var Name1,Name2: String): Integer; Assembler;„{ Author: drs. Robert E. Swart„}„Asm„  push  DS„  lds   SI,Name1               { ds:si pts to Name1       }„  les   DI,Name2               { es:di pts to Name2       }„  cld„  lodsb                        { get String1 length in AL }„  mov   AH,ES:[DI]             { get String2 length in AH }„  inc   DI„  mov   BX,AX                  { save both lengths in BX  }„  xor   CX,CX                  { clear cx                 }„  mov   CL,AL                  { get String1 length in CX }„  cmp   CL,AH                  { equal to String2 length? }„  jb    @Len                   { CX stores minimum length }„  mov   CL,AH                  { of String1 and String2   }„ @Len: jcxz  @Exit                  { quit if null             }„„ @Loop: lodsb                        { String1[i] in AL         }„  mov   AH,ES:[DI]             { String2[i] in AH         }„  cmp   AL,AH                  { compare Str1 to Str2     }„  jne   @Not                   { loop if equal            }„  inc   DI„  loop  @Loop                  { go do next Char          }„  jmp   @Exit                  { Strings OK, Length also? }„„ @Not: mov   BX,AX                  { BL = AL = String1[i],„                                 BH = AH = String2[i]     }„ @Exit: xor   AX,AX„  cmp   BL,BH                  { length or contents comp  }„  je    @Equal                 { 1 = 2: return  0         }„  jb    @Lower                 { 1 < 2: return -1         }„  inc   AX                     { 1 > 2: return  1         }„  inc   AX„ @Lower: dec   AX„ @Equal: pop   DS„end {CompStr};„„Procedure Stop; Far;„begin„  ExitProc := SaveExit;„  Close(InFile);„  Close(OutFile);„end {Stop};„„„begin„  Writeln(Title);„  if Paramcount <> 2 then„  begin„    Writeln(Usage);„    Halt„  end;„„  Assign(InFile,ParamStr(1));„  SetTextBuf(InFile,InBuf);„  Reset(InFile);„  if IOResult <> 0 then„  begin„    WriteLn('Error: could not open ', ParamStr(1));„    Halt(1)„  end;„„  Assign(OutFile,ParamStr(2));„  SetTextBuf(OutFile,OutBuf);„  Reset(OutFile);„  if IOResult = 0 then„  begin„    WriteLn('Error: File ', ParamStr(2),' already exists');„    Halt(2)„  end;„„  ReWrite(OutFile);„  if IOResult <> 0 then„  begin„    WriteLn('Error: could not create ', ParamStr(2));„    Halt(3)„  end;„„  SaveExit := ExitProc;„  ExitProc := @Stop;„„  While not eof(InFile) do„  begin„    readln(InFile);„    Inc(NumLines);„  end;„  Writeln('There are ',NumLines,' lines in this File.'#13#10);„  Writeln('Press any key to stop the search For duplicate lines');„  NmLdiv80 := NumLines div 80;„„  Root := nil;„  reset(InFile);„  While CurrentL <> NumLines do„  begin„    if KeyPressed then„      Halt { calls Stop };„    Inc(CurrentL);„    if (CurrentL and NmLdiv80) = 0 then„      Write('#');„    readln(InFile,TagLine);„„    if root = nil then { first TagLine }„    begin„      New(Root);„      Root^.left := nil;„      Root^.right := nil;„      Root^.Info := TagLine;„      Writeln(OutFile,tagLine)„    end„    else { binary search For TagLine }„    begin„      Current := Root;„      Repeat„        Prev := Current;„        i := CompStr(Current^.Info,TagLine);„        if i > 0 then„          Current := Current^.left„        else„        if i < 0 then„          Current := Current^.right„      Until (i = 0) or (Current = nil);„„      if i <> 0 then { TagLine not found }„      begin„        New(Current);„        Current^.left := nil;„        Current^.right := nil;„        Current^.Info := TagLine;„„        if i > 0 then„          Prev^.left := Current { Current before Prev }„        else„          Prev^.right := Current { Current after Prev };„        Writeln(OutFile,TagLine)„      end„    end„  end;„  Writeln(#13#10'100% Completed, result is in File ',ParamStr(2))„  { close is done by Stop }„end.„„{„> I also tried DJ's idea of the buffer of 65535 but it said the structure„> was too large. So I used 64512.„Always try to use a multiple of 4K, because the hard disk 'eats' space in these„chunks. Reading/Writing in these chunks goes a lot faster that way.„}                                                                                                        17     08-27-9320:20ALL                      RUFUS HENDON             Fast Boyer-Moore Search  IMPORT              114    }   { BOYERMO2.PAS (23 January 1988) (Rufus S. Hendon) }„„{    This Unit provides facilities For searching a Text For a target using„  the Boyer-Moore search method.  The routine is based on Don Strenczewilk's„  Implementation of a Variant form of the Boyer-Moore method (his case-„  insensitive version B1, available on CompuServe in File BLINE.ARC in„  Borland BPROGA Data Library 4, uploaded 21 August 1987).  In addition to„  repackaging his routine as a Turbo Pascal 4.0 Unit, I have modified it„  (1) to provide protection against endless loops that in the original„  version can arise due to wrap-around of the index used to scan the Text„  when the the length of the Text approaches the maximum (65521 Characters)„  allowed by Turbo Pascal 4.0 For Arrays of Type Char and (2) to improve„  efficiency slightly by removing three instructions (a PUSH, a MOV, and a„  POP) from the comparison loop.„     The Text to be searched must be stored in an Array of Type Char or an„  equivalent user-defined Type.  The lower bound of the Array must be 1.„  The target For which the Text is to be searched must be of Type String.„  The Program must also provide a Variable For the storage of the shift„  table used by the Boyer-Moore method when it searches the Text.  This„  Variable must provide 256 Bytes of storage; it can, For example, be a„  Variable of Type Array[Char] of Byte.  The target Variable and the shift-„  table Variable must be in the same segment:  they must both be global„  Variables (located in the data segment) or both local Variables (stored„  in the stack segment).„     Whenever the Text is to be searched For a new target, the Program must„  call MAKE_BOYER_MOORE_TABLE to create the shift table For the target.„  Thereafter the Text can be searched For the target by invoking„  BOYER_MOORE_SEARCH, specifying as arguments the target and its shift„  table as well as the position in the Text where the search is to begin.„  if the Program maintains multiple target Variables and a separate shift„  table and starting-position Variable For each target, searches for„  occurrences of the Various targets can be underway simultaneously.„     In a call to BOYER_MOORE_SEARCH, the argument associated With the„  parameter START determines the position in the Text With which the search„  begins.  To search the entire Text, the Function would be invoked With„  START = 1.  The Function scans the Text beginning from the START position„  For the first subString that matches the target specified by the Variable„  associated With the parameter TARGET, using the shift table stored in the„  Variable associated With the parameter TABLE.  if such a subString is„  found, the Function returns the position (Array subscript) of the initial„  Character of the matching subString; since the Array is required to have„  1 as its lower bound, the position returned after a successful search„  will always be greater than 0.  if the Function fails to find a matching„  subString, it returns 0.  (if the requirement that the TARGET and TABLE„  Variables be in the same segment is violated, the Function also returns„  0.)„     When it is required that all occurrences in the Text of a given target„  be found, BOYER_MOORE_SEARCH would be invoked in a loop, in which the„  START argument would initially have the value of 1; thereafter, after„  every successful search, the START argument would be reset to the„  position returned by the Function plus 1.  The loop would terminate when„  the Function reported failure.  The loop would have a general structure„  similar to this:„„    item := [the target String];„    make_Boyer_Moore_table(item,shift_table);„    scan_beginning := 1;„    search_Text_length := length(search_Text);„    Repeat„      i := Boyer_Moore_search(search_Text,scan_beginning,search_Text_length,„          item,shift_table);„      if i > 0 then begin„        [do whatever processing is required when the search is successful];„        scan_beginning := i+1„      end„    Until i = 0„„     Note that if the Text Array can only be referred to by means of a„  Pointer, as will be the Case if the Array is allocated in the heap by„  means of the NEW Procedure, the Pointer, when used as the first argument„  of BOYER_MOORE_SEARCH, must be dereferenced by writing '^' after it.  If,„  For example, TextPTR is a Pointer to the Text Array, the call to the„  search Function in the loop just given would take this form:„„      i := Boyer_Moore_search(Textptr^,scan_beginning,search_Text_length,„          item,shift_table);„                                                                             }„{============================================================================}„Unit BOYERMO2;„{============================================================================}„Interface„„Procedure MAKE_BOYER_MOORE_TABLE(Var target: String; Var table);„{ TARGET is the target String For which a Text is to be searched.  The„  shift table For the target String is Constructed in TABLE, which must be„  a Variable providing 256 Bytes of storage, e.g. a Variable declared as„  Array[Char] of Byte. }„„Function BOYER_MOORE_SEARCH(Var Text_Array; start, Text_length: Word;„    Var target: String; Var table): Word;„{ Text_Array is an Array of Characters in which a Text is stored; the„  Text begins in Text_Array[1] and is Text_LENGTH Characters long.  TARGET„  must either be the same Variable used as parameter TARGET in an earlier„  call to MAKE_BOYER_MOORE_TABLE or another Variable With the same value.„  TABLE must be the Variable that was used as parameter TABLE in the same„  call to MAKE_BOYER_MOORE_TABLE.  TARGET and TABLE must be in the same„  segment, i.e. they must both be global Variables or both local Variables.„  A Boyer-Moore search is performed on the Text in Text_Array, beginning„  With the Character in position START and using shift table TABLE, for„  the first subString that matches TARGET.  if a match is found, the„  position of the first Character of the matching subString is returned.„  Otherwise 0 is returned.  A Function value of 0 is also returned if TABLE„  and TARGET are not in the same segment. }„{============================================================================}„Implementation„„Const„  copy: String = '';„Var„  table: Array[Char] of Byte;„{****************************************************************************}„Procedure MAKE_BOYER_MOORE_TABLE(Var target: String; Var table);„{ TARGET is the target String For which a Text is to be searched.  The„  shift table For the target String is Constructed in TABLE, which must be„  a Variable providing 256 Bytes of storage, e.g. a Variable declared as„  Array[Char] of Byte. }„begin { MAKE_BOYER_MOORE_TABLE }„  Inline„    ($1E/              {       push ds            }„     $C5/$76/<target/  {       lds si,[bp+target] }„     $89/$F3/          {       mov bx,si          }„     $8A/$04/          {       mov al, [si]       }„     $88/$C4/          {       mov ah,al          }„     $B9/$80/$00/      {       mov cx,$0080       }„     $C4/$7E/<table/   {       les di,[bp+table]  }„     $89/$FA/          {       mov dx,di          }„     $FC/              {       cld                }„     $F2/$AB/          {       rep stosw          }„     $89/$DE/          {       mov si,bx          }„     $89/$D7/          {       mov di,dx          }„     $46/              {       inc si             }„     $98/              {       cbw                }„     $3C/$01/          {       cmp al,1           }„     $7E/$13/          {       jle done           }„     $48/              {       dec ax             }„     $88/$E1/          {       mov cl,ah          }„     $88/$E7/          {       mov bh,ah          }„     $8A/$1C/          { next: mov bl,[si]        }„     $89/$C2/          {       mov dx,ax          }„     $29/$CA/          {       sub dx,cx          }„     $88/$11/          {       mov [bx+di],dl     }„     $46/              {       inc si             }„     $41/              {       inc cx             }„     $39/$C1/          {       cmp cx,ax          }„     $75/$F2/          {       jne next           }„     $1F)              { done: pop ds             }„end; { MAKE_BOYER_MOORE_TABLE }„„{****************************************************************************}„Function BOYER_MOORE_SEARCH(Var Text_Array; start, Text_length: Word;„    Var target: String; Var table): Word;„{ Text_Array is an Array of Characters in which a Text is stored; the„  Text begins in Text_Array[1] and is Text_LENGTH Characters long.  TARGET„  must either be the same Variable used as parameter TARGET in an earlier„  call to MAKE_BOYER_MOORE_TABLE or another Variable With the same value.„  TABLE must be the Variable that was used as parameter TABLE in the same„  call to MAKE_BOYER_MOORE_TABLE.  TARGET and TABLE must be in the same„  segment, i.e. they must both be global Variables or both local Variables.„  A Boyer-Moore search is performed on the Text in Text_Array, beginning„  With the Character in position START and using shift table TABLE, for„  the first subString that matches TARGET.  if a match is found, the„  position of the first Character of the matching subString is returned.„  Otherwise 0 is returned.  A Function value of 0 is also returned if TABLE„  and TARGET are not in the same segment. }„begin { BOYER_MOORE_SEARCH }„  Inline„    ($1E/                  {            push ds                 }„     $33/$C0/              {            xor ax,ax               }„     $C5/$5E/<table/       {            lds bx,[bp+table]   } { if TABLE and  }„     $8C/$D9/              {            mov cx,ds           } { TARGET are in }„     $C5/$76/<target/      {            lds si,[bp+target]  } { different     }„     $8C/$DA/              {            mov dx,ds           } { segments, re- }„     $3B/$D1/              {            cmp dx,cx           } { port failure  }„     $75/$76/              {            jne notfound2       } { at once       }„     $8A/$F4/              {            mov dh,ah               }„     $8A/$14/              {            mov dl,[si]             }„     $80/$FA/$01/          {            cmp dl,1                }„     $7F/$1F/              {            jg boyer                }„     $7C/$6B/              {            jl notfound2            }„     $8A/$44/$01/          {            mov al,[si+1]           }„     $8B/$56/<start/       {            mov dx,[bp+start]       }„     $4A/                  {            dec dx                  }„     $8B/$4E/<Text_length/ {            mov cx,[bp+Text_length] }„     $2B/$CA/              {            sub cx,dx               }„     $C4/$7E/<Text_Array/  {            les di,[bp+Text_Array]  }„     $8B/$DF/              {            mov bx,di               }„     $03/$FA/              {            add di,dx               }„     $FC/                  {            cld                     }„     $F2/$AE/              {            repne scasb             }„     $75/$53/              {            jne notfound2           }„     $97/                  {            xchg ax,di              }„     $2B/$C3/              {            sub ax,bx               }„     $EB/$50/              {            jmp short Exit          }„     $FE/$CA/              { boyer:     dec dl                  }„     $03/$F2/              {            add si,dx               }„     $C4/$7E/<Text_Array/  {            les di,[bp+Text_Array]  }„     $8B/$CF/              {            mov cx,di               }„     $03/$4E/<Text_length/ {            add cx,[bp+Text_length] }„     $49/                  {            dec cx                  }„     $4F/                  {            dec di                  }„     $03/$7E/<start/       {            add di,[bp+start]       }„     $03/$FA/              {            add di,dx               }„     $8A/$74/$01/          {            mov dh,[si+1]           }„     $55/                  {            push bp                 }„     $8B/$E9/              {            mov bp,cx               }„     $8A/$EC/              {            mov ch,ah               }„     $FD/                  {            std                     }„     $EB/$05/              {            jmp short comp          }„     $D7/                  { nexttable: xlat                    }„     $03/$F8/              {            add di,ax               }„     $72/$2A/              {            jc notfound             }„     $3B/$EF/              { comp:      cmp bp,di               }„     $72/$26/              {            jb notfound             }„     $26/$8A/$05/          {            mov al,es:[di]          }„     $3A/$F0/              {            cmp dh,al               }„     $75/$F0/              {            jne nexttable           }„     $4F/                  {            dec di                  }„     $8A/$CA/              {            mov cl,dl               }„     $F3/$A6/              {            repe cmpsb              }„     $74/$0D/              {            je found                }„     $8A/$C2/              {            mov al,dl               }„     $2B/$C1/              {            sub ax,cx               }„     $03/$F8/              {            add di,ax               }„     $47/                  {            inc di                  }„     $03/$F0/              {            add si,ax               }„     $8A/$C6/              {            mov al,dh               }„     $EB/$DC/              {            jmp short nexttable     }„     $5D/                  { found:     pop bp                  }„     $C4/$46/<Text_Array/  {            les ax,[bp+Text_Array]  }„     $97/                  {            xchg ax,di              }„     $2B/$C7/              {            sub ax,di               }„     $40/                  {            inc ax                  }„     $40/                  {            inc ax                  }„     $EB/$03/              {            jmp short Exit          }„     $5D/                  { notfound:  pop bp                  }„     $32/$C0/              { notfound2: xor al,al               }„     $89/$46/$FE/          { Exit:      mov [bp-2],ax           }„     $FC/                  {            cld                     }„     $1F)                  {            pop ds                  }„end; { BOYER_MOORE_SEARCH }„{****************************************************************************}„end.„„                                                                          18     10-28-9311:36ALL                      GUY MCLOUGHLIN           Position Search          IMPORT              26     }   {===========================================================================„Date: 10-07-93 (13:12)„From: GUY MCLOUGHLIN„Subj: Pos-Search Demo„---------------------------------------------------------------------------}„„ {.$DEFINE DebugMode}„„ {$IFDEF DebugMode}„„   {$A+,B-,D+,E-,F-,I+,L+,N-,O-,R+,S+,V+}„   {$M 4096,65536,65536}„„ {$ELSE}„„   {$A+,B-,D-,E-,F-,I-,L-,N-,O-,R-,S-,V-}„   {$M 4096,65536,65536}„„ {$ENDIF}„„              (* Public-domain Search routine, using the standard TP  *)„              (* POS function. Guy McLoughlin - May 16, 1993.         *)„program DemoPosSearch;„„„  (***** Force alphabetical characters to uppercase.                  *)„  (*                                                                  *)„  procedure UpCaseData({input } var Data;„                                    wo_Size : word); far; assembler;„  asm„    push  ds„    cld„    lds   si, Data„    mov   di, si„    mov   cx, wo_Size„    xor   ah, ah„„  @L1:„    jcxz  @END„    lodsb„    cmp   al, 'a'„    jb    @L2„    cmp   al, 'z'„    ja    @L2„    sub   al, 20h„„  @L2:„    stosb„    loop  @L1„„  @END:„    pop ds„„  end;        (* UpCaseData.                                          *)„„„  (***** PosSearch function. Returns 0 if string is not found.        *)„  (*     Returns 65,535 if BufferSize is too large.                   *)„  (*     ie: Greater than 65,520 bytes.                               *)„  (*                                                                  *)„  function PosSearch({input } var Buffer;„                                  BuffSize  : word;„                                  Pattern   : string;„                                  ExactCase : boolean) : {output} word;„  type„    arwo_2    = array[1..2] of word;„    arch_255  = array[1..255] of char;„  var„    po_Buffer  : ^arch_255;„    by_Temp,„    by_IncSize : byte;„    wo_Index   : word;„  begin„    if (BuffSize > 65520) then„      begin„        PosSearch := $FFFF;„        exit„      end;„    by_IncSize := (255 - pred(length(Pattern)));„    po_Buffer := addr(Buffer);„    if NOT ExactCase then„      begin„        UpCaseData(po_Buffer^, BuffSize);„        for wo_Index := 1 to length(Pattern) do„          Pattern[wo_Index] := upcase(Pattern[wo_Index])„      end;„„    wo_Index := 0;„    repeat„      by_Temp := pos(Pattern, po_Buffer^);„      if (by_Temp = 0) then„        begin„          inc(wo_Index, by_IncSize);„          inc(arwo_2(po_Buffer)[1], by_IncSize)„        end„      else„        inc(wo_Index, by_Temp)„    until (by_Temp <> 0) or (wo_Index > BuffSize);„    if (by_Temp = 0) then„      PosSearch := 0„    else„      PosSearch := wo_Index„  end;        (* PosSearch.                                           *)„„„type„  arby_64K = array[1..65520] of byte;„„var„  Index   : word;„  st_Temp : string[20];„  Buffer  : ^arby_64K;„„BEGIN„  new(Buffer);„  fillchar(Buffer^, sizeof(Buffer^), 0);„  st_Temp := 'aBcDeFgHiJkLmNoPqRsT';„  move(st_Temp[1], Buffer^[65501], length(st_Temp));„  st_Temp := 'AbCdEfGhIjKlMnOpQrSt';„  Index := PosSearch(Buffer^, sizeof(Buffer^), st_Temp, false);„  writeln(st_Temp, ' found at offset ', Index)„END.„„                                                     19     11-21-9309:26ALL                      COSTAS MENICO            VERY FAST Boyer-Moore    IMPORT              55     }   {„  The originial benchmark program was to demonstrate the speed difference„  between the POS() in Turbo Pascal 4 or 5 brute-force„  and the Boyer-Moore method function POSBM()„  Program author: Costas Menico„„   Call: posbm(pat,buf,buflen);„   or if you are using a string buffer:„         posbm(pat,s[1],length(s));„}„„program bufSearch;„„uses„  dos, crt;„„„{$F+}„function posbm(pat:string; var buf; buflen:word):word; EXTERNAL;„{$L BM.OBJ}„{$F-}„„function bruteForce(var such:string; var buf; buflen:word):word; ASSEMBLER;„ASM„	cld„	push ds„	les	di,buf„	mov	cx,buflen„	jcxz @@30„	lds	si,such„	mov  al,[si]„	or   al,al„	je   @@30„	xor  ah,ah„	cmp  ax,cx„	ja   @@30„	mov  bx,si„	dec  cx„  @@10:„	mov  si,bx„	lodsw„	xchg al,ah          { AH=StringlÑnge, AL=Suchchar }„	repne scasb„	jne  @@30„	dec  ah„	or   ah,ah„	je   @@20„„	inc  cx             { CX++ nach rep... }„	xchg cx,ax„	mov  cl,ch„	xor  ch,ch„	mov  dx,di„	repe	cmpsb„	mov  di,dx„	mov  cx,ax„	loopne @@10„  @@20:„	mov  ax,buflen„	sub  ax,cx„	dec  ax„	jmp  @@40„  @@30:„	xor  ax,ax„  @@40:„	pop  ds„end;„„„„procedure showtime(s : string; t : registers);„„begin„  writeln(s, ' Hrs:', t.ch, ' Min:', t.cl, ' Sec:', t.dh, ' Milsec:', t.dl);„end;„„var„  pat    : string;„  i,„  j      : integer;„  start,„  finish : registers;„  arr    : array[1..4096] of char;„„const„  longloop = 5000;„„begin„  clrscr;„  randomize;„  for i := 1 to 4096 do„    arr[i] := chr(random(255)+1);„„  move(arr[4090],pat[1],5); pat[0]:=#5;„„  writeln('Search using Brute-Force Method <please wait>');„  start.ah := $2C;„  msdos(start);„  for j := 1 to longloop do„    i := bruteForce(pat,arr,4096);„  finish.ah := $2C;„  msdos(finish);„  showtime('Start  ', start);„  showtime('Finish ', finish);„  writeln('Pattern found at position ', i);„  writeln;„  writeln('Search using Boyer-Moore Method <please wait>');„  start.ah := $2C;„  msdos(start);„  for j := 1 to longloop do„    i := posbm(pat, arr,4096);„  finish.ah := $2C;„  msdos(finish);„  showtime('Start  ', start);„  showtime('Finish ', finish);„  writeln('Pattern found at position ', i);„  writeln;„  writeln('Done ... Press Enter');„  readln;„end.„„{ --------------------------   XX34 OBJECT CODE  ----------------------- }„{ ------------------------- CUT OUT AND SAVE AS BM.XX  ------------------}„{ ------------------------  USE XX3401 D BM.XX   ------------------------}„„*XX3401-000392-050693--68--85-03573----------BM.OBJ--1-OF--1„U-M+32AuL3--IoB-H3l-IopQEYoiEJBBYcUU++++53FpQa7j623nQqJhMalZQW+UJaJm„QqZjPW+n9X8NW-k+ECbfXgIO32AuL3--IoB-H3l-IopQEYoiEJBB+sU1+21dH7M0++-c„W+A+E84IZUM+-2BDF2J3a+Q+OCQ++U2-1d+A+++--J-DIo7B++++rMU2+20W+N4Uuk+-„++-JUSkA+Mjg5X9YzAKq4+4AbUM-f+f+REDdjU09m6Z4+6aq-+53hVE-X7s8+Mi42U29„k5I1uO6+WIM0WPM6+MDt+LIPlPM2+On2jUU-Wos0weto+ya1+6jrUys0uqyEXLs2XB8C„kcd4+6fUiM++wuj3hUE-XJs2Wos+GMjRXKs2AiGgWzW60y9tf6jsW+i9uwKq0+4BTUG9„JU78WoM+G19zzGjEQXE1w6cQBcc-0g-pwMjSWos+l9s2+Iw1yTCaR+ms+E0BTUG9wn9z„uxK9lgKq0+2flUI0+Cg0Aw1w5sjZUQEA+Jr80U-fWU6++5E+„***** END OF XX-BLOCK *****„„{ --------------------------   ASSEMBLER CODE  ------------------------- }„{ ------------------------- CUT OUT AND SAVE AS BM.AMS ------------------}„{ ------------------------  USE TASM TO ASSEMBLE ------------------------}„„; filename: BM.ASM„; fast search routine to search strings in ARRAYS OF CHARS„; function in Turbo Pascal >= 4. Based on the Boyer-Moore algorithm.„; program author: Costas Menico.„; Very small modifications for using an ARRAY OF CHAR buffer instead of„; a string made by Jochen Magnus in May 93.„; declare as follows:„; {$F+}„; {$L BM.OBJ}„; function posbm(pat:string; var buffer; buflen:word):WORD; external;„; call as follows from Turbo 4..7:„; location := posbm(pat, buf, buflen);„; call for a search in a string typed buffer:„; location := posbm(pat, str[1], length(str));„„„skiparrlength	equ	256„„; function work stack„„dstk		struc„patlen		dw	?„strlen		dw	?„skiparr		db	skiparrlength dup(?)„pattxt		dd	0„strtxt		dd	0„dstk		ends„„; total stack (callers plus work stack)„„cstk		struc„ourdata		db	size dstk dup(?)„bpsave		dw	0„retaddr		dd	0„paramlen       dw   0           						; JO„straddr		dd	0„pataddr		dd	0„cstk		ends„„paramsize	equ	size pataddr+size straddr +size paramlen   	; +2  JO„„code		segment	para public„		assume cs:code„„; entry point to posbm function„„posbm		proc	far„		public	posbm„„		push	bp„			 sub	sp, size dstk„			 mov	bp, sp„			 push    ds„			 xor	ah, ah„			 cld„„; get and save the length and address of the pattern„„		lds	si, [bp.pataddr]„			 mov	word ptr [bp.pattxt][2], ds„			 lodsb„			 or	al, al„			 jne	notnullp„			 jmp	nomatch„„notnullp:„		mov	cx, ax„			 mov	[bp.patlen], ax„			 mov	word ptr [bp.pattxt], si„„; get and save the length and address of the string text„„		lds	si, [bp.straddr]„			 mov	word ptr [bp.strtxt][2], ds„			 mov ax,[bp.paramlen]  					; JO„			 or  ax,ax	   	   					; JO„			 jne	notnulls„			 jmp	nomatch„„notnulls:„		mov	[bp.strlen], ax„			 mov	word ptr [bp.strtxt], si„			 cmp	cx, 1„			 jne	do_boyer_moore„			 lds	si, [bp.pattxt]„			 lodsb„			 les	di, [bp.strtxt]„			 mov	cx, [bp.strlen]„			 repne	scasb„			 jz	match1„			 jmp	nomatch„„match1:„		mov	si, di„			 sub	si, 2„			 jmp	exactmatch„„do_boyer_moore:„„; fill the ASCII character skiparray with the„; length of the pattern„„		lea	di, [bp.skiparr]„			 mov	dx, ss„			 mov	es, dx„			 mov	al, byte ptr [bp.patlen]„			 mov	ah, al„			 mov	cx, skiparrlength/2„			 rep	stosw„„; replace in the ASCII skiparray the corresponding„; character offset from the end of the pattern minus 1„„		lds	si, [bp.pattxt]„			 lea	bx, [bp.skiparr]„			 mov	cx, [bp.patlen]„			 dec	cx„			 mov	bx, bp„			 lea	bp, [bp.skiparr]„			 xor	ah, ah„„fill_skiparray:„		lodsb„			 mov	di, ax„			 mov	[bp+di], cl„			 loop	fill_skiparray„			 lodsb„			 mov	di, ax„			 mov	[bp+di], cl„			 mov	bp, bx„„; now initialize our pattern and string text pointers to„; start searching„„		lds	si, [bp.strtxt]„			 lea	di, [bp.skiparr]„			 mov	dx, [bp.strlen]„			 dec	dx„			 mov	ax, [bp.patlen]„			 dec	ax„			 xor	bh, bh„			 std„„; get character from text. use the character as an index„; into the skiparray, looking for a skip value of 0.„; if found, execute a brute-force search on the pattern„„searchlast:„		sub	dx, ax„			 jc	nomatch„			 add	si, ax„			 mov	bl, [si]„			 mov	al, ss:[di+bx]„			 or	al, al„			 jne	searchlast„„; we have a possible match, therefore„; do the reverse brute-force compare„„		mov	bx, si„			 mov	cx, [bp.patlen]„			 les	di, [bp.pattxt]„			 dec	di„			 add	di, cx„			 repe	cmpsb„			 je	exactmatch„			 mov	ax, 1„			 lea	di, [bp.skiparr]„			 mov	si, bx„			 xor	bh, bh„			 jmp	short searchlast„„exactmatch:„		mov	ax, si„			 lds	si, [bp.strtxt]„			 sub	ax, si„			 add	ax, 2„			 jmp	short endsearch„„nomatch:„		xor	ax, ax„„endsearch:„		cld„			 pop	ds„			 mov	sp, bp„			 add	sp, size dstk„			 pop	bp„			 ret	paramsize„posbm		endp„„code		ends„		end„{-----------------------   END OF ASSEMBLER CODE -------------------------} 