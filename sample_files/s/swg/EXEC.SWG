SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00022         EXECUTION ROUTINES                                                1      05-28-9313:45ALL                      SWAG SUPPORT TEAM        EXECHILD.PAS             IMPORT              35     U^† (* This unit lets you execute any child program and redirect the„   child program output to NUL / PRN / CON or file.„   It's very simple to use (look at the EXAMPLE.PAS).„   This source is completlly freeware but make sure to remove„   this remark if any changes are made I don't want anyone to„   spread his bugs with my source.„   Of course any suggestions are welcome as well as questions„   about the source.„„   Written by Schwartz Gabriel.   20/03/1993.„   Anyone who has any question can leave me a message at „   CompuServe to EliaShim address 100320,36„*)„„{$A+,B-,D-,E-,F+,G-,I-,L-,N-,O-,P-,Q-,R-,S-,T-,V-,X+,Y+}„„Unit Redir;„„Interface„„Var„  IOStatus      : Integer;„  RedirError    : Integer;„  ExecuteResult : Word;„„{------------------------------------------------------------------------------}„procedure Execute (ProgName, ComLine, Redir: String);„{------------------------------------------------------------------------------}„„Implementation„„Uses DOS;„„Type„  PMCB = ^TMCB;„  TMCB = record„           Typ   : Char;„           Owner : Word;„           Size  : Word;„         end;„„  PtrRec = record„             Ofs, Seg : Word;„           end;„„  THeader = record„              Signature : Word;„              PartPag   : Word;„              PageCnt   : Word;„              ReloCnt   : Word;„              HdrSize   : Word;„              MinMem    : Word;„              MaxMem    : Word;„              ReloSS    : Word;„              ExeSP     : Word;„              ChkSum    : Word;„              ExeIP     : Word;„              ReloCS    : Word;„              TablOff   : Word;„              OverNo    : Word;„            end;„„Var„  PrefSeg      : Word;„  MinBlockSize : Word;„  MCB          : PMCB;„  FName        : PathStr;„  F            : File;„  MyBlockSize  : Word;„  Header       : THeader;„„{------------------------------------------------------------------------------}„„procedure Execute (ProgName, ComLine, Redir: String);„„type„  PHandles = ^THandles;„  THandles = Array [Byte] of Byte;„„  PWord = ^Word;„„var„  RedirChanged : Boolean;„  Handles      : PHandles;„  OldHandle    : Byte;„„  {............................................................................}„„  function ChangeRedir : Boolean;„„  begin„    ChangeRedir:=False;„    If Redir = '' then Exit;„    Assign (F, Redir);„    Rewrite (F);„    RedirError:=IOResult;„    If IOStatus <> 0 then Exit;„    Handles:=Ptr (PrefixSeg, PWord (Ptr (PrefixSeg, $34))^);„    OldHandle:=Handles^[1];„    Handles^[1]:=Handles^[FileRec (F).Handle];„    ChangeRedir:=True;„  end;„„  {............................................................................}„„  procedure CompactHeap;„„  var„    Regs : Registers;„„  begin„    Regs.AH:=$4A;„    Regs.ES:=PrefSeg;„    Regs.BX:=MinBlockSize + (PtrRec (HeapPtr).Seg - PtrRec (HeapOrg).Seg);„    MsDos (Regs);„  end;„„  {............................................................................}„„  procedure DosExecute;„„  Begin„    SwapVectors;„    Exec (ProgName, ComLine);„    IOStatus:=DosError;„    ExecuteResult:=DosExitCode;„    SwapVectors;„  End;„„  {............................................................................}„„  procedure ExpandHeap;„„  var„    Regs : Registers;„„  begin„    Regs.AH:=$4A;„    Regs.ES:=PrefSeg;„    Regs.BX:=MyBlockSize;„    MsDos (Regs);„  end;„„  {............................................................................}„„  procedure RestoreRedir;„„  begin„    If not RedirChanged then Exit;„    Handles^[1]:=OldHandle;„    Close (F);„  end;„„  {............................................................................}„„Begin„  RedirError:=0;„  RedirChanged:=ChangeRedir;„  CompactHeap;„  DosExecute;„  Expandheap;„  RestoreRedir;„End;„„{------------------------------------------------------------------------------}„„Begin„  SetCBreak (False);„  FName:=ParamStr (0);„  Assign (F, FName);„  Reset (F, 1);„  IOStatus:=IOResult;„  If IOStatus = 0 then„    begin„      BlockRead (F, Header, SizeOf (Header));„      IOStatus:=IOResult;„      If IOStatus = 0 then MinBlockSize:=Header.PageCnt * 32 + Header.MinMem + 1„      Else MinBlockSize:=$8000;„      Close (F);„    end„  Else MinBlockSize:=$8000;„  PtrRec (MCB).Seg:=PrefixSeg - 1;„  PtrRec (MCB).Ofs:=$0000;„  MyBlockSize:=MCB^.Size;„  PrefSeg:=PrefixSeg;„End.„                                        2      05-28-9313:45ALL                      SWAG SUPPORT TEAM        EXECINFO.PAS             IMPORT              3      U!ì {$M 4096,0,4096}„„Uses„  Dos, Prompt;„„begin„  ChangeShellPrompt('Hi There');„  SwapVectors;„  Exec(GetEnv('COMSPEC'),'');„  SwapVectors;„end.                                                                                                                  3      05-28-9313:45ALL                      SWAG SUPPORT TEAM        PROMPT.PAS               IMPORT              23     Uî' {$A+,B-,F-,L-,N-,O-,R-,S-,V-}„„Unit prompt;„„{„„Author:   Trevor J Carlsen„          PO Box 568„          Port Hedland„          Western Australia 6721„          61-[0]-91-73-2026  (voice)„          61-[0]-91-73-2930  (data )„          „Released into the public domain.„„This Unit will automatically create a predefined prompt when shelling to Dos.„if you wish to create your own custom prompt, all that is required is to give„the Variable NewPrompt another value and call the Procedure ChangeShellPrompt.„„}„„Interface„„Uses Dos;„„Var„  NewPrompt : String;„„Procedure ChangeShellPrompt(Nprompt: String);„„Implementation„„ Type„   EnvArray  = Array[0..32767] of Byte;„   EnvPtr    = ^EnvArray;„ Var„   EnvSize, EnvLen, EnvPos: Word;„   NewEnv, OldEnv         : EnvPtr;„   TempStr                : String;„   x                      : Word;„„ Procedure ChangeShellPrompt(Nprompt: String);„„   Function MainEnvSize: Word;„     Var„       x      : Word;„       found  : Boolean;„     begin„       found  := False; x := 0;„       Repeat„         if (OldEnv^[x] = 0) and (OldEnv^[x+1] = 0) then„           found := True„         else„           inc(x);„       Until found;„       MainEnvSize := x - 1;„     end; { MainEnvSize}„„   Procedure AddEnvStr(Var s; Var offset: Word; len: Word);„     Var st : EnvArray Absolute s;„     begin„       move(st[1],NewEnv^[offset],len);„       inc(offset,len+1);„     end;„„ begin„   OldEnv   := ptr(MemW[PrefixSeg:$2C],0);„   { this gets the actual starting segment of the current Program's env }„„   EnvSize      :=  MemW[seg(OldEnv^)-1:3] shl 4;„   { Find the size of the current environment }„„   if MaxAvail < (EnvSize+256) then begin„     Writeln('Insufficient memory');„     halt;„   end;„„   GetMem(NewEnv, EnvSize + $100);„   if ofs(NewEnv^) <> 0 then begin„      inc(LongInt(NewEnv),$10000 + ($10000 * (LongInt(NewEnv) div 16)));„      LongInt(NewEnv) := LongInt(NewEnv) and $ffff0000;„   end;„   FillChar(NewEnv^,EnvSize + $100,0);„   { Allocate heap memory For the new environment adding enough to allow }„   { alignment to a paraGraph boundary or a longer prompt than the default }„   { and initialise to nuls }„   EnvPos   := 0;„„   AddEnvStr(Nprompt,EnvPos,length(Nprompt));„   For x := 1 to EnvCount do begin„     TempStr := EnvStr(x);„     if TempStr <> GetEnv('PROMPT') then„       AddEnvStr(TempStr,EnvPos,length(TempStr));„   end; { For }„   inc(EnvPos);„   { Transfer old env Strings except the prompt to new environment }„„   if lo(DosVersion) > 2 then„     AddEnvStr(OldEnv^[MainEnvSize + 2],EnvPos,EnvSize-(MainEnvSize + 2));„   { Add the rest of the environment }„„   MemW[PrefixSeg:$2C] := seg(NewEnv^);„   { let the Program know where the new environment is }„ end;  { ChangeShellPrompt }„„end.  { prompt }„  „                                                4      08-17-9308:51ALL                      SWAG SUPPORT TEAM        Demonstrates DOS Exec    IMPORT              18     UdÒ {$M 8192,0,0}„{* This memory directive is used to make„   certain there is enough memory left„   to execute the DOS shell and any„   other programs needed.  *}„„Program EXEC_Demo;„„{*„„  EXEC.PAS„„  This program demonstrates the use of„  Pascal's EXEC function to execute„  either an individual DOS command or„  to move into a DOS Shell.„„  You may enter any command you could„  normally enter at a DOS prompt and„  it will execute.  You may also hit„  RETURN without entering anything and„  you will enter into a DOS Shell, from„  which you can exit by typing EXIT.„„  The program stops when you hit a„  'Q', upper or lower case.„*}„„„Uses Crt, Dos;„„Var„  Command : String;„„{**************************************}„Procedure Do_Exec; {*******************}„„  Var„    Ch : Char;„„  Begin„    If Command <> '' Then„      Command := '/C' + Command„    Else„      Writeln('Type EXIT to return from the DOS Shell.');„    {* The /C prefix is needed to„       execute any command other than„       the complete DOS Shell. *}„„    SwapVectors;„    Exec(GetEnv('COMSPEC'), Command);„    {* GetEnv is used to read COMSPEC„       from the DOS environment so the„       program knows the correct path„       to COMMAND.COM. *}„„    SwapVectors;„    Writeln;„    Writeln('DOS Error = ',DosError);„    If DosError <> 0 Then„      Writeln('Could not execute COMMAND.COM');„    {* We're assuming that the only„       reason DosError would be something„       other than 0 is if it couldn't„       find the COMMAND.COM, but there„       are other errors that can occur,„       we just haven't provided for them„       here. *}„„    Writeln;„    Writeln;„    Writeln('Hit any key to continue...');„    Ch := ReadKey;„  End;„„„Function Get_Command : String;„„  Var„    Count : Integer;„    Cmnd : String;„„  Begin„    Clrscr;„    Write('Enter DOS Command (or Q to Quit): ');„    Readln(Cmnd);„    Get_Command := Cmnd„  End;„„Begin„  Command := Get_Command;„  While NOT ((Command = 'Q') OR (Command = 'q')) Do„    Begin„      Do_Exec;„      Command := Get_Command„    End;„End.                                                                                                                    5      08-27-9321:37ALL                      KELD R. HANSEN           Exec with Memory Shrink  IMPORT              12     U©È (*„KELD R. HANSEN„„> I need to *simulate* something like:„> {$M 16384,0,0}               {reduce heap}„> Exec('c:\myprgm.exe','');    {run myprgm.exe}„> {$M 16384,110000,110000}     {restore heap}„„EXECUTE shrinks your programs memory allocation to the smallest possible value,„then runs the program and then expands it back up again. Works in TP 6.0 and„7.0!„*)„„USES„  DOS;„„TYPE„  STR127 = STRING[127];„„PROCEDURE ReallocateMemory(P : POINTER); ASSEMBLER;„ASM„  MOV  AX, PrefixSeg„  MOV  ES, AX„  MOV  BX, WORD PTR P+2„  CMP  WORD PTR P,0„  JE   @OK„  INC  BX„„ @OK:„  SUB  BX, AX„  MOV  AH, 4Ah„  INT  21h„  JC   @X„  LES  DI, P„  MOV  WORD PTR HeapEnd,DI„  MOV  WORD PTR HeapEnd+2,ES„„ @X:„END;„„FUNCTION EXECUTE(Name : PathStr ; Tail : STR127) : WORD; ASSEMBLER;„ASM„  {$IFDEF CPU386}„  DB      66h„  PUSH    WORD PTR HeapEnd„  DB      66h„  PUSH    WORD PTR Name„  DB      66h„  PUSH    WORD PTR Tail„  DB      66h„  PUSH    WORD PTR HeapPtr„  {$ELSE}„  PUSH    WORD PTR HeapEnd+2„  PUSH    WORD PTR HeapEnd„  PUSH    WORD PTR Name+2„  PUSH    WORD PTR Name„  PUSH    WORD PTR Tail+2„  PUSH    WORD PTR Tail„  PUSH    WORD PTR HeapPtr+2„  PUSH    WORD PTR HeapPtr„  {$ENDIF}„  CALL ReallocateMemory„  CALL SwapVectors„  CALL DOS.EXEC„  CALL SwapVectors„  CALL ReallocateMemory„  MOV  AX, DosError„  OR   AX, AX„  JNZ  @OUT„  MOV  AH, 4Dh„  INT  21h„„ @OUT:„END;„                                       6      10-28-9311:30ALL                      MAYNARD PHILBROOK        EXEC DOS in a Window     IMPORT              10     Uv¿ {===================================================================„Date: 10-19-93 (19:37)„From: MAYNARD PHILBROOK„Subj: Re: Execwindow graphics„----------------------------------------------------------------------}„{$F+,I-,S-,D-}„{$m 1024, 0, 3000}„„Uses Crt, Dos;„Var„OLD_29H :Pointer;„C   :Char;         { Holds Charactor to Write }„{$F+}„„Procedure Patch1;„Interrupt;„Begin„    Write(C);„End;„„Procedure Patch; Assembler;„  Asm„    Push DS„    Push Ax„        Mov   AX, Seg C;„        Mov   DS, AX;„        Pop   AX;„        Mov   C, Al;„        Pop   DS„        Jmp   Patch1;„  End;„Begin„ Clrscr;„ GetINtVec($29, OLD_29H);„ SetIntVec($29, @Patch);„ Window(14, 10, 40, 22);„ ClrScr;„ Exec('C:\Command.com',' /c dir');„ Readkey;„ SetIntVec($29, OLD_29h);„End.„„The Command.com is just an example..„Note:„If your using ANSI.SYS in Dos, this will not use Anis..„TP uses its own screen writes, but this code directs all Dos Char Output„to the TP window.„To Stop echo of Dos functions or what ever, use the„> NULL at the end of the parms when executing..„„--- MsgToss 2.0b„ * Origin: Sherwood Forest RBBS 203-455-0646 (1:327/453)„                    7      10-28-9311:31ALL                      GAYLE DAVIS              FIND AND EXECUTE         IMPORT              24     U∂f {$S-,R-,V-,I-,N-,B-,F-}„„{$IFNDEF Ver40}„  {Allow overlays}„  {$F+,O-,X+,A-}„{$ENDIF}„„UNIT FINDEXEC;„„INTERFACE„„USES CRT,DOS;„„PROCEDURE FLUSHALLDOS;„PROCEDURE REBOOT;„FUNCTION  EXECUTE (Name : PathStr ; Tail : STRING) : WORD;„PROCEDURE RunInWindow (FN, Cmd : STRING; PAUSE : BOOLEAN);„„IMPLEMENTATION„VAR„     cname   : STRING;„     Old_29H : POINTER;„„PROCEDURE FLUSHALLDOS; ASSEMBLER;„ASM„  mov   ah, 0Dh„  INT   21h„  XOR   cx, cx„@1 :„  push  cx„  INT   28h„  pop   cx„  loop  @1„END;„„PROCEDURE Reboot; assembler;„asm„  CALL  FLUSHALLDOS„  MOV   ds, cx„  MOV   WORD PTR [472h], 1234h„  DEC   cx„  PUSH  cx„  PUSH  ds„END;„„{F+}„Procedure Int29Handler(AX, BX, CX, DX, SI, DI, DS, ES, BP : Word); Interrupt;„Var„  Dummy : Byte;„begin„  Asm„    Sti„  end;„  Write(Char(Lo(Ax)));„  Asm„    Cli„  end;„end;„{$F-}„„{   EXECUTE STUFF - SHRINK HEAP AND EXECUTE LIKE EXECDOS }„„PROCEDURE ReallocateMemory (P : POINTER); ASSEMBLER;„ASM„  MOV  AX, PrefixSeg„  MOV  ES, AX„  MOV  BX, WORD PTR P + 2„  CMP  WORD PTR P, 0„  JE   @OK„  INC  BX„„ @OK :„  SUB  BX, AX„  MOV  AH, 4Ah„  INT  21h„  JC   @X„  LES  DI, P„  MOV  WORD PTR HeapEnd, DI„  MOV  WORD PTR HeapEnd + 2, ES„ @X :„END;„„{ ZAP this DEFINE if NOT 386,486}„{..$DEFINE CPU386}„„FUNCTION EXEC (Name : PathStr ; Tail : STRING) : WORD; ASSEMBLER;„ASM„  CALL    FLUSHALLDOS„  {$IFDEF CPU386}„  DB      66h„  PUSH    WORD PTR HeapEnd„  DB      66h„  PUSH    WORD PTR Name„  DB      66h„  PUSH    WORD PTR Tail„  DB      66h„  PUSH    WORD PTR HeapPtr„  {$ELSE}„  PUSH    WORD PTR HeapEnd + 2„  PUSH    WORD PTR HeapEnd„  PUSH    WORD PTR Name + 2„  PUSH    WORD PTR Name„  PUSH    WORD PTR Tail + 2„  PUSH    WORD PTR Tail„  PUSH    WORD PTR HeapPtr + 2„  PUSH    WORD PTR HeapPtr„„  {$ENDIF}„„  CALL ReallocateMemory„  CALL SwapVectors„  CALL DOS.EXEC„  CALL SwapVectors„  CALL ReallocateMemory„  MOV  AX, DosError„  OR   AX, AX„  JNZ  @OUT„  MOV  AH, 4Dh„  INT  21h„„ @OUT :„„END;„„FUNCTION EXECUTE (Name : PathStr ; Tail : STRING)  : WORD;„VAR W : PathStr;„BEGIN„ DosError := 2;„ W := FSEARCH (Name, GetEnv ('PATH') );„ IF W = '' THEN EXIT;„ EXECUTE := EXEC(W,Tail);„END;„„PROCEDURE RunInWindow (FN, Cmd : STRING; PAUSE : BOOLEAN);„„VAR sa : BYTE;„    w  : pathstr;„„BEGIN„„ DosError := 2;„ W := FSEARCH (fn, GetEnv ('PATH') );„ IF W = '' THEN EXIT;„ sa       := Textattr;„„ GETINTVEC ($29, OLD_29H);„ SETINTVEC ($29, @Int29Handler);         { Install interrupt handler }„ WINDOW (LO (WindMin) + 1, HI (WindMin) + 1, LO (WindMax) + 1, HI (WindMax) + 1);„ EXEC (W, Cmd );„ SETINTVEC ($29, OLD_29h);„„ IF PAUSE THEN„    BEGIN„    WRITELN;„    WRITELN (' .. Any Key Continues .. ');„    asm„      Mov AX, $0C00;               { flush keyboard }„      Int 21h;„    end;„    WHILE NOT KEYPRESSED DO;„    asm„      Mov AX, $0C00;„      Int 21h;„    end;„    END;„ Textattr := sa;„END;„„END.                                                                                                          8      10-28-9311:38ALL                      MIKE DICKSON             Search Execute           IMPORT              14     U±Ó {===========================================================================„Date: 09-18-93 (23:25)„From: MIKE DICKSON„Subj: EXEC ()„---------------------------------------------------------------------------„[MM]  ± I've written my own EXEC function that performs an FSearch() on the„[MM] Well, that's great. (Why don't you post it!).„„Okay...here's an illustrative little program... }„„{$M $4000,0,0 }„Program JohnMajorHadBetterResignPrettyDamnedShortly;„„Uses DOS;„„FUNCTION  FileExists (FileName: String):Boolean;{ Checks if file„exists  } var„   Attr : Word;„   f    : file;„begin„   Assign (f, Filename);„   GetFAttr(f, attr);„   FileExists := (DOSError = 0);„end;„„FUNCTION SearchExec (ProgramName, Parameters : String) : Integer;„var„   Result : Integer;„begin„{ If the program doesn't exist then search on the %PATH for it }„   If Not FileExists(ProgramName) then„      ProgramName := FSearch(ProgramName, GetEnv('PATH'));„„{ If it's a batch file then call it through the command processor }„   If Pos('.BAT', ProgramName) <> 0 then begin„      Parameters := '/C '+ProgramName+' '+Parameters;„      ProgramName := GetEnv('COMSPEC');„   end;„„{ Now call the program...if it didn't exist the set DOSError to 2 }„   If ProgramName <> '' then begin„      SwapVectors;„      Exec (ProgramName, Parameters);„      Result := DOSError;„      SwapVectors;„      SearchExec := Result;„   end else SearchExec := 2;„„end;„„begin„   If SearchExec ('AUTOEXEC.BAT', '/?') <> 0„      then writeln ('Execution was okay!')„      else writeln ('Execution was NOT okay!');„end.„                                                                                                 9      11-02-9305:32ALL                      MARTIN AUSTERMEIER       Redirection in DOS       IMPORT              12     U√“ {„MARTIN AUSTERMEIER„„> PKZIP Filename -Z < zipcomment„> Is there any way to do this WithOUT calling COMSPEC For anothershell?„„yes, but much more complicated than leaving the job to %comspec..„„Before executing PKZIP, you have to„„  * open a Text File„  * get its handle (see TextRec); save it in - say - "newStdIn"„  * then perform something like„  if (newSTDIN <> 0) then begin„    saveHandle[STDIN]:=DosExt.DuplicateHandle (STDIN);„    DosExt.ForceDuplicateHandle (newSTDIN, STDIN);„    created[STDIN]:=True;„  end;„  (DosExt.xx Routines and STDIN Const explained below)„„  * Exec()„  * Cancel redirections:„}„„Procedure CancelRedirections; { of ExecuteProgram }„Var„  redirCnt : Word;„begin„  For redirCnt := STDIN to STDOUT do„  begin„    if created[redirCnt] then„    begin„      DosExt.ForceDuplicateHandle(saveHandle[redirCnt], redirCnt);„      DosExt.CloseHandle(saveHandle[redirCnt]);„    end;„  end;„end;„„Const„  STDIN  = 0;„  STDOUT = 1;„  STDERR = 2;„„Procedure CallDos; Assembler;„Asm„  mov Dos.DosError, 0„  Int 21h„  jnc @@Ok„  mov Dos.DosError, ax„ @@Ok:„end;„„Function DuplicateHandle(handle : Word) : Word;  Assembler;„Asm„  mov ah, 45h„  mov bx, handle„  call CallDos„  { DuplicateHandle := AX; }„end;„„Procedure ForceDuplicateHandle(h1, h2 : Word); Assembler;„Asm„  mov ah, 46h„  mov bx, h1„  mov cx, h2„  call CallDos„end;„„                                                            10     11-02-9306:30ALL                      TRISDARESA SUMARJOSO     Trapping INT29 Output    IMPORT              61     Us> {„TRISDARESA SUMARJOSO„„> I was wondering if anyone knew how to make a split screen While„> making EXEC calls and not losing your Windows?„„> Anyone got any ideas or routines that do this? I can do it easily„> using TTT when I just stay Within the Program, but the problems arise„> when I do the SwapVectors and do my Exec call, all hell breaks loose.„> Lynn.„„	Here is a Unit that I've created to trap Int 29h. the Function of this„Unit is to trap the output that Dos spits through the Int 29h (such as XCopy,„PkZip, etc) and redirect it into a predefined Window.„	Here is the stuff:„}„„Unit I29UnitA;„„{ This Unit will trap Dos output which use Int 29h. Any other„  method of writing the scren, such as Direct Write which bypasses„  Int 29h call, will not be trapped. }„„Interface„„{ Initialize the view that will be use to output the Dos output.„  Will also draw basic Window frame. }„Procedure InitView(XX1, XY1, XX2, XY2 : Byte);„{ Clear the pre-defined view. }„Procedure ClearView;„{ Procedure to redirect the Turbo Pascal Write and WriteLn Procedure.„  (standard OutPut only).„  Do not call this Procedure twice in the row.„  More than once call to this Procedure will result Pascal's standard„  output Procedure will not be restored properly. }„Procedure TrapWrite;„{ Restore Pascal's Write and WriteLn Procedure into its original„  condition that was altered With TRAPWrite. (standard OutPut only). }„Procedure UnTrapWrite;„„Implementation„„Uses„  Dos;„„Type„  VioCharType = Record„    Case Boolean Of„      True  : (Ch, Attr : Byte);„      False : (Content : Word);„    end;„„  DrvFunc    = Function(Var F : TextRec) : Integer;„  VioBufType = Array [0..24, 0..79] Of VioCharType;„„Var„  OldInt29     : Pointer;„  OldExit      : Pointer;„  OldIOFunc    : DrvFunc;„  OldFlushFunc : DrvFunc;„  TrapWriteVar : Boolean;„  X1, Y1, X2,„  Y2           : Byte;„  XVio         : Byte;„  YVio         : Byte;„  VioBuffer    : ^VioBufType;„  VioCurLoc    : Word Absolute $0040:$0050;„„{$F+}„Procedure NewInt29(Flags, CS, IP, AX, BX, CX, DX, SI, DI, DS, ES, BP: Word);„Interrupt;„begin„  VioBuffer^[YVio, XVio].Attr := VioBuffer^[YVio, XVio].Attr And Not 112;„  if (Lo(AX) = 13) Then„  begin„    XVio := X1;„    AX := 0;„  end„  else„  if (Lo(AX) = 10) Then„  begin„    Inc(YVio);„    AX := 0;„  end;„  begin„    if (XVio > X2) Then„    begin„      XVio := X1;„      Inc(YVio);„    end;„    if (YVio > Y2) Then„    begin„      Asm„        Mov   AH, 06„        Mov   AL, YVio„        Sub   AL, Y2„        Mov   CH, Y1„        Mov   CL, X1„        Mov   DH, Y2„        Mov   DL, X2„        Mov   BH, 07„        Int   10h„      end;„„      YVio := Y2;„    end;„„    if (Lo(AX) = 32) Then„    begin„      if (Lo(VioCurLoc) < XVio) Then„      begin„        XVio := Lo(VioCurLoc);„        VioBuffer^[YVio, XVio].Ch := Lo(AX);„      end„      else„      begin„        VioBuffer^[YVio, XVio].Ch := Lo(AX);„        Inc(XVio);„      end;„    end„    else„    begin„      VioBuffer^[YVio, XVio].Ch := Lo(AX);„      Inc(XVio);„    end;„    VioCurLoc := YVio Shl 8 + XVio;„  end;„  VioBuffer^[YVio, XVio].Attr := VioBuffer^[YVio, XVio].Attr Or 112;„end;„{$F-}„„{$F+}„Procedure RestoreInt29;„begin„  ExitProc := OldExit;„  SetIntVec($29, OldInt29);„  if TrapWriteVar Then„  begin„    TextRec(OutPut).InOutFunc := @OldIOFunc;„    TextRec(OutPut).FlushFunc := @OldFlushFunc;„  end;„end;„{$F-}„„Procedure HookInt29;„begin„  GetIntVec($29, OldInt29);„  SetIntVec($29, @NewInt29);„  OldExit := ExitProc;„  ExitProc := @RestoreInt29;„end;„„Procedure InitView(XX1, XY1, XX2, XY2: Byte);„Var„  I    : Byte;„begin„  X1 := XX1+1;„  Y1 := XY1+1;„  X2 := XX2-1;„  Y2 := XY2-1;„  XVio := X1;„  YVio := Y1;„  For I := XX1 To XX2 Do„  begin„    VioBuffer^[XY1, I].Ch := 205;„    VioBuffer^[XY2, I].Ch := 205;„  end;„  For I := XY1+1 To XY2-1 Do„  begin„    VioBuffer^[I, XX1].Ch := 179;„    VioBuffer^[I, XX2].Ch := 179;„  end;„  VioBuffer^[XY1, XX1].Ch := 213;„  VioBuffer^[XY2, XX1].Ch := 212;„  VioBuffer^[XY1, XX2].Ch := 184;„  VioBuffer^[XY2, XX2].Ch := 190;„  VioCurLoc := YVio Shl 8 + XVio;„end;„„Procedure DoWriteStuff(F : TextRec);„Var„  I    : Integer;„  Regs : Registers;„begin„  For I := 0 To F.BufPos-1 Do„  begin„    Regs.AL := Byte(F.BufPtr^[I]);„    Intr($29, Regs);„  end;„end;„„{$F+}„Function NewOutputFunc(Var F : TextRec) : Integer;„begin„  DoWriteStuff(F);„  F.BufPos := 0;„  NewOutPutFunc := 0;„end;„{$F-}„„{$F+}„Function NewFlushFunc(Var F : TextRec) : Integer;„begin„  DoWriteStuff(F);„  F.BufPos := 0;„  NewFlushFunc := 0;„end;„{$F-}„„Procedure TrapWrite;„begin„  if Not TrapWriteVar Then„  begin„    With TextRec(OutPut) Do„    begin„      OldIOFunc := DrvFunc(InOutFunc);„      InOutFunc := @NewOutPutFunc;„      OldFlushFunc := DrvFUnc(FlushFunc);„      FlushFunc := @NewFlushFunc;„    end;„    TrapWriteVar := True;„  end;„end;„„Procedure UnTrapWrite;„begin„  if TrapWriteVar Then„  begin„    TextRec(OutPut).InOutFunc := @OldIOFunc;„    TextRec(OutPut).FlushFunc := @OldFlushFunc;„    TrapWriteVar := False;„  end;„end;„„Procedure ClearView;„begin„  Asm„    Mov   AH, 06„    Mov   AL, 0„    Mov   CH, Y1„    Mov   CL, X1„    Mov   DH, Y2„    Mov   DL, X2„    Mov   BH, 07„    Int   10h„  end;„  XVio := X1;„  YVio := Y1;„  VioCurLoc := YVio Shl 8 + XVio;„end;„„Procedure CheckMode;„Var„  MyRegs : Registers;„begin„  MyRegs.AH := $F;„  Intr($10, MyRegs);„  Case MyRegs.AL Of„    0, 1, 2, 3  : VioBuffer := Ptr($B800, $0000);„    7           : VioBuffer := Ptr($B000, $0000);„  end;„end;„„begin„  X1 := 0;„  Y1 := 0;„  X2 := 79;„  Y2 := 24;„  XVio := 0;„  YVio := 0;„  VioCurLoc := YVio Shl 8 + XVio;„  HookInt29;„  TrapWriteVar := False;„  CheckMode;„end.„„„Program Int29Testing;„„{$A+,B-,D+,E+,F-,G-,I+,L+,N-,O-,P-,Q-,R-,S+,T-,V+,X+}„{$M $800,0,0}„„Uses„  Dos, Crt,„  I29UnitA;„„Var„  CmdLine      : String;„  I            : Byte;„„{ Function to convert a String to upper case.„  Return the upper-case String. }„„Function Str2Upr(Str : String) : String; Assembler;„Asm„  Push DS„  CLD„  LDS  SI, Str„  LES  DI, @Result„  LodSB„  Or   AL, AL„  Jz   @Done„  StoSB„  Xor  CH, CH„  Mov  CL, AL„ @@1:„  LodSB„  Cmp  AL, 'a'„  JB   @@2„  Cmp  AL, 'z'„  JA   @@2„  Sub  AL, 20h„ @@2:„  StoSB„  Loop @@1„ @Done:„  Pop  DS„end;„„begin„  ClrScr;„  GotoXY(1,1);„  WriteLn('Output interceptor.');„  { Initialize redirector's area. }„  InitView(0,2,79,24);„  Repeat„	  { Redirect Turbo's output into the predefined Window. }„    TrapWrite;„    Write(#0,' Please enter Dos command (Done to Exit): ');„    ReadLn(CmdLine);„    WriteLn;„    { Restore Turbo's original Output routine. }„    UnTrapWrite;„    GotoXY(1,2);„    WriteLn('Command executed : ', CmdLine);„    CmdLine := Str2Upr(CmdLine);„    if (CmdLine <> 'DONE') And (CmdLine <> '') Then„    begin„      SwapVectors;„      Exec('C:\Command.Com', '/C'+CmdLine);„      SwapVectors;„    end;„    GotoXY(1,2);„    WriteLn('Command execution done. Press anykey to continue...');„    Repeat Until ReadKey <> #0;„    ClearView;„    GotoXY(1,2);„    WriteLn('                                                   ');„  Until (CmdLine = 'DONE');„  ClrScr;„end.„„{„Both the testing Program and the Unit itself (expecially the Unit), is by no„mean perfect. Use With caution. It might not wise to use such redirector„(my int 29 Unit) in a Program that swaps itself out of memory. The above„Programs were not optimized in anyway (so it might slow your Program a„little). And I don't guarantee that this Program will work on your computer„(it work Without a problem on mine). if you like this Unit, you can use it„anyway you desire. Just remember I can guarantee nothing For this method.„}„                                                               11     11-02-9310:33ALL                      KELLY SMALL              Change the MASTER Env    IMPORT              14     U–4 {„KELLY SMALL„„>Does anyone know how to change the "master" environment?  I want to have my„>program change the dos prompt and have it be there after my program ends.„>DOS's stupid little batch language can do it, so there must be a way.„„Here's a procedure that should do it from TeeCee:„}„„procedure InitNewPrompt;„{-set up a new prompt for shelling to dos}„type„  _2karray = array[1..2048] of byte;„  SegPtr   = ^_2karray;„const„  NewPrompt : string = ('PROMPT=Type EXIT to return to program$_$p$g'+#0);„var„  EnvSegment,„  NewEnvSeg   : word;„  PtrSeg,„  NewEnv      : SegPtr;„begin„  EnvSegment := memw[prefixseg:$2C];„  {-this gets the actual starting segment of the current program's env}„„  PtrSeg := ptr(pred(EnvSegment), 0);„  {-The segment of the program's MCB - (Memory control block) }„„  getmem(NewEnv, 1072 + length(NewPrompt));„  {-Allocate heap memory and allow enough room for a dummy mcb }„„  if ofs(NewEnv^) <> 0 then„    NewEnvSeg := seg(NewEnv^) + 2„  else„    NewEnvSeg := succ(seg(NewEnv^));„  {-Force the new environment to start at paragraph boundary}„„  move(PtrSeg^, mem[pred(NewEnvSeg) : 0], 16);„  {-copy the old mcb and force to paragraph boundary}„„  memw[pred(NewEnvSeg) : 3] := (1072 + length(NewPrompt)) shr 4;„  {-Alter the environment length by changing the dummy mcb}„„  move(NewPrompt[1], memw[NewEnvSeg : 0], length(NewPrompt));„  {-install new prompt}„„  memw[prefixseg:$2C] := NewEnvSeg;„  {-let the program know where the new env is}„„  move(mem[EnvSegment : 0], mem[NewEnvSeg : length(NewPrompt)], 1024);„  {-shift the old env to the new area}„end;„                                                                       12     01-27-9411:58ALL                      TOM CARROLL              Execution in a DOS WindowIMPORT              31     U› (*„   Written by Tom Carroll, Nova 24, 1993 for TP 7.0.„„   Adapted from the example code posted by Kelly Small in the FidoNet„   Pascal echo 11/19/93.„„   Released to the Public Domain 11/24/93.„„   Please give credit where credit is due„„   This Program will execute a program within a text window„   and all program scrolling will be maintained within„   the window.„„   This would be better to put inside a unit, but I couldn't get the„   interrupt to work within the unit.  If you're able to get it to work„   inside a unit, I would appreciate you posting the unit so I can see„   how it was done.„*)„„Program ExecInATextWindow;„„USES„   Dos,  { Used for the Exec call }„   Crt;  { For the GotoXY calls }„„VAR„   ExitVal    : WORD;„   MyProg     : STRING;„   MyParams   : STRING;„   OldIntVect : POINTER;„„{$F+}„PROCEDURE Int29Handler(AX, BX, CX, DX, SI, DI, DS, ES, BP : WORD);„„INTERRUPT;„„VAR„   Dummy : BYTE;„„BEGIN„   Write(Chr(Lo(AX)));   { Writes each output character to the screen }„   Asm Sti; END;„END;„{$F-}„„PROCEDURE HookInt29;„„BEGIN„   GetIntVec($29, OldIntVect);      { Save the old vector }„   SetIntVec($29, @Int29Handler);   { Install interrupt handler }„END;„„FUNCTION ExecWin(ProgName, Params : STRING; LeftCol, TopLine,„                 RightCol, BottomLine : WORD) : WORD;„„VAR„   A : WORD;„„BEGIN„   GotoXY(LeftCol, TopLine);               { Puts cursor at the top left }„   Write(Chr(201));                        { hand corner of the window   }„„{ I use three FOR loops to write the actual window borders to the screen.„„  NOTE: The window size for the executed program will actually be two„        rows and two columns smaller that what you call.  This is because„        there is no error checking to see if the call will place the„        window borders outside the maximum row column range for the„        video.                                                           }„„   FOR A := 1 TO (RightCol-LeftCol) - 1 DO„      Write(Chr(205));„   Write(Chr(187));„   FOR A := 1 TO (BottomLine-TopLine) - 1 DO„      BEGIN„         GotoXY(LeftCol, TopLine + A);„         Write(Chr(186));„         GotoXY(RightCol,TopLine + A);„         Write(Chr(186));„      END;„   GotoXY(LeftCol, BottomLine);„   Write(Chr(200));„   FOR A := 1 TO (RightCol-LeftCol) - 1 DO„      Write(Chr(205));„   Write(Chr(188));„„{ Now set the text window so the program will not scroll the outline of„  the window off the screen.                                            }„„   Window(LeftCol + 1, TopLine + 1, RightCol - 1, BottomLine - 1);„   GotoXY(1, 1);     { Jumps to the upper left hand corner of the window }„   HookInt29;        { Hooks Interrupt 29 for video output }„   {$M 10000, 0, 0}  { This works good for Archive utilities }„   SwapVectors;„   Exec(ProgName, Params);„   ExecWin := DOSExitCode; { Return the exit code for error trapping }„   SwapVectors;„   SetIntVec($29,OldIntVect); { Restore the interrupt }„   Window(LeftCol, TopLine, RightCol, BottomLine); { Set the window to the }„   ClrScr;                                         { actual size of the    }„   Window(1, 1, 80, 25);                           { border so it can be   }„END;                                               { cleared properly.     }„„BEGIN„„ClrScr;„„{ Modify these two lines to suit your system }„„MyProg := 'C:\UTIL\PKUNZIP.EXE';„MyParams := '-t C:\QMPRO\DL\STORE\WAV\SEINWAV1.ZIP';„„ExitVal := ExecWin(MyProg, MyParams, 5, 6, 75, 16);„„WriteLn('DOS exit code = ', ExitVal);„„ReadLn;„„END.„„{ I would like to modify this code to allow for a screen save feature that„  will restore the previous screen for the coordinates passed to the ExecWin„  function.„  Other nice features would be to add a sideways scrolling effect,„  exploding windows for the text window and then make it implode when„  the previous video is restored. }„„   13     01-27-9412:00ALL                      LARRY HADLEY             Appending to EXE Files   IMPORT              42     UY© {„>Hmmm.... how about this.... I want to put a 75k MOD file into the EXE...„>I've heard that you use pointers and appending the MOD to end of your„>compiled program and stuff like that... I'm not too sure how to go about„>it.„„In short, the easiest way is to append to to your .EXE file. The„following code will search the current .exe for data appended to„the end of the .exe file.„}„„Uses„  DOS;„„TYPE              { .exe file header }„  EXEH = RECORD„    id,            { .exe signature }„    Lpage,         { .exe file size mod 512 bytes; < 512 bytes }„    Fpages,        { .exe file size div 512 bytes; + 1 if Lpage > 0 }„    relocitems,    { number of relocation table items }„    size,          { .exe header size in 16-byte paragraphs }„    minalloc,      { min heap required in additional to .exe image }„    maxalloc,      { extra heap desired beyond that required„                     to hold .exe's image }„    ss,            { displacement of stack segment }„    sp,            { initial SP register value }„    chk_sum,       { complemented checksum }„    ip,            { initial IP register value }„    cs,            { displacement of code segment }„    ofs_rtbl,      { offset to first relocation item }„    ovr_num : word; { overlay numbers }„  END;„„CONST„  MAX_BLOCK_SIZE = 65528; {maximum allowable size of data block in„                            TP}„TYPE„  pdata = ^data_array;„  data_array = array[0..MAX_BLOCK_SIZE] of byte;„„  pMODblock = ^MODblock;„  MODblock = RECORD„    data     :pdata;„    datasize :word;„  end;„„VAR„  exefile : file;„  exehdr  : exeh;„  blocks  : word;„„  exesize,„  imgsize : longint;„„  path    : dirstr;„  name    : namestr;„  ext     : extstr;„  EXEName : pathstr;„  n       : byte;„„  dirfile : searchrec;„„  M       : pMODblock;„„{Determines the exe filename, opens the file for read-only, and„ determines the actual .exe code image size by reading the„ standard .exe header that is in front of every .exe file. The .MOD„ data will be in the file *after* the end of the code image.}„Procedure ReadHdr;„„  {this "finds" your exe filename}„  Function CalcEXEName : string;„  var„    Dir  : DirStr;„    Name : NameStr;„    Ext  : ExtStr;„  begin„    if Lo(DosVersion) >= 3 then„      EXEName := ParamStr(0)„    else„      EXEName := FSearch('progname.EXE', GetEnv('PATH'));„                         {  ^^^^^^^^ } { change this to intended EXE name }„    FSplit(EXEName, Dir, Name, Ext);„    CalcEXEName := Name;„  end;„„begin„  Name := CalcEXEName;„„  findfirst(EXEName, anyfile, dirfile);„  while (doserror=0) do„  BEGIN„    Assign(exefile, EXEName);„    Reset(exefile, 1);         { reset for 1 byte records }„    BlockRead(exefile, exehdr, SizeOf(exehdr), blocks);„    if blocks<SizeOf(exehdr) then„    begin„      Writeln('File read error!');„      Halt(1);„    end;„    exesize := dirfile.size;     { the total file size of exe+data }„    with exehdr do„    begin„      imgsize := FPages; {exe img size div 512 bytes, +1 if Lpage>0}„      if LPage > 0 then„        dec(imgsize);„      imgsize := (imgsize*512) + LPage; {final image size}„    end;„  END;„end;„„{ this function reads the 64k-8 byte sized block, numbered„  "blocknum" from the end of the file exefile (already opened in„  ReadHdr proc above), allocates a new pMODblock structure and„  passes it back to the caller. "blocknum" is 0-based - ie, data„  offset starts at 0. If the remaining data is less than 64k, the„  data record will be sized to the remaining data.}„Function ReadBlockFromMOD(blocknum):pMODblock;„var„  filepos : longint;„  mod     : pMODblock;„begin„  filepos := imgsize + (blocknum*MAX_BLOCK_SIZE);„  if filepos > exesize then {block position asked for exceeds filesize}„  begin„    ReadBlockFromMOD := NIL; { return error signal }„    EXIT;                    {...and return}„  end;„  New(mod);„„  if (filepos+MAX_BLOCK_SIZE>exesize) then„    mod^.datasize := exesize-filepos„        { data left in this block is less than 64k }„  else„    mod^.datasize := MAX_BLOCK_SIZE;„        { data block is a full 64k }„  GetMem(mod^.data, mod^.datasize); {get the memory for the data buffer}„„  Seek(exefile, filepos); { position dos's filepointer to beginning of block}„  BlockRead(exefile, mod^.data^, mod^.datasize, blocks);„„  if blocks<mod^.datasize then { make sure we got all the data }„  begin„    Writeln('File read error!');„    FreeMem(mod^.data, mod^.datasize);„    Dispose(mod);„    ReadBlockFromMOD := NIL;„    EXIT;„  end;„„  ReadBlockFromMOD := mod;„end;„„{„   This will read in the .MOD from the "back" of the .exe 64k-8„   bytes at a time. As written, you manually have to pass a block„   number to the "read" function.„„   A couple of caveats - doing it as written is error-prone. Using„   this code "barebones" in a finished application is not advisable,„   but it does demonstrate the concept and gives you a starting„   point. THIS CODE HAS NOT BEEN TESTED! If you have problems with„   it, let me know and I'll help you out.„„   After you have digest the code, ask some more questions and we„   can discuss streams and OOP techniques to do this in a less„   dangerous manner.„}                                                                                                                  14     01-27-9412:09ALL                      NORBERT IGL              DOS Windowed Ouput       IMPORT              19     U≈« {„   Norbert Igl„   Fido    : 2:243/8301.3„   Gernet  : 21:100/40.3„   Internet: q3976866@fernuni-hagen.de„„> I seen some code posted here a few weeks ago. I meant to save it,„> but didn't. The code creates a windowed DOS shell.„> I would like to simply run a .BAT installation file in a window„> from my pascal program.„„ ...same question a few days ago here in our local echo ... (:-)„ Its not only with windowed output ( easy possible )„ but also stores the pgm's output in your pgm's buffer ....„ have fun!„}„„program test29;  {$M $1000,0,$FFF0}{ $C <Norbert Igl '93> }„uses    crt, dos;„const   maxBufSize = 64000;„        old29  : pointer = nil;„type    tVBuff = record„                    siz : word;„                    last: word;„                    txt : array[1..MaxBufSize] of char;„                 end;„        pVBuff = ^tVBuff;„var     Buf    : pVBuff;„„procedure New29(Flags, CS, IP, AX,„                BX,CX, DX, SI, DI,„                DS, ES, BP: Word);  interrupt;„begin„  if Buf <> NIL then„  with Buf^ do„  begin„    if last < siz then inc( Last );„    txt[last] := CHAR(AX)„  end„end;„„procedure BeginCapture;„begin„  if Old29 = NIL then  getintvec($29, Old29);„  SetIntVec($29, @New29 );„end;„„procedure DoneCapture;„begin„  if old29 <> Nil then„  begin„    SetIntVec($29, old29);„    old29 := NIL„  end„end;„„procedure InitBuffer;„begin„  Buf    := NIL„end;„„procedure BeginBuffer(Size:word);„begin„  if Size > maxBufSize then size := maxBufSize;„  GetMem( Buf, Size );„  Buf^.siz := Size;„  Buf^.last:= 0;„  fillchar( Buf^.txt, size-4, 0);„end;„„procedure DoneBuffer;„begin„  if Buf <> NIL then„  begin„    dispose(buf);„    initBuffer;„  end„end;„„procedure ShowBuffer;„var i, maxy : word;„begin„  if buf = NIL then exit;„  maxy := (WindMax - WindMin) shr 8;„  clrscr;„  for i := 1 to Buf^.last do„  begin„    if wherey = maxy then„    begin„      write(' --- weiter mit Taste --- '); clreol;„      readkey;„      clrscr;„    end;„    write( buf^.txt[i] );„  end;„  write(#13#10' --- Ende, weiter mit Taste --- '); clreol;„  readkey;„  clrscr;„end;„„begin„  InitBuffer;„  BeginBuffer($4000); { 16k Buffer, max=64k }„  BeginCapture;„  swapvectors;„  exec( getenv('comspec'),' /C DIR *.pas');„  swapvectors;„  DoneCapture;„  ShowBuffer;„  DoneBuffer„end.„                      15     01-27-9412:14ALL                      BJORN FELTEN             Self-Modifying EXE Files IMPORT              22     UxÀ {„OK. Maybe this isn't exactly what you were asking for, but I've seen quite a„number of variations on this peeka-boo-into-the-exe-file, so I felt I just had„to write a comment to this matter.„„   Using some kind of a magic constant, which is then searched for in the exe„file, probably is the most common approach to this kind of problem. But there's„really no need to do a search. You can calculate exactly where any const is (or„should be) located.„„   The trick is to use a couple of simple facts:„„   1/ The size of the exe header, in paragraphs, is located at byte 8 in the„header (actually it's a word made up by bytes 8 and 9 but I still haven't seen„an exe header of more than 4k, so I make it simple for myself using only the„byte).„„   2/ After the exe header comes the code segment and then directly the data„segment. Thus the size of the code segment can be calculated by a simple dseg-„cseg. Still talking paragraphs.„„   3/ Now we've reached the data segment in the exe file. The location in the„data segment can be found with ofs. Here we're talking bytes.„„   Using these facts, here's a simple sample that let's you change a const„string to whatever paramstr(1) you supply. Hope you'll be able to pick out the„stuff you may find any need for.„„   Since this code was extracted from a pretty small program I once wrote, it„uses the rather crude method to read the entire exe file into a buffer, and„then creating a new file blockwriting the entire buffer. If your program is„larger than 64k you obviously need to use some other method.„}„„program SelfModifier;   (* Looks for a const and alters it *)„                        (* Puts paramstr(1) into Name *)„„const„    Name : string = 'Fix me up';      {get 256 bytes to play with}„type„    Buffer = array[0..$3fff] of byte;„var„    ExeFile : file;„    P       : ^Buffer;„    N,I,O   : word;„    NStr    : string;„„begin„ begin„  new(P);                             {get mem for our buffer}„  assign(ExeFile,paramstr(0));        {get myself}„  reset(ExeFile,1);„  blockread(ExeFile,P^,sizeof(Buffer),N);„  close(ExeFile);                     {got it into Buf, now close it}„  O:=(dseg-cseg+word(P^[8])) shl 4;   {start of data seg in exe file}„  writeln('Name: ',Name);„  NStr := paramstr(1);                {new string to put in Name}„  inc(O,ofs(Name));                   {where Name is located}„  move(NStr[0],P^[O],length(NStr)+1); {move string incl. length byte}„  rewrite(ExeFile,1);                 {create new version}„  blockwrite(ExeFile,P^,N);           {write it}„  close(ExeFile);                     {close it...}„  dispose(P)                          {...and release mem}„ end„end.„                        16     01-27-9412:17ALL                      FRED JOHNSON             Operating Modes          IMPORT              11     U0ƒ {„If you ever wanted to tell what Operating System Mode you are using,„this /ditty/ will do the trick.  It sets a global integer to a value„which represents the Mode being used.  There is also a demo_prog at the„end of the unit.„}„„unit mode;„„interface„„var„  OperatingMode : integer;„„{ This integer holds a value of 0, 1, 2 or 3, which is an indicator„  if the machine is in:„    Dos Mode              (0),„    Windows Standard Mode (1),„    Windows Enhanced Mode (2),„    DESQview mode         (3); }„implementation„„function wincheck : integer;„begin„ asm„   mov  ax,   $4680„   int  $2f„   mov  dl,   $1„   or   ax,   ax„   jz   @finished„   mov  ax,   $1600„   int  $2f„   mov  dl,   $2„   or   al,   al„   jz   @Not_Win„   cmp  al,   $80„   jne  @finished„  @Not_Win:„   mov  ax,   $1022„   mov  bx,   $0„   int  $15„   mov  dl,   $3„   cmp  bx,   $0a01„   je   @finished„   xor  dl,   dl„  @finished:„   xor  ah,   ah„   mov  al,   dl„   mov  @Result, ax„ end;„end;„„begin„   OperatingMode := Wincheck;„end.„„program Use_Mode;„„uses„  mode;„„const„  xModeStringArr : Array[0..3] of string[16] =„     ('Dos Mode', 'Windows Standard', 'Windows Enhanced', 'DESQview Mode');„begin„   Write(xModeStringArr[OperatingMode]);„end.„                                                17     01-27-9412:24ALL                      TOM CARROLL              Yet Another Window Shell IMPORT              75     U £ {„-> I seen some code posted here a few weeks ago. I meant to save it,„-> but didn't.  The code creates a windowed DOS shell.  I would like„-> to simply run a .BAT installation file in a window from my pascal„-> program.„„Here's some code that I posted.  Maybe this is what you were talking„about:„}„„(* Written by Tom Carroll, Nov 24, 1993.„„   Adapted from the example code posted by Kelly Small in the FidoNet„   Pascal echo 11/19/93.„„   Released to the Public Domain 11/24/93.„„   Please give credit where credit is due„„   This unit will execute a program within a text window„   and all program scrolling will be maintained within„   the window.„„   11-24-93 - Initial release /twc/„   11-29-93 - Added code to allow for multiple border styles,„              color usage, window titles, and screen save/restore„              under the window. /twc/„„   FUTURE PLANS:  To add a check for the video mode and adjust the„                  window boundary checking accordingly.„*)„„UNIT ExecTWin;„„INTERFACE„„FUNCTION ExecWin(ProgName, Params, Title : STRING;„                 LeftCol, TopLine, RightCol, BottomLine,„                 ForeColor, BackColor, ForeBorder, BackBorder,„                 Border, ForeTitle, BackTitle : WORD) : WORD;„„IMPLEMENTATION„„USES„   Dos,„   Crt,„   ScrnCopy;„„VAR„   OldIntVect : POINTER;„„{$F+}„PROCEDURE Int29Handler(AX, BX, CX, DX, SI, DI, DS, ES, BP : WORD); INTERRUPT;„„VAR„   Dummy : BYTE;„„BEGIN„   Write(Chr(Lo(AX)));         {write each character to screen}„   Asm Sti; END;„END;„{$F-}„„PROCEDURE HookInt29;„„BEGIN„   GetIntVec($29, OldIntVect);               { Save the old vector }„   SetIntVec($29, @Int29Handler);            { Install interrupt handler }„END;„„FUNCTION ExecWin(ProgName, Params, Title : STRING;„                 LeftCol, TopLine, RightCol, BottomLine,„                 ForeColor, BackColor, ForeBorder, BackBorder,„                 Border, ForeTitle, BackTitle : WORD) : WORD;„„{„  ProgName   = Program name to execute (must includes the full path)„  Params     = Program parameters passed to child process„  Title      = Title assigned to the text window (unused if blank)„  LeftCol    = Left column of the window border„  TopLine    = Top line of the window border„  RightCol   = Right column of the window border„  BottomLine = Bottom line of the window border„  ForeColor  = Foreground color of the window„  BackColor  = Background color of the window„  ForeBorder = Foreground color of the window border„  BackBorder = Background color of the window border„  Border     = Border type to use.  Where type is:„                0 - None used„                1 - '+'„                2 - '+'„                3 - '#'„                4 - '+'„  ForeTitle  = Foreground color of the window title„  BackTitle  = Background color of the window title„„  If an error is encountered, the program will return the following„  error codes in the ExecWin variable.„„      97 - Title wider than the window„      98 - The left or right screen margins have been exceeded„      99 - The top or bottom screen margins have been exceeded„}„„LABEL„   ExitExec;„„VAR„   A : WORD;„„BEGIN„   IF (LeftCol < 1) OR (RightCol > 80) THEN„      BEGIN„         ExecWin := 98;„         GOTO ExitExec;„      END;„   IF (TopLine < 1) OR (BottomLine > 24) THEN„      BEGIN„         ExecWin := 99;„         GOTO ExitExec;„      END;„   SaveScrn(0);„   TextColor(ForeBorder);„   TextBackground(BackBorder);„   GotoXY(LeftCol, TopLine);„   CASE Border OF„      1 : BEGIN„             Write('+');„             FOR A := 1 TO (RightCol - LeftCol) - 1 DO„                Write('-');„             Write('+');„             FOR A := 1 TO (BottomLine - TopLine) - 1 DO„                BEGIN„                   GotoXY(LeftCol, TopLine + A);„                   Write('|');„                   GotoXY(RightCol, TopLine + A);„                   Write('|');„                END;„             GotoXY(LeftCol, BottomLine);„             Write('+');„             FOR A := 1 TO (RightCol - LeftCol) - 1 DO„                Write('-');„             Write('+');„             IF Ord(Title[0]) > 0 THEN„                IF (Ord(Title[0])) <= (RightCol - LeftCol) THEN„                   BEGIN„                      A := Ord(Title[0]);„                      A := RightCol - LeftCol - A;„                      A := A DIV 2;„                      GotoXY(A - 2 + LeftCol, TopLine);„                      Write('+ ');„                      TextColor(ForeTitle);„                      TextBackground(BackTitle);„                      Write(Title);„                      TextColor(ForeBorder);„                      TextBackground(BackBorder);„                      Write(' +');„                   END„                ELSE„                   BEGIN„                      ExecWin := 97;„                      GOTO ExitExec;„                   END;„          END;„      2 : BEGIN„             Write('+');„             FOR A := 1 TO (RightCol - LeftCol) - 1 DO„                Write('-');„             Write('+');„             FOR A := 1 TO (BottomLine - TopLine) - 1 DO„                BEGIN„                   GotoXY(LeftCol, TopLine + A);„                   Write('|');„                   GotoXY(RightCol, TopLine + A);„                   Write('|');„                END;„             GotoXY(LeftCol, BottomLine);„             Write('+');„             FOR A := 1 TO (RightCol - LeftCol) - 1 DO„                Write('-');„             Write('+');„             IF Ord(Title[0]) > 0 THEN„                IF (Ord(Title[0])) <= (RightCol - LeftCol) THEN„                   BEGIN„                      A := Ord(Title[0]);„                      A := RightCol - LeftCol - A;„                      A := A DIV 2;„                      GotoXY(A - 2 + LeftCol, TopLine);„                      Write('+ ');„                      TextColor(ForeTitle);„                      TextBackground(BackTitle);„                      Write(Title);„                      TextColor(ForeBorder);„                      TextBackground(BackBorder);„                      Write(' +');„                   END„                ELSE„                   BEGIN„                      ExecWin := 97;„                      GOTO ExitExec;„                   END;„          END;„      3 : BEGIN„             Write('#');„             FOR A := 1 TO (RightCol - LeftCol) - 1 DO„                Write('#');„             Write('#');„             FOR A := 1 TO (BottomLine - TopLine) - 1 DO„                BEGIN„                   GotoXY(LeftCol, TopLine + A);„                   Write('#');„                   GotoXY(RightCol, TopLine + A);„                   Write('#');„                END;„             GotoXY(LeftCol, BottomLine);„             Write('#');„             FOR A := 1 TO (RightCol - LeftCol) - 1 DO„                Write('#');„             Write('#');„             IF Ord(Title[0]) > 0 THEN„                IF (Ord(Title[0])) <= (RightCol - LeftCol) THEN„                   BEGIN„                      A := Ord(Title[0]);„                      A := RightCol - LeftCol - A;„                      A := A DIV 2;„                      GotoXY(A - 2 + LeftCol, TopLine);„                      Write('# ');„                      TextColor(ForeTitle);„                      TextBackground(BackTitle);„                      Write(Title);„                      TextColor(ForeBorder);„                      TextBackground(BackBorder);„                      Write(' #');„                   END„                ELSE„                   BEGIN„                      ExecWin := 97;„                      GOTO ExitExec;„                   END;„          END;„      4 : BEGIN„             Write('+');„             FOR A := 1 TO (RightCol - LeftCol) - 1 DO„                Write('-');„             Write('+');„             FOR A := 1 TO (BottomLine - TopLine) - 1 DO„                BEGIN„                   GotoXY(LeftCol, TopLine + A);„                   Write('|');„                   GotoXY(RightCol, TopLine + A);„                   Write('|');„                END;„             GotoXY(LeftCol, BottomLine);„             Write('+');„             FOR A := 1 TO (RightCol - LeftCol) - 1 DO„                Write('-');„             Write('+');„             IF Ord(Title[0]) > 0 THEN„                IF (Ord(Title[0])) <= (RightCol - LeftCol) THEN„                   BEGIN„                      A := Ord(Title[0]);„                      A := RightCol - LeftCol - A;„                      A := A DIV 2;„                      GotoXY(A - 2 + LeftCol, TopLine);„                      Write('| ');„                      TextColor(ForeTitle);„                      TextBackground(BackTitle);„                      Write(Title);„                      TextColor(ForeBorder);„                      TextBackground(BackBorder);„                      Write(' |');„                   END„                ELSE„                   BEGIN„                      ExecWin := 97;„                      GOTO ExitExec;„                   END;„          END;„      END;„   TextColor(ForeColor);„   TextBackground(BackColor);„   Window(LeftCol + 1, TopLine + 1, RightCol - 1, BottomLine - 1);„   ClrScr;„   HookInt29;„   SwapVectors;„   Exec(ProgName, Params);„   SwapVectors;„   ExecWin := DOSExitCode;„   SetIntVec($29,OldIntVect); { Restore the interrupt }„   Window(1, 1, 80, 25);„   RestoreScrn(0);„„   ExitExec:„„END;„„END.„„{„The ScrnCopy unit may be found within the SWAG files or you can make up„your own.„„Tom Carroll„Dataware Software„}„      18     02-03-9410:49ALL                      CARL YORK                Nice DOS Shell Unit      IMPORT              48     U   { A bit wordy - but easy to include in an application - three "hooks" in }„{ the form of the first three internal procedures to customize the code. }„{ NOTE! MaxHeap must be limited to allow the EXEC procedure to function. }„{ By Carl York with code by Neil J. Rubenking and Richard S. Sandowsky.  }„„UNIT DOSShell;„„INTERFACE„procedure ShellToDOS;„„IMPLEMENTATION„USES CRT, DOS;„„procedure ShellToDOS;„const„  SmallestAllowableRam = 5;                   { Set   }„  Normal               = 7;                   { to    }„  Reverse              = 112;                 { your  }„  ApplicationName      = 'MY OWN PROGRAM';    { specs }„var„  ProgramName,„  CmdLineParam,„  NewDirect,„  HoldDirect     : PathStr;„  HoldAttr       : byte;„  HoldMin,„  HoldMax        : word;„  SlashSpot,„  BlankSpot      : byte;„„{+++++++++++++++++++++++++++++++}„procedure PrintMessage;„begin„  { Clever message to make your end user feel foolish }„end;„{-------------------------------}„„{++++++++++++++++++++++}„procedure SwapScreenOut;„begin„  { Whatever routine you want to use to    }„  { save the contents on the active screen }„end;„{---------}„„{++++++++++++++++++++++}„procedure SwapScreenIn;„begin„  { Whatever routine you want to use to }„  { restore the contents on the screen  }„end;„{---------}„„{+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}„function GetProgramToRun : PathStr;„{ Courtesy of Neil Rubenking, this code duplicates the way DOS normally }„{ searches the path for a file name typed in at the DOS level using the }„{ TP5 routines FSearch and FExpand (code published PC Magazine 1/17/89) }„var„  Name : PathStr;„begin„  Name := FSearch(ProgramName + '.COM','');          { Search    }„  If Name = '' then                                  { the       }„    Name := FSearch(ProgramName + '.EXE','');        { active    }„  If Name = '' then                                  { drive/    }„    Name := FSearch(ProgramName + '.BAT','');        { directory }„  If Name = '' then„    Name := FSearch(ProgramName + '.COM',GetEnv('PATH'));„  If Name = '' then                                          { Search }„    Name := FSearch(ProgramName + '.EXE',GetEnv('PATH'));    { the    }„  If Name = '' then                                          { path   }„    Name := FSearch(ProgramName + '.BAT',GetEnv('PATH'));„  If Name <> '' then„    Name := FExpand(Name);„  GetProgramToRun := Name;„end;„{------------------------------------------------------------------------}„„{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}„function RAMFreeInK : Word;„{ A tidy little chunk of Inline code from Rich Sandowsky }„Inline(„  $B8/$00/$48/           {  mov   AX,$4800  ; set for DOS function 48h}„  $BB/$FF/$FF/           {  mov   BX,$FFFF  ; try to allocate more RAM}„                         {                  ; than is possible}„  $CD/$21/               {  int   $21       ; execute the DOS call}„  $B1/$06/               {  mov   CL,6      ;}„  $D3/$EB/               {  shr   BX,CL     ; convert to 1K blocks}„  $89/$D8);              {  mov   AX,BX     ; return number of 1K blocks}„                         {                  ; RAM free as function result}„{------------------------------------------------------------------------}„„{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}„procedure WritePrompt;„{ Create a DOS prompt for the user }„begin„  TextAttr := Normal;„  Write('Temporarily in DOS (',RAMFreeInK,'K available) ... Type ');„  TextAttr := Reverse;„  Write('EXIT');„  TextAttr := Normal;„  WriteLn(' to return to ',ApplicationName);„  Write(NewDirect,'>');„end;„{------------------------------------------------------------------------}„„{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}„procedure RunTheShell;„{ The actual use of the EXEC procedure }„var„  Index : integer;„begin„  GetDir(0,NewDirect);„  WritePrompt;„  CmdLineParam := '';„  ReadLn(ProgramName);„  For Index := 1 to length(ProgramName) do„    ProgramName[index] := Upcase(ProgramName[Index]);„  While ProgramName[length(ProgramName)] = #32 do„    Dec(ProgramName[0]);„  While (length(ProgramName) > 0) and (ProgramName[1] = #32) do„    Delete(ProgramName,1,1);„  If (ProgramName <> 'EXIT') then„    begin„      EXEC(GetEnv('COMSPEC'),'/C '+ ProgramName + CmdLineParam);„      { Brute force to see if we need to pursue any further }„      If Lo(DOSExitCode) <> 0 then„        begin„          BlankSpot := pos(' ',ProgramName);„          SlashSpot := pos('/',ProgramName);„          If SlashSpot > 0 then„            If (SlashSpot < BlankSpot) or (BlankSpot = 0) then„              BlankSpot := SlashSpot;„          If BlankSpot > 0 then„            begin„              CmdLineParam := copy(ProgramName,BlankSpot,Length(ProgramName));„              ProgramName[0] := Chr(pred(BlankSpot));„            end;„          ProgramName := GetProgramToRun;„          If ProgramName <> '' then„            If pos('.BAT',ProgramName) > 0 then„              EXEC(GetEnv('COMSPEC'),'/C '+ ProgramName + CmdLineParam)„            else EXEC(ProgramName,CmdLineParam);„        end;„    end;„  WriteLn;„end;„{------------------------------------------------------------------------}„„{=================================}„begin„  If RamFreeInK <= SmallestAllowableRam then„    begin„      PrintMessage;„      EXIT;„    end;„  HoldAttr := TextAttr;           { Grab the current video attribute }„  GetDir(0,HoldDirect);           { Grab the current drive/path }„  HoldMin := WindMin;„  HoldMax := WindMax;             { And the current window }„  TextAttr := Normal;„  SwapScreenOut;„  Window(1,1,80,25);„  ClrScr;„  SwapVectors;„  Repeat„    RunTheShell;„  Until ProgramName = 'EXIT';„  SwapVectors;                      { Restore all the original set up }„  ChDir(HoldDirect);„  TextAttr := HoldAttr;„  Window(Lo(HoldMin),Hi(HoldMin),Lo(HoldMax),Hi(HoldMax));„  ClrScr;„  SwapScreenIn;„end;„„END.„                                                           19     02-03-9416:18ALL                      RADEK KADNER             Hiding EXEC commands     IMPORT              15     U   {„ RG> I am writing a simple program which executes other programs.  I am using„ RG> the function„„ RG> EXEC(ProgramName,CmdLine)„„ RG> which is working just fine.  However, I would like to somehow prevent the„ RG> executed program from writing to the screen, rather I just want to display„ RG> in my program something like„„ RG> Working...„„ RG> While still maintaining the screen which the program is using for output.„ RG> So my questions is, how would I go about doing this?„„Try this unit! }„„unit Redir;„„interface„„uses„  Dos;„„function SetOutput(FileName: PathStr): Boolean;„procedure CancelOutput;„„implementation„„const„  OutRedir: Boolean = False;„„function SetOutput(FileName: PathStr): Boolean;„begin„  FileName:=FileName+#0;„  SetOutput:=False;„  asm„    push  ds„    mov   ax, ss„    mov   ds, ax„    lea   dx, FileName[1]„    mov   ah, 3Ch„    int   21h„    pop   ds„    jnc   @@1„    ret„@@1:„    push  ax„    mov   bx, ax„    mov   cx, Output.FileRec.Handle„    mov   ah, 46h„    int   21h„    mov   ah, 3Eh„    pop   bx„    jnc   @@2„    ret„@@2:„    int   21h„  end;„  OutRedir:=True;„  SetOutput:=True;„end;„„procedure CancelOutput;„var„  FileName: String[4];„begin„  if not OutRedir then Exit;„  FileName:='CON'#0;„  asm„    push  ds„    mov   ax, ss„    mov   ds, ax„    lea   dx, FileName[1]„    mov   ax, 3D01h„    int   21h„    pop   ds„    jnc   @@1„    ret„@@1:„    push  ax„    mov   bx, ax„    mov   cx, Output.FileRec.Handle„    mov   ah, 46h„    int   21h„    mov   ah, 3Eh„    pop   bx„    int   21h„  end;„  OutRedir:=False;„end;„„end.„„________________„„Standard output will be changed to FileName. The FileName can be NUL. When your„executed program is using int $10, all is hardly. In your main program use:„„SetOutput('NUL');„Exec(....);„CancelOutput;„„ 20     02-15-9408:06ALL                      GREG ESTABROOKS          Shell to DOS with PROMPT IMPORT              27     U   „ {change the dos prompt when Shelling to DOS without„  having to change the current or master enviroment(It makes it's own).}„„{***********************************************************************}„PROGRAM PromptDemo;             { Feb 12/94, Greg Estabrooks.           }„{$M 16840,0,0}                  { Reserved some memory for the shell.   }„USES CRT,                         { IMPORT Clrscr,Writeln.              }„     DOS;                         { IMPORT Exec.                        }„„PROCEDURE ShellWithPrompt( Prompt :STRING );„                         { Routine to allocate a temporary Enviroment   }„                         { with our prompt and the execute COMMAND.COM. }„                         { NOTE: This does NO error checking.           }„VAR„   NewEnv :WORD;                { Points to our newly allocated env.    }„   OldEnv :WORD;                { Holds Old Env Segment.                }„   EnvPos :WORD;                { Position inside our enviroment.       }„   EnvLp  :WORD;                { Variable to loop through ENVStrings.  }„   TempStr:STRING;              { Holds temporary EnvString info.       }„BEGIN„  ASM„   Mov AH,$48                   { Routine to allocate memory.           }„   Mov BX,1024                  { Allocate 1024(1k) of memory.          }„   Int $21                      { Call DOS to allocate memory.          }„   Mov NewEnv,AX                { Save segment address of our memory.   }„  END;„„  EnvPos := 0;                  { Initiate pos within our Env.          }„  FOR EnvLp := 1 TO EnvCount DO { Loop through entire enviroment.       }„   BEGIN„    TempStr := EnvStr(EnvLp);   { Retrieve Envirment string.            }„    IF Pos('PROMPT=',TempStr) <> 0 THEN  { If its our prompt THEN ....  }„     TempStr := 'PROMPT='+Prompt+#0  { Create our new prompt.           }„    ELSE                        {  .... otherwise.........              }„     TempStr := TempStr + #0;   { Add NUL to make it ASCIIZ compatible. }„    Move(TempStr[1],Mem[NewEnv:EnvPos],Length(TempStr)); { Put in Env.  }„    INC(EnvPos,Length(TempStr)); { Point to new position in Enviroment. }„   END;{For}„„  OldEnv := MemW[PrefixSeg:$2C];{ Save old enviroment segment.          }„  MemW[PrefixSeg:$2C] := NewEnv;{ Point to our new enviroment.          }„  SwapVectors;                  { Swap Int vectors in case of conflicts.}„  Exec(GetEnv('COMSPEC'),'');   { Call COMMAND.COM.                     }„  SwapVectors;                  { Swap em back.                         }„  MemW[PrefixSeg:$2C] := OldEnv;{ Point back to old enviroment.         }„„  ASM„   Push ES                      { Save ES.                              }„   Mov AH,$49                   { Routine to deallocate memory.         }„   Mov ES,NewEnv                { Point ES to area to deallocate.       }„   Int $21;                     { Call DOS to free memory.              }„   Pop ES                       { Restore ES.                           }„  END;„END;{ShellWithPrompt}„„BEGIN„  Clrscr;                        { Clear the screen.                    }„  Writeln('Type EXIT to return');{ Show message on how to exit shell.   }„  ShellWithPrompt('[PromptDemo] $P$G'); { shell to DOS with our prompt. }„END.{PromptDemo}„                                                                                       21     05-25-9408:09ALL                      BILL MULLEN              DOS Shell                SWAG9405            39     U   {„ ⁄ƒƒ GEORGE VAISEY ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„ ≥ GVØ I've read throught the book and even looked it up in the two   ≥„ ≥ GVØ pascal books I've got and can't seem to get any help.I'm       ≥„ ≥ GVØ trying (without luck) to get this this command:                ≥„ ≥ GVØ trying (without luck) to get this this PROMPT $mTYPE "EXIT" TO ≥„ ≥ GVØ RETURN to be sent as a command before it shells. This is so    ≥„ ≥ GVØ that the individual that shells out will always know that he   ≥„ ≥ GVØ needs to type EXIT to return.  If you can help or know of a    ≥„ ≥ GVØ better way PLEASE let me know.  Here is what I use to shell to ≥„ ≥ GVØ OS:                                                            ≥„ ≥                                                                    ≥„ ≥ GVØ Begin                                                          ≥„ ≥ GVØ   ClrScr;                                                      ≥„ ≥ GVØ   TextColor(Yellow+Blink);                                     ≥„ ≥ GVØ   Writeln ('Type EXIT To Return To Program');                  ≥„ ≥ GVØ   SwapVectors;                                                 ≥„ ≥ GVØ   Exec(GetEnv('Comspec'), '');                                 ≥„ ≥ GVØ   SwapVectors;                                                 ≥„ ≥ GVØ   NormVideo;                                                   ≥„ ≥ GVØ End.                                                           ≥„ ≥ GVØ I want it to be                                                ≥„ ≥ GVØ TYPE "EXIT" TO RETURN                                          ≥„ ≥ GVØ then the prompt command.  Thanks again for your help.          ≥„ ≥ GVØ     George Vaisey                                              ≥„ ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„„George,„„  You should get either Object Professional or Turbo Professional from„  Turbo Power software (800) 333-4160 and use the xxDOS unit.  It has„  routines in it to change environment variables on the fly.  These„  routines work really well.„„  In the mean time you can use the technique shown in the code below.„  Beware however, that you MUST have enough environment space to deal„  with the extra space required and that there will actually be two„  copies of COMMAND.COM running in addition to the master copy.„„  The technique shown in SHELLTODOS is not exactly what you asked for, but„  it does show you how to do what you want.  SHELLTODOS1 is the code used„  if you have either Object Pro or Turbo Pro.„„  P.S.  Long lines of code may get truncated by my "QWK" mailer.  Inspect„        the SHELLMESSAGE procedure as it appears it may get truncated.  Also„        change all the WRITE commands in SHELLMESSAGE to WRITELN's.„„[-------------------------------CUT HERE-----------------------------------]„}„„{$M 4096, 0, 655360 }„Program DosShell;„uses„ OpDos,                                      { Needed only by SHELLTODOS1 }„ Memory,„ Dos,„ CRT;„„„Procedure ShellMessage ( ProgName : String );„  Function Extend ( AStr : String; ML : byte ) : String;„  begin„    while ord ( AStr[0] ) < ML do„      AStr := AStr + ' ';„    Extend := AStr;„  end;„begin„ clrscr;„ Change the following 6 lines to WRITELN's then delete this line entirely.„ write(' …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª');„ write(' ∫ ˛ While in the DOS SHELL, do not execute any TSR programs like  ∫');„ write(' ∫   SideKick or DOS''s PRINT command.                              ∫')„ write(' ∫ ˛ Type EXIT and press ENTER to quit the SHELL and return to the ∫');„ write(Extend ( ' ∫   ' + ProgName  + ' program.', 67 ), '∫' );„ write(' »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº');„end;„„„Procedure ShellToDos ( ProgName : string );„var„ T : text;„ D : string;„begin„ (* Save current directory                                    *)„ GetDir ( 0, D );„„ (* Create a DOS batch file with a PROMPT command             *)„ assign  ( T, 'DOSSHELL.BAT' );„ rewrite ( T );„ writeln ( T, '@echo off' );„ writeln ( T, 'Prompt [EXIT] $p$g' );„ writeln ( T, GetEnv ( 'COMSPEC' ) );„ close   ( T );„„ (* Execute the batch file which in turn executes COMMAND.COM *)„ ShellMessage ( ProgName );„ DoneDosMem;„ swapvectors;„ exec ( GetEnv ( 'COMSPEC' ), '/c DOSSHELL.BAT' );„ swapvectors;„ InitDosMem;„„ (* Erase the batch file and restore the working directory    *)„ erase ( T );„ chdir ( D );„end;„„„Procedure ShellToDos1 ( ProgName : string );„var„ NewPrompt : String;„ D : string;„begin„ getdir ( 0, D );„ ShellMessage ( ProgName );„ NewPrompt := 'Type "EXIT" and press ENTER to return to DOSSHELL'^M^J+„              '[' + ProgName + '] ' + GetEnvironmentString ('PROMPT');„ ShellWithPrompt ( NewPrompt, NoExecDosProc );„ chdir ( D );„end;„„„begin„ InitMemory;„ ShellToDos  ( 'DosShell' );„ ShellToDos1 ( 'DosShell' );„ DoneMemory;„end.„     22     05-26-9408:32ALL                      GAYLE DAVIS              Execute PKZIP            SWAG9405            67     U   UNIT PKZExec;„„INTERFACE„„USES DOS;„„{ Purpose :  Execute PKZIP/PKUNZIP on archive files                         }„{ Uses specialized EXEC procedure so main program can use ALL of the memory }„{ Also shows how to take over INT29 to NOT display anything on the CRT      }„„CONST„    PKZIP             : PathStr = 'PKZIP.EXE';„    PKUNZIP           : PathStr = 'PKUNZIP.EXE';„„VAR ZIPError          : INTEGER;„„PROCEDURE CleanUpDir (WorkDir, FileMask : STRING);„                   {Erases files based on a mask }„„PROCEDURE DisplayZIPError;„                   { PKZip interface }„„PROCEDURE DefaultCleanup (WorkDir : STRING);„                   {Erases files *.BAK, *.MAP, temp*.*}„„PROCEDURE ShowEraseStats;„                   {shows count & bytes recovered}„„FUNCTION  UnZIPFile (ZIPOpts, ZIPName, DPath, fspec : STRING; qt : BOOLEAN) : BOOLEAN;„                   {Uses PKUnZip to de-archive files }„„FUNCTION  ZIPFile (ZIPOpts, ZIPName, fspec  : STRING; qt : BOOLEAN) : BOOLEAN;„                   {Uses PKZip to archive files }„„IMPLEMENTATION„„VAR  ZIPDefaultZIPOpts : STRING [16];„VAR  ZIPFileName       : STRING [50];„VAR  ZIPDPath          : STRING [50];„„VAR  EraseCount        : WORD;        { files erased }„     EraseSizeK        : LONGINT;     { kilobytes released by erasing files }„     ShowOnWrite       : BOOLEAN;„     I29H              : POINTER;„„{ EXECUTE STUFF - SHRINK HEAP AND EXECUTE LIKE EXECDOS }„„{$F+}„PROCEDURE Int29Handler (AX, BX, CX, DX, SI, DI, DS, ES, BP : WORD); INTERRUPT;„VAR„  Dummy : BYTE;„BEGIN„  Asm„    Sti„  END;„  IF ShowOnWrite THEN WRITE (CHAR (LO (Ax) ) );„  Asm„    Cli„  END;„END;„„PROCEDURE ReallocateMemory (P : POINTER); ASSEMBLER;„ASM„  MOV  AX, PrefixSeg„  MOV  ES, AX„  MOV  BX, WORD PTR P + 2„  CMP  WORD PTR P, 0„  JE   @OK„  INC  BX„„ @OK :„  SUB  BX, AX„  MOV  AH, 4Ah„  INT  21h„  JC   @X„  LES  DI, P„  MOV  WORD PTR HeapEnd, DI„  MOV  WORD PTR HeapEnd + 2, ES„ @X :„END;„„{ ZAP this DEFINE if NOT 386,486}„{..$DEFINE CPU386}„„FUNCTION EXECUTE (Name : PathStr ; Tail : STRING) : WORD; ASSEMBLER;„ASM„  {$IFDEF CPU386}„  DB      66h„  PUSH    WORD PTR HeapEnd„  DB      66h„  PUSH    WORD PTR Name„  DB      66h„  PUSH    WORD PTR Tail„  DB      66h„  PUSH    WORD PTR HeapPtr„  {$ELSE}„  PUSH    WORD PTR HeapEnd + 2„  PUSH    WORD PTR HeapEnd„  PUSH    WORD PTR Name + 2„  PUSH    WORD PTR Name„  PUSH    WORD PTR Tail + 2„  PUSH    WORD PTR Tail„  PUSH    WORD PTR HeapPtr + 2„  PUSH    WORD PTR HeapPtr„  {$ENDIF}„„  CALL ReallocateMemory„  CALL SwapVectors„  CALL DOS.EXEC„  CALL SwapVectors„  CALL ReallocateMemory„  MOV  AX, DosError„  OR   AX, AX„  JNZ  @OUT„  MOV  AH, 4Dh„  INT  21h„ @OUT :„END;„{$F-}„„FUNCTION ExecuteCommand(p,s : STRING; quiet : BOOLEAN) : INTEGER;„BEGIN„ShowOnWrite := NOT quiet;  { turn off INT 29 }„GETINTVEC ($29, I29H);„SETINTVEC ($29, @Int29Handler);         { Install interrupt handler }„Execute(p,s);„SETINTVEC ($29, I29h);„IF DosError = 0 THEN ExecuteCommand := DosExitCode   ELSE ExecuteCommand := DosError;„END;„„FUNCTION AddBackSlash (dName : STRING) : STRING;„BEGIN„  IF dName [LENGTH (dName) ] IN ['\', ':', #0] THEN„    AddBackSlash := dName„  ELSE„    AddBackSlash := dName + '\';„END;„„FUNCTION EraseFile ( S : PathStr ) : BOOLEAN ;„„VAR F : FILE;„„BEGIN„„EraseFile := FALSE;„„ASSIGN (F, S);„RESET (F);„„IF IORESULT <> 0 THEN EXIT;„„  CLOSE (F);„  ERASE (F);„  EraseFile := (IORESULT = 0);„„END;„„FUNCTION FileExists ( S : PathStr ) : BOOLEAN ;„„VAR F : FILE;„„BEGIN„„FileExists := FALSE;„„ASSIGN (F, S);„RESET (F);„„IF IORESULT <> 0 THEN EXIT;„„  CLOSE (F);„  FileExists := (IORESULT = 0);„„END;„„PROCEDURE CleanUpFile (WorkDir : STRING; SR : searchRec);„VAR l    : LONGINT;„    BEGIN„    WITH SR DO„        BEGIN„        l := size DIV 512;„        IF (attr AND 31) = 0 THEN„            BEGIN„            IF l = 0 THEN l := 1;„            EraseSizeK := EraseSizeK + l;„            WRITELN ('         Removing: ', (AddBackSlash (WorkDir) + name),„                    '   ', l DIV 2, 'k');„            EraseFile (AddBackSlash (WorkDir) + name);„            INC (EraseCount);„            END„        ELSE WRITELN (' ??  ', (AddBackSlash (WorkDir) + name), '   ', l DIV 2, 'k',„                     '  attr: ', attr);„        END;„    END;„„„PROCEDURE CleanUpDir (WorkDir, FileMask : STRING);„VAR Frec : SearchRec;„    s    : STRING [64];„    BEGIN„    s := '';„    FINDFIRST (AddBackSlash (WorkDir) + FileMask, anyfile, Frec);„    WHILE doserror = 0 DO„        BEGIN„        CleanUpFile (WorkDir, Frec);„        FINDNEXT (Frec);„        END;„    END;„„„PROCEDURE DefaultCleanup (WorkDir : STRING);„    BEGIN„    CleanUpDir (WorkDir, '*.BAK');„    CleanUpDir (WorkDir, '*.MAP');„    CleanUpDir (WorkDir, 'TEMP*.*');„    END;„„„PROCEDURE DisplayZIPError;„    BEGIN„    CASE ziperror OF„        0       : WRITELN ('no error');„        2,3     : WRITELN (ziperror : 3, ' Error in ZIP file ');„        4..8    : WRITELN (ziperror : 3, ' Insufficient Memory');„        11,12   : WRITELN (ziperror : 3, ' No MORE files ');„        9,13    : WRITELN (ziperror : 3, ' File NOT found ');„        14,50   : WRITELN (ziperror : 3, ' Disk FULL !! ');„        51      : WRITELN (ziperror : 3, ' Unexpected EOF in ZIP file ');„        15      : WRITELN (ziperror : 3, ' Zip file is Read ONLY! ');„        10,16   : WRITELN (ziperror : 3, ' Bad or illegal parameters ');„        17      : WRITELN (ziperror : 3, ' Too many files ');„        18      : WRITELN (ziperror : 3, ' Could NOT open file ');„        1..90   : WRITELN (ziperror : 3, ' Exec DOS error ');„        98      : WRITELN (ziperror : 3, ' requested file not produced ');„        99      : WRITELN (ziperror : 3, ' archive file not found');„        END;„    END;„„„PROCEDURE PKZIPInit;„     BEGIN„     PKZIP   := FSearch('PKZIP.EXE',GetEnv('PATH'));„     PKUNZIP := FSearch('PKUNZIP.EXE',GetEnv('PATH'));„     ZIPError          := 0;„     ZIPDefaultZIPOpts := '-n';„     ZIPFileName       := '';„     ZIPDPath          := '';„     EraseCount        := 0;„     EraseSizeK        := 0;„     END;„„„PROCEDURE ShowEraseStats;„    {-Show statistics at the end of run}„    BEGIN„    WRITELN ('Files Erased: ', EraseCount,„            '  bytes used: ', EraseSizeK DIV 2, 'k');„    END;„„„FUNCTION  UnZIPFile ( ZIPOpts, ZIPName, DPath, fspec : STRING; qt : BOOLEAN) : BOOLEAN;„VAR s, zname     : STRING;„    i, j         : INTEGER;„    BEGIN„    ZIPError       := 0;„    UnZIPFile := TRUE;„    s := '';„    IF ZIPOpts <> '' THEN  s := s + ZIPOpts„    ELSE                   s := s + ZIPDefaultZIPOpts;„„    IF ZIPName <> '' THEN  zname := ZIPName„    ELSE                   zname := ZIPFileName;„    IF NOT FileExists (zname) THEN„        BEGIN„        WRITELN ('zname: [', zname, ']');„        UnZIPFile := FALSE;„        ZIPError := 99;„        EXIT;„        END;„„    s := s + ' ' + zname;„„    IF DPath <> '' THEN s := s + ' ' + DPath„    ELSE                   s := s + ' ' + ZIPDPath;„    s := s + ' ' + fspec;„    ZIPError := ExecuteCommand (PKUNZIP,s,qt);„    IF ZIPError > 0 THEN„         BEGIN„         WRITELN ('PKUNZIP start failed ', ZIPError, ' [', s, ']');„         UnZIPFile := FALSE;„         END„    ELSE BEGIN„         i := POS ('*', fspec);„         j := POS ('?', fspec);„         IF (i = 0) AND (j = 0) THEN„             BEGIN„             IF NOT FileExists (DPath + fspec) THEN„                  BEGIN„                  UnZIPFile := FALSE;„                  ZIPError := 98;„                  END;„             END;„         END;„    END;„„FUNCTION  ZIPFile ( ZIPOpts, ZIPName, fspec  : STRING; qt : BOOLEAN) : BOOLEAN;„VAR s, zname     : STRING;„    i, j         : INTEGER;„    BEGIN„    ZIPError       := 0;„    ZIPFile := TRUE;„    s  := '';„    IF ZIPOpts <> '' THEN  s := s + ZIPOpts„    ELSE                   s := s + ZIPDefaultZIPOpts;„„    IF ZIPName <> '' THEN  zname := ZIPName„    ELSE                   zname := ZIPFileName;„    s := s + ' ' + zname;„    s := s + ' ' + fspec;„    ZIPError := ExecuteCommand (PKZIP,s,qt);„    IF ZIPError > 0 THEN„         BEGIN„         WRITELN ('PKZIP start failed ', ZIPError, ' [', s, ']');„         ZIPFile := FALSE;„         END„    ELSE BEGIN„         IF NOT FileExists (ZIPname + '.ZIP') THEN„              BEGIN„              ZIPFile := FALSE;„              ZIPError := 98;„              END;„         END;„    END;„„„     BEGIN„     PKZIPInit;„     END.„                                                                      