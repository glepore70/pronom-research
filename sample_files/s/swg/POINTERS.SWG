SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00016         POINTERS, LINKING, LISTS, TREES                                   1      05-28-9313:54ALL                      SWAG SUPPORT TEAM        DLLIST1.PAS              IMPORT              9           { > Does anybody have any good source/Units For Turbo„ > Pascal 6.0/7.0 For doing Double Linked List File„ > structures?„}„„Type„„   DLinkPtr = ^DLinkRecord;„„   DLinkRecord = Record„      Data     : Integer;„      Next     : DLinkPtr;„      Last     : DLinkPtr;„     end;„„Var„  Current,„  First,„  Final,„  Prev    : DLinkPtr;„  X       : Byte;„„Procedure AddNode;„begin„  if First = Nil then„   begin„     New(Current);„     Current^.Next:=Nil;„     Current^.Last:=Nil;„     Current^.Data:=32;„     First:=Current;„     Final:=Current;„   end„  else„   begin„    Prev:=Current;„    New(Current);„    Current^.Next:=Nil;„    Current^.Last:=Prev;„    Current^.Data:=54;„    Prev^.Next:=Current;„    Final:=Current;„   end;„end;„„begin„  First:=Nil;„  For X:=1 to 10 Do AddNode;„  Writeln('First: ',first^.data);„  Writeln('Final: ',final^.data);„  Writeln('Others:');„  Writeln(first^.next^.data);„„end.„                                                                                                                       2      05-28-9313:54ALL                      SWAG SUPPORT TEAM        LINKLIST.PAS             IMPORT              63          {„The following is the LinkList Unit written by Peter Davis in his wonderful„but, unFortunately, short-lived newsletter # PNL002.ZIP.  I have used this„Unit to Write tests of three or four of the Procedures but have stumped my toe„on his DELETE_HERE Procedure, the last one in the Unit.  I will post my tests„in the next message For any who may wish to see it:  Pete's Unit is unmodified.„ I almost think there is some kind of error in DELETE_HERE but he was too„thorough For that.  Can you, or someone seeing this show me how to use this„Procedure?  It will help me both With Pointers and With Units.„„Here is the Unit:„}„„Unit LinkList;„„{ This is the linked list Unit acCompanying The Pascal NewsLetter, Issue #2.„  This Unit is copyrighted by Peter Davis.„  It may be freely distributed in un-modified Form, or modified For use in„  your own Programs. Programs using any modified or unmodified Form of this„(107 min left), (H)elp, More?   Unit must include a run-time and source visible recognition of the author,„  Peter Davis.„}„„{ The DataType used is Integer, but may be changed to whatever data Type„  that you want.„}„„Interface„„„Type„  DataType = Integer;    { Change this data-Type to whatever you want  }„„  Data_Ptr = ^Data_Rec;  { Pointer to our data Records                 }„„  Data_Rec = Record      { Our Data Record Format                      }„    OurData  : DataType;„    Next_Rec : Data_Ptr;„  end;„„„Procedure Init_List(Var Head : Data_Ptr);„Procedure Insert_begin(Var Head : Data_Ptr; Data_Value : DataType);„Procedure Insert_end(Var Head : Data_Ptr; Data_Value : DataType);„Procedure Insert_In_order(Var Head : Data_Ptr; Data_Value : DataType);„Function Pop_First(Var Head : Data_Ptr) : DataType;„Function Pop_Last(Var Head : Data_Ptr) : DataType;„Procedure Delete_Here(Var Head : Data_Ptr; Our_Rec : Data_Ptr);„„„„Implementation„„Procedure Init_List(Var Head : Data_Ptr);„„begin„  Head := nil;„end;„„Procedure Insert_begin(Var Head : Data_Ptr; Data_Value : DataType);„„{ This Procedure will insert a link and value into the„  beginning of a linked list.                             }„„Var„  Temp : Data_Ptr;                { Temporary  Pointer.            }„„begin„  new(Temp);                      { Allocate our space in memory.  }„  Temp^.Next_Rec := Head;         { Point to existing list.        }„  Head:= Temp;                    { Move head to new data item.    }„  Head^.OurData := Data_Value;    { Insert Data_Value.             }„end;„„Procedure Insert_end(Var Head : Data_Ptr; Data_Value : DataType);„„{ This Procedure will insert a link and value into the„  end of the linked list.                                 }„„Var„  Temp1,             { This is where we're going to put new data }„  Temp2 : Data_Ptr;  { This is to move through the list.         }„„begin„  new(Temp1);„  Temp2 := Head;„  if Head=nil then„    begin„      Head := Temp1;                  { if list is empty, insert first   }„      Head^.OurData := Data_Value;    { and only Record. Add value and   }„      Head^.Next_Rec := nil;          { then put nil in Next_Rec Pointer }„    end„  else„    begin„      { Go to the end of the list. Since Head is a Variable parameter,„        we can't move it through the list without losing Pointer to the„        beginning of the list. to fix this, we use a third Variable:„        Temp2.„      }„      While Temp2^.Next_Rec <> nil do    { Find the end of the list. }„        Temp2 := Temp2^.Next_Rec;„„      Temp2^.Next_Rec := Temp1;          { Insert as last Record.    }„      Temp1^.Next_Rec := nil;            { Put in nil to signify end }„      Temp1^.OurData := Data_Value;      { and, insert the data      }„    end;„end;„„Procedure Insert_In_order(Var Head : Data_Ptr; Data_Value : DataType);„„{ This Procedure will search through an ordered linked list, find„  out where the data belongs, and insert it into the list.        }„„Var„  Current,              { Where we are in the list               }„  Next     : Data_Ptr;  { This is what we insert our data into.  }„„begin„  New(Next);„  Current := Head;      { Start at the top of the list.          }„„  if Head = Nil then„    begin„      Head:= Next;„      Head^.OurData := Data_Value;„      Head^.Next_Rec := Nil;„    end„  else„  { Check to see if it comes beFore the first item in the list   }„  if Data_Value < Current^.OurData then„    begin„      Next^.Next_Rec := Head;      { Make the current first come after Next }„      Head := Next;                { This is our new head of the list       }„      Head^.OurData := Data_Value; { and insert our data value.             }„    end„  else„    begin„      { Here we need to go through the list, but always looking one step„        ahead of where we are, so we can maintain the links. The method„        we'll use here is: looking at Current^.Next_Rec^.OurData„        A way to explain that in english is "what is the data pointed to„        by Pointer Next_Rec, in the Record pointed to by Pointer„        current." You may need to run that through your head a few times„        beFore it clicks, but hearing it in English might make it a bit„        easier For some people to understand.                            }„„      While (Data_Value >= Current^.Next_Rec^.OurData) and„            (Current^.Next_Rec <> nil) do„        Current := Current^.Next_Rec;„      Next^.OurData := Data_Value;„      Next^.Next_Rec := Current^.Next_Rec;„      Current^.Next_Rec := Next;„    end;„end;„„Function Pop_First(Var Head : Data_Ptr) : DataType;„„{ Pops the first item off the list and returns the value to the caller. }„„Var„  Old_Head : Data_Ptr;„„begin„  if Head <> nil then   { Is list empty? }„    begin„      Old_Head := Head;„      Pop_First := Head^.OurData;  { Nope, so Return the value }„      Head := Head^.Next_Rec;      { and increment head.       }„      Dispose(Old_Head);           { Get rid of the old head.  }„    end„  else„    begin„      Writeln('Error: Tried to pop an empty stack!');„      halt(1);„    end;„end;„„„Function Pop_Last(Var Head : Data_Ptr) : DataType;„„{ This Function pops the last item off the list and returns the„  value of DataType to the caller.                              }„„Var„  Temp : Data_Ptr;„„begin„  Temp := Head;       { Start at the beginning of the list. }„  if head = nil then  { Is the list empty? }„    begin„      Writeln('Error: Tried to pop an empty stack!');„      halt(1);„    end„  else„  if head^.Next_Rec = Nil then { if there is only one item in list, }„    begin„      Pop_Last := Head^.OurData;  { Return the value               }„      Dispose(Head);              { Return the memory to the heap. }„      Head := Nil;                { and make list empty.           }„    end„  else„    begin„      While Temp^.Next_Rec^.Next_Rec <> nil do  { otherwise, find the end }„        Temp := Temp^.Next_rec;„      Pop_Last := Temp^.Next_Rec^.OurData;  { Return the value          }„      Dispose(Temp^.Next_Rec);              { Return the memory to heap }„      Temp^.Next_Rec := nil;                { and make new end of list. }„    end;„end;„„„Procedure Delete_Here(Var Head : Data_Ptr; Our_Rec : Data_Ptr);„„„{ Deletes the node Our_Rec from the list starting at Head. The Procedure„  does check For an empty list, but it assumes that Our_Rec IS in the list.„}„„Var„  Current : Data_Ptr;  { Used to move through the list. }„„begin„  Current := Head;„  if Current = nil then   { Is the list empty? }„    begin„      Writeln('Error: Cant delete from an empty stack.');„      halt(1);„    end„  else„    begin   { Go through list Until we find the one to delete. }„      While Current^.Next_Rec <> Our_Rec do„        Current := Current^.Next_Rec;„      Current ^.Next_Rec := Our_Rec^.Next_Rec; { Point around old link. }„      Dispose(Our_Rec);                        { Get rid of the link..  }„    end;„end;„„„end.„                                                                                                3      05-28-9313:54ALL                      SWAG SUPPORT TEAM        LL-INSRT.PAS             IMPORT              13          {     The following Program yields output that indicates that I have it set up„correctly but With my scanty understanding of exactly how to handle a linked„list I would be surprised if it is.  This is one difficult area in which Swan„is not quite as expansive as he might be.„„        I will appreciate critique and commentary on this if you are anybody„would be so kind as to give it:„}„„Program InsertLink;„Uses Crt;„„Type„  Str15 = String[15];„  Aptr = ^Link;„  Link = Record„       Data : Str15;„       Node : Aptr;„  end;„„Var„  FirstItem, NewItem, OldItem : Aptr;„„Procedure CreateList;„begin„  Writeln('Linked list BEForE insertion of node.');„  Writeln;„  New(FirstItem);„  FirstItem^.Data := 'inSERT ';„  Write(FirstItem^.Data);„  Write('             ');„  New(FirstItem^.Node);„  FirstItem^.Node^.Data := 'HERE';„  Writeln(FirstItem^.Node^.Data);„  FirstItem^.Node^.Node := NIL;„end;„„Procedure InsertALink;„begin„  Writeln; Writeln;„  Writeln('Linked list AFTER insertion of node.');„  Writeln;„  Write(FirstItem^.Data);„  New(NewItem);„  NewItem^.Node := OldItem^.Node;„  OldItem^.Node := NewItem;„  FirstItem^.Node^.Data := 'inSERTEDLinK';„  Write(FirstItem^.Node^.Data);„  New(FirstItem^.Node^.Node);„  FirstItem^.Node^.Node^.Data := ' HERE';„  Writeln(FirstItem^.Node^.Node^.Data);„  FirstItem^.Node^.Node^.Node := NIL;„end;„„Procedure DisposeList;„begin„  Dispose(FirstItem^.Node^.Node);„  FirstItem^.Node := NIL;„end;„„begin„  ClrScr;„  CreateList;„  Writeln;„  InsertALink;„  DisposeList;„end.„                        4      05-28-9313:54ALL                      SWAG SUPPORT TEAM        LL_TEST.PAS              IMPORT              20          {„This is the test Program that I drew up to test the Procedures in Pete„Davis' LinkList.Pas posted in the previous message.  It could be a little more„dressed up but it does work and offers some insight, I think, into the use of„Pointers and linked lists:  note that I ran a little manual test to locate a„designated Pointer in a given list.  Here it is:„}„„Uses„  Crt, LinkList;„„Var„  AList1, AList2, AList3, AList4 : Data_Ptr;„  ANum : DataType;„  Count : Integer;„„begin„  ClrScr;„  Init_List(AList1);„  Writeln('Results of inserting links at the beginning of a list: ');„  For Count := 1 to 20 do„  begin„    ANum := Count;„    Write(' ',ANum);„    Insert_begin(AList1, ANum); {pay out first link (1) to last (20) like}„                                {a fishing line With #-cards.  You end up}„  end;                          {with 20 in your hand going up to 1}„  Writeln;„  Writeln('Watch - Last link inserted is the highest number.');„  Writeln('You are paying out the list like reeling out a fishing line,');„  Writeln('Foot 1, Foot 2, Foot 3, etc. - last one is Foot 20.');„  Writeln('Now, mentally reel in the line to the fourth number.');„  Writeln(' ',alist1^.Next_Rec^.Next_Rec^.Next_Rec^.OurData);„  Writeln;„  Writeln('Now insert one additional number at beginning of list');„  begin„    ANum := 21;„    Insert_begin(AList1,ANum);„  end;„  Writeln(' ',AList1^.OurData);„   Writeln;„„„  Init_List(Alist2);„  Writeln('Results of Inserting links in turn at the end of a list: ');„  For Count := 1 to 20 do„  begin„    ANum := Count;„    Write(' ',ANum);„    Insert_end(Alist2,ANum);„  end;„  Writeln;„  Writeln('note, just the reverse situation of the process above.');„  Writeln('Reel in the line to the fourth number.');„  Writeln(' ',Alist2^.Next_Rec^.Next_Rec^.Next_Rec^.OurData);„          {We inserted at the end so we are now going out toward the 20}„„„„ Init_List(Alist3);„ Writeln('Results of Inserting links in turn in orDER');„ For Count := 1 to 20 do„ begin„   Anum := Count;„   Write(' ',ANum);„   Insert_In_order(Alist3,ANum);„ end;„ Writeln;„ Writeln(' ',Alist3^.Next_Rec^.Next_Rec^.Next_Rec^.OurData);„„end.„{„        In Case anybody missed Pete Davis' Linklist Unit in the previous„message but may have it in her/his library (PNL002.ZIP) what I was asking is„some help With writing code to test the Procedure DELETE_HERE which is the last„Procedure in the Unit.„}                                     5      05-28-9313:54ALL                      SWAG SUPPORT TEAM        OOP-LLST.PAS             IMPORT              90          Program Linked;„„Type„  FileDescriptor =„    Object„      Fpt       : File;„      Name      : String[80];„      HeaderSize: Word;„      RecordSize: Word;„      RecordPtr : Pointer;„      SoftPut   : Boolean;„      IsOpen    : Boolean;„      CurRec    : LongInt;„„      Constructor Init(Nam : String; Hdr : Word; Size : Word; Buff : Pointer;„Put : Boolean);„      Destructor  Done; Virtual;„      Procedure   OpenFile; Virtual;„      Procedure   CloseFile; Virtual;„      Procedure   GetRecord(Rec : LongInt);„      Procedure   PutRecord(Rec : LongInt);„    end;„„  FileLable =„    Record„      Eof : LongInt;„      MRD : LongInt;„      Act : LongInt;„      Val : LongInt;„      Sync: LongInt;„    end;„„  LabeledFile =„    Object(FileDescriptor)„      Header : FileLable;„„      Constructor Init(Nam : String; Size : Word; Buff : Pointer; Put :„Boolean);„      Destructor  Done; Virtual;„      Procedure   OpenFile; Virtual;„      Procedure   CloseFile; Virtual;„      Procedure   WriteHeader;„      Procedure   ReadHeader;„      Procedure   AddRecord;„      Procedure   DelRecord(Rec : LongInt);„    end;„„  DetailHeaderPtr = ^DetailHeader;„  DetailHeader =„    Record„      Master : LongInt;„      Prev   : LongInt;„      Next   : LongInt;„    end;„„  MasterHeaderPtr = ^MasterHeader;„  MasterHeader =„    Record„      First  : LongInt;„      Last   : LongInt;„    end;„„  DetailFileDetailPtr = ^DetailFileDetail;„  DetailFileDetail =„    Object(LabeledFile)„      Constructor Init(Nam : String; Size : Word; Buff : Pointer; Put :„Boolean);„      Procedure   LinkChain(MR, Last, Curr : LongInt);„      Procedure   DelinkChain(Rec : LongInt);„    end;„„  DetailFileMaster =„    Object(LabeledFile)„      Constructor Init(Nam : String; Size : Word; Buff : Pointer; Put :„Boolean);„      Procedure   LinkDetail(DF : DetailFileDetailPtr);„      Procedure   DelinkDetail(DF : DetailFileDetailPtr; DR : LongInt);„      Procedure   GetFirst(DF : DetailFileDetailPtr);„      Procedure   GetLast(DF : DetailFileDetailPtr);„      Procedure   GetNext(DF : DetailFileDetailPtr);„      Procedure   GetPrev(DF : DetailFileDetailPtr);„    end;„„{---------------------------------------------------------------------------}„„Constructor FileDescriptor.Init(Nam : String; Hdr : Word; Size : Word; Buff :„                                Pointer; Put : Boolean);„  begin„    IsOpen := False;„    Name := Nam;„    HeaderSize := Hdr;„    RecordSize := Size;„    RecordPtr := Buff;„    SoftPut := Put;„    CurRec := -1;„  end;„„Destructor  FileDescriptor.Done;„  begin„    if SoftPut and (CurRec <> -1) then„        PutRecord(CurRec);„    if IsOpen then„        CloseFile;„  end;„„Procedure   FileDescriptor.OpenFile;„  begin„    if IsOpen then„        Exit;„    Assign(Fpt,Name);„    {$I-}„    Reset(Fpt,1);„    if IoResult <> 0 then„        ReWrite(Fpt,1);„    if IoResult = 0 then„        IsOpen := True;„    {$I+}„    CurRec := -1;„  end;„„Procedure   FileDescriptor.CloseFile;„  begin„    if not IsOpen then„        Exit;„    {$I-}„    Close(Fpt);„    if IoResult = 0 then„        IsOpen := False;„    {$I+}„    CurRec := -1;„  end;„„Procedure   FileDescriptor.GetRecord(Rec : LongInt);„  Var„    Result : Word;„  begin„    if not IsOpen then„        Exit;„    if CurRec = Rec then„        Exit;„    if SoftPut and (CurRec <> -1) then„        PutRecord(CurRec);„    {$I-}„    if Rec = 0 then„      begin„        Seek(Fpt,0);„        if IoResult = 0 then„          begin„            BlockRead(Fpt,RecordPtr^,HeaderSize,Result);„            if (Result <> HeaderSize) or (IoResult <> 0) then„                {Error Routine};„          end;„      end„    else„      begin„        Seek(Fpt,HeaderSize + (Rec - 1) * RecordSize);„        if IoResult = 0 then„          begin„            BlockRead(Fpt,RecordPtr^,RecordSize,Result);„            if (Result <> RecordSize) or (IoResult <> 0) then„                {Error Routine};„          end;„      end;„    {$I+}„    CurRec := Rec;„  end;„„Procedure   FileDescriptor.PutRecord(Rec : LongInt);„  Var„    Result : Word;„  begin„    if not IsOpen then„        Exit;„    {$I-}„    if Rec = 0 then„      begin„        Seek(Fpt,0);„        if IoResult = 0 then„          begin„            BlockWrite(Fpt,RecordPtr^,HeaderSize,Result);„            if (Result <> HeaderSize) or (IoResult <> 0) then„                {Error Routine};„          end;„      end„    else„      begin„        Seek(Fpt,HeaderSize + (Rec - 1) * RecordSize);„        if IoResult = 0 then„          begin„            BlockWrite(Fpt,RecordPtr^,RecordSize,Result);„            if (Result <> RecordSize) or (IoResult <> 0) then„                {Error Routine};„          end;„      end;„    CurRec := Rec;„    {$I+}„  end;„„{---------------------------------------------------------------------------}„„Constructor LabeledFile.Init(Nam : String; Size : Word; Buff : Pointer; Put :„Boolean);„  begin„    if Size < 4 then„      begin„        WriteLN('Record size must be 4 or larger');„        Fail;„      end;„    FileDescriptor.Init(Nam,Sizeof(Header),Size,Buff,Put);„    Header.Eof := 0;„    Header.MRD := 0;„    Header.Act := 0;„    Header.Val := 0;„    Header.Sync:= 0;„  end;„„Destructor LabeledFile.Done;„  begin„    CloseFile;„    FileDescriptor.Done;„  end;„„Procedure LabeledFile.OpenFile;„  begin„    FileDescriptor.OpenFile;„    if IsOpen then„        ReadHeader;„  end;„„Procedure LabeledFile.CloseFile;„  begin„    {$I-}„    if IsOpen then„      begin„        if SoftPut and (CurRec <> -1) then„            PutRecord(CurRec);„        Header.Val := 0;„        WriteHeader;„        CurRec := -1;„      end;„    FileDescriptor.CloseFile;„    {$I+}„  end;„„Procedure LabeledFile.ReadHeader;„  Var„    Result : Word;„  begin„    {$I-}„    Seek(Fpt,0);„    if IoResult = 0 then„      begin„        BlockRead(Fpt,Header,HeaderSize,Result);„        if (Result <> HeaderSize) or (IoResult <> 0) then„            {Error Routine};„      end;„    {$I+}„  end;„„Procedure LabeledFile.WriteHeader;„  Var„    Result : Word;„  begin„    {$I-}„    Seek(Fpt,0);„    if IoResult = 0 then„      begin„        BlockWrite(Fpt,Header,HeaderSize,Result);„        if (Result <> HeaderSize) or (IoResult <> 0) then„            {Error Routine};„      end;„    {$I+}„  end;„„Procedure LabeledFile.AddRecord;„  Var„    TmpRec : Pointer;„    Result : Word;„    Next   : LongInt;„  begin„    {$I-}„    if Header.MRD <> 0 then„      begin„        GetMem(TmpRec,RecordSize);„        Seek(Fpt,HeaderSize + (Header.MRD - 1) * RecordSize);„        if IoResult = 0 then„          begin„            BlockRead(Fpt,TmpRec^,RecordSize,Result);„            if (Result <> RecordSize) or (IoResult <> 0) then„                {Error Routine};„            Next := LongInt(TmpRec^);„            PutRecord(Header.MRD);„            Header.MRD := Next;„            Header.Act := Header.Act + 1;„          end;„        FreeMem(TmpRec,RecordSize);„      end„    else„      begin„        PutRecord(Header.Eof);„        Header.Eof := Header.Eof + 1;„        Header.Act := Header.Act + 1;„      end;„    WriteHeader;„    {$I+}„  end;„„Procedure LabeledFile.DelRecord(Rec : LongInt);„  Var„    TmpRec : Pointer;„    Result : Word;„  begin„    {$I-}„    GetMem(TmpRec,RecordSize);„    Seek(Fpt,HeaderSize + (Rec - 1) * RecordSize);„    if IoResult = 0 then„      begin„        BlockRead(Fpt,TmpRec^,RecordSize,Result);„        LongInt(TmpRec^) := Header.MRD;„        BlockWrite(Fpt,TmpRec^,RecordSize,Result);„        if (Result <> RecordSize) or (IoResult <> 0) then„           {Error Routine};„        Header.MRD := Rec;„        Header.Act := Header.Act - 1;„        WriteHeader;„      end;„    {$I+}„  end;„„{---------------------------------------------------------------------------}„„Constructor DetailFileDetail.Init(Nam : String; Size : Word; Buff : Pointer;„Put : Boolean);„  begin„    if Size < 12 then„      begin„        WriteLn('Detail File Records must be 12 Bytes or more');„        Fail;„      end;„    LabeledFile.Init(Nam,Size,Buff,Put);„  end;„„Procedure   DetailFileDetail.LinkChain(MR, Last, Curr : LongInt);„  Var„    Hdr : DetailHeaderPtr;„  begin„    Hdr := RecordPtr;„    if Last <> 0 then„      begin„        GetRecord(Last);„        Hdr^.Next := Curr;„        PutRecord(Last);„      end;„    GetRecord(Curr);„    Hdr^.Prev := Last;„    Hdr^.Master := MR;„    Hdr^.Next := 0;„    PutRecord(Curr);„  end;„„Procedure   DetailFileDetail.DelinkChain(Rec : LongInt);  Var„    Hdr : DetailHeaderPtr;„    Tmp : LongInt;„  begin„    Hdr := RecordPtr;„    GetRecord(Rec);„    if Hdr^.Next <> 0 then„      begin„        Tmp := Hdr^.Prev;„        GetRecord(Hdr^.Next);„        Hdr^.Prev := Tmp;„        PutRecord(CurRec);„        GetRecord(Rec);„      end;„    if Hdr^.Prev <> 0 then„      begin„        Tmp := Hdr^.Next;„        GetRecord(Hdr^.Prev);„        Hdr^.Next := Tmp;„        PutRecord(CurRec);„        GetRecord(Rec);„      end;„    Hdr^.Master := 0;„    Hdr^.Next := 0;„    Hdr^.Prev := 0;„    PutRecord(Rec);„  end;„„{---------------------------------------------------------------------------}„„Constructor DetailFileMaster.Init(Nam : String; Size : Word; Buff : Pointer;„Put : Boolean);„  begin„    if Size < 8 then„      begin„        WriteLn('Master File Records must be 8 Bytes or more');„        Fail;„      end;„    LabeledFile.Init(Nam,Size,Buff,Put);„  end;„„Procedure   DetailFileMaster.LinkDetail(DF : DetailFileDetailPtr);„  Var„    Hdr : MasterHeaderPtr;„  begin„    Hdr := RecordPtr;„    DF^.AddRecord;„    DF^.LinkChain(CurRec,Hdr^.Last,DF^.CurRec);„    Hdr^.Last := DF^.CurRec;„    if Hdr^.First = 0 then Hdr^.First := DF^.CurRec;„    PutRecord(CurRec);„  end;„„Procedure   DetailFileMaster.DelinkDetail(DF : DetailFileDetailPtr; DR :„LongInt);„  Var„    Hdr : MasterHeaderPtr;„  begin„    Hdr := RecordPtr;„    DF^.GetRecord(DR);„    if Hdr^.Last = DR then„        Hdr^.Last := DetailHeader(DF^.RecordPtr^).Prev;„    if Hdr^.First = DR then„        Hdr^.First := DetailHeader(DF^.RecordPtr^).Next;„    DF^.DelinkChain(DR);„    PutRecord(CurRec);„  end;„„Procedure   DetailFileMaster.GetFirst(DF : DetailFileDetailPtr);„  Var„    Hdr : MasterHeaderPtr;„  begin„    Hdr := RecordPtr;„    if Hdr^.First = 0 then„      begin„        FillChar(DF^.RecordPtr^,DF^.RecordSize,#0);„        DF^.CurRec := -1;„        Exit;„      end;„    DF^.GetRecord(Hdr^.First);„  end;„„Procedure   DetailFileMaster.GetLast(DF : DetailFileDetailPtr);„  Var„    Hdr : MasterHeaderPtr;„  begin„    Hdr := RecordPtr;„    if Hdr^.Last = 0 then„      begin„        FillChar(DF^.RecordPtr^,DF^.RecordSize,#0);„        DF^.CurRec := -1;„        Exit;„      end;„    DF^.GetRecord(Hdr^.Last);„  end;„„Procedure   DetailFileMaster.GetNext(DF : DetailFileDetailPtr);„  Var„    Hdr : DetailHeaderPtr;„  begin„    Hdr := DF^.RecordPtr;„    if Hdr^.Next = 0 then„      begin„        FillChar(DF^.RecordPtr^,DF^.RecordSize,#0);„        DF^.CurRec := -1;„        Exit;„      end;„    DF^.GetRecord(Hdr^.Next);„  end;„„Procedure   DetailFileMaster.GetPrev(DF : DetailFileDetailPtr);„  Var„    Hdr : DetailHeaderPtr;„  begin„    Hdr := DF^.RecordPtr;„    if Hdr^.Prev = 0 then„      begin„        FillChar(DF^.RecordPtr^,DF^.RecordSize,#0);„        DF^.CurRec := -1;„        Exit;„      end;„    DF^.GetRecord(Hdr^.Prev);„  end;„„{---------------------------------------------------------------------------}„„begin„end.„„                      6      05-28-9313:54ALL                      SWAG SUPPORT TEAM        PTR-MEM.PAS              IMPORT              5           Program Test_Pointers;„„Type„  Array_Pointer = ^MyArray;„  MyArray = Array[1..10] of String;„„Var„  MyVar : Array_Pointer;„„begin„  Writeln('Memory beFore initializing Variable : ',MemAvail);„„  New(MyVar);„„  Writeln('Memory after initializiation : ',MemAvail);„„  MyVar^[1] := 'Hello';„  MyVar^[2] := 'World!';„„  Writeln(MyVar^[1], ' ', MyVar^[2]);„„  Dispose(MyVar);„„  Writeln('Memory after Variable memory released : ',MemAvail);„end.„                                                                       7      05-28-9313:54ALL                      SWAG SUPPORT TEAM        PTRARRAY.PAS             IMPORT              13          DS> Hi, I've recently encountered a problem With not having enough memory„DS> to open a large sized Array [ie: 0..900].  Is there any way to„DS> allocate more memory to the Array as to make larger Arrays„„Array of what?  if the total size of the Array (i.e. 901 *„sizeof(whatever_it_is_you're_talking_about)) is less than 64K, it's a snap.„Read your dox on Pointers and the heap.  You'll end up doing something like„this:„„Type„  tWhatever : whatever_it_is_you're_talking_about;„  tMyArray : Array[0..900] of tWhatever;„  tPMyArray : ^MyArray;„„Var„  PMyArray : tPMyArray;„„begin„  getmem(PMyArray,sizeof(tMyArray));„„  { now access your Array like this:„    PMyArray^[IndexNo] }„„if your Array is >64K, you can do something like this:„„Type„  tWhatever : whatever_it_is_you're_talking_about;„  tPWhatever : ^tWhatever;„„Var„  MyArray : Array[0..900] of tPWhatever;„  i : Word;„„begin„  For i := 0 to 900 do„    getmem(MyArray[i],sizeof(tWhatever));„„  { now access your Array like this:„    MyArray[IndexNo]^ }„„if you don't have enough room left in your data segment to use this latter„approach (and I'll bet you do), you'll just need one more level of indirection.„Declare one Pointer in the data segment that points to the Array of Pointers on„the heap, which in turn point to your data.„„if you're a beginner, this may seem impossibly Complex (it did to me), but keep„at it and it will soon be second nature.„                                                                                                                          8      05-28-9313:54ALL                      SWAG SUPPORT TEAM        TREEHITE.PAS             IMPORT              7           {„Authors: Chet Kress and Jerome Tonneson„„>Help !!! I need a Function or Procedure in standard pascal that will„>calculate the height of a binary tree. It must be able to calculate the„>height of the tree if the tree is either balanced, unbalanced or full.„>The Procedure must be recursive.„„Here are the only two Functions you will need.„}„„Function Max(A, B : Integer) : Integer;„begin {Max}„  If A > B then„    Max := A;„  else„    Max := B;„end; {Max}„„Function Height (Tree : TreeType) : Integer;„begin {Height}„  If Tree = Nil then„    Height := 0„  else„    Height := Max(Height(Tree^.Right), Height(Tree^.Left)) + 1;„end; {Height}„                                                                                                                                9      06-22-9309:20ALL                      SWAG SUPPORT TEAM        Generic Linked List      IMPORT              34          UNIT LinkList;„„{-------------------------------------------------„          Generic linked list object            -„-------------------------------------------------}„„{***************************************************************}„                          INTERFACE„{***************************************************************}„„TYPE„„    { Generic Linked List Handler Definition }„„  NodeValuePtr = ^NodeValue;„„  NodeValue = OBJECT„    CONSTRUCTOR Init;„    DESTRUCTOR  Done; VIRTUAL;„  END;„„  NodePtr = ^Node;„  Node = RECORD„    Retrieve : NodeValuePtr;„    Next     : NodePtr;„  END;„„„    { Specific Linked List Handler Definition }„„  NodeListPtr = ^NodeList;„„  NodeList = OBJECT„    Items : NodePtr;„    CONSTRUCTOR Init;„    DESTRUCTOR Done; VIRTUAL;„    PROCEDURE Add (A_Value : NodeValuePtr);„„    (* Iterator Functions *)„„    PROCEDURE StartIterator (VAR Ptr : NodePtr);„    PROCEDURE NextValue (VAR Ptr : NodePtr);„    FUNCTION AtEndOfList (Ptr : NodePtr) : Boolean;„  END;„„{***************************************************************}„                         IMPLEMENTATION„{***************************************************************}„„„CONSTRUCTOR NodeValue.Init;„BEGIN„END;„„DESTRUCTOR NodeValue.Done;„BEGIN„END;„„CONSTRUCTOR NodeList.Init;„BEGIN„  Items := NIL;„END;„„DESTRUCTOR NodeList.Done;„    VAR„         Temp : NodePtr;„BEGIN„    WHILE Items <> NIL DO„    BEGIN„         Temp := Items;„         IF Temp^.Retrieve <> NIL THEN„              Dispose (Temp^.Retrieve, Done);„         Items := Items^.Next;„         Dispose (Temp);„    END;„END;„„PROCEDURE NodeList.Add (A_Value : NodeValuePtr);„    VAR„         Cell : NodePtr;„         Temp : NodePtr;„BEGIN„    (* Go TO the END OF the linked list. *)„    Cell := Items;„    IF Cell <> NIL THEN„         WHILE Cell^.Next <> NIL DO„              Cell := Cell^.Next;„„    New (Temp);„    Temp^.Retrieve := A_Value;„    Temp^.Next := NIL;„    IF Items = NIL„    THEN„         Items := Temp„    ELSE„         Cell^.Next := Temp;„END;„„PROCEDURE NodeList.StartIterator (VAR Ptr : NodePtr);„BEGIN„    Ptr := Items;„END;„„PROCEDURE NodeList.NextValue (VAR Ptr : NodePtr);„BEGIN„    IF Ptr <> NIL THEN„    Ptr := Ptr^.Next;„END;„„FUNCTION NodeList.AtEndOfList (Ptr : NodePtr) : Boolean;„BEGIN„  AtEndOfList := (Ptr = NIL);„END;„„END.„„{ DEMO PROGRAM }„„PROGRAM LL_Demo;„„USES LinkList;„„{ Turbo Pascal Linked List Object Example }„„TYPE„„  DataValuePtr = ^DataValue;„„  DataValue = OBJECT (NodeValue)„    Value : Real;„    CONSTRUCTOR Init (A_Value : Real);„    FUNCTION TheValue : Real;„  END;„„  DataList = OBJECT (NodeList)„    FUNCTION CurrentValue (Ptr : NodePtr) : Real;„    PROCEDURE SetCurrentValue (Ptr : NodePtr; Value : Real);„  END;„„VAR„    Itr : NodePtr;„    TestLink : DataList;„„{------ Unique methods to create for your linked list type -----}„„CONSTRUCTOR DataValue.Init (A_Value : Real);„BEGIN„    Value := A_Value;„END;„„FUNCTION DataValue.TheValue : Real;„BEGIN„  TheValue := Value;„END;„„FUNCTION DataList.CurrentValue (Ptr : NodePtr) : Real;„BEGIN„  CurrentValue := DataValuePtr (Ptr^.Retrieve)^.TheValue;„END;„„PROCEDURE DataList.SetCurrentValue (Ptr : NodePtr; Value : Real);„BEGIN„  DataValuePtr (Ptr^.Retrieve)^.Value := Value;„END;„„„BEGIN„  TestLink.Init;        {Create the list then add 5 values to it}„„  TestLink.Add (New (DataValuePtr, Init (1.0)));„  TestLink.Add (New (DataValuePtr, Init (2.0)));„  TestLink.Add (New (DataValuePtr, Init (3.0)));„  TestLink.Add (New (DataValuePtr, Init (4.0)));„  TestLink.Add (New (DataValuePtr, Init (5.0)));„„  TestLink.StartIterator (Itr);      {Display the list on screen}„  WHILE NOT TestLink.AtEndOfList (Itr) DO BEGIN„    Write (TestLink.CurrentValue (Itr) : 5 : 1);„    TestLink.NextValue (Itr);„    END;„  WriteLn;„„  TestLink.StartIterator (Itr);  {Change some values in the list}„  TestLink.SetCurrentValue (Itr, 0.0);„  TestLink.NextValue (Itr);„  TestLink.SetCurrentValue (Itr, -1.0);„„  TestLink.StartIterator (Itr);       {Redisplay the list values}„  WHILE NOT TestLink.AtEndOfList (Itr) DO BEGIN„    Write (TestLink.CurrentValue (Itr) : 5 : 1);„    TestLink.NextValue (Itr);„  END;„  WriteLn;„  ReadLn;„END.„                                           10     08-17-9308:39ALL                      SWAG SUPPORT TEAM        Binary Tree - Linked ListIMPORT              73     ”Õ   Unit BinTree;„„Interface„„Const TOTAL_NODES = 100;„„Type BTreeStr = String[40];„  ShiftSet = (TiltL_Tilt, neutral, TiltR_Tilt);„  BinData  = Record„    Key : BTreeStr;„  End;„  BinPtr = ^Bin_Tree_Rec;„  Bin_Tree_Rec = Record„    BTreeData    : BinData;„    Shift        : ShiftSet;„    TiltL, TiltR : BinPtr;„  End;„  BTreeRec = Array[1..TOTAL_NODES] of BinData;„„Procedure Ins_BinTree„  (Var Rt   : BinPtr;„       Node : BinData);„„Function Srch_BinTree„  (Rt     : BinPtr;„   Node   : BinData;„   Index1 : Word) : Word;„„Procedure BSortArray„  (Var Rt       : BinPtr;„   Var SortNode : BTreeRec;„   Var Index    : Word);„„Procedure Del_BinTree„  (Var Rt      : BinPtr;„       Node    : BinData;„       Var DelFlag : Boolean);„„Implementation„„Procedure Move_TiltR(Var Rt : BinPtr);„„  Var„    Ptr1, Ptr2 : BinPtr;„„  Begin„    Ptr1 := Rt^.TiltR;„    If Ptr1^.Shift = TiltR_Tilt Then Begin„      Rt^.TiltR := Ptr1^.TiltL;„      Ptr1^.TiltL := Rt;„      Rt^.Shift := neutral;„      Rt := Ptr1„    End„    Else Begin„      Ptr2 := Ptr1^.TiltL;„      Ptr1^.TiltL := Ptr2^.TiltR;„      Ptr2^.TiltR := Ptr1;„      Rt^.TiltR := Ptr2^.TiltL;„      Ptr2^.TiltL := Rt;„      If Ptr2^.Shift = TiltL_Tilt„        Then Ptr1^.Shift := TiltR_Tilt„        Else Ptr1^.Shift := neutral;„      If Ptr2^.Shift = TiltR_Tilt„        Then Rt^.Shift := TiltL_Tilt„        Else Rt^.Shift := neutral;„      Rt := Ptr2„    End;„    Rt^.Shift := neutral„  End;„„Procedure Move_TiltL(Var Rt : BinPtr);„„  Var„    Ptr1, Ptr2 : BinPtr;„„  Begin„    Ptr1 := Rt^.TiltL;„    If Ptr1^.Shift = TiltL_Tilt Then Begin„      Rt^.TiltL := Ptr1^.TiltR;„      Ptr1^.TiltR := Rt;„      Rt^.Shift := neutral;„      Rt := Ptr1„    End„    Else Begin„      Ptr2 := Ptr1^.TiltR;„      Ptr1^.TiltR := Ptr2^.TiltL;„      Ptr2^.TiltL := Ptr1;„      Rt^.TiltL := Ptr2^.TiltR;„      Ptr2^.TiltR := Rt;„      If Ptr2^.Shift = TiltR_Tilt„        Then Ptr1^.Shift := TiltL_Tilt„        Else Ptr1^.Shift := neutral;„      If Ptr2^.Shift = TiltL_Tilt„        Then Rt^.Shift := TiltR_Tilt„        Else Rt^.Shift := neutral;„      Rt := Ptr2;„    End;„    Rt^.Shift := neutral„  End;„„Procedure Ins_Bin(Var Rt    : BinPtr;„                      Node  : BinData;„                  Var InsOK : Boolean);„„  Begin„    If Rt = NIL Then Begin„      New(Rt);„      With Rt^ Do Begin„        BTreeData := Node;„        TiltL := NIL;„        TiltR := NIL;„        Shift := neutral„      End;„      InsOK := TRUE„    End„    Else If Node.Key <= Rt^.BTreeData.Key Then Begin„      Ins_Bin(Rt^.TiltL, Node, InsOK);„      If InsOK Then„        Case Rt^.Shift Of„          TiltL_Tilt : Begin„                        Move_TiltL(Rt);„                        InsOK := FALSE„                       End;„          neutral    : Rt^.Shift := TiltL_Tilt;„          TiltR_Tilt : Begin„                        Rt^.Shift := neutral;„                        InsOK := FALSE„                       End;„        End;„      End„      Else Begin„        Ins_Bin(Rt^.TiltR, Node, InsOK);„        If InsOK Then„          Case Rt^.Shift Of„            TiltL_Tilt : Begin„                          Rt^.Shift := neutral;„                          InsOK := FALSE„                         End;„            neutral    : Rt^.Shift := TiltR_Tilt;„            TiltR_Tilt : Begin„                          Move_TiltR(Rt);„                          InsOK := FALSE„                         End;„          End;„        End;„  End;„„Procedure Ins_BinTree(Var Rt   : BinPtr;„                        Node : BinData);„„  Var Ins_ok : Boolean;„„  Begin„    Ins_ok := FALSE;„    Ins_Bin(Rt, Node, Ins_ok)„  End;„„Function Srch_BinTree(Rt     : BinPtr;„                      Node   : BinData;„                      Index1 : Word)„                      : Word;„„  Var„    Index : Word;„„  Begin„    Index := 0;„    While (Rt <> NIL) AND (Index < Index1) Do„      If Node.Key > Rt^.BTreeData.Key Then Rt := Rt^.TiltR„      Else if Node.Key < Rt^.BTreeData.Key Then Rt := Rt^.TiltL„      Else Begin„        Inc(Index);„        Rt := Rt^.TiltL„      End;„    Srch_BinTree := Index„  End;„„Procedure Tvrs_Tree„  (Var Rt       : BinPtr;„   Var SortNode : BTreeRec;„   Var Index    : Word);„„  Begin„    If Rt <> NIL Then Begin„      Tvrs_Tree(Rt^.TiltL, SortNode, Index);„      Inc(Index);„      If Index <= TOTAL_NODES Then„        SortNode[Index].Key := Rt^.BTreeData.Key;„      Tvrs_Tree(Rt^.TiltR, SortNode, Index);„    End;„  End;„„Procedure BSortArray„  (Var Rt       : BinPtr;„   Var SortNode : BTreeRec;„   Var Index    : Word);„„  Begin„    Index := 0;„    Tvrs_Tree(Rt, SortNode, Index);„  End;„„Procedure Shift_TiltR„  (Var Rt      : BinPtr;„   Var DelFlag : Boolean);„„  Var„    Ptr1, Ptr2 : BinPtr;„    balnc2, balnc3 : ShiftSet;„„  Begin„    Case Rt^.Shift Of„      TiltL_Tilt : Rt^.Shift := neutral;„      neutral    : Begin„                     Rt^.Shift := TiltR_Tilt;„                     DelFlag := FALSE„                   End;„      TiltR_Tilt : Begin„           Ptr1 := Rt^.TiltR;„           balnc2 := Ptr1^.Shift;„           If NOT (balnc2 = TiltL_Tilt) Then Begin„             Rt^.TiltR := Ptr1^.TiltL;„             Ptr1^.TiltL := Rt;„             If balnc2 = neutral Then Begin„               Rt^.Shift := TiltR_Tilt;„               Ptr1^.Shift := TiltL_Tilt;„               DelFlag := FALSE„             End„             Else Begin„               Rt^.Shift := neutral;„               Ptr1^.Shift := neutral;„             End;„             Rt := Ptr1„           End„           Else Begin„             Ptr2 := Ptr1^.TiltL;„             balnc3 := Ptr2^.Shift;„             Ptr1^.TiltL := Ptr2^.TiltR;„             Ptr2^.TiltR := Ptr1;„             Rt^.TiltR := Ptr2^.TiltL;„             Ptr2^.TiltL := Rt;„             If balnc3 = TiltL_Tilt Then„               Ptr1^.Shift := TiltR_Tilt„             Else„               Ptr1^.Shift := neutral;„             If balnc3 = TiltR_Tilt Then„               Rt^.Shift := TiltL_Tilt„             Else„               Rt^.Shift := neutral;„             Rt := Ptr2;„             Ptr2^.Shift := neutral;„           End;„         End;„      End;„    End;„„Procedure Shift_TiltL„  (Var Rt      : BinPtr;„   Var DelFlag : Boolean);„„  Var„    Ptr1, Ptr2 : BinPtr;„    balnc2, balnc3 : ShiftSet;„„  Begin„    Case Rt^.Shift Of„      TiltR_Tilt : Rt^.Shift := neutral;„      neutral    : Begin„                     Rt^.Shift := TiltL_Tilt;„                     DelFlag := False„                   End;„      TiltL_Tilt : Begin„           Ptr1 := Rt^.TiltL;„           balnc2 := Ptr1^.Shift;„           If NOT (balnc2 = TiltR_Tilt) Then Begin„             Rt^.TiltL := Ptr1^.TiltR;„             Ptr1^.TiltR := Rt;„             If balnc2 = neutral Then Begin„               Rt^.Shift := TiltL_Tilt;„               Ptr1^.Shift := TiltR_Tilt;„               DelFlag := FALSE„             End„             Else Begin„               Rt^.Shift := neutral;„               Ptr1^.Shift := neutral;„             End;„             Rt := Ptr1„           End„           Else Begin„             Ptr2 := Ptr1^.TiltR;„             balnc3 := Ptr2^.Shift;„             Ptr1^.TiltR := Ptr2^.TiltL;„             Ptr2^.TiltL := Ptr1;„             Rt^.TiltL := Ptr2^.TiltR;„             Ptr2^.TiltR := Rt;„             If balnc3 = TiltR_Tilt Then„               Ptr1^.Shift := TiltL_Tilt„             Else„               Ptr1^.Shift := neutral;„             If balnc3 = TiltL_Tilt Then„               Rt^.Shift := TiltR_Tilt„             Else„               Rt^.Shift := neutral;„             Rt := Ptr2;„             Ptr2^.Shift := neutral;„           End;„         End;„    End;„  End;„„Procedure Kill_Lo_Nodes„  (Var Rt,„       Ptr     : BinPtr;„   Var DelFlag : Boolean);„„  Begin„    If Ptr^.TiltR = NIL Then Begin„      Rt^.BTreeData := Ptr^.BTreeData;„      Ptr := Ptr^.TiltL;„      DelFlag := TRUE„    End„    Else Begin„      Kill_Lo_Nodes(Rt, Ptr^.TiltR, DelFlag);„      If DelFlag Then Shift_TiltL(Ptr,DelFlag);„    End;„  End;„„Procedure Del_Bin(Var Rt      : BinPtr;„                      Node    : BinData;„                  Var DelFlag : Boolean);„„  Var„    Ptr : BinPtr;„„  Begin„    If Rt = NIL Then„       DelFlag := False„    Else„      If Node.Key < Rt^.BTreeData.Key Then Begin„        Del_Bin(Rt^.TiltL, Node, DelFlag);„        If DelFlag Then Shift_TiltR(Rt, DelFlag);„      End„      Else Begin„        If Node.Key > Rt^.BTreeData.Key Then Begin„          Del_Bin(Rt^.TiltR, Node, DelFlag);„          If DelFlag Then Shift_TiltL(Rt, DelFlag);„        End„        Else Begin„          Ptr := Rt;„          If Rt^.TiltR = NIL Then Begin„            Rt := Rt^.TiltL;„            DelFlag := TRUE;„            Dispose(Ptr);„          End„          Else If Rt^.TiltL = NIL Then Begin„            Rt := Rt^.TiltR;„            DelFlag := TRUE;„            Dispose(Ptr);„          End„          Else Begin„            Kill_Lo_Nodes(Rt, Rt^.TiltL, DelFlag);„            If DelFlag Then Shift_TiltR(Rt, DelFlag);„            Dispose(Rt^.TiltL);„          End;„        End;„      End;„  End;„„Procedure Del_BinTree„  (Var Rt      : BinPtr;„       Node    : BinData;„   Var DelFlag : Boolean);„„  Begin„    DelFlag := FALSE;„    Del_Bin(Rt, Node, DelFlag)„  End;„End.                   11     08-27-9320:11ALL                      SWAG SUPPORT TEAM        AVL Binary Trees         IMPORT              52     ”Õ   {„> Does anyone have code(preferably TP) the implements AVL trees?„> I'm having trouble With the insertion part of it.  I'm writing a small„> parts inventory Program For work(although I'm not employed as a„> Programmer) and the AVL tree would be very fast For it.„}„„„Program avl;„„Type„  nodeptr = ^node;„  node    = Record„    key   : Char;„    bal   : -1..+1; { bal = h(right) - h(left) }„    left,„    right : nodeptr„  end;„„  tree = nodeptr;„„Var„  t : tree;„  h : Boolean; { insert & delete parameter }„„„Procedure maketree(Var t : tree);„begin„  t := nil;„end;„„Function member(k : Char; t : tree) : Boolean;„begin { member }„  if t = nil then„    member := False„  else„  if k = t^.key then„    member := True„  else„  if k < t^.key then„    member := member(k, t^.left)„  else„    member := member(k, t^.right);„end;„„Procedure ll(Var t : tree);„Var„  p : tree;„begin„  p := t^.left;„  t^.left  := p^.right;„  p^.right := t;„  t := p;„end;„„Procedure rr(Var t : tree);„Var„   p : tree;„begin„  p := t^.right;„  t^.right := p^.left;„  p^.left  := t;„  t := p;„end„„Procedure lr(Var t : tree);„begin„  rr(t^.left);„  ll(t);„end;„„Procedure rl(Var t : tree);„begin„  ll(t^.right);„  rr(t);„end;„„Procedure insert(k : Char; Var t : tree; Var h : Boolean);„„  Procedure balanceleft(Var t : tree; Var h : Boolean);„  begin„    Writeln('balance left');„    Case t^.bal of„      +1 :„        begin„          t^.bal := 0;„          h := False;„        end;„       0 : t^.bal := -1;„      -1 :„        begin { rebalance }„          if t^.left^.bal = -1 then„          begin { single ll rotation }„            Writeln('single ll rotation');„            ll(t);„            t^.right^.bal := 0;„          end„          else { t^.left^.bal  = +1 }„          begin  { double lr rotation }„            Writeln('double lr rotation');„            lr(t);„            if t^.bal = -1 then„              t^.right^.bal := +1„            else„              t^.right^.bal := 0;„            if t^.bal = +1 then„              t^.left^.bal := -1„            else„              t^.left^.bal := 0;„          end;„          t^.bal := 0;„          h := False;„        end;„    end;„  end;„„  Procedure balanceright(Var t : tree; Var h : Boolean);„  begin„    Writeln('balance right');„    Case t^.bal of„      -1 :„        begin„          t^.bal := 0;„          h := False;„        end;„       0 : t^.bal := +1;„      +1 :„        begin { rebalance }„          if t^.right^.bal = +1 then„          begin { single rr rotation }„            Writeln('single rr rotation');„            rr(t);„            t^.left^.bal := 0„          end„          else { t^.right^.bal  = -1 }„          begin  { double rl rotation }„            Writeln('double rl rotation');„            rl(t);„            if t^.bal = -1 then„              t^.right^.bal := +1„            else„              t^.right^.bal := 0;„            if t^.bal = +1 then„              t^.left^.bal := -1„            else„              t^.left^.bal := 0;„          end;„          t^.bal := 0;„          h := False;„        end;„    end;„  end;„„begin { insert }„  if t = nil then„  begin„    new(t);„    t^.key   := k;„    t^.bal   := 0;„    t^.left  := nil;„    t^.right := nil;„	  h := True;„  end„  else„  if k < t^.key then„  begin„    insert(k, t^.left, h);„	  if h then„      balanceleft(t, h);„  end„  else„  if k > t^.key then„  begin„    insert(k, t^.right, h);„    if h then„      balanceright(t, h);„  end;„end;„„Procedure delete(k : Char; Var t : tree; Var h : Boolean);„„  Procedure balanceleft(Var t : tree; Var h : Boolean);„  begin„    Writeln('balance left');„    Case t^.bal of„      -1 :„        begin„          t^.bal := 0;„          h := True;„        end;„       0 :„         begin„	         t^.bal := +1;„	         h := False;„	       end;„      +1 :„        begin { rebalance }„          if t^.right^.bal >= 0 then„          begin„            Writeln('single rr rotation'); { single rr rotation }„		        if t^.right^.bal = 0 then„            begin„              rr(t);„		          t^.bal := -1;„		          h := False;„		        end„		        else„            begin„              rr(t);„		          t^.left^.bal := 0;„		          t^.bal := 0;„		          h := True;„		        end;„          end„          else { t^.right^.bal  = -1 }„          begin„		        Writeln('double rl rotation');„ 	          rl(t);„		        t^.left^.bal := 0;„            t^.right^.bal := 0;„		        h := True;„		      end;„        end;„    end;„  end;„„  Procedure balanceright(Var t : tree; Var h : Boolean);„  begin„    Writeln('balance right');„    Case t^.bal of„      +1 :„        begin„          t^.bal := 0;„          h := True;„        end;„       0 :„         begin„	         t^.bal := -1;„	         h := False;„	       end;„      -1 :„        begin { rebalance }„          if t^.left^.bal <= 0 then„          begin { single ll rotation }„            Writeln('single ll rotation');„		        if t^.left^.bal = 0 then„            begin„              ll(t);„		          t^.bal := +1;„		          h := False;„		        end„	  	      else„            begin„              ll(t);„		          t^.left^.bal := 0;„		          t^.bal := 0;„		          h := True;„		        end;„          end„          else { t^.left^.bal  = +1 }„          begin  { double lr rotation }„            Writeln('double lr rotation');„            lr(t);„		        t^.left^.bal := 0;„		        t^.right^.bal := 0;„		        h := True;„          end;„        end;„    end;„  end;„„  Function deletemin(Var t : tree; Var h : Boolean) : Char;„  begin { deletemin }„    if t^.left = nil then„    begin„      deletemin := t^.key;„      t := t^.right;„	    h := True;„    end„    else„    begin„      deletemin := deletemin(t^.left, h);„	    if h then„        balanceleft(t, h);„    end;„  end;„„begin { delete }„  if t <> nil then„  begin„    if k < t^.key then„    begin„      delete(k, t^.left, h);„	    if h then„        balanceleft(t, h);„    end„    else„    if k > t^.key then„    begin„      delete(k, t^.right, h);„	    if h then„        balanceright(t, h);„    end„    else„    if (t^.left = nil) and (t^.right = nil) then„    begin„      t := nil;„	    h := True;„    end„    else„    if t^.left = nil then„    begin„      t := t^.right;„	    h := True;„    end„    else„    if t^.right = nil then„    begin„      t := t^.left;„	    h := True;„    end„    else„    begin„      t^.key := deletemin(t^.right, h);„	    if h then„	      balanceright(t, h);„    end;„  end;„end;„„begin„end.„                        12     09-26-9308:50ALL                      GARRY J. VASS            Linked Lists in EMS      IMPORT              111    ”Õ   {„       PROTOTYPE PROCEDURES FOR CREATING AND ACCESSING SORTED„                 LINKED LISTS IN EXPANDED MEMORY„„                  GARRY J. VASS [72307,3311]„„The procedures and functions given below present a prototype„method for creating and accesing linked lists in expanded memory.„Although pointer variables are used in a way that appears to„conform to the TPascal pointer syntax, there are several major„differences:„„            -  there are none of the standard NEW, GETMEM,„               MARK, RELEASE, DISPOSE, FREEMEM, and MAXAVAIL„               calls made.  These are bound to the program's„               physical location in memory, and have no„               effect in expanded memory.  Attempting to„               use these here, or to implement standard„               linked procedures by altering the HeapPtr„               standard variable is dangerous and highly„               discouraged.„            -  pointer variables are set and queried by„               a simulation of TPascal's internal procedures„               that is specially customized to the EMS„               page frame segment.„            -  the MEMAVAIL function is useless here.  These„               procedures will support a list of up to 64K.„„The general pseudo-code for creating a linked list in expanded„memory is:„„      1.  Get a handle and allocate memory from the EMM.„      2.  Get the page frame segment for the handle to„          mark the physical beginning of the list in„          expanded memory.„      3.  Initialize the root pointer to the page frame„          segment.„      4.  For each new record (or list member):„„          a.  Calculate a new physical location for the„              record using a simulated normalization„              procedure.„          b.  Set the appropriate values to the„              pointers using a simulated pointer„              assignment procedure.„          c.  Assure that the last logical record„              contains a pointer value of NIL.„„Accessing the list is basically the same as the standard algorithms.„„The procedures here assume that each list record (or member) is composed„of three elements:„„        -  a pointer to the next logical record.  If the member is the„           last logical record, this pointer is NIL.„        -  an index, or logical sort key.  This value determines the„           logical position of the record in the list.  These routines„           and the demo use an integer type for index.  The index,„           however, can be of any type where ordinal comparisons„           can be made, including pointers.„        -  an area for the actual data in each record.  These routines„           and the demo use a string of length 255, but this area can„           be of any type, including pointers to other lists.„„Please note that these routines are exploratory and prototype.  In no way„are they intended to be definitive, accurate, efficient, or exemplary.„„Areas for further analysis are:„„      1.  A reliable analog to the MEMAVAIL function.„      2.  Creating linked lists that cross handle boundaries.„      3.  Creating linked lists that begin in heapspace and„          extend to expanded memory.„      4.  A reliable method for assigning the standard„          variable, HeapPtr, to the base page.„„Please let me know of your progress in these areas, or improvements„to the routines below via the BORLAND SIG [72307,3311] or my PASCAL/„PROLOG SIG at the POLICE STATION BBS (201-963-3115).„„}„PROGRAM LINKED_LISTS;„Uses dos,crt;„CONST„     ALLOCATE_MEMORY =   $43;„     EMS_SERVICES    =   $67;„     FOREVER:BOOLEAN = FALSE;„     GET_PAGE_FRAME  =   $41;„     LOGICAL_PAGES   =     5;„     MAP_MEMORY      =   $44;„     RELEASE_HANDLE  =   $45;„TYPE„    ANYSTRING = STRING[255];„    LISTPTR   = ^LISTREC;„    LISTREC   = RECORD„                      NEXT_POINTER : LISTPTR;„                      INDEX_PART   : INTEGER;„                      DATA_PART    : ANYSTRING;„                END;„VAR„   ANYINTEGER : INTEGER;„   ANYSTR     : ANYSTRING;„   HANDLE     : INTEGER;    { HANDLE ASSIGNED BY EMM }„   LIST       : LISTREC;„   NEWOFFSET  : INTEGER;    { PHYSICAL OFFSET OF RECORD }„   NEWSEGMENT : INTEGER;    { PHYSICAL SEGMENT OF RECORD }„   REGS1      : Registers;„   ROOT       : LISTPTR;    { POINTER TO LIST ROOT }„   SEGMENT    : INTEGER;    { PAGE FRAME SEGMENT }„„{--------------------- GENERAL SUPPORT ROUTINES  ----------------------}„FUNCTION HEXBYTE(N:INTEGER):ANYSTRING;„CONST H:ANYSTRING='0123456789ABCDEF';„BEGIN„     HEXBYTE:=H[((LO(N)DIV 16)MOD 16)+1]+H[(LO(N) MOD 16)+1];„END;„„FUNCTION HEXWORD(N:INTEGER):ANYSTRING;„BEGIN„     HEXWORD:= HEXBYTE(HI(N))+HEXBYTE(LO(N));„END;„„FUNCTION CARDINAL(I:INTEGER):REAL;„BEGIN„     CARDINAL:=256.0*HI(I)+LO(I);„END;„„PROCEDURE  PAUSE;„VAR CH:CHAR;„BEGIN„     WRITELN;WRITELN('-- PAUSING FOR KEYBOARD INPUT...');„     READ(CH);„     WRITELN;„END;„„PROCEDURE DIE(M:ANYSTRING);„BEGIN„     WRITELN('ERROR IN: ',M);„     WRITELN('HALTING HERE, SUGGEST REBOOT');„     HALT;„END;„FUNCTION EXIST(FILENAME:ANYSTRING):BOOLEAN;VAR FILVAR:FILE;BEGIN ASSIGN(FILVAR,FILENAME);{$I-}„RESET(FILVAR);{$I+}EXIST := (IORESULT = 0);END;„{--------------------- END OF GENERAL SUPPORT ROUTINES  ----------------}„„{----------------------  EMS SUPPORT ROUTINES  -------------------------}„„FUNCTION EMS_INSTALLED:BOOLEAN;         { RETURNS TRUE IF EMS IS INSTALLED }„BEGIN                                   { ASSURED DEVICE NAME OF EMMXXXX0  }„     EMS_INSTALLED := EXIST('EMMXXXX0');{ BY LOTUS/INTEL/MS STANDARDS      }„END;„„FUNCTION NEWHANDLE(NUMBER_OF_LOGICAL_PAGES_NEEDED:INTEGER):INTEGER;„BEGIN„     REGS1.AH := ALLOCATE_MEMORY;„     REGS1.BX := NUMBER_OF_LOGICAL_PAGES_NEEDED;„     INTR(EMS_SERVICES, REGS1);„     IF REGS1.AH <> 0 THEN DIE('ALLOCATE MEMORY');„     NEWHANDLE := REGS1.DX;„END;„„PROCEDURE KILL_HANDLE(HANDLE_TO_KILL:INTEGER);  { RELEASES EMS HANDLE.    }„BEGIN                                           { THIS MUST BE DONE IF    }„     REPEAT                                     { OTHER APPLICATIONS ARE  }„          WRITELN('RELEASING EMS HANDLE');      { TO USE THE EM ARES.  DUE}„          REGS1.AH := RELEASE_HANDLE;            { TO CONCURRENT PROCESSES,}„          REGS1.DX := HANDLE_TO_KILL;            { SEVERAL TRIES MAY BE    }„          INTR(EMS_SERVICES, REGS1);             { NECESSARY.              }„     UNTIL REGS1.AH = 0;„     WRITELN('HANDLE RELEASED');„END;„„FUNCTION PAGE_FRAME_SEGMENT:INTEGER;         { RETURNS PFS }„BEGIN„     REGS1.AH := GET_PAGE_FRAME;„     INTR(EMS_SERVICES, REGS1);„     IF REGS1.AH <> 0 THEN DIE('GETTING PFS');„     PAGE_FRAME_SEGMENT := REGS1.BX;„END;„„PROCEDURE MAP_MEM(HANDLE_TO_MAP:INTEGER);  {MAPS HANDLE TO PHYSICAL}„CONST PHYSICAL_PAGE = 0;                 {PAGES.}„BEGIN„     REGS1.AH := MAP_MEMORY;„     REGS1.AL := PHYSICAL_PAGE;„     REGS1.BX := PHYSICAL_PAGE;„     REGS1.DX := HANDLE_TO_MAP;„     INTR(EMS_SERVICES, REGS1);„     IF REGS1.AH <> 0 THEN DIE('MAPPING MEMORY');„END;„„PROCEDURE GET_EMS_MEMORY(NUMBER_OF_16K_LOGICAL_PAGES:INTEGER);„VAR TH:INTEGER;                     { REQUESTS EM FROM EMM IN 16K INCREMENTS }„BEGIN„     HANDLE :=  NEWHANDLE(NUMBER_OF_16K_LOGICAL_PAGES);„     SEGMENT := PAGE_FRAME_SEGMENT;„     MAP_MEM(HANDLE);„END;„{----------------- END OF EMS SUPPORT ROUTINES  -----------------------}„„{----------------- CUSTOMIZED LINKED LIST SUPPORT ---------------------}„FUNCTION ABSOLUTE_ADDRESS(S, O:INTEGER):REAL;   { RETURNS THE REAL }„BEGIN                                           { ABSOLUTE ADDRESS }„     ABSOLUTE_ADDRESS :=  (CARDINAL(S) * $10)   { FOR SEGMENT "S"  }„                         + CARDINAL(O);         { AND OFFSET "O".  }„END;„„PROCEDURE NORMALIZE(VAR S, O:INTEGER); { SIMULATION OF TURBO'S INTERNAL }„VAR                                    { NORMALIZATION ROUTINES FOR     }„   NEW_SEGMENT: INTEGER;               { POINTER VARIABLES.             }„   NEW_OFFSET : INTEGER;               { NORMALIZES SEGMENT "S" AND     }„BEGIN                                  { OFFSET "O" INTO LEGITAMATE     }„     NEW_SEGMENT := S;                 { POINTER VALUES.                }„     NEW_OFFSET  := O;„     REPEAT„           CASE NEW_OFFSET OF„              $00..$0E   : NEW_OFFSET := SUCC(NEW_OFFSET);„              $0F..$FF   : BEGIN„                               NEW_OFFSET := 0;„                               NEW_SEGMENT := SUCC(NEW_SEGMENT);„                           END;„           END;„     UNTIL  (ABSOLUTE_ADDRESS(NEW_SEGMENT, NEW_OFFSET) >„             ABSOLUTE_ADDRESS(S, O) + SIZEOF(LIST));„     S := NEW_SEGMENT;„     O := NEW_OFFSET;„END;„„FUNCTION VALUEOF(P:LISTPTR):ANYSTRING;  { RETURNS A STRING IN   }„                                        { SEGMENT:OFFSET FORMAT }„                                        { WHICH CONTAINS VALUE  }„BEGIN                                   { OF A POINTER VARIABLE }„     VALUEOF := HEXBYTE(MEM[SEG(P):OFS(P) + 3]) +„                HEXBYTE(MEM[SEG(P):OFS(P) + 2]) +':'+„                HEXBYTE(MEM[SEG(P):OFS(P) + 1]) +„                HEXBYTE(MEM[SEG(P):OFS(P) + 0]);„END;„„PROCEDURE SNAP(P:LISTPTR);                   { FOR THE RECORD BEING         }„BEGIN                                        { POINTED TO BY "P", THIS      }„     WRITELN(VALUEOF(P):10,                  { PRINTS THE SEGMENT/OFFSET    }„             VALUEOF(P^.NEXT_POINTER):20,    { LOCATION, THE SEGMENT/       }„             P^.INDEX_PART:5,                { OFFSET OF THE RECORD PONTER, }„             '     ',P^.DATA_PART);          { RECORD INDEX, AND DATA.      }„END;„„PROCEDURE PROCESS_LIST;               { GET AND PRINT MEMBERS OF A LIST }„VAR M1:LISTPTR;                       { SORTED IN INDEX ORDER.          }„BEGIN„     PAUSE;„     M1 := ROOT;„     WRITELN;„     WRITELN('---------------- LINKED LIST ---------------------------------');„     WRITELN('MEMBER LOCATION           MEMBER CONTENTS');„     WRITELN('IN MEMORY             POINTER    INDEX  DATA   ');„     WRITELN('---------------       -----------------------------------------');„     WRITELN;„     REPEAT„           SNAP(M1);„           M1 := M1^.NEXT_POINTER;„     UNTIL M1 = NIL;„     WRITELN('------------ END OF LIST----------');„END;„„PROCEDURE LOAD_MEMBER_HIGH (IND:INTEGER; DAT:ANYSTRING);„VAR M1:LISTPTR;„     P:LISTPTR;                  { INSERTS A RECORD AT THE HIGH }„BEGIN                            { END OF THE LIST.             }„     M1 := ROOT;„     REPEAT„           IF M1^.NEXT_POINTER <> NIL THEN M1 := M1^.NEXT_POINTER;„     UNTIL M1^.NEXT_POINTER = NIL;„     NORMALIZE(NEWSEGMENT, NEWOFFSET);„     M1^.NEXT_POINTER := PTR(NEWSEGMENT, NEWOFFSET);„     P := M1^.NEXT_POINTER;„     P^.INDEX_PART := IND;„     P^.DATA_PART := DAT;„     P^.NEXT_POINTER := NIL;„END;„„PROCEDURE LOAD_MEMBER_MIDDLE (IND:INTEGER; DAT:ANYSTRING);„VAR M1:LISTPTR;„    M2:LISTPTR;„    P :LISTPTR;„    T :LISTPTR;„BEGIN                         { INSERTS A MEMBER INTO THE MIDDLE }„     M1 := ROOT;              { OF A LIST.                       }„     REPEAT„           M2 := M1;„           IF M1^.NEXT_POINTER <> NIL THEN M1 := M1^.NEXT_POINTER;„     UNTIL (M1^.NEXT_POINTER = NIL) OR (M1^.INDEX_PART >= IND);„     IF (M1^.NEXT_POINTER = NIL) AND„        (M1^.INDEX_PART <   IND) THEN„        BEGIN„             LOAD_MEMBER_HIGH (IND, DAT);„             EXIT;„        END;„     T := M2^.NEXT_POINTER;„     NORMALIZE(NEWSEGMENT, NEWOFFSET);„     M2^.NEXT_POINTER := PTR(NEWSEGMENT, NEWOFFSET);„     P := M2^.NEXT_POINTER;„     P^.INDEX_PART := IND;„     P^.DATA_PART := DAT;„     P^.NEXT_POINTER := T;„END;„„PROCEDURE LOAD_MEMBER (IND:INTEGER; DAT:ANYSTRING);„VAR  M1:LISTPTR;„BEGIN„     WRITELN('ADDING:  ',DAT,' WITH AGE OF ',IND);„     WRITELN('TURBO`S HEAP POINTER:  ',VALUEOF(HEAPPTR),„             ', MEMAVAIL = ',MEMAVAIL * 16.0:8:0);„     WRITELN;„     PAUSE;„     WRITELN('... SEARCHING FOR ADD POINT ...');„     IF ROOT^.INDEX_PART <= IND THEN             { ENTRY POINT ROUTINE FOR }„        BEGIN                                    { ADDING NEW LIST MEMBERS }„             LOAD_MEMBER_MIDDLE(IND, DAT);       { ACTS ONLY IF NEW MEMBER }„             EXIT;                               { SHOULD REPLACE CURRENT  }„        END;                                     { ROOT.                   }„     M1 := ROOT;„     NORMALIZE(NEWSEGMENT, NEWOFFSET);„     ROOT := PTR(NEWSEGMENT, NEWOFFSET);„     ROOT^.INDEX_PART   := IND;„     ROOT^.DATA_PART    := DAT;„     ROOT^.NEXT_POINTER := M1;„END;„„PROCEDURE INITIALIZE_ROOT_ENTRY(IND:INTEGER; DAT:ANYSTRING);„BEGIN„     ROOT := PTR(NEWSEGMENT, NEWOFFSET);       { INITIALIZES A LIST AND }„     ROOT^.INDEX_PART   := IND;                { ADDS FIRST MEMBER AS   }„     ROOT^.DATA_PART    := DAT;                { "ROOT".                }„     ROOT^.NEXT_POINTER := NIL;„END;„„BEGIN„     TEXTCOLOR(15);„     IF NOT EMS_INSTALLED THEN DIE('LOCATING EMS DRIVER');„     CLRSCR;„     WRITELN('DEMO OF LINKED LIST IN EXPANDED MEMORY...');„     WRITELN('SETTING UP EMS PARAMETERS...');„     GET_EMS_MEMORY(LOGICAL_PAGES);„     WRITELN;„     WRITELN('ASSIGNED HANDLE:  ',HANDLE);„     NEWSEGMENT := SEGMENT;„     NEWOFFSET  := 0;„     WRITELN('EMS PARAMETERS SET.  BASE PAGE IS:  ',HEXWORD(SEGMENT));„     WRITELN;„     WRITELN('TURBO`S HEAP POINTER IS ',VALUEOF(HEAPPTR));„     WRITELN('READY TO ADD RECORDS...');„     PAUSE;„„{ Demo:  Create a linked list of names and ages with age as the index/sort„  key.  Use random numbers for the ages so as to get a different sequence„  each time the demo is run.}„„     INITIALIZE_ROOT_ENTRY(RANDOM(10) + 20, 'Anne Baxter (original root)');„     LOAD_MEMBER(RANDOM(10) + 20,  'Rosie Mallory  ');„     LOAD_MEMBER(RANDOM(10) + 20,  'Sue Perkins    ');„     LOAD_MEMBER(RANDOM(10) + 20,  'Betty Williams ');„     LOAD_MEMBER(RANDOM(10) + 20,  'Marge Holly    ');„     LOAD_MEMBER(RANDOM(10) + 20,  'Lisa Taylor    ');„     LOAD_MEMBER(RANDOM(10) + 20,  'Carmen Abigail ');„     LOAD_MEMBER(RANDOM(10) + 20,  'Rhonda Perlman ');„     PROCESS_LIST;„     KILL_HANDLE(HANDLE);„END.„                                                        13     01-27-9412:12ALL                      WARREN PORTER            Linked List Queues       IMPORT              32     ”Õ   {„≥ I'm trying to understand the rudiments of linked lists„„≥ 4) What are common uses for linked lists?  Is any one particular form„≥    (oneway, circular etc ) preferred or used over any other form?„„One use is to maintain queues.  New people, requests, or jobs come in at„the end of the line (or break in with priority), but once the head of„the line has been serviced, there is no need to maintain its location in„the queue.  I wrote the following last semester:„---------------------------------------------------------------„Purpose:„  Maintains a queue of jobs and priorities of those jobs in a linked list.„  The user will be prompted for job number and priority and can list the„  queue, remove a job from the front of the queue (as if it ran), and stop„  the program.  A count of jobs outstanding at the end will be displayed. }„„type„  PriRange = 0 .. 9;„  JobPnt   = ^JobNode;„  Jobnode  = RECORD„    Numb     : integer;„    Priority : PriRange;„    Link     : JobPnt„  END;„„procedure addrec(var Start : JobPnt; comprec : Jobnode);„var„  curr,„  next,„  this  : JobPnt;„  found : boolean;„begin„  new(this);„  this^.Numb := comprec.Numb;„  this^.Priority := comprec.Priority;„  if Start = NIL then„  begin„    Start := this;   {Points to node just built}„    Start^.Link := NIL; {Is end of list}„  end„  else    {Chain exists, find a place to insert it}„  if comprec.Priority > Start^.Priority then„  begin„    this^.Link := Start;     {Prep for a new beg of chain}„    Start := this„  end {Condition for insert at beg of chain}„  else„  begin {Begin loop to insert after beg of chain}„    found := false;  {To initialize}„    curr  := start;„    while not found do„    begin„      next := curr^.link;„      if (next = NIL) or (comprec.Priority > next^.Priority) then„        found := true;„        if not found then„          curr:= next  {another iteration needed}„    end;„    {Have found this^ goes after curr^ and before next^}„    this^.Link := next; {Chain to end (even if NIL)}„    curr^.Link := this;  {Insertion complete}„  end;„end;„„procedure remove(Var Start : JobPnt);„var„  hold : JobPnt;„begin„  if Start = NIL then„    Writeln('Cannot remove from empty queue', chr(7))„  else„  begin„    hold := Start^.Link; {Save 1st node of new chain}„    dispose(Start);     {Delete org from chain}„    Start := hold;       {Reset to new next job}„  end;„end;„„procedure list(Start : JobPnt); {List all jobs in queue. "var" omitted}„begin„  if Start = NIL then„    Writeln('No jobs in queue')„  else„  begin„    Writeln('Job No     Priority');„    Writeln;„    while Start <> NIL do„    begin„      Writeln('  ',Start^.Numb : 3, '          ', Start^.Priority);„      Start:=Start^.Link„    end;„    Writeln;„    Writeln('End of List');„  end;„end;„„{Main Procedure starts here}„var„  cntr  : integer;„  build : JobNode;„  work,„  Start : JobPnt;„  Achar : char;„„begin„  Start := NIL; {Empty at first}„  cntr  := 0;„  REPEAT„    Write('Enter (S)top, (R)emove, (L)ist, or A jobnumb priority to');„    Writeln(' add to queue');„    Read(Achar);„„    CASE Achar of„      'A', 'a' :„      begin„        Read(build.Numb);„        REPEAT„          Readln(build.Priority);„          if (build.Priority < 0) or (build.priority > 9) then„            Write(chr(7), 'Priority between 0 and 9, try again ');„        UNTIL (build.Priority >= 0) and (build.Priority <= 9);„        addrec(Start, build);„      end;„„      'R', 'r' :„      begin„        Readln;„        remove(Start);„      end;„„      'L', 'l' :„      begin„        Readln;„        list(Start);„      end;„„      'S', 's' : Readln; {Will wait until out of CASE loop}„„      else„      begin„        Readln;„        Writeln('Invalid option',chr(7))„      end;„    end;„„  UNTIL (Achar = 's') or (Achar = 'S');„  work := start;„  while work <> NIL do„  begin„    cntr := cntr + 1;„    work := work^.link„  end;„  Writeln('Number of jobs remaining in queue: ', cntr);„end.„                              14     02-03-9416:08ALL                      KEN BURROWS              Linked List of Text      IMPORT              24     ”Õ   {„From: KEN BURROWS„Subj: Linked List Problem„---------------------------------------------------------------------------„Here is a short Linked List example. It loads a file, and lets you traverse the„list in two directions. It's as simple as it gets. You may also want to look„into the TCollection objects associated with the Objects unit of Borlands„version 6 and 7.„}„„{$A+,B-,D+,E-,F+,G-,I-,L+,N-,O-,P-,Q-,R-,S-,T-,V-,X+,Y+}„{$M 16384,0,655360}„Program LinkedListOfText; {tested}„Uses Dos,CRT;„Type„  TextListPtr = ^TextList;„  TextList    = Record„                 line : string;„                 next,„                 prev : TextListPtr;„                end;„Const„  first : TextListPtr = nil;„  last  : TextListPtr = nil;„„Procedure FreeTheList(p:TextListPtr);„   var hold:TextListPtr;„   begin„     while p <> Nil do„       begin„         hold := p;„         p := p^.next;„         dispose(hold);„       end;„   end;„„Procedure ViewForward(p:TextListPtr);„   begin„     clrscr;„     while p <> nil do„       begin„         writeln(p^.line);„         p := p^.next;„       end;„   end;„„Procedure ViewReverse(p:TextListPtr);„   begin„     clrscr;„     while p <> nil do„       begin„         writeln(p^.line);„         p := p^.prev;„       end;„   end;„„Procedure Doit(fname:string);„   var f    :Text;„       s    :string;„       curr,„       hold : TextListPtr;„       stop : boolean;„   begin„     assign(f,fname);„     reset(f);„     if ioresult <> 0 then exit;„     curr := nil;„     hold := nil;„„     while (not eof(f)) and„           (maxavail > SizeOf(TextList)) do„       begin          {load the list forward and link the prev fields}„         readln(f,s);„         new(curr);„         curr^.prev := hold;„         curr^.next := nil;„         curr^.line := s;„         hold := curr;„      end;„     close(f);„„     while curr^.prev <> nil do   {traverse the list backwards}„       begin                      {and link the next fields}„         hold := curr;„         curr := curr^.prev;„         curr^.next := hold;„       end;„„     first := curr;               {set the first and last records}„     while curr^.next <> Nil do curr := curr^.next;„     last := curr;„„     Repeat   {test it}„       clrscr;„       writeln(' [F]orward view : ');„       writeln(' [R]everse view : ');„       writeln(' [S]top         : ');„       write('enter a command : ');„       readln(s);„       stop := (s = '') or (upcase(s[1]) = 'S');„       if   not stop„       then case upcase(s[1]) of„             'F' : ViewForward(first);„             'R' : ViewReverse(last);„            end;„     Until Stop;„„     FreeTheList(First);„   end;„„var m:longint;„Begin„  m := memavail;„  if   paramcount > 0„  then doit(paramstr(1))„  else writeln('you need to supply a filename');„  if   m <> memavail„  then writeln('memory error of ',m-memavail,' bytes');„End.„                                                                                     15     05-25-9408:21ALL                      ALEXANDER STAUBO         Buffer Streams           SWAG9405            45     ”Õ   „{„JB> AS>Use buffered streams.  That way you can access fairly many records on„JB> AS>disk without noticable speed degradation.„JB>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^„JB> Do you mean from RAM?? Whoah! How do you go about using buffered„JB> streams?„„Actually, you should write a local "cache" for your records.  Ie.,„your implement an array of records, say 1..50, or, 1..MaxCacheSize,„where MaxCacheSize is a defined constant.  Then you have a couple of„generalized procedures for putting/getting records; now, the point is,„whenever the program asks for a record -that is in the cache-, that„record is read directly from RAM.  If the record is -not- in the„cache, the record is read, and, if there is space in the cache, the„record is inserted into the cache.„„Let's try a Pascal implementation.„}„„        const„          MaxCacheSize = 50; (* cache can hold 50 records *)„„        type„          (* this is the cache item *)„          PCacheItem = ^TCacheItem;„          TCacheItem =„            record„              Offset : Longint; (* file offset of cache record *)„              Rec    : TRecord; (* use your own record type here *)„            end;„„        var„          Cache : array[1..MaxCacheSize] of PCacheItem;„          CacheSize : Word;„„        procedure InitCache;„          {-Resets cache}„        begin„          CacheSize:=0;„        end;„„        function FindCache (Offset : Longint) : PCacheItem;„          {-Returns cache item for Offset if found, otherwise nil}„        var„          W : Word;„        begin„          for W:=1 to CacheSize do„            if Cache[W]^.Offset = Offset then„              begin„                FindCache:=Cache[W];„                Exit;„              end;„          FindCache:=nil;„        end;„„        var„          F : file of TRecord; (* file in question *)„„        procedure PutRecord (Offset : Longint; var Rec : TRecord);„          {-Put record into cache and file}„        var„          P : PCacheItem;„        begin„          Write(F, Rec);„„          (* if exists in RAM (cache), update it *)„          P:=FindCache(Offset);„          if P <> nil then„            P^.Rec:=Rec„          else„            begin„              (* put into cache *)„              Inc(CacheSize);„              New(Cache[CacheSize]);„              Cache[CacheSize]^.Offset:=Offset;„              Cache[CacheSize]^.Rec:=Rec;„            end;„        end;„„        procedure GetRecord (Offset : Longint; var Rec : TRecord);„          {-Get record from cached file}„        var„          P : PCacheItem;„        begin„          (* if exists in RAM (cache), get it *)„          P:=FindCache(Offset);„          if P <> nil then„            Rec:=P^.Rec„          else if CacheSize < MaxCacheSize then„            begin„              (* read record from file *)„              Read(F, Rec);„„              (* put into cache *)„              Inc(CacheSize);„              New(Cache[CacheSize]);„              Cache[CacheSize]^.Offset:=Offset;„              Cache[CacheSize]^.Rec:=Rec;„            end;„        end;„„To use the routines:„„          Assign(F, 'MYFILE.DAT');„          Reset(F);„          GetRecord(FilePos(F), MyRec);„          GetRecord(FilePos(F), MyRec);„          GetRecord(FilePos(F), MyRec);„          PutRecord(FilePos(F), MyRec);„          Close(F);„„Or something like that, anyway.„„Now, there is a simpler way; "simpler" in this case means "some guy„has already spent hours writing it just for you".  The concept is„called streams.  Now, I don't know how "novice" a programmer you are,„but knowledge of streams requires knowledge of OOP.  I suggest you„read about OOP right away.„„Streams work in a very simple way.  You have a basic, "abstract"„object, which provides some simple I/O tools.  A stream is a type of„(abstract) file, an input/output mechanism, that you may manipulate;„most often it's on a hierarchical level, ie., the high-level„procedures call low-level procedures, just like DOS.  Think of streams„as the Pascal type "file", except now the stream is a shell for„anything.„„The shell implements a -standard- interface for any kind of„information area.  You have file streams, buffered streams (streams„that caches areas of the file in memory to optimize access„efficiency), EMS streams (yes, you can have a "virtual file" that lies„in EMS memory and may be used just like a file), and so on.  The„standardization implies that you may write more flexible programs.„„A tiny example:„„        var„          S   : TBufStream;„          T   : TRecord;„          Str : string;„        begin„          S.Init('MYFILE.DAT', stOpen, 2048);„              (* |             |          |„                 file name     file mode  buffer size„              *)„          S.Read(T, SizeOf(T));„          S.Write(T, SizeOf(T));„          Str:=S.ReadStr^;„„          S.Done;„        end;„„The corresponding boring-old-Dos example'd be:„„        var„          F   : file;„          T   : TRecord;„          Str : string;„        begin„          (* note: no buffering -> slower! *)„          Assign(F, 'MYFILE.DAT');„          Reset(F, 1);„„          BlockRead(F, T, SizeOf(T));„          BlockWrite(F, T, SizeOf(T));„          Read(F, Str[0]);„          BlockRead(F, Str[1], Ord(Str[0]));„„          Close(F);„        end;„„In the end, streams -are- simpler, too.  And they are extremely fast;„a friend of mine is writing a mail reader and is using object streams„for the message/conference/etc. databases.  Now, personally I use„indexed, light-speed B-tree databases.  And his work -just fine-.„                                                                  16     05-26-9411:06ALL                      BILL ZECH                Linked List Routine      SWAG9405            82     ”Õ   „{ Links Unit - Turbo Pascal 5.5„  Patterned after the list processing facility in Simula class SIMSET.„  Simula fans will note the same naming conventions as Simula-67.„„  Written by Bill Zech @CIS:[73547,1034]), May 16, 1989.„„  The Links unit defines objects and methods useful for implementing„  list (set) membership in your own objects.„„  Any object which inherits object <Link> will acquire the attributes„  needed to maintain that object in a doubly-linked list.  Because the„  Linkage object only has one set of forward and backward pointers, a„  given object may belong to only one list at any given moment.  This„  is sufficient for many purposes.  For example, a task control block„  might belong in either a ready list, a suspended list, or a swapped„  list, but all are mutually exclusive.„„  A list is defined as a head node and zero or more objects linked„  to the head node.  A head node with no other members is an empty„  list.  Procedures and functions are provided to add members to the„  end of the list, insert new members in position relative to an„  existing member, determine the first member, last member, size„  (cardinality) of the list, and to remove members from the list.„„  Because your object inherits all these attributes, your program„  need not concern itself with allocating or maintaining pointers„  or other stuff.  All the actual linkage mechanisms will be„  transparent to your object.„„  *Note*„          The following discussion assumes you have defined your objects„          as static variables instead of pointers to objects.  For most„          programs, dynamic objects manipulated with pointers will be„          more useful.  Some methods require pointers as arguments.„          Example program TLIST.PAS uses pointer type variables.„„  Define your object as required, inheriting object Link:„„                type„                        myObjType = object(Link)„                                xxx.....xxxx„                        end;„„  To establish a new list, declare a variable for the head node„  as a type Head:„„                var„                        Queue1        :Head;„                        Queue2        :Head;„„        Define your object variables:„„                var„                        X    : myObjType;„                        Y    : myObjType;„                        Z    : myObjType;„                        P    :^myObjType;„„        Make sure the objects have been Init'ed as required for data„        initialization, VMT setup, etc.„„                        Queue1.Init;„                        Queue2.Init;„                        X.Init;„                        Y.Init;„                        Z.Init;„„        You can add your objects to a list with <Into>:„        (Note the use of the @ operator to make QueueX a pointer to the„         object.)„„                begin„                        X.Into(@Queue1);„                        Y.Into(@Queue2);„„        You can insert at a specific place with <Precede> or <Follow>:„„                        Z.Precede(@Y);„                        Z.Follow(@Y);„„        Remove an object with <Out>:„„                        Y.Out;„„        Then add it to another list:„„                        Y.Into(@Queue1);„„        Note that <Into>, <Precede> and <Follow> all have a built-in„        call to Out, so to move an object from one list to another can„        be had with a single operation:„„                        Z.Into(@Queue1);„„        You can determine the first and last elements with <First> and <Last>:„        (Note the functions return pointers to objects.)„„                        P := Queue1.First;„                        P := Queue1.Last;„„        The succcessor or predecessor of a given member can be found with„        fucntions <Suc> and <Pred>:„„                        P := X.Pred;„                        P := Y.Suc;„                        P := P^.Suc;„„        The number of elements in a list is found with <Cardinal>:„„                        N := Queue1.Cardinal;„„        <Empty> returns TRUE is the list has no members:„„                        if Queue1.Empty then ...„„        You can remove all members from a list with <Clear>:„„                        Queue1.Clear;„„        GENERAL NOTES:„„                The TP 5.5 type compatibility rules allow a pointer to a„                descendant be assigned to an ancestor pointer, but not vice-versa.„                So although it is perfectly legal to assign a pointer to„                type myObjType to a pointer to type Linkage, it won't let„                us do it the opposite.„„                We would like to be able to assign returned values from„                Suc, Pred, First, and Last to pointers of type myObjType,„                and the least fussy way is to define these pointer types„                internal to this unit as untyped pointers.  This works fine„                because all we are really doing is passing around pointers„                to Self, anyway.  The only down-side to this I have noticed„                is you can't do:  P^.Suc^.Pred because the returned pointer„                type cannot be dereferenced without a type cast.„}„„unit Links;„„interface„„type„„  pLinkage = ^Linkage;„  pLink = ^Link;„  pHead = ^Head;„„  Linkage = object„          prede :pLinkage;„          succ  :pLinkage;„          function Suc  :pointer;„          function Pred :pointer;„          constructor Init;„  end;„„  Link = object(Linkage)„          procedure Out;„          procedure Into(s :pHead);„          procedure Follow (x :pLinkage);„          procedure Precede(x :pLinkage);„  end;„„  Head = object(Linkage)„          function First :pointer;„          function Last  :pointer;„          function Empty :boolean;„          function Cardinal :integer;„          procedure Clear;„          constructor Init;„  end;„„„„implementation„„constructor Linkage.Init;„begin„  succ := NIL;„  prede := NIL;„end;„„function Linkage.Suc :pointer;„begin„  if TypeOf(succ^) = TypeOf(Head) then„         Suc := NIL„  else Suc := succ;„end;„„function Linkage.Pred :pointer;„begin„  if TypeOf(prede^) = TypeOf(Head) then„         Pred := NIL„  else Pred := prede;„end;„„procedure Link.Out;„begin„        if succ <> NIL then„        begin„          succ^.prede := prede;„          prede^.succ := succ;„          succ := NIL;„          prede := NIL;„        end;„end;„„procedure Link.Follow(x :pLinkage);„begin„        Out;„        if x <> NIL then„        begin„          if x^.succ <> NIL then„          begin„                  prede := x;„                  succ := x^.succ;„                  x^.succ := @Self;„                  succ^.prede := @Self;„          end;„        end;„end;„„„procedure Link.Precede(x :pLinkage);„begin„        Out;„        if x <> NIL then„        begin„                if x^.succ <> NIL then„                begin„                        succ := x;„                        prede := x^.prede;„                        x^.prede := @Self;„                        prede^.succ := @Self;„                end;„        end;„end;„„procedure Link.Into(s :pHead);„begin„        Out;„        if s <> NIL then„        begin„                succ := s;„                prede := s^.prede;„                s^.prede := @Self;„                prede^.succ := @Self;„        end;„end;„„„function Head.First :pointer;„begin„        First := suc;„end;„„function Head.Last :pointer;„begin„        Last := Pred;„end;„„function Head.Empty :boolean;„begin„  Empty := succ = prede;„end;„„function Head.Cardinal :integer;„var„        i   :integer;„        p   :pLinkage;„begin„        i := 0;„        p := succ;„        while p <> @Self do„          begin„                  i := i + 1;„                  p := p^.succ;„          end;„        Cardinal := i;„end;„„procedure Head.Clear;„var„        x  : pLink;„begin„        x := First;„        while x <> NIL do„          begin„                  x^.Out;„                  x := First;„          end;„end;„„constructor Head.Init;„begin„  succ := @Self;„  prede := @Self;„end;„„end.„„{------------------------   DEMO PROGRAM --------------------- }„„program tlist;„„uses Links;„„type„        NameType = string[10];„        person = object(link)„                name :NameType;„                constructor init(nameArg :NameType);„        end;„        Pperson = ^person;„„constructor person.init(nameArg :NameType);„begin„        name := nameArg;„        link.init;„end;„„var„        queue : Phead;„        man   : Pperson;„        man2  : Pperson;„        n     : integer;„        tf    : boolean;„„begin„        new(queue,Init);„        tf := queue^.Empty;„        new(man,Init('Bill'));„        man^.Into(queue);„        new(man,Init('Tom'));„        man^.Into(queue);„        new(man,Init('Jerry'));„        man^.Into(queue);„„        man := queue^.First;„        writeln('First man in queue is ',man^.name);„        man := queue^.Last;„        writeln('Last man in queue is ',man^.name);„„        n := queue^.Cardinal;„        writeln('Length of queue is ',n);„        if not queue^.Empty then writeln('EMPTY reports queue NOT empty');„„        new(man2,Init('Hugo'));„        man2^.Precede(man);„„        new(man2,Init('Alfonso'));„        man2^.Follow(man);„        { should now be: Bill Tom Hugo Jerry Alfonso }„        writeln('After PRECEDE and FOLLOW calls, list should be:');„        writeln('  {Bill, Tom, Hugo, Jerry, Alfonso}');„        writeln('Actual list is:');„„        man := queue^.First;„        while man <> NIL do„          begin„                  write(man^.name,' ');„                  man := man^.Suc;„          end;„          writeln;„„        man := queue^.Last;„        writeln('The same list backwards is:');„        while man <> NIL do„          begin„                 write(man^.name,' ');„                 man := man^.Pred;„          end;„          writeln;„„        n := queue^.Cardinal;„        writeln('Queue size should be 5 now, is: ', n);„„        queue^.Clear;„        writeln('After clear operation,');„        n := queue^.Cardinal;„        writeln('   Queue size is ',n);„        tf := queue^.Empty;„        if tf then writeln('    and EMTPY reports queue is empty.');„        writeln;„        writeln('Done with test.');„end.„„                                                                                                                      