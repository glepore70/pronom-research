SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00019         TIMER/RESOLUTION ROUTINES                                         1      05-28-9314:09ALL                      SWAG SUPPORT TEAM        Millisecond Timer Unit   IMPORT              13     ÆuUe { millisecond timer Unit }„„Unit msecs;„„Interface„„Var„   timer:Word;                     { msec timer }„   idle:Procedure; {  you can change this to do something useful when Delaying}„„Procedure Delay_ticks(t:Word);     { resume Until t clock ticks have elapsed }„Procedure start_clock;             { starts the 1 msec timer }„Procedure stop_clock;              { stops the 1 msec timer }„„Implementation„„Uses Dos;„„Procedure Delay_ticks(t:Word);„begin„  inc(t,timer);„  Repeat idle Until Integer(timer - t) >= 0;„end;„„Const clock_active:Boolean = False;„      one_msec = 1193;„Var   save_clock:Pointer;„      clocks:Word;„„Procedure tick_int; Far; Assembler;„Asm„  push ax„  push ds„  mov ax,seg @data„  mov ds,ax„  mov al,$20„  out $20,al„  inc [timer]„  add [clocks],one_msec„  jnc @1„  pushf„  call [save_clock]„@1:„  pop ds„  pop ax„  iret„end;„„„Procedure start_clock;„begin„  if clock_active then Exit;„  inc(clock_active);„  timer := 0;„  clocks := 0;„  getintvec($08,save_clock);„  setintvec($08,@tick_int);„  port[$43] := $36;„  port[$40] := lo(one_msec);„  port[$40] := hi(one_msec);„end;„„Procedure stop_clock;„begin„  if not clock_active then Exit;„  dec(clock_active);„  port[$43] := $36;„  port[$40] := 0;„  port[$40] := 0;„  setintvec($08,save_clock);„end;„„Procedure nothing; Far;„begin„end;„„Var saveexit:Pointer;„„Procedure uninstall; Far;„begin„  Exitproc := saveexit;„  if clock_active then stop_clock;„end;„„begin„  timer := 0;„  idle := nothing;„  saveexit := Exitproc;„  Exitproc := @uninstall;„end.„„„„     2      05-28-9314:09ALL                      SWAG SUPPORT TEAM        TCTIMER.PAS              IMPORT              4      ÆuÙ¡ Unit tctimer;„„Interface„Uses tptimer;„„  Var„    start : LongInt;„„Procedure StartTimer;„„Procedure WriteElapsedTime;„„„„Implementation„„Procedure StartTimer;„  begin„    start := ReadTimer;„  end;„„Procedure  WriteElapsedTime;„  Var stop : LongInt;„  begin„    stop := ReadTimer;„    Writeln('Elapsed time = ',(ElapsedTime(start,stop) / 1000):10:6,' seconds');„  end;„„„end.„       3      05-28-9314:09ALL                      D.J. MURDOCH             Time Code Segments       IMPORT              26     Æuf›  {$G+,S-,R-,Q-}„ program timer;„„ { Program to time short segments of code; inspired by Michael Abrash's„   Zen timer.  Donated to the public domain by D.J. Murdoch }„„ uses„   opdos; { Object Professional unit, needed only for TimeMS,„            a millisecond timer. }„„ const„   onetick = 1/33E6;  { This is the time in seconds for one cpu cycle.„                        I've got it set for a 33 Mhz machine. }„„ { Instructions:  put your code fragment into a short routine called Segment.„   It should leave the stack unchanged, or it'll blow up when we clone it.„   It *must* have a far return at the end.  Play around with declaring it„   as an assembler procedure or not to see the cost of the TP entry and„   exit code. }„„ { This example is Sean Palmer's "var2 := var1 div 2" replacement fragment. }„„ var„   var1,var2 : integer;„„ procedure Segment; far; assembler;„ asm„    mov ax,var1„    sar ax,1„    jns @S„    adc ax,0„  @S:„    mov var2,ax„ end;„„ { This is the comparison TP code.  Note that it includes entry/exit code;„   play around with variations on the assembler version to make it a fair„   comparison }„ (*„ procedure Segment; far;„ begin„   var2 := var1 div 2;„ end;„ *)„„ { This procedure is essential!!! Do not move it. It must follow„   Segment directly. }„ procedure Stop;„ begin„ end;„„ { This routine will only be called once at the beginning of the program;„   set up any variables that Segment needs }„„ procedure Setup;„ begin„   var1 := 5;„   writeln('This run, var1=',var1);„ end;„„ const„   maxsize=65520;„   RETF   = $CB;„ var„   p : pointer;„   src,dest : ^byte;„   size : word;„   repeats : word;„   i : word;„   start,finish : longint;„   count : longint;„   main,overhead,millisecs : real;„ begin„„   setup;„„   { Get a segment of memory, and fill it up with as many copies„     of the segment as possible }„„   size := ofs(stop) - ofs(Segment) -1;„   repeats := maxsize div size;„   getmem(p, size*repeats + 1);„   src := @Segment;„   dest := p;„   for i:=1 to repeats do„   begin„     move(src^,dest^,size);„     inc(dest,size);„   end;„   { Add a final RETF at the end. }„   dest^ := RETF;„„   { Now do the timing.  Keep repeating one second loops indefinitely. }„„   writeln(' Bytes     Clocks       ns       MIPS');„   repeat„     { First loop:  one second worth of calls to the segment }„     start := timems;„     count := 0;„     repeat„       asm„         call dword ptr p„       end;„       finish := timems;„       inc(count);„     until finish > 1000+start;„     main := (finish - start)/repeats/count;„„     { Second loop:  1/2 second worth of calls to the RETF }„     start := timems;„     count := 0;„     repeat„       asm„         call dword ptr dest„       end;„       finish := timems;„       inc(count);„     until finish > 500+start;„     overhead := (finish-start)/count;„     millisecs := (main-overhead/repeats);„     writeln(size:6,millisecs/1000/onetick:11:1,„                    1.e6*millisecs:11:0,„                    1/millisecs/1000:11:3);„   until false;„ end.„„„--- Msg V3.2„ * Origin: Murdoch's Point, Kingston, Ont, Canada  - -   (1:249/99.5)„                                                                               4      05-28-9314:09ALL                      SWAG SUPPORT TEAM        TIMELOOP.PAS             IMPORT              5      ÆuØL {$A+,B-,D-,E-,F-,I-,N-,O-,R-,S-,V-}„„Program TimeNullRoutine;„„Uses„  TpTimer;„„Var„  Count : Byte;„„Procedure DoNothing;„begin„end;„„Var„  Loop : Word;„  Start,„  Stop : LongInt;„„begin„  Start := ReadTimer;„  For Loop := 1 to 1000 do„    DoNothing;„  Stop := ReadTimer;„  WriteLn('Time = ', ElapsedTimeString(Start, Stop), ' ms')„end.„„{„  ...Well running the Program listed above, 1000 nul loops time„  in at 3.007 miliseconds on my 386SX-25.„}                                                                 5      05-28-9314:09ALL                      SWAG SUPPORT TEAM        Calculate Program Time   IMPORT              29     Æu? { SB> Has anyone by any chance written a Procedure For calculating the amount„ SB> of time a Program runs.  I understand how to use getTime, etc, but I am„ SB> trying to figure out a way around all the possibilities...i.e. someone„ SB> starts a Program at 23:59:03.44, and it's finished at 00:02:05.33.„ SB>„ SB> Anyway, if someone already has this figured out, I'd sure appreciate it„ SB> or even some ideas...„„Scott,„    try:„„    Var„        Timer : LongInt Absolute $0040:$006c;„„    That's the Tic counter, stored at Segment 0040h, offset 006Ch. It„stores the number of ticks since you turned the Computer on and so will„only wrap after MorE THAN 3 YEARS, if you never close the machine ;-)„„    it is incremented 18.2 times/sec, so divide it by 18.2 to get the„number of seconds. You can figure out the rest ;-)„„    Store its content to another LongInt at the start of the Program,„again at the end. Substract the first value from the second and you have„the number of ticks elapsed during the Program's execution.„„Oh what the heck, here is a Complete Unit, all you have to do is include„it in your Uses clause nothing more unless you want to save the time in„a log File or something.„}„„{$A+,B-,D+,E-,F+,G+,I-,L+,N-,O+,P+,Q-,R-,S-,T-,V-,X+,Y+}„{$M 8192,0,0}„Unit TimePrg;„(**) Interface (**)„(**) Implementation (**)„Uses„  Dos;„Type„  CmdLine = String[127];„Var„  TimerTicks : LongInt Absolute $0040:$006C;„  OldCommandLine, NewCommandline : CmdLine;„  CommandLine : ^CmdLine;„  TimeIn, TimeOut, Spent : LongInt;„  Years, Days, Hours, Minutes, Seconds, ms : Byte;„  ExitBeForeTimePrg : Pointer;„  D : DirStr;„  N : NameStr;„  E : ExtStr;„  Index : Integer;„„Function Strfunc(Value:Byte):String;„Var„  temp : String;„begin„  Str(Value:0, Temp);„  StrFunc := #32+temp;„end;„„Procedure TimePrgExit; Far;„begin„  TimeOut := TimerTicks;„  ExitProc := ExitBeForeTimePrg;„  Spent := TimeOut - TimeIn;„  ms := (Spent - trunc(Spent / 18.2))*55;„  Spent := Trunc(Spent / 18.2);„  Years := Spent div (3600*24*365);„  Spent := Spent mod (3600*24*365);„  Days := Spent div (3600*24);„  Spent := Spent mod (3600*24);„  Hours := Spent div 3600;„  Spent := Spent mod 3600;„  Minutes := Spent div 60;„  Spent := Spent mod 60;„  Seconds := Spent;„  CommandLine := Ptr(PrefixSeg, $80);„  OldCommandLine := CommandLine^;„  NewCommandLine := '';„  if Years>0 then„    NewCommandLine := NewCommandLine + Strfunc(Years) + ' Years';„  if Days>0 then„    NewCommandLine := NewCommandLine + Strfunc(Days) + ' Days';„  if Hours>0 then„    NewCommandLine := NewCommandLine + Strfunc(Hours) + ' Hours';„  if Minutes>0 then„    NewCommandLine := NewCommandLine + Strfunc(Minutes) + ' Minutes';„  if Seconds>0 then„    NewCommandLine := NewCommandLine + Strfunc(Seconds)	+ ' Seconds';„  if ms>0 then„    NewCommandLine := NewCommandLine + Strfunc(ms) + ' milli-seconds';„  CommandLine^ := NewCommandLine;„  Write('Thanks For spending ');„  Case Paramcount of„    0: Write('so little time');„    2: Write(ParamStr(1),#32, Paramstr(2));„  else„    For Index := 1 to ParamCount - 3 do begin„      Write(Paramstr(Index));„      if odd(Index) then„        Write(' ')„      else„        Write(', ');„    end;„    Write(Paramstr(Index+1), ' and ',„    Paramstr(Index+2), ' ', Paramstr(Index+3));„  end;„  CommandLine^ := OldCommandLine;„  Fsplit(Paramstr(0), D, N, E);„  Writeln(' In ', N);„end;„„begin„  TimeIn := TimerTicks;„  ExitBeForeTimePrg := ExitProc;„  ExitProc := @TimePrgExit;„end.„                                                                                                                      6      05-28-9314:09ALL                      SWAG SUPPORT TEAM        Timing Using TP Clock    IMPORT              8      Æuh {„> Does anyone know of a proFiler For TP 6, or is there a special„> command using TPC to activate a proFiler to tell how much time the„> Program takes doing a task. Thanks, Luke„„Try this Unit.  Put a ClockOn and it will start timing then when the ClockOff„is reached it will tell you how long it took.  It's very nice For optimizing„pieces of code.„}„„Unit Timer;„„Interface„„Procedure ClockOn;„Procedure ClockOff;„„Implementation„Uses Dos;„„Var„  H, M, S, S100 : Word;„  Startclock, Stopclock : Real;„„Procedure ClockOn;„ begin„   GetTime(H, M, S, S100);„   StartClock := (H * 3600) + (M * 60) + S + (S100 / 100);„end;„„Procedure ClockOff;„ begin„  GetTime(H, M, S, S100);„  StopClock := (H * 3600) + (M * 60) + S + (S100 / 100);„  WriteLn('Elapsed time = ', (StopClock - StartClock):0:2);„ end;„„end.„„                                                                                          7      05-28-9314:09ALL                      SWAG SUPPORT TEAM        High Resolution Timer    IMPORT              46     Æudw {$S-,R-,I-,V-,B-}„„{*********************************************************}„{*                   TPTIMER.PAS 2.00                    *}„{*                by TurboPower Software                 *}„{*********************************************************}„„Unit TpTimer;„  {-Allows events to be timed With 1 microsecond resolution}„„„„Interface„Const„  TimerResolution = 1193181.667;„Procedure InitializeTimer;„  {-ReProgram the timer chip to allow 1 microsecond resolution}„„Procedure RestoreTimer;„  {-Restore the timer chip to its normal state}„„Function ReadTimer : LongInt;„  {-Read the timer With 1 microsecond resolution}„„Function ElapsedTime(Start, Stop : LongInt) : Real;„  {-Calculate time elapsed (in milliseconds) between Start and Stop}„„Function ElapsedTimeString(Start, Stop : LongInt) : String;„  {-Return time elapsed (in milliseconds) between Start and Stop as a String}„„  {==========================================================================}„„Implementation„„Var„  SaveExitProc : Pointer;„  Delta : LongInt;„„  Function Cardinal(L : LongInt) : Real;„    {-Return the unsigned equivalent of L as a Real}„  begin                      {Cardinal}„    if L < 0 then„      Cardinal := 4294967296.0+L„    else„      Cardinal := L;„  end;                       {Cardinal}„„  Function ElapsedTime(Start, Stop : LongInt) : Real;„    {-Calculate time elapsed (in milliseconds) between Start and Stop}„  begin                      {ElapsedTime}„    ElapsedTime := 1000.0*Cardinal(Stop-(Start+Delta))/TimerResolution;„  end;                       {ElapsedTime}„„  Function ElapsedTimeString(Start, Stop : LongInt) : String;„    {-Return time elapsed (in milliseconds) between Start and Stop as a String}„  Var„    R : Real;„    S : String;„  begin                      {ElapsedTimeString}„    R := ElapsedTime(Start, Stop);„    Str(R:0:3, S);„    ElapsedTimeString := S;„  end;                       {ElapsedTimeString}„„  Procedure InitializeTimer;„    {-ReProgram the timer chip to allow 1 microsecond resolution}„  begin                      {InitializeTimer}„    {select timer mode 2, read/Write channel 0}„    Port[$43] := $34;        {00110100b}„    Inline($EB/$00);         {jmp short $+2 ;Delay}„    Port[$40] := $00;        {LSB = 0}„    Inline($EB/$00);         {jmp short $+2 ;Delay}„    Port[$40] := $00;        {MSB = 0}„  end;                       {InitializeTimer}„„  Procedure RestoreTimer;„    {-Restore the timer chip to its normal state}„  begin                      {RestoreTimer}„    {select timer mode 3, read/Write channel 0}„    Port[$43] := $36;        {00110110b}„    Inline($EB/$00);         {jmp short $+2 ;Delay}„    Port[$40] := $00;        {LSB = 0}„    Inline($EB/$00);         {jmp short $+2 ;Delay}„    Port[$40] := $00;        {MSB = 0}„  end;                       {RestoreTimer}„„  Function ReadTimer : LongInt;„    {-Read the timer With 1 microsecond resolution}„  begin                      {ReadTimer}„    Inline(„      $FA/                   {cli             ;Disable interrupts}„      $BA/$20/$00/           {mov  dx,$20     ;Address PIC ocw3}„      $B0/$0A/               {mov  al,$0A     ;Ask to read irr}„      $EE/                   {out  dx,al}„      $B0/$00/               {mov  al,$00     ;Latch timer 0}„      $E6/$43/               {out  $43,al}„      $EC/                   {in   al,dx      ;Read irr}„      $89/$C7/               {mov  di,ax      ;Save it in DI}„      $E4/$40/               {in   al,$40     ;Counter --> bx}„      $88/$C3/               {mov  bl,al      ;LSB in BL}„      $E4/$40/               {in   al,$40}„      $88/$C7/               {mov  bh,al      ;MSB in BH}„      $F7/$D3/               {not  bx         ;Need ascending counter}„      $E4/$21/               {in   al,$21     ;Read PIC imr}„      $89/$C6/               {mov  si,ax      ;Save it in SI}„      $B0/$FF/               {mov  al,$0FF    ;Mask all interrupts}„      $E6/$21/               {out  $21,al}„      $B8/$40/$00/           {mov  ax,$40     ;read low Word of time}„      $8E/$C0/               {mov  es,ax      ;from BIOS data area}„      $26/$8B/$16/$6C/$00/   {mov  dx,es:[$6C]}„      $89/$F0/               {mov  ax,si      ;Restore imr from SI}„      $E6/$21/               {out  $21,al}„      $FB/                   {sti             ;Enable interrupts}„      $89/$F8/               {mov  ax,di      ;Retrieve old irr}„      $A8/$01/               {test al,$01     ;Counter hit 0?}„      $74/$07/               {jz   done       ;Jump if not}„      $81/$FB/$FF/$00/       {cmp  bx,$FF     ;Counter > $FF?}„      $77/$01/               {ja   done       ;Done if so}„      $42/                   {inc  dx         ;else count int req.}„      {done:}„      $89/$5E/$FC/           {mov [bp-4],bx   ;set Function result}„      $89/$56/$FE);          {mov [bp-2],dx}„  end;                       {ReadTimer}„„  Procedure Calibrate;„    {-Calibrate the timer}„  Const„    Reps = 1000;„  Var„    I : Word;„    L1, L2, Diff : LongInt;„  begin                      {Calibrate}„    Delta := MaxInt;„    For I := 1 to Reps do begin„      L1 := ReadTimer;„      L2 := ReadTimer;„      {use the minimum difference}„      Diff := L2-L1;„      if Diff < Delta then„        Delta := Diff;„    end;„  end;                       {Calibrate}„„  {$F+}„  Procedure OurExitProc;„    {-Restore timer chip to its original state}„  begin                      {OurExitProc}„    ExitProc := SaveExitProc;„    RestoreTimer;„  end;                       {OurExitProc}„  {$F-}„„begin„  {set up our Exit handler}„  SaveExitProc := ExitProc;„  ExitProc := @OurExitProc;„„  {reProgram the timer chip}„  InitializeTimer;„„  {adjust For speed of machine}„  Calibrate;„end.„                                                      8      05-28-9314:09ALL                      SWAG SUPPORT TEAM        Release Time Slices      IMPORT              17     Æu»b {„Some months ago we discussed the problem With Dos Programs„that eats CPU time in multitask environments (as OS/2),„when they're idle.  I have successfully used an Inline„statement in my Pascal Programs that calls intr $28, which„is the Keyboard Busy Flag, For this purpose.  I found that„Inline statement in a TurboPower Program, which they use„to signalize to TSRs that it's OK to interrupt processing.„„Here's the Inline statement I use in keyboard loops:„„    Inline($CD/$28);„„But...  This statement doesn't work in the Idle method of„Turbo Vision Programs...  In our previous discussion on„this subject, somebody here looked up another intr in„Ralph Brown's excellent Compilation list of interrupts.„This intr, $2F, works in another way by releasing the„reminder of unused time-slice to the operating system.„Called in a tight Program loop, this means that the„Program will free up it's idle time to the OS.„„Here's a Function I made that I now use in TV's Idle method:„}„„Uses„  Dos;„„Function  ReleaseTimeSlice: Boolean;„Var„  Regs: Registers;„„begin„  With Regs do„  begin„    AX := $1680;„    Intr($2F, Regs);„    ReleaseTimeSlice := (AL = $00);  { AL=$80 if not supported by OS }„  end;„end;„„{„ ...and here's how the Idle loop Uses it in a TV Program:„}„„Procedure TMyProgram.Idle;„begin„  TApplication.Idle;„„  { more idle calls go here ... }„  {  :                          }„„  { Inline($CD/$28); }  { this has no effect on PULSE.EXE by itself }„  ReleaseTimeSlice;     { remember to use $X+ when Compiling the Program }„end;„„{„...This works fine, judging by PULSE.EXE in OS/2.„Ralph Brown also says this works in Windows, tho Windows„native Programs may not use it.„Maybe someone can comment on if it's necesarry to also„put in the Inline statement above For servicing TSRs.„I can't see any reason For not doing it, but I might've„overlooked something here...  :-)„„Borland doesn't do this in their Idle method For TP/BP.„It should be quite easy to patch this in the RTL code,„For those of you that have it, and reCompile BP.„}„„ 9      08-27-9322:03ALL                      MARCO MILTENBURG         Giving Timeslices        IMPORT              7      Æu   {„MARCO MILTENBURG„„>> if you find SOURCE to detect/give up time slices For Windows/OS/2/Desqview,„>> could you post it? I have stuff For Desqview, I believe.„„>  Procedure GiveTimeSlice; Inline( $cd/$28 );„„This is nice, but you have to be sure that you have enough stack space left,„because Dos or TSR's that hook this interrupt will use SS:SP For their own„stack. I use the following in my multitasker detect Unit :„}„„Procedure TimeSlice;„Var„  Regs : Registers;„begin„  Case OS_Type Of„    _Dos :„      begin„      end;„„    _DV,„    _DVX :„       begin„         Regs.AX := $1000;„         Intr($15, Regs);„       end;„„    _OS2,„    _WINS,„    _WIN3:„      begin„        Regs.AX := $1680;„        Intr($2F, Regs);„      end;„  end;„end;„                         10     08-27-9322:04ALL                      DAVID DAHL               Controling DOS Timer     IMPORT              15     Æu   {„DAVID DAHL„„I never posted it as a Unit.  I just posted a couple routines to set the„timer.  They're actually a part of another, larger project I've been working„on to play digitized Sound out of several different output devices.  When I„was asked if it were possible to speed up the tick and still have Dos's timer„Function behave normally, I threw them into a Unit and wrote the Program you„quoted from to illustrate how it would be done.  Here are the timer routines„as a Unit:„„The routines perform no error checking on input values, so be careful„with them.  The Procedure Set8253Channel should never have a„channel value of more than 2 since the 8253 only has 3 channels„(0 - 2).„}„„Unit C8253;„„(* PUBLIC DOMAIN *)„„Interface„„Procedure SetPlaySpeed(Speed : LongInt);„Procedure SetDefaultTimerSpeed;„Procedure Set8253Channel(ChannelNumber : Byte; ProgramValue  : Word);„„Implementation„„Const„  C8253ModeControl   = $43;„  C8253OperatingFreq = 1193180;„  C8253Channel : Array [0..2] of Byte = ($40, $41, $42);„„{=[ 8253 Timer Programming Routines ]=====================================}„Procedure Set8253Channel(ChannelNumber : Byte; ProgramValue  : Word);„begin„  Port[C8253ModeControl] := 54 or (ChannelNumber SHL 6); { XX110110 }„  Port[C8253Channel[ChannelNumber]] := Lo(ProgramValue);„  Port[C8253Channel[ChannelNumber]] := Hi(ProgramValue);„end;„{-[ Set Clock Channel 0 (INT 8, IRQ 0) To Input Speed ]-------------------}„Procedure SetPlaySpeed (Speed : LongInt);„Var„  ProgramValue : Word;„begin„  ProgramValue := C8253OperatingFreq div Speed;„  Set8253Channel(0, ProgramValue);„end;„{-[ Set Clock Channel 0 Back To 18.2 Default Value ]----------------------}„Procedure SetDefaultTimerSpeed;„begin„  Set8253Channel (0, 0);„end;„„end.„„„                                        11     08-27-9322:05ALL                      DANNY MELTON             Free time for DV         IMPORT              8      Æu   {„> Does anyone know how to give up your free time under dv or dv/x? Or make„> these programs desqview aware?„„DONATED TO THE PUBLIC DOMAIN by Danny Melton„}„„program YourProgramHere;„„uses„  DOS, CRT;„„const„  MultiTasking : boolean = false;„„function UnderDV : boolean;„var„  R : registers;„begin„  if MultiTasking then„    exit;„  R.AX := $1022;„  R.BX := $0000;„  intr($15, R);„  MultiTasking := boolean(R.BX <> 0);„  UnderDV := MultiTasking;„end;„„procedure GiveUpTimeSlice;„var„  R : registers;„begin„  if not MultiTasking then„    exit;„  R.AX := $1000;„  intr($15, R);„end;„„begin„  if UnderDV then„    writeln('Running under a multi-tasker.');„  writeln('Press a key when ready');„  while not keypressed do„    GiveUpTimeSlice;„  writeln('You pressed a key.');„end.„„                                                                                                                        12     09-26-9309:30ALL                      MARTIN RICHARDSON        Hi-Res Timer             IMPORT              7      Æu   {*****************************************************************************„ * Function ...... Timer„ * Purpose ....... Returns the number of seconds since midnight„ * Parameters .... None„ * Returns ....... Number of seconds since midnight to the 100th decimial place„ * Notes ......... None„ * Author ........ Martin Richardson„ * Date .......... May 13, 1992„ *****************************************************************************}„FUNCTION Timer : REAL;„VAR hour,„    minute,„    second,„    sec100  : WORD;„BEGIN„     GETTIME(hour, minute, second, sec100);„     Timer := ((hour*60*60) + (minute*60) + (second) + (sec100 * 0.01))„END;„„                                                                                                                      13     11-02-9306:29ALL                      CEES BINKHORST           Setting Timing at 21Khz  IMPORT              23     Æu   {„CEES BINKHORST„„>  Has anyone ever succeeded in setting the timer rate at a higher frequency„> than 21KHz in protected mode? I've tried every possible thing, and it„Could you give details on that 21KHz? Sounds rather a high rate.„„> don't know whether I have enough IOPL as to make CLI and STI to work, but„Try the following:„}„„{dr. dobb's 80286/386 #185}„Function SensitiveOK : Boolean; Assembler; {sensitive instructions are: }„                                    {IN    read a port           }„                                    {OUT   Write to a port       }„                                    {INS   read a String from a port}„                                    {OUTS  Write a String to a port}„                                    {CLI   disable interrupts    }„                                    {STI   enable interrupts     }„Asm„  push  ax„  push  bx„  pushf                             {put flags 'I/O privilege level' (IOPL)}„  pop   ax                          { into ax }„  and   ax, 3000h                   {00110000 00000000 - mask all but iopl}„                                    {ax = 00??0000 00000000 now}„  shr   ax, 12                      {ax -> 00000000 000000??}„                                    {compile With 286 instructions enabled!!}„  mov   iopl, al„  mov   bx, cs                      {current privilege level (cpl) is in cs}„  and   bx, 3                       {00000000 00000011 - mask all but cpl}„  mov   cpl, bl„  cmp   bx, ax                      {compare cpl and iopl}„  ja    @not_sensitive              {jump  if cpl > iopl}„  clc„  mov   @result, True               {sensitive instructions ok}„  jmp   @exit„ @not_sensitive:„  stc„  mov   @result, False              {sensitive instructions not ok}„ @exit:„  pop   bx„  pop   ax„end;„„Function PrivilegeOK: Boolean; Assembler; {privileged instructions are:}„                                    {HLT   halt the processor    }„                                    {LGDT  load the GDT register }„                                    {LIDT  load the interrupt-descriptor-}„                                    {      table register        }„                                    {LLDT  load the LDT register  }„                                    {CLTS  clear the task-switched flag}„                                    {LMSW  load the MSW          }„                                    {LTR   load the task register}„Asm„  push  ax„  mov   ax, cs                    {cpl resides in cs}„  and   ax, 3                     {00000000 00000011 - mask all but cpl}„                                  {ax = 00000000 000000?? now}„  jnz   @lbl1„  mov   @result, True             {privileged}„  jmp   @exit„ @lbl1:„  mov   @result, False            {not privileged}„ @exit:„  pop   ax„end;„                                            14     01-27-9412:23ALL                      CHRIS BOYD               Timing Unit              IMPORT              40     Æu   {„> Now what I want to do is calculate the total run-time of the overall„> event, from start to finish, i.e., parse the log file taking the last and„> first time entries and calculate the time. I'm sure there is an easier way„> to do this but I'm new to Pascal, and, open to suggestions.  Below is what„> appears in the event.log :„}„„Unit Timer;„„{       SIMPLE TIMER 1.0„        =================„„ This is a Timer unit, it calculates time by system clock.  A few limitations„ are:„„   1) Must not modify clock.„   2) Must not time more than a day„   3) Must StopTimer before displaying Time„„   Usage:„„      StartTimer;   Starts Timer„      StopTimer;    Stops Timer„      CalcTimer;    Calculates time„      DispTime:     Displays time between StartTimer and StopTimer,„                    you don't need to call CalcTimer if you call DispTime.„„ This unit may be used in freeware and shareware programs as long as:„„   1) The program is a DECENT program, no "Adult" or "XXX" type programs„      shall lawfully contain any code found within this file (modified or„      in original form) or this file after it's been compiled.„„   2) This copyrighting is not added to, or removed from the program by„      any other person other than I, the author.„„ This is copyrighted but may be used or modified in programs as long as the„ above conditions are followed.„„ I may be reached at:„„   1:130/709                              - Fidonet„   Chris.Boyd@f709.n130.z1.fidonet.org    - Internet„   Alpha Zeta, Ft. Worth (817) 246-3058   - Bulletin Board„„ If you have any comments or suggestions (not complaints).  I assume no„ responsibility for anything resulting from the usage of this code.„„                                                   -Chris Boyd„„}„„Interface„„Uses„  Dos;„„Type„  TimeStruct = record„    Hour,„    Minute,„    Second,„    S100   : Word;„  End;„„Var„  StartT,„  StopT,„  TimeT   : TimeStruct;„  Stopped : Boolean;„„procedure StartTimer;„procedure StopTimer;„procedure DispTime;„procedure CalcTimer;„„Implementation„„procedure TimerError(Err : Byte);„Begin„  Case Err of„    1 :„    Begin„      Writeln(' Error: Must Use StartTimer before StopTimer');„      Halt(1);„    End;„„    2 :„    Begin„      Writeln(' Error: Timer can not handle change of day');„      Halt(2);„    End;„„    3 :„    Begin„      Writeln(' Error: Internal - Must StopTimer before DispTime');„      Halt(3);„    End;„  End;„End;„„procedure CalcTimer;„Begin„  If (Stopped = True) Then„  Begin„    If (StopT.Hour < StartT.Hour) Then„      TimerError(2);„    TimeT.Hour := StopT.Hour - StartT.Hour;„„    If (StopT.Minute < StartT.Minute) Then„    Begin„      TimeT.Hour   := TimeT.Hour - 1;„      StopT.Minute := StopT.Minute + 60;„    End;„    TimeT.Minute := StopT.Minute - StartT.Minute;„„    If (StopT.Second < StartT.Second) Then„    Begin„      TimeT.Minute := TimeT.Minute - 1;„      StopT.Second := StopT.Second + 60;„    End;„    TimeT.Second := StopT.Second - StartT.Second;„„    If (StopT.S100 < StartT.S100) Then„    Begin„      TimeT.Second := TimeT.Second - 1;„      StopT.S100   := StopT.S100 + 100;„    End;„    TimeT.S100 := StopT.S100 - StartT.S100;„  End„  Else„    TimerError(3);„End;„„procedure DispTime;„Begin„  CalcTimer;„  Write(' Time : ');„  Write(TimeT.Hour);„  Write(':');„„  If (TimeT.Minute < 10) Then„    Write('0');„  Write(TimeT.Minute);„  Write(':');„„  If (TimeT.Second < 10) Then„    Write('0');„  Write(TimeT.Second);„  Write('.');„„  If (TimeT.S100 < 10) Then„    Write('0');„  Writeln(TimeT.S100);„End;„„procedure StartTimer;„Begin„  GetTime(StartT.Hour, StartT.Minute, StartT.Second, StartT.S100);„  Stopped := False;„End;„„procedure StopTimer;„Begin„  If (Stopped = False) Then„  Begin„    GetTime(StopT.Hour, StopT.Minute, StopT.Second, StopT.S100);„    Stopped := TRUE;„  End„  Else„    TimerError(1);„End;„„End.„„{„This is a unit that I wrote.  It will not change day without calling an error„in itself.  This can be modified though, I just haven't went about doing it.„For example, if you started the timer at 11:29 pm and stopped it at 1:00 am, it„wouldn't work, but if you started the timer at 12:00 am and stopped it at 11:59„pm in that same day it would work.  The TimeStruct type doesn't store day, just„time and the only thing you have to do to use it is:„„In your main program:„}„Program MyProg;„„Uses„  Timer;„„Begin„{ Program stuff.... }„StartTimer;„{ More Program Stuff... }„StopTimer;„{ If you don't want to display the time to the screen, then you need to„  call CalcTimer, so that it modifies TimeT}„DispTime; {Whenever you want to display the time..  The calculated time is„stored in the record variable Timer.TimeT, if you wanted to access    it.  All„the fields of the record a word in type.  To access the hours for example,„you'd go like:„„                Timer.TimeT.Hour    or    TimeT.Hour„„           You probably will have to try both.}„End.„„                                                                                     15     01-27-9413:34ALL                      TUBRO POWER SOFTWARE     Timer Code               IMPORT              46     Æu   {$S-,R-,I-,V-,B-}„„{*********************************************************}„{*                   TPTIMER.PAS 2.00                    *}„{*                by TurboPower Software                 *}„{*********************************************************}„„unit TpTimer;„  {-Allows events to be timed with 1 microsecond resolution}„„interface„„procedure InitializeTimer;„  {-Reprogram the timer chip to allow 1 microsecond resolution}„„procedure RestoreTimer;„  {-Restore the timer chip to its normal state}„„function ReadTimer : LongInt;„  {-Read the timer with 1 microsecond resolution}„„function ElapsedTime(Start, Stop : LongInt) : Real;„  {-Calculate time elapsed (in milliseconds) between Start and Stop}„„function ElapsedTimeString(Start, Stop : LongInt) : string;„  {-Return time elapsed (in milliseconds) between Start and Stop as a string}„„  {==========================================================================}„„implementation„„const„  TimerResolution = 1193181.667;„var„  SaveExitProc : Pointer;„  Delta : LongInt;„„  function Cardinal(L : LongInt) : Real;„    {-Return the unsigned equivalent of L as a real}„  begin                      {Cardinal}„    if L < 0 then„      Cardinal := 4294967296.0+L„    else„      Cardinal := L;„  end;                       {Cardinal}„„  function ElapsedTime(Start, Stop : LongInt) : Real;„    {-Calculate time elapsed (in milliseconds) between Start and Stop}„  begin                      {ElapsedTime}„    ElapsedTime := 1000.0*Cardinal(Stop-(Start+Delta))/TimerResolution;„  end;                       {ElapsedTime}„„  function ElapsedTimeString(Start, Stop : LongInt) : string;„    {-Return time elapsed (in milliseconds) between Start and Stop as a string}„  var„    R : Real;„    S : string;„  begin                      {ElapsedTimeString}„    R := ElapsedTime(Start, Stop);„    Str(R:0:3, S);„    ElapsedTimeString := S;„  end;                       {ElapsedTimeString}„„  procedure InitializeTimer;„    {-Reprogram the timer chip to allow 1 microsecond resolution}„  begin                      {InitializeTimer}„    {select timer mode 2, read/write channel 0}„    Port[$43] := $34;        {00110100b}„    inline($EB/$00);         {jmp short $+2 ;delay}„    Port[$40] := $00;        {LSB = 0}„    inline($EB/$00);         {jmp short $+2 ;delay}„    Port[$40] := $00;        {MSB = 0}„  end;                       {InitializeTimer}„„  procedure RestoreTimer;„    {-Restore the timer chip to its normal state}„  begin                      {RestoreTimer}„    {select timer mode 3, read/write channel 0}„    Port[$43] := $36;        {00110110b}„    inline($EB/$00);         {jmp short $+2 ;delay}„    Port[$40] := $00;        {LSB = 0}„    inline($EB/$00);         {jmp short $+2 ;delay}„    Port[$40] := $00;        {MSB = 0}„  end;                       {RestoreTimer}„„  function ReadTimer : LongInt;„    {-Read the timer with 1 microsecond resolution}„  begin                      {ReadTimer}„    inline(„      $FA/                   {cli             ;Disable interrupts}„      $BA/$20/$00/           {mov  dx,$20     ;Address PIC ocw3}„      $B0/$0A/               {mov  al,$0A     ;Ask to read irr}„      $EE/                   {out  dx,al}„      $B0/$00/               {mov  al,$00     ;Latch timer 0}„      $E6/$43/               {out  $43,al}„      $EC/                   {in   al,dx      ;Read irr}„      $89/$C7/               {mov  di,ax      ;Save it in DI}„      $E4/$40/               {in   al,$40     ;Counter --> bx}„      $88/$C3/               {mov  bl,al      ;LSB in BL}„      $E4/$40/               {in   al,$40}„      $88/$C7/               {mov  bh,al      ;MSB in BH}„      $F7/$D3/               {not  bx         ;Need ascending counter}„      $E4/$21/               {in   al,$21     ;Read PIC imr}„      $89/$C6/               {mov  si,ax      ;Save it in SI}„      $B0/$FF/               {mov  al,$0FF    ;Mask all interrupts}„      $E6/$21/               {out  $21,al}„      $B8/$40/$00/           {mov  ax,$40     ;read low word of time}„      $8E/$C0/               {mov  es,ax      ;from BIOS data area}„      $26/$8B/$16/$6C/$00/   {mov  dx,es:[$6C]}„      $89/$F0/               {mov  ax,si      ;Restore imr from SI}„      $E6/$21/               {out  $21,al}„      $FB/                   {sti             ;Enable interrupts}„      $89/$F8/               {mov  ax,di      ;Retrieve old irr}„      $A8/$01/               {test al,$01     ;Counter hit 0?}„      $74/$07/               {jz   done       ;Jump if not}„      $81/$FB/$FF/$00/       {cmp  bx,$FF     ;Counter > $FF?}„      $77/$01/               {ja   done       ;Done if so}„      $42/                   {inc  dx         ;Else count int req.}„      {done:}„      $89/$5E/$FC/           {mov [bp-4],bx   ;set function result}„      $89/$56/$FE);          {mov [bp-2],dx}„  end;                       {ReadTimer}„„  procedure Calibrate;„    {-Calibrate the timer}„  const„    Reps = 1000;„  var„    I : Word;„    L1, L2, Diff : LongInt;„  begin                      {Calibrate}„    Delta := MaxInt;„    for I := 1 to Reps do begin„      L1 := ReadTimer;„      L2 := ReadTimer;„      {use the minimum difference}„      Diff := L2-L1;„      if Diff < Delta then„        Delta := Diff;„    end;„  end;                       {Calibrate}„„  {$F+}„  procedure OurExitProc;„    {-Restore timer chip to its original state}„  begin                      {OurExitProc}„    ExitProc := SaveExitProc;„    RestoreTimer;„  end;                       {OurExitProc}„  {$F-}„„begin„  {set up our exit handler}„  SaveExitProc := ExitProc;„  ExitProc := @OurExitProc;„„  {reprogram the timer chip}„  InitializeTimer;„„  {adjust for speed of machine}„  Calibrate;„end.„                                                       16     02-03-9407:08ALL                      JAKE CHAPPLE             Events on IRQ/TIMERS     IMPORT              101    Æu   {„From: JAKE CHAPPLE„Subj: Events on IRQ/TIMERS„---------------------------------------------------------------------------„}„„{----------------------- Beginning of TIMER.PAS -----------------------}„Unit Timer;„„{========================================================================}„{                           INTERFACE SECTION                            }„{========================================================================}„{                                                                        }„{ This unit implements a set of general purpose, low resolution timers   }„{ for use in any application that requires them.  The design of the      }„{ timer system is adapted from the following magazine article:           }„{                                                                        }„{   Jones S., A High-Performance Lightweight Timer Package, Tech         }„{      Specialist, Vol. 2, No. 1, Jan 1991, pp 17-27.                    }„{                                                                        }„{ Most of Jones' design has been copied, although this implementation is }„{ in Turbo Pascal rather than MASM.  By default, this unit provides 10   }„{ timers, although this can be increased by increasing the value of      }„{ MAX_TIMER and re-compiling.                                            }„{                                                                        }„{ Timers are referenced by "handles" i.e. small integers.  These are     }„{ actually indexes into the timer array.  To obtain a handle one must    }„{ ALLOCATE a timer.  The Allocate function also requires the address of  }„{ a routine to execute when the timer expires as well as a user context  }„{ variable.  The timer function must be compiled as a FAR routine.  The  }„{ user context variable is a 16 bit word of data that can be used for any}„{ application specific purpose.  It is passed to the timer routine when  }„{ the timer expires.  This is useful if a common timer routine is used   }„{ for multiple timers.  It allows the common timer routine to determine  }„{ which timer expired and take appropriate action.                       }„{                                                                        }„{ Once a timer is allocated, it must be STARTED.  The StartTimer         }„{ procedure requires the timer handle and a timer running time.  The     }„{ timer running timer is passed as a RELATIVE number of MILLISECONDS i.e.}„{ the number of milliseconds from now when the timer should expire.      }„{                                                                        }„{ A timer can be stopped before it expires with StopTimer which just     }„{ requires the timer handle.  There is the possibility that the StopTimer}„{ routine could be interrupted by a clock tick and the expiration routine}„{ could run before the StopTimer procedure actually stops the timer.     }„{ It's up to you to guard against this.                                  }„{                                                                        }„{ Finally, an allocated timer can be deallocated with DeallocateTimer    }„{========================================================================}„„INTERFACE„„uses„    Dos;„„type„    UserProc = procedure(context : word);„„„function  AllocateTimer(UserContext : word; UserRtn : UserProc) : integer;„procedure StartTimer(handle : integer; rel_timeout : longint);„procedure StopTimer(handle : integer);„procedure DeallocateTimer(handle : integer);„„{========================================================================}„{                        IMPLEMENTATION SECTION                          }„{========================================================================}„„IMPLEMENTATION„„const„     MAX_TIMER = 10;            {Total number of timers}„     MILLISECS_PER_TICK = 55;   {clock tick interval}„     TIMER_ALLOCATED = 1;       {bits in the timer flags word}„     TIMER_RUNNING   = 2;„„type„    timer_rec = record                  {Timer descriptor record}„                  timeout : longint;    {Timeout.  Absolute number of millisecs}„                                        {From beginning of program execution}„                  routine : UserProc;   {User procedure to run on expiration}„                  flags   : word;       {Timer status flags}„                  context : word;       {User parameter to pass to User Proc}„                end;„var„   timers      : array[1..MAX_TIMER] of timer_rec;   {timer database}„   Int1CSave   : pointer;  {dword to hold original Int $1C vector}„   TimeCounter : longint;  {incremented by 55 millisecs on every entry to ISR}„   ExitSave    : pointer;  {Save the address of next unit exit proc in chain}„   i           : integer;  {loop counter}„„{$F+}„{------------------------------------------------------------------------}„procedure Clock_ISR; interrupt;„{------------------------------------------------------------------------}„{ Description:                                                           }„{   This is an interrupt service routine which is hooked into the PC's   }„{   $1C vector.  An Int $1C is generated at each clock tick.  Int $1C is }„{   executed by the hardware interrupt service routine after it has up-  }„{   dated the system time-of-day clock.                                  }„{ Parameters:                                                            }„{   None.                                                                }„{------------------------------------------------------------------------}„var„   i : integer;        {local loop counter}„begin„„  {Update the current time, relative to the start of the program}„„  inline($FA); {cli}„  TimeCounter := TimeCounter + MILLISECS_PER_TICK; {update millisecond counter}„„  {Scan the array of timers looking for ones which have expired}„„  for i := 1 to MAX_TIMER do„    with timers[i] do„      if (flags and TIMER_ALLOCATED) > 0 then   {Is this timer allocated? if no}„        if (flags and TIMER_RUNNING) > 0 then   {Is this timer running? if not}„          if timeout <= TimeCounter then begin  {Has this timer expired yet?}„            flags := flags and (not TIMER_RUNNING); {turn off running flag}„            inline($FB);          {sti}„            routine(context);     {call user expiration routine}„            inline($FA);          {cli}„          end;„  inline($FB); {sti}„end;„{$F-}„„{------------------------------------------------------------------------}„function AllocateTimer(UserContext : word; UserRtn : UserProc) : integer;„{------------------------------------------------------------------------}„{ Description:                                                           }„{   Allocate the next available timer in the timer database for use by   }„{   application.                                                         }„{ Parameters:                                                            }„{   UserContext - application specific word of data to be passed to the  }„{                 expiration routine when it is called.                  }„{   UserProc - address of a procedure to be called when the timer expires}„{ Returns:                                                               }„{   Handle - integer from 1 to MAX_TIMER                                 }„{            OR -1 if no timers available.                               }„{------------------------------------------------------------------------}„var„   i : integer;„begin„  inline($FA); {cli}„  for i := 1 to MAX_TIMER do begin  {scan timer database looking for 1st free}„    with timers[i] do begin„      if flags = 0 then begin„         flags := TIMER_ALLOCATED;      {Mark timer as allocated}„         context := UserContext;        {Save users context variable}„         routine := UserRtn;            {Store user routine}„         AllocateTimer := i;            {Return handle to timer}„         inline($FB);                   {Enable interrupts}„         exit;„      end;„    end;„  end;„  { No timers available, return error}„  AllocateTimer := -1;„  inline($FB);„end;„„{------------------------------------------------------------------------}„procedure DeallocateTimer(handle : integer);„{------------------------------------------------------------------------}„{ Description:                                                           }„{   Return a previously allocated timer to the pool of available timers  }„{------------------------------------------------------------------------}„begin„  timers[handle].flags := 0;„end;„„„{------------------------------------------------------------------------}„procedure StartTimer(handle : integer; rel_timeout : longint);„{------------------------------------------------------------------------}„{ Description:                                                           }„{    Start an allocated timer ticking.                                   }„{ Parameters:                                                            }„{    Handle - the handle of a previously allocated timer.                }„{    rel_timeout - number of milliseconds before the timer is to expire. }„{------------------------------------------------------------------------}„begin„  inline($FA);  {cli}„  with timers[handle] do begin„    flags := flags or TIMER_RUNNING;       {set timmer running flag}„    timeout := TimeCounter + rel_timeout;  {Convert relative timeout to absolute}„  end;„  inline($FB);  {sti}„end;„„{------------------------------------------------------------------------}„procedure StopTimer(handle : integer);„{------------------------------------------------------------------------}„{ Description:                                                           }„{   Stop a ticking timer from running.  This routine does not deallocate }„{   the timer, just stops it.  Remember, it is possible for the clock    }„{   interrupt to interrupt this routine before it actually stops the     }„{   timer.  Therefore, it is possible for the expiration routine to run  }„{   before the timer is stopped i.e. unexpectedly.                       }„{ Parameters:                                                            }„{   Handle - handle of timer to stop.                                    }„{------------------------------------------------------------------------}„begin„  with timers[handle] do„     flags := flags and (not TIMER_RUNNING);„end;„„{$F+}„{------------------------------------------------------------------------}„Procedure myExitProc;„{------------------------------------------------------------------------}„{ Description:                                                           }„{  This is the unit exit procedure which is called as part of a chain of }„{  exit procedures at program termination.                               }„{------------------------------------------------------------------------}„begin„  ExitProc := ExitSave;  {Restore the chain so other units get a turn}„  SetIntVec($1C, Int1CSave);     {restore the original Int $1C vector}„end;„{$F-}„„{=========================================================================}„{                        INITIALIZATION SECTION                           }„{=========================================================================}„„Begin {unit initialization code}„„  (* Establish the unit exit procedure *)„„  ExitSave := ExitProc;„  ExitProc := @myExitProc;„„  {Initialize the timers database and install the custom Clock ISR}„„  for i := 1 to MAX_TIMER do   {clear flag word for all timers}„     timers[i].flags := 0;„  TimeCounter := 0;              {clear current time counter}„  GetIntVec($1C, Int1CSave);     {Save original Int $1C vector}„  SetIntVec($1C, @Clock_ISR);    {install the the clock ISR}„end.„„{------------------------- End of TIMER.PAS -----------------------------}„„{---------------------- Beginning of TIMERTST.PAS -----------------------}„program timer_test;„„uses„    Crt, timer;„var„    t1, t2 : integer; {timer handles}„    done   : boolean;„„{---- Procedure to be run when timer 1 expires ----}„procedure t1_proc(context1 : word); far;„begin„  writeln('Timer ',context1);„  StartTimer(t1, 1000);        {Keep timer 1 running}„end;„„{---- Procedure to be run when timer 2 expires ----}„procedure t2_proc(context2 : word); far;„begin„  done := true;„  writeln('Timer ',context2,' expired');„end;„„begin„  ClrScr;„  done := false;„  t1 := AllocateTimer(1, t1_proc);        {Create timer 1}„  t2 := AllocateTimer(2, t2_proc);        {Create timer 2}„  StartTimer(t2, 5000);        {Start timer 2 for 5 second delay}„  StartTimer(t1, 1000);        {Start timer 1 for 1 second delay}„  while not done do begin      {Do nothing until timer 2 expires}„     end;„  StopTimer(t1);„end.„                                                        17     05-25-9408:24ALL                      TONI PERRETTA            Timing Functions         SWAG9405            27     Æu   {„   ›Is there an easy way to time functions and/or procedures??  I'm trying„   ›to compare a couple functions that do the samething and I would like to„   ›time them.  I've tried using the GetTime procedure but the hundredths of„   ›seconds isn't fast enough.  Can any one help?„„   I think this unit may help you:„„***************************************************************************„}„unit tptimer;„„interface„„procedure cardinal(l:longint; var result:double);„„procedure elapsedtime(start:longint; stop:longint; var result:double);„(*Calculate time elapsed (in milliseconds) between Start and Stop*)„„procedure initializetimer;„(*Reprogram the timer chip to allow 1 microsecond resolution*)„„procedure restoretimer;„(*Restore the timer chip to its normal state*)„„function readtimer:longint;„(*Read the timer with 1 microsecond resolution*)„„implementation„uses dos;„„const„TimerResolution=1193181.667;„„procedure cardinal(l:longint; var result:double);„ Begin„  if l < 0 then result:= l + 4294967296.0„    else„  result := l;„ End;„„procedure elapsedtime(start, stop:longint; var result:double);„  var r:double;„ Begin„  cardinal(stop - start, r);„  result := (1000 * r) / TimerResolution;„ End;„„procedure initializetimer;„label NullJump1,NullJump2;„Begin„  port[$043]:=$034;„  asm jmp NullJump1;„  NullJump1:„  end;„  port[$040]:=$000;„  asm jmp NullJump2„  NullJump2:„  end;„  port[$040]:=$000;„End;„„procedure restoretimer;„label NullJump1,NullJump2;„Begin„  port[$043]:=$036;„  asm jmp NullJump1;„  NullJump1:„  end;„  port[$040]:=$000;„  asm jmp NullJump2„  NullJump2:„  end;„  port[$040]:=$000;„End;„„function readtimer:longint; assembler;„label done;„Asm„  cli             (* Disable interrupts *)„  mov  dx,020h     (* Address PIC ocw3   *)„  mov  al,00Ah     (* Ask to read irr    *)„  out  dx,al„  mov  al,00h     (* Latch timer 0 *)„  out  043h,al„  in   al,dx      (* Read irr      *)„  mov  di,ax      (* Save it in DI *)„  in   al,040h     (* Counter --> bx*)„  mov  bl,al      (* LSB in BL     *)„  in   al,040h„  mov  bh,al      (* MSB in BH     *)„  not  bx         (* Need ascending counter *)„  in   al,021h     (* Read PIC imr  *)„  mov  si,ax      (* Save it in SI *)„  mov  al,00FFh    (* Mask all interrupts *)„  out  021h,al„  mov  ax,040h     (* read low word of time *)„  mov  es,ax      (* from BIOS data area   *)„  mov  dx,es:[06Ch]„  mov  ax,si      (* Restore imr from SI   *)„  out  021h,al„  sti             (* Enable interrupts *)„  mov  ax,di      (* Retrieve old irr  *)„  test al,001h     (* Counter hit 0?    *)„  jz   done       (* Jump if not       *)„  cmp  bx,0FFh     (* Counter > 0x0FF?    *)„  ja   done       (* Done if so        *)„  inc  dx         (* Else count int req. *)„done:„  mov ax,bx   (* set function result *)„End;„„End.„„***********************************************************************„„and here is a program to test the unit:„„Program TestTime;„uses crt, dos, tptimer;„ var start_time, stop_time: longint;„     time:double;„Begin„ Clrscr;„ initializetimer;„ delay(100);„ start_time:=readtimer;„ delay(2);„ stop_time:=readtimer;„ elapsedtime(start_time, stop_time, time);„ writeln('elapsed time = ', time:0:10);„ readln;„ restoretimer;„End.„„                                                                                                          18     05-26-9406:18ALL                      MARTIN ROMMEL            Stop Watch Function      SWAG9405            19     Æu   {„„I am sure it is not the most elegant implementation. Except for the night„of February 29th to March 1st, it should work fine. You might want to„through out the escape and beep procedures. }„„„„unit Time;  {JMR'91}    { Unit zur Bestimmung von Programmlaufzeiten }„„interface„„  uses DOS,Crt;„„  procedure Start;„  procedure Elapsed(var Hour,Minute,Second,HundSec:Word); „  function ElapsedStr:String;    { 'HH:MM:SS,HH' }„  { Elapsed und ElapsedStr ermitteln die Zeit, die seit dem Aufruf von  }„  { Start vergangen ist. Schaltjahre werden nicht berÅcksichtigt.  }„  procedure beep;           { gibt kurzen Ton }„  function escape:Boolean;  { true, wenn <Esc> gedrÅckt wurde (ReadKey) }„{***************************************************************************}„„implementation„„var Y,Month,Day,DoW,Month0,Day0,Hour0,Minute0,Second0,HundSec0:Word;„„procedure Start;„  begin„    GetTime(Hour0,Minute0,Second0,HundSec0);„    GetDate(Y,Month0,Day0,DoW);„  end;„„procedure Elapsed;„  begin„    GetTime(Hour,Minute,Second,HundSec);„    GetDate(Y,Month,Day,DoW);„    HundSec:=HundSec-HundSec0;„    if HundSec>99 then begin HundSec:=HundSec+100; dec(Second) end;„    Second:=Second-Second0;„    if Second>59 then begin Second:=Second+60; dec(Minute) end;„    Minute:=Minute-Minute0;„    if Minute>59 then begin Minute:=Minute+60; dec(Hour) end;„    Hour:=Hour-Hour0;„    Day:=Day-Day0;„    if Day>30 then if Month in [1,3,5,7,8,10,12] then Day:=Day+31„    else if Month<>2 then Day:=Day+30„         else Day:=Day+28;„    if Hour>23 then Hour:=Hour+24*Day;„  end;„„function ElapsedStr;„  var Hour,Minute,Second,HundSec:Word;„  function LeadingZero(w:Word):String;„    var s:String;„    begin„      Str(w:0,s);„      if Length(s)=1 then s:='0'+s;„      LeadingZero:=s;„    end;„  begin„    Elapsed(Hour,Minute,Second,HundSec);„    ElapsedStr:=LeadingZero(Hour)+':'+LeadingZero(Minute)+':'„        +LeadingZero(Second){+','+LeadingZero(HundSec)};„  end;„„procedure beep;„  begin„    sound(440);„    delay(10);„    nosound;„  end;„„function Escape;„  var Taste:Char;„  begin„    if Keypressed then„ if Ord(ReadKey)=27 then Escape:=true„     else Escape:=false„    else Escape:=false;„  end;„„end. { Unit Time }„                                                                                                  19     05-26-9407:30ALL                      SOUTHERN SOFTWARE        Wait Correction          SWAG9405            50     Æu   „{$A+,B-,E-,F-,I-,N-,O-,R-,S-,V-}„„(*„FastWait               Copyright (c) 1991  Southern Software„„Version 1.00 - 4/8/91„„Allows PC's faster than 20 mhz (386/486) to properly use a delay„function based upon a null looping procedure such as is used in the„Turbo Pascal "Delay" procedure.  Wait is accurate for PC's as fast as„1,100 mhz equivalent!„„USAGE: Simply place "FastWait" in the Uses section of your program„       and replace each occurrence of "delay" in your program with„       "wait".„„Example-„=======„„     Existing program:„     ----------------„     Uses CRT;„„     begin„     writeln('This program delays for 5 seconds.);„     delay(5000);„     end.„„     New program:„     -----------„     Uses FastWait, CRT;                {Now also uses "FastWait"}„„     begin„     writeln('This program delays for 5 seconds.);„     wait(5000);                        {changed "delay" to "wait"}„     end.„*)„„unit FastWait;„„  (*   Version 1.00 - 4/8/91  *)„„  {$ifdef DEBUG}„    {$D+,L+}„  {$else}„    {$D-,L-}„  {$endif}„„(****************************************************************************)„ interface„(****************************************************************************)„„var„                   (* Number of loops to do for 1 ms wait.                  *)„  WaitOneMS : word;„„                   (* Number of loops per timer tick.                       *)„  LoopsPerTick : longint;„„                   (* System timer, 18.2/second.                            *)„  BIOSTick : longint absolute $40:$6C;„„                   (* Pauses execution for "ms" milliseconds. *)„procedure Wait(ms : word);„„{$ifdef VER60}„„                 (* This procedure is for very short timing loops ( < 1ms)„                    that cannot be handled by the delay routine.„„                    The variable "LoopsPerTick" has the number of loops„                    to do for one BIOS tick (18.2 of these/sec). If you„                    want to delay for "X" Ês, the number of loops required„                    would be  "(LoopsPerTick * X) div 54945". This will not„                    compile if you are using TP 4.0, 5.0 or 5.5 due to the„                    conditional defines. This is because it makes use of„                    the "asm" statement which is not available in TP„                    versions prior to 6.0. *)„„ procedure ShortDelay(NumLoops : word);„  „{$endif}„„„(****************************************************************************)„ implementation„(****************************************************************************)„„  {$L WAIT.OBJ}„„  procedure Wait(ms : word); external;„„  procedure WaitInit; external;„„{$ifdef VER60}„„  procedure ShortDelay(NumLoops : word); assembler;„  asm„    mov  cx,NumLoops„    jcxz @@2„    xor  di,di         (* ES:DI points to dummy address *)„    mov  es,di         (* which won't change *)„    mov  al,es:[di]    (* AL has the value there *)„   @@1:„    cmp  al,es:[di]„    jne  @@2„    loop @@1„   @@2:„  end;„„{$endif}„„BEGIN              (* Code to execute at start-up to calibrate the loop     *)„                   (* delay.                                                *)„  WaitInit„END.„„{ XX3402 Code to WAIT.OBJ„{ Cut and save as WAIT.XX.  Execute : XX3402 D WAIT.XX to create WAIT.OBJ }„{ ------------------   CUT HERE -------------------------- }„„„*XX3402-000319-080491--72--85-45848--------WAIT.OBJ--1-OF--1„U+c+03R-GJEiEJBB8cUU++++J5JmMawUELBnNKpWP4Jm60-KNL7nOKxi616iA145W-++ECbg„gsUK03R-GJEiEJBBhcU1+21dH7M0++-cW+A+E84IZUM+-2F-J234a+Q+8++++U2-BNM4++F1„HoF3FNU5+0VR++A-+RSA4U+7Jo37J2xCFIpH++lAHoxEIp-3IZF7Eog+vt+D+++003R-GJF7„HYZI8+++ld+9+++0-3R-GJE6+++WW+E+E86-YO-V++6++0Mu-LI0sjb1WxkqWpQ20x7o2nDz„XgQaWUK95U++Wwjcrjx8RTX8+U0sE+0Ck9xg+9bzznDG7cc37Xc3RDgaWUIaCUJp-S9tEijq„i1Q+YTTEck++WFM0+DTlck++kzWQ3E124kM-+QFF-U20l3I4+E92KUM-+E88+U++R+++„***** END OF BLOCK 1 *****„„{ --------------------------   CUT HERE ------------------------   }„{ TEST PROGRAM }„„program TestWait;„uses„  crt,„  FastWait;„„var„  Counter : word;„  jj : longint;„„BEGIN„  clrscr;„  HighVideo;„  writeln('           Southern Software  (c) 1991'#10);„  LowVideo;„  writeln('This test compares the standard "delay" routine with our new "Wait"');„  writeln('procedure.  Below is the calculated number of small loops the PC goes');„  writeln('through for one millisecond delay.  If this number is above 1,191 then');„  writeln('the "delay" routine in the Turbo CRT unit as well as those in the');„  writeln('TurboPower Software Object Professional and Turbo Professional series');„  writeln('will yield delays that are too short.  Our "wait" procedure is the same');„  writeln('as the "delay" procedure except that it will adjust for faster machines.');„  writeln;„  writeln('The looping below is for 10 seconds in each case.  The seconds are shown');„  writeln('and at the end, the number of BIOS ticks is shown.  A properly calibrated');„  writeln('delay routine should be almost exactly 10 seconds long, which is 182 ticks.');„  writeln;„  writeln('To abort at any time, press any key.');„  writeln(#10);„  write('The delay factor for this machine is actually ');„  HighVideo;„  writeln(WaitOneMS);„  LowVideo;„  writeln(#10);„  writeln('10 second delays using');„  write('    CRT unit "delay" : ');„  HighVideo;„                   (* Delay 10 seconds using the CRT unit "delay" routine.  *)„  jj := BIOSTick;„  repeat„  until (jj <> BIOSTick);„  jj := BIOSTick;„  for Counter := 1 to 10 do „    begin„      delay(1000);„      write(Counter)„    end;„  jj := (BIOSTick - jj);„  LowVideo;„  write('         BIOS Ticks : ');„  HighVideo;„  writeln(jj);„  LowVideo;„  write('FastWait unit "wait" : ');„  HighVideo;„                   (* Delay 10 seconds using FastWait unit "wait" routine.  *)„  jj := BIOSTick;„  repeat„  until (jj <> BIOSTick);„  jj := BIOSTick;„  for Counter := 1 to 10 do „    begin„      wait(1000);„      write(Counter)„    end;„  jj := (BIOSTick - jj);„  LowVideo;„  write('         BIOS Ticks : ');„  HighVideo;„  writeln(jj, #10);„  LowVideo;„  write('Press any key to end ');„  repeat„  until keypressed;„  while keypressed do„    Counter := ord(ReadKey);„  clrscr„END.„„„                                                                                                        