SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00006         DOS REDIRECTION ROUTINES                                          1      05-28-9313:56ALL                      SWAG SUPPORT TEAM        DOS-REDR.PAS             IMPORT              28          Unit Execute;„„Interface„„Procedure Exec(Path,CmdLine : String);„„Implementation„„Uses„  Dos;„„Function ExtractFileName(Var Line : String;Index : Integer) : String;„„Var„  Temp : String;„„begin„  Delete(Line,Index,1);„  While (Index <= Length(Line)) and (Line[Index] = ' ')„    Do Delete(Line,Index,1);„  Temp := '';„  While (Index <= Length(Line)) and (Line[Index] <> ' ') Do„  begin„    Temp := Temp + Line[Index];„    Delete(Line,Index,1);„  end;„  ExtractFileName := Temp;„end;„„Procedure CloseHandle(Handle : Word);„„Var„  Regs : Registers;„„begin„  With Regs Do„  begin„    AH := $3E;„    BX := Handle;„    MsDos(Regs);„  end;„end;„„Procedure Duplicate(SourceHandle : Word;Var TargetHandle : Word);„„Var„  Regs : Registers;„„begin„  With Regs Do„  begin„    AH := $45;„    BX := SourceHandle;„    MsDos(Regs);„    TargetHandle := AX;„  end;„end;„„Procedure ForceDuplicate(SourceHandle : Word;Var TargetHandle : Word);„„Var„  Regs : Registers;„„begin„  With Regs Do„  begin„    AH := $46;„    BX := SourceHandle;„    CX := TargetHandle;„    MsDos(Regs);„    TargetHandle := AX;„  end;„end;„„Procedure Exec(Path,CmdLine : String);„„Var„  StdIn   : Word;„  Stdout  : Word;„  Index   : Integer;„  FName   : String[80];„  InFile  : Text;„  OutFile : Text;„„  InHandle  : Word;„  OutHandle : Word;„         { ===============>>>> }   { change below For STDERR }„begin„  StdIn := 0;„  StdOut := 1;                    { change to 2 For StdErr       }„  Duplicate(StdIn,InHandle);      { duplicate standard input     }„  Duplicate(StdOut,OutHandle);    { duplicate standard output    }„  Index := Pos('>',CmdLine);„  If Index > 0 Then               { check For output redirection }„  begin„    FName := ExtractFileName(CmdLine,Index);  { get output File name  }„    Assign(OutFile,FName);                    { open a Text File      }„    ReWrite(OutFile);                         { .. For output         }„    ForceDuplicate(TextRec(OutFile).Handle,StdOut);{ make output same }„  end;„  Index := Pos('<',CmdLine);„  If Index > 0 Then               { check For input redirection }„  begin„    FName := ExtractFileName(CmdLine,Index);  { get input File name  }„    Assign(InFile,FName);                     { open a Text File     }„    Reset(InFile);                            { For input            }„    ForceDuplicate(TextRec(InFile).Handle,StdIn);  { make input same }„  end;„  Dos.Exec(Path,CmdLine);           { run EXEC }„  ForceDuplicate(InHandle,StdIn);   { put standard input back to keyboard }„  ForceDuplicate(OutHandle,StdOut); { put standard output back to screen  }„  CloseHandle(InHandle);            { Close the redirected input File     }„  CloseHandle(OutHandle);           { Close the redirected output File    }„end;„„end.„„{===============================================================}„{„Use it exactly as you would the normal EXEC Procedure:„„  Exec('MAsm.EXE','mystuff.Asm');„„To activate redirection simply add the redirection symbols, etc:„„  Exec('MAsm.EXE','mystuff.Asm >err.lst');„„One note of caution.  This routine temporarily Uses extra handles. It's„either two or four more.  The Various books I have are not clear as to„whether duplicated handles 'count' or not. My guess is yes.  If you don't„plan on redirecting STDIN then reMove all the code For duplicating it to„cut your handle overhead in half.„}„„                                                                                                                        2      05-28-9313:56ALL                      SWAG SUPPORT TEAM        DUALOUT.PAS              IMPORT              37          Unit dualout;„„{ This Unit is designed to demonstrate directing all screen output to a File }„{ in addition to the normal display.  This means that any Write or Writeln   }„{ will display normally on the screen and also be Recorded in a Text File.   }„{ The File name For the output can be supplied by a command line parameter   }„{ in the Format -  dual=c:\test\output.dat or you can provide an environment }„{ Variable named dual that supplies the File name or it will default to the  }„{ current directory and output.dat.                                          }„„Interface„„Uses„  globals,  { contains the Function exist, which tests For the existence of  }„            { a File.  It also defines the Type str80 as String[80]          }„  Dos,„  tpString; { from TPro. Needed For StUpCase Function in Procedure initialise}„„Const „  DualOn   : Boolean = False;„  DualOK   : Boolean = False;„  fname    : str80   = 'output.dat';  { The default File name For the output }„  „Type„  DriverFunc = Function(Var f: TextRec): Integer;„„Var„  OldExitProc    : Pointer;                  { For saving old Exit Procedure }„  OldInOutOutput,                            { The old output InOut Function }„  OldFlushOutput : DriverFunc;               { The old output Flush Function }„  dualf          : Text;„„Procedure  dual(status: Boolean);„„{===========================================================================}„Implementation„„Var„  cmdline : String;„  „Procedure DualWrite(Var f: TextRec);„  { Writes the output from stdout to a File }„  Var„    x : Word;„  begin„    For x := 0 to pred(f.BufPos) do„      Write(dualf, f.BufPtr^[x]);„  end;  { DualWrite }„„{$F+}„Function InOutOutput(Var f: TextRec): Integer;„  begin„    DualWrite(f);                                        { Write to the File }„    InOutOutput := OldInOutOutput(f);                { Call the old Function }„  end; { InOutOutput }„„Function FlushOutput(Var f: TextRec): Integer;„  begin„    DualWrite(f);                                        { Write to the File }„    FlushOutput := OldFlushOutput(f);                { Call the old Function }„  end; { FlushOutput }„„Procedure DualExitProc;„  begin„    close(dualf);„    ExitProc := OldExitProc;                { Restore the old Exit Procedure }„    With TextRec(output) do begin„      InOutFunc := @OldInOutOutput;          { Restore the old output Record }„      FlushFunc := @OldFlushOutput;           { Restore the old flush Record }„    end; { With }„  end; { DualExitProc }„„{$F-,I-}„Procedure dual(status: Boolean);„  Var„    ErrorCode : Integer;„  begin„    if status then begin„      assign(dualf,fname);„      if Exist(fname) then { open For writing }„        append(dualf)„      else { start new File }„        reWrite(dualf);„      ErrorCode := Ioresult;   „      if ErrorCode <> 0 then „        halt(ErrorCode);„      With TextRec(output) do begin„        { This is where the old output Functions are rerouted }„        OldInOutOutput := DriverFunc(InOutFunc);„        OldFlushOutput := DriverFunc(FlushFunc);„        InOutFunc := @InOutOutput;„        FlushFunc := @FlushOutput;„      end; { With }„      OldExitProc := ExitProc;            { Save the current Exit Procedure }„      ExitProc    := @DualExitProc;            { Install new Exit Procedure }„      DualOn      := True;„    end { if status }  „    else { switch dual output off } begin  „      if DualOn then begin„        close(dualf);  if Ioresult = 0 then;                   { dummy call }„        ExitProc := OldExitProc;           { Restore the old Exit Procedure }„        OldExitProc := nil;„        With TextRec(output) do begin„          InOutFunc := @OldInOutOutput;     { Restore the old output Record }„          FlushFunc := @OldFlushOutput;      { Restore the old flush Record }„        end; { With }„      end; { if DualOn }„    end; { else }„  end; { dual }„{$I+}  „„„Procedure Initialise;„  { Determines if a File name For the output has been provided. }„  begin„    if GetEnv('DUAL') <> '' then„      fname := GetEnv('DUAL')„    else begin„      if ParamCount <> 0 then begin„        cmdline := String(ptr(PrefixSeg,$80)^);„        cmdline := StUpCase(cmdline);„        if pos('DUAL=',cmdline) <> 0 then begin„          fname := copy(cmdline,pos('DUAL=',cmdline)+5,80);„          if pos(' ',fname) <> 0 then„            fname := copy(fname,1,pos(' ',fname)-1);„        end; { if pos('Dual... }„      end;  { if ParamCount... }„    end; { else }„  end; { Initialise }„  „begin„  Initialise;„end.  „„                                                                                           3      05-28-9313:56ALL                      SWAG SUPPORT TEAM        REDIRCT1.PAS             IMPORT              43          {„All these solutions of using a shell to redirect output.„„There are two Dos interrupts that allow Filehandles to be duplicated.„„Redirec and unredirec allow easy access to dup and dup2 For standard in„and out (input and output are reserved TP Words) to a Text File that you„have previously opened (reset/reWrite/append as appropriate). It must be„opened - this allocates a File handle (a Byte - you declare this, you'll„need it later to get your output back). if you don't unredirec to the„right handle you could loose all your output to the File or a black hole -„be warned.„„You could make similar Procedures to redirec/unredirec For redirection of„other standard handles (3 is Printer (LST), 4 I think is STDERR  and 5„is AUX aren't they?)„„Here's the Unit:„}„„{$O+ $F+}„„Unit ReDIRECt;„„Interface„„Function dup (hand : Byte; Var error : Boolean) : Byte;„   { provides a new handle For an already opened device or File.„     if error, then the return is the error code - 4 no handles available or„     6, invalid handle.}„„Procedure dup2 (source, destination : Byte;  Var err : Byte);„   { Makes two File handles refer to the same opened File at the same„     location. The destination is closed first.„     Err returns 0 if no error or error code as For dup.„     to redirect then return to normal - do as follows:„     1. Use DUP to save the handle to be directed (the source).„     2. Assign and reWrite/reset the destination.„     3. Redirect the handle using DUP2.„     4. Do the exec„     5. Use dup2 again restoring the saved handle.„     6. reset/reWrite the redirected items & close the destination}„„Function Redirec (op : Boolean; Var f:Text; Var hand : Byte) : Boolean;„  {redirects standard out to (if op True) or standard in from File fn.„   returns handle in handle to be used by undirec, below, and True if„   successful.}„„Procedure Undirec (op : Boolean; hand : Byte);„   {undoes the redirection from the previous redirec. Assumes File closed„    by caller.}„„Function getFilehandle(Filename : String; Var error : Boolean) : Integer;„„{////////////////////////////////////////////////////////////////////////}„Implementation„„Uses„  Dos;„„Function dup (hand : Byte; Var error : Boolean) : Byte;„Var„  regs : Registers;„begin„  With regs do„  begin„    AH := $45;„    BX := hand;„„    MsDos (regs);„„    error := flags and fcarry <> 0;  {error if carry set}„„    dup := AX;„  end;„end;„„Procedure dup2 (source, destination : Byte;  Var err : Byte);„Var„  regs : Registers;„begin„  With regs do„  begin„    AH := $46;„    BX := source;„    CX := destination ;„„    MsDos (regs);„„    if flags and fcarry <> 0 then {error if carry set}„      err := AX„    else„      err := 0;„  end;„end;„„Function Redirec (op : Boolean; Var f:Text; Var hand : Byte) : Boolean;„  {redirects standard out to (if op True) or standard in from File fn.„   returns handle in handle to be used by undirec, below, and True if„   successful.}„Var„  err     : Byte;„  error   : Boolean;„begin„  redirec := False;„  err := 0;„  if op then„  begin„    flush (output);„    hand := dup (Textrec(output).handle, error)„  end„  else„  begin„    flush (input);„    hand := dup (Textrec(input).handle, error)„  end;„  if error then„    Exit;„  {$i-}„  if op then„    reWrite (f)„  else„    reset (f);„  {$i+}„  if ioresult <> 0 then„    Exit;„  if op then„    dup2 (Textrec(f).handle, Textrec(output).handle,err)„  else„    dup2 (Textrec(f).handle, Textrec(input).handle,err);„„  redirec := (err = 0);„end;„„Procedure Undirec (op : Boolean; hand : Byte);„   {undoes the redirection from the previous redirec. Assumes File closed„    by caller.}„Var„  err : Byte;„begin„  if op then„  begin„    dup2 (hand, Textrec(output).handle, err);„    reWrite (output)„  end„  else„  begin„    dup2 (hand, Textrec(input).handle, err);„    reset (input)„  end„end; {undirec}„„„Function getFilehandle( Filename : String; Var error : Boolean) : Integer;„Var„  regs : Registers;„  i : Integer;„begin„  Filename := Filename + #0;„  fillChar(regs, sizeof(regs), 0);„„  With regs do„  begin„    ah := $3D;„    AL := $00;„    ds := seg(Filename);„    dx := ofs(Filename) + 1;„  end;„„  MsDos(Regs);„„  I := regs.ax;„„  if (lo(regs.flags) and $01) > 0 then„  begin„    error := True;„    getFilehandle := 0;„    Exit„  end;„„  getFilehandle := i;„end;„„end.„„{ Here's a demo }„„Program dupdemo;„„{$M 2000,0,0}„Uses„  Direc, Dos;„„„Var„  arcname : String;„  tempFile : Text;„  op : Boolean;„  handle : Byte;„  Handle2 : Byte;„  err : Boolean;„  Error : Byte;„  InFile : File;„„begin„  Handle := 0;„„  Handle2 := Dup(Handle,Err);„„  if Err then„  begin„     Writeln('Error getting another handle');„     halt;„  end;„„  arcname := 'C:\qmpro\download\qmpro102.ZIP';„  assign (tempFile, 'C:\qmpro\download\TEMP.FIL');„  ReWrite(TempFile);„„  Dup2(Handle, Handle2, Error);„  if Error <> 0 then„  begin„     Writeln('ERRor: ',Error);„     Halt;„  end;„„„  if redirec(op, tempFile, handle2) then„  begin„    SwapVectors;„    Writeln('Running ZIP!');„    Exec('PKUNZIP',' -V ' + ArcName);„    SwapVectors;„    close (tempFile);„    undirec (op, handle2);„  end„  else„    Writeln('Error!');„end.„„{„I wrote the DUPDEMO Program, but the Unit is the brainchild of an author that I„can't remember, but I use this regularly.  It will work up to TP 7.0, I've„never tested it With TP 7.0 because I don't own it.„}„„         4      05-28-9313:56ALL                      SWAG SUPPORT TEAM        REDIRCT2.PAS             IMPORT              14          {„> When pkzip executes... it Writes to the screen and scrolls my„> screen up. Is there a way in which I can prevent pkzip from writing„> to the screen.„„This thread comes up a bunch.  Here's a tried and tested solution :„}„Unit Redir;„„{ Redirect input, output, and errors }„„Interface„„Procedure RedirectInput (TextFile : String);„Procedure RedirectOutput (TextFile : String);„Procedure StdInput;„Procedure StdOutput;„„Implementation„„Uses„  Dos;„„Const„    STDin  = 0;„    STdoUT = 1;„    STDERR = 2;„„Procedure Force_Dup (Existing,              { Existing handle         }„                     Second     : Word);    { Handle to place it to   }„„Var„  R : Registers;„„begin„„    r.AH := $46;„    r.BX := Existing;„    r.CX := Second;„„    MSDos (R);„„    if (r.Flags and FCarry) <> 0 then„        Writeln ('Error ', r.AX, ' changing handle ', Second);„end;„„„Procedure RedirectInput (TextFile : String);„„Var„    TF : Text;„„begin„    Assign (TF, TextFile);„    Reset (TF);„    Force_Dup (TextRec (TF).Handle, STDin);„end;„„Procedure RedirectOutput (TextFile : String);„„Var„    TF : Text;„„begin„    Assign (TF, TextFile);„    ReWrite (TF);„    Force_Dup (TextRec (TF).Handle, STdoUT);„    Force_Dup (TextRec (TF).Handle, STDERR);„end;„„Procedure StdInput;„„begin„    Assign (Input, '');„    Reset (Input);„end;„„Procedure StdOutPut;„„begin„    Assign (Output, '');„    ReWrite (Output);„end;„„end.„„{------ cut here ------}„{„In your Program :„„Uses Redir;„„begin„     RedirectOutput ('LOGFile.OUT');„     Exec ('PKZIP.EXE', '');„     StdOutPut;„end.„}                                                                                                          5      05-28-9313:56ALL                      SWAG SUPPORT TEAM        REDIRCT3.PAS             IMPORT              32          {„MARK LEWIS„„>> Still need a bit of help here.  I can't redirect output from a„>> Program when executing it from a Pascal Program!  Is there any„>> this from Pascal? Any help would be greatly appreciated.„> if I understand you, you are using the Exec Procedure to run a„> Program.  if that is the Case you won't be ablr to redirect since„> this is a Function of Dos and not the Program you exec.  You will„> need to run the Program through a child process in order to„> perform the redirect, something like:„> Exec(GetEnv('COMSPEC'),'/C MyProg.exe>redirect');„„one could also utilize duplicate File handles -=B-)„„}„Unit Execute;„„Interface„„Procedure Exec(Path, CmdLine : String);„„Implementation„„Uses„  Dos;„„Function ExtractFileName(Var Line : String; Index : Integer) : String;„Var„  Temp : String;„begin„  Delete(Line, Index, 1);„  While (Index <= Length(Line)) and (Line[Index] = ' ') Do„    Delete(Line, Index, 1);„  Temp := '';„  While (Index <= Length(Line)) and (Line[Index] <> ' ') Do„  begin„    Temp := Temp + Line[Index];„    Delete(Line, Index, 1);„  end;„  ExtractFileName := Temp;„end;„„Procedure CloseHandle(Handle : Word);„Var„  Regs : Registers;„begin„  With Regs Do„  begin„    AH := $3E;„    BX := Handle;„    MsDos(Regs);„  end;„end;„„Procedure Duplicate(SourceHandle : Word;Var TargetHandle : Word);„Var„  Regs : Registers;„begin„  With Regs Do„  begin„    AH := $45;„    BX := SourceHandle;„    MsDos(Regs);„    TargetHandle := AX;„  end;„end;„„Procedure ForceDuplicate(SourceHandle : Word;Var TargetHandle : Word);„Var„  Regs : Registers;„begin„  With Regs Do„  begin„    AH := $46;„    BX := SourceHandle;„    CX := TargetHandle;„    MsDos(Regs);„    TargetHandle := AX;„  end;„end;„„Procedure Exec(Path,CmdLine : String);„Var„  StdIn,„  Stdout    : Word;„  Index     : Integer;„  FName     : String[80];„  InFile,„  OutFile   : Text;„  InHandle,„  OutHandle : Word;„         { ===============>>>> }   { change below For STDERR }„begin„  StdIn  := 0;„  StdOut := 1;                    { change to 2 For StdErr       }„  Duplicate(StdIn, InHandle);      { duplicate standard input     }„  Duplicate(StdOut, OutHandle);    { duplicate standard output    }„  Index := Pos('>', CmdLine);„  if Index > 0 Then               { check For output redirection }„  begin„    FName := ExtractFileName(CmdLine, Index);  { get output File name  }„    Assign(OutFile, FName);                    { open a Text File      }„    ReWrite(OutFile);                         { .. For output         }„    ForceDuplicate(TextRec(OutFile).Handle, StdOut);{ make output same }„  end;„  Index := Pos('<', CmdLine);„  if Index > 0 Then               { check For input redirection }„  begin„    FName := ExtractFileName(CmdLine, Index);  { get input File name  }„    Assign(InFile, FName);                     { open a Text File     }„    Reset(InFile);                            { For input            }„    ForceDuplicate(TextRec(InFile).Handle, StdIn);  { make input same }„  end;„  Dos.Exec(Path, CmdLine);           { run EXEC }„  ForceDuplicate(InHandle, StdIn);   { put standard input back to keyboard }„  ForceDuplicate(OutHandle, StdOut); { put standard output back to screen  }„  CloseHandle(InHandle);            { close the redirected input File     }„  CloseHandle(OutHandle);           { close the redirected output File    }„end;„„end.„„{===============================================================}„{„Use it exactly as you would the normal EXEC Procedure:„„  Exec('MAsm.EXE','mystuff.Asm');„„To activate redirection simply add the redirection symbols, etc:„„  Exec('MAsm.EXE','mystuff.Asm >err.lst');„„„One note of caution.  This routine temporarily Uses extra handles. It's„either two or four more.  The Various books I have are not clear as to„whether duplicated handles 'count' or not. My guess is yes.  if you don't„plan on redirecting STDIN then remove all the code For duplicating it to„cut your handle overhead in half.„}„„                   6      01-27-9412:19ALL                      FRED JOHNSON             Redirection              IMPORT              16     Üu   {„Here's a neat little ditty I converted from a C++ tip I saw in a mag a few„years ago.  It tests to see if its own output has been redirected and„returns a 1 if TRUE (redirected) or a 0 if FALSE (not redirected). This„function includes a sample prog that demonstrates its use. SIDE NOTE: I„put this function in the U_FILE.pas.tpu for use with all of my home-grown„file related functions and procedures.„„TEST WITH: Test_Red (enter)„   [you should see a NOT REDIRECTED msg, 10 lines and a FINISHED msg.]„„TEST WITH: Test_Red > this.dat (enter)„   [you should see a REDIRECTED msg, (no lines) and a FINISHED msg„    and the output of the lines will be in the this.dat file]„}„„program test_red;„„{$A+,B-,D-,E-,F-,G-,I+,L-,N-,O-,P-,Q-,R-,S+,T-,V+,X-}„{$M 1024,0,655360}„„{*******************************************************************!HDR**„** Function Name: fn_bRedirected()„** Description  : Determines if output has been redirected;„** Returns      : Integer to be treated as boolean;„** Calls        :„** Special considerations:„** Modification history:„** Created: 11/03/93 20:23„*********************************************************************!END}„„function fn_bRedirected : Integer; Assembler; {Treated as BOOLEAN}„asm„  push  ds„  mov   ax,      prefixseg„  mov   ds,      ax„  xor   bx,      bx„  les   bx,      [bx + $34]„  mov   al,      es:[bx]„  mov   ah,      es:[bx +1]„  pop   ds„  cmp   al,      ah„  mov   ax,      1„  jne   @_exit„  xor   ax,      ax„ @_exit:„  {mov   @Result, AX}„end;„„var„  Count    : Byte;„  hOutFile : text;„„begin„  Assign(hOutFile, 'CON');„  ReWrite(hOutFile);„  if not (boolean(fn_bRedirected)) then„    writeln(hOutFile, 'Not Redirected')„  else„    writeln(hOutFile, 'Please wait while redirection is in progress');„  for Count := 1 to 10 do„    writeln('Line ', Count : 2);„  writeln(hOutFile, 'Finished!');„end.„                                                  