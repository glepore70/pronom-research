SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00014         TEXT EDITING ROUTINES                                             1      05-28-9314:08ALL                      SWAG SUPPORT TEAM        CENTER1.PAS              IMPORT              5      F…œx {„>Anyways, does anyone here have a quick and easy Procedure or„>Function For centering Text?„}„„Program CenterIt_Demo;„„Uses„  Crt;„„{ Display a String centered on the screen. }„Procedure DisplayCenter(st_Temp : String; by_Yaxis : Byte);„begin„  GotoXY(((Succ(Lo(WindMax)) - Length(st_Temp)) div 2), by_Yaxis);„  Writeln(st_Temp);„end; {DisplayCenter. }„„Var„  by_OldAttr : Byte;„„begin„  ClrScr;„  DisplayCenter('The Spirit of Elvis says... Hi!', 10);„  ReadKey;„end.„                                          2      05-28-9314:08ALL                      SWAG SUPPORT TEAM        CENTER2.PAS              IMPORT              3      F…ÃV { Center Text }„„Uses Crt;„Var„  s : String;„  i : Integer;„begin„  Write('String? ');„  readln(s);„  i := (succ(lo(windmax)) - length(s)) shr 1;„  gotoXY(i,10);„  Write(s);„end.„                                                                             3      05-28-9314:08ALL                      SWAG SUPPORT TEAM        FORMAT1.PAS              IMPORT              14     F…8â {„> - How can I get TP to make what ever the user enters in to CAPS or     ≥„>   NONCAPS?  Example:                                                   ≥„>                     Enter Name -> ChRiS BrAtEnE                        ≥„>                     Your name is Chris Bratene? (Y/n)?                 ≥„„„I just wrote a routine that does this on the fly, so to speak, For„another user, and I haven't erased it yet, so here it is (slightly„modified, so that it Forces lowerCase, too):„}„„Uses„  Crt;„„Procedure Backspace;„begin„  Write(#8' '#8)„end;„„Function LoCase(ch : Char) : Char;„begin„  if ch in ['A'..'Z'] then„    LoCase := Char(ord(ch)+32)„  else„    LoCase := ch;„end;„„Procedure Dibble(Var st : String);„{ Forces upperCase For first letter in each Word,„  lowerCase For other letters. }„Var„  len : Byte Absolute st;„  ch : Char;„„  Function ForceCap : Boolean;„  begin„    ForceCap := (len = 0) or (st[len] = ' ');„  end;„„begin„  st := '';„  Repeat„    ch := ReadKey;„    if ForceCap then„      ch := upCase(ch)„    else„      ch := LoCase(ch);„    Case ch of„      #8  : if len > 0 then„            begin„              Backspace;„              dec(len);„            end;„      #27 : While len > 0 do„            begin„              BackSpace;„              dec(len);„            end;„      #0  : ch := ReadKey;„„      else„        begin„          Write(ch);„          st := st + ch;„        end;„„    end;„  Until ch in [#13,#27];„„  Writeln;„„end;„„„Var„  st : String;„„begin { test }„  Writeln;„  Write('Enter String:  ');„  Dibble(st);„  Writeln(st);„end.„                                                                                            4      05-28-9314:08ALL                      SEAN L. PALMER           GHOSTED.PAS              IMPORT              77     F…™ TR>Can anyone (please, it's important) , post here an example of a source code„TR>that will show a text file , and let me scroll it (Up , Down ) ?„TR>Also I need an example of a simple editor.„„Try this for an example. Turbo Pascal 6.0+ source.„Compiles to a 7K text editor. Neat?„„{$A-,B-,D-,E-,F-,G-,I-,L-,N-,O-,R-,S-,V-,X+}„{$M $C00,0,0}„program ghostEd; {Ghost Editor v0.4 (C) 1993 Sean L. Palmer}„const„ version='0.4';„ maxF=$3FFF;     {only handles small files!}„ txtColor=$B;„ vSeg:word=$B800;„var„ nLines:byte;„ halfPage:byte;„ txt:array[0..maxF]of char;„ crs,endF,pgBase,lnBase:integer;„ x,y:word;„ update:boolean;„ theFile:file;„ ticks:word absolute $40:$6C;   {ticks happen 18.2 times/second}„„procedure syncTick;var i:word;begin i:=ticks;repeat until i<>ticks;end;„„function readKey:char;assembler;asm mov ah,$07; int $21; end;„„function keyPressed:boolean;assembler;asm mov ah,$B; int $21; and al,$FE;„end; „„procedure moveScrUp(s,d,n:word);assembler;asm„ mov cx,n;„ push ds;„ mov ax,vSeg; mov es,ax; mov ds,ax;„ mov si,s; shl si,1;„ mov di,d; shl di,1;„ cld; repz movsw; {attr too!}„ pop ds; @X:„ end;„„procedure moveScrDn(s,d,n:word);assembler;asm„ mov cx,n;„ push ds;„ mov ax,vSeg; mov es,ax; mov ds,ax;„ mov si,s; add si,cx; shl si,1;„ mov di,d; add di,cx; shl di,1;„ std; repz movsw; {attr too!}„ pop ds; @X:„ end;„„procedure moveScr(var s;d,n:word);assembler;asm„ mov cx,n; jcxz @X;„ push ds;„ mov ax,vSeg; mov es,ax;„ mov di,d; shl di,1;„ lds si,s;„ cld;„@L: movsb; inc di; loop @L;„ pop ds; @X:„ end;„„procedure fillScr(d,n:word;c:char);assembler;asm„ mov cx,n; jcxz @X;„ mov ax,vSeg; mov es,ax;„ mov di,d; shl di,1;„ mov al,c; cld;„@L: stosb; inc di; loop @L;„@X:„ end;„„procedure fillAttr(d,n:word;c:byte);assembler;asm„ mov cx,n; jcxz @X;„ mov ax,vSeg; mov es,ax;„ mov di,d; shl di,1;„ mov al,c; cld;„@L: inc di; stosb; loop @L;„@X:„ end;„„procedure cls;begin„ fillAttr(80,pred(nLines)*80,txtColor);„ fillScr(80,pred(nLines)*80,' ');„ end;„„procedure scrollUp;begin„ moveScrUp(320,160,pred(nLines)*160);„ fillScr(pred(nLines)*160,80,' ');„ end;„procedure scrollDn;begin„ moveScrDn(160,320,pred(nLines)*320);„ fillScr(160,80,' ');„ end;„„{put cursor after preceding CR or at 0}„function scanCrUp(i:integer):integer;assembler;asm„ mov di,i; mov cx,di; add di,offset txt„ mov ax,ds; mov es,ax;„ std; mov al,$D;„ dec di;„ repnz scasb;„ jnz @S; inc di; @S:„ inc di;„ sub di,offset txt;„ mov ax,di;„ end;„„{put cursor on next CR or endF}„function scanCrDn(i:integer):integer;assembler;asm„ mov di,i; mov cx,endF;„ sub cx,di; inc cx; add di,offset txt;„ mov ax,ds; mov es,ax;„ cld; mov al,$D;„ repnz scasb;„ dec di;„ sub di,offset txt;„ mov ax,di;„ end;„„procedure findxy;begin„ lnBase:=scanCrUp(crs);x:=crs-lnBase;„ y:=1;pgBase:=lnBase;„ while(pgBase>0)and(y<halfPage) do begin„  pgBase:=scanCrUp(pred(pgBase)); inc(y);„  end;„ end;„„procedure display;var i,j,k,oldY:integer;begin„ findXY;„ if update then begin„  update:=false;„  j:=pgBase;i:=1;„  while (j<=endf) and (i<pred(nLines)) do begin„   k:=scanCrDn(j);„   moveScr(txt[j],i*80,k-j);„   fillScr(i*80+k-j,80-k+j,' ');„   fillAttr(i*80,80,txtColor);„   j:=succ(k); inc(i);„   end;„  if i<pred(nLines) then begin„   fillScr(i*80,80*pred(nLines-i),'X');„   fillAttr(i*80,80*pred(nLines-i),1);„   end;„  end„ else begin„>>> Continued to next message„„ * OLX 2.2 * "Could you continue your petty bickering? I find it most „„--- Maximus 2.01wb„ * Origin: >>> Sun Mountain BBS <<< (303)-665-6922 (1:104/123)„„>>> Continued from previous message„  i:=scanCrDn(lnBase)-lnBase;„  moveScr(txt[lnBase],y*80,i);„  fillScr(y*80+i,80-i,' ');„  end;„ end;„„const menuStr:string='Ghost Editor v'+version+'-(C) Sean Palmer 1993';„procedure title;begin„ fillAttr(0,80,$70);fillScr(0,80,' ');„ MoveScr(MenuStr[1],1,length(MenuStr));„ end;„„procedure error(s:string);begin„ fillattr(0,80,$CE);fillScr(0,80,' ');„ moveScr(s[1],1,length(s));„ write(^G);readkey;„ title;„ end;„„procedure tooBigErr;begin error('File too big');end;„„procedure insChar(c:char);forward;„procedure delChar;forward;„procedure backChar;forward;„„procedure trimLine;var i,t,b:integer;begin„ i:=crs;„ b:=scanCrDn(crs); t:=scanCrUp(crs);„ crs:=b;„ while txt[crs]=' ' do begin„  delchar;„  if i>crs then dec(i);„  if crs>0 then dec(crs);„  end;„ crs:=i;„ end;„„procedure checkWrap(c:integer);var i,t,b:integer;begin„ b:=scanCrDn(c); t:=scanCrUp(c);„ i:=b;„ if i-t>=79 then begin„  i:=t+79;„  repeat dec(i); until (txt[i]=' ')or(i=t);„  if i=t then backChar   {just disallow lines that long with no spaces}„  else begin„   txt[i]:=^M;  {change sp into cr, to wrap}„   update:=true;„   if (b<endF)and(txt[b]=^M)and(txt[succ(b)]<>^M) then begin„    txt[b]:=' '; {change cr into sp, to append wrapped part to next line}„    checkWrap(b); {recursively check next line since it got stuff added}„    end;„   end;„  end;„ end;„„procedure changeLines;begin„ trimLine; update:=true;  {signal to display to redraw}„ end;„„procedure insChar(c:char);begin„ if endf=maxF then begin tooBigErr;exit;end;„ move(txt[crs],txt[succ(crs)],endf-crs);„ txt[crs]:=c;inc(crs);inc(endf);„ if c=^M then changeLines;„ checkWrap(crs);„ end;„procedure delChar;begin„ if crs=endf then exit;„ if txt[crs]=^M then changeLines;„ move(txt[succ(crs)],txt[crs],endf-crs);„ dec(endf);„ checkWrap(crs);„ end;„„procedure addLF;var i:integer;begin„ for crs:=endF downto 1 do if txt[pred(crs)]=^M then begin„  insChar(^J); dec(crs);„  end;„ end;„„procedure stripLF;var i:integer;begin„ for crs:=endF downto 0 do if txt[crs]=^J then delChar;„ end;„„procedure writeErr;begin error('Write Error');end;„„procedure saveFile;begin„ addLF;„ rewrite(theFile,1);„ if ioresult<>0 then writeErr„ else begin„  blockwrite(theFile,txt,endf);„  if ioresult<>0 then writeErr;„  close(theFile);„  end;„ end;„„procedure newFile;begin crs:=0;endF:=0;update:=true;end;„„procedure readErr;begin error('Read Error');end;„„procedure loadFile;var i,n:integer;begin„ reset(theFile,1);„ if ioresult<>0 then newFile„ else begin„  n:=filesize(theFile);if n>maxF then begin tooBigErr;n:=maxF;end;„  blockread(theFile,txt,n,i);if i<n then readErr;„  close(theFile);„  crs:=0;endf:=i;update:=true;„  stripLF;„  end;„ end;„„procedure signOff;var f:file;i,n:integer;begin„ assign(f,'signoff.txt');„ reset(f,1);„ if ioresult<>0 then error('No SIGNOFF.TXT defined')  {no macro defined}„ else begin„  n:=filesize(f);„  blockread(f,txt[endF],n,i);if i<n then readErr;„  close(f);„  inc(endf,i);update:=true;„  i:=crs; stripLF; crs:=i; {stripLF messes with crs}„  end;„ end;„„procedure goLf;begin„ if crs>0 then dec(crs);„ if txt[crs]=^M then changeLines;„ end;„procedure goRt;begin„ if txt[crs]=^M then changeLines;„ if crs<endf then inc(crs);„ end;„procedure goCtrlLf;var c:char;begin„ repeat goLf;c:=txt[crs];until (c<=' ')or(crs=0);„ end;„procedure goCtrlRt;var c:char;begin„ repeat goRt;c:=txt[crs];until (c<=' ')or(crs>=endF);„ end;„procedure goUp;var i:integer;begin„ if lnBase>0 then begin„  changeLines;„  lnBase:=scanCrUp(pred(lnBase));crs:=lnBase;„  i:=scanCrDn(crs)-crs;„>>> Continued to next message„„ * OLX 2.2 * "Could you continue your petty bickering? I find it most „„--- Maximus 2.01wb„ * Origin: >>> Sun Mountain BBS <<< (303)-665-6922 (1:104/123)„                                                                             „ „                           >>> Continued from previous message„  if i>=x then inc(crs,x) else inc(crs,i);„  end;„ end;„procedure goDn;var i:integer;begin„ changeLines;„ crs:=scanCrDn(crs);if crs>=endF then exit;„ inc(crs);lnBase:=crs;„ i:=scanCrDn(crs)-crs;„ if i>=x then inc(crs,x) else inc(crs,i);„ end;„procedure goPgUp;var i:byte;begin for i:=halfPage downto 0 do goUp; end;„procedure goPgDn;var i:byte;begin for i:=halfPage downto 0 do goDn; end;„procedure goHome;begin crs:=scanCrUp(crs); end;„procedure goEnd;begin crs:=scanCrDn(crs); end;„„procedure backChar;begin„ if (crs>0) then begin goLf; delChar; end;„ end;„„procedure deleteLine;var i:integer;begin„ i:=scanCrDn(crs);crs:=scanCrUp(crs);„ if i<endF then begin move(txt[succ(i)],txt[crs],endf-i); dec(endF);end;„ dec(endf,i-crs); changeLines;„ end;„„procedure flipCursor;var j,k,l:word;begin„ j:=succ((y*80+x)shl 1);„ l:=mem[vSeg:j];   {save attr under cursor}„ mem[vSeg:j]:=$7B; if not keypressed then syncTick;„ mem[vSeg:j]:=l; if not keypressed then syncTick;„ end;„„procedure edit;var c:char;begin„ repeat„  display;„  repeat flipcursor;until keypressed;„  c:=readkey;„  if c=#0 then case readkey of„   #59:signOff;„   #75:goLf;„   #77:goRt;„   #115:goCtrlLf;„   #116:goCtrlRt;„   #72:goUp;„   #80:goDn;„   #83:delChar;„   #73:goPgUp;„   #81:goPgDn;„   #71:goHome;„   #79:goEnd;„   end„  else case c of„   ^[:saveFile;„   ^H:backChar;„   ^C:{abortFile};„   ^Y:deleteLine;„   else insChar(c);„   end;„  until (c=^[)or(c=^C);„ end;„„function getRows:byte;assembler;asm„ mov ax,$1130; xor dx,dx; int $10;„ or dx,dx; jnz @S; mov dx,24; @S: {cga/mda don't have this fn}„ inc dx; mov al,dl;„ end;„„var oldMode:byte;„begin„ asm mov ah,$F; int $10; mov oldMode,al; end;  {save old Gr mode}„ if oldMode=7 then vSeg:=$B000;  {check for Mono}„ nLines:=getRows;„ halfPage:=pred(nLines shr 1);„ cls; title;„ if paramCount=0 then error('Need filename as parameter')„ else begin„  asm mov bh,0; mov dl,0; mov dh,nLines; mov ah,2; int $10; end; {put cursor„of   assign(theFile,paramStr(1));„  loadFile;„  edit;„  end;„ end.„„ * OLX 2.2 * "Could you continue your petty bickering? I find it most „„--- Maximus 2.01wb„ * Origin: >>> Sun Mountain BBS <<< (303)-665-6922 (1:104/123)„                                                                             „ „                                                                                                                           5      05-28-9314:08ALL                      SWAG SUPPORT TEAM        WORDWRP1.PAS             IMPORT              12     F…† {This was a Programming contest Program- BTW, this is to Van„Slingerhead, not to Mike...„}„Program Wordwrap; „Uses Crt,Printer; „Const„  max = 10; „Var„  ch : Char;„  arr : Array[1..800] of Char;„  small,„  s : String;„  w,„  len,„  counter : Integer; „begin„  w := 1;„  Writeln; Writeln;„  Repeat„    arr[w] := ReadKey;„    inc(w);„    if arr[w-1] = #8 then„      begin„        Write(#8' '#8);„        if w > 2 then„          dec(w,2)„        else„          w:= 1;„      end  { if }„    else„      Write(arr[w-1]);„  Until arr[w-1] = #13;„  arr[w-1] := ' ';„„  dec(w);„  Writeln; Writeln;„  For counter := 1 to w do„    Write(arr[counter]);„„  small := '';„  len := 0;„  Writeln(lst);„  Writeln(lst,'123456789012345678901234567890123456789012345');„  Writeln(lst,'         ^         ^         ^         ^    ^');„  For counter := 1 to w do„    begin„      if arr[counter] <> ' ' then„        begin„          small := small + arr[counter];„          inc(len);„        end„      else„        if len <= 45 then„          begin„            Write(lst,small,' ');„            small := '';„            inc(len);„          end„        else„          begin„            Writeln(lst);„            Write(lst,small,' ');„            len := length(small)+1;„            small := '';„          end;  { else }„    end; „end.„„                                                                                                 6      05-28-9314:08ALL                      SWAG SUPPORT TEAM        WORDWRP2.PAS             IMPORT              18     F…a∆ {„>    P.S.  A pre-made Unit to do a Word-wrap Function might also be nice.„}„„Unit WordWrap;„„Interface„„Uses„  Crt;„„Type„  Strn80 = String[80];„„Const„  MaxWordLineLength : Byte = 80;„„Var„  WordLine  : Strn80;„  Index1    : Byte;„  Index2    : Byte;„„Procedure ResetWrapStrn;„Procedure WrapStrn (InputStrn: Strn80);„„Implementation„„Procedure ResetWrapStrn;„begin„  Index1 := 0;„  Index2 := 0;„  Wordline := '';„end;„„Procedure WrapStrn (InputStrn: Strn80);„Var„  Count : Byte;„  InputChar : Char;„begin„  For Count := 1 to Length (InputStrn) do„  begin„    InputChar := InputStrn[Count];„    Case InputChar OF„      ^H: {Write destructive backspace & remove Char from WordLine}„          begin„            Write(^H,' ',^H);„            DELETE(WordLine,(LENGTH(WordLine) - 1),1)„          end;„      #0: {user pressed a Function key, so dismiss it}„          begin„            InputChar := ReadKey; {Function keys send two-Char scan code!}„            InputChar := ' '„          end;„      #13: { it is an enter key.. reset everything and start on a new line}„          begin„            Writeln;„            Index1 := 0; Index2 := 0; Wordline := '';„          end;„      else {InputChar contains a valid Char, so deal With it}„      begin„        Write(InputChar);„        WordLine := (WordLine + InputChar);„        if (LENGTH(WordLine) >= (MaxWordLineLength - 1)) then„        {we have to do a Word-wrap}„        begin„          Index1 := (MaxWordLineLength - 1);„          While ((WordLine[Index1] <> ' ') and (WordLine[Index1] <> '-')„                  and (Index1 <> 0)) DO„            Index1 := (Index1 - 1);„          if (Index1 = 0) then {whoah, no space was found to split line!}„            Index1 := (MaxWordLineLength - 1); {forces split}„          DELETE(WordLine,1,Index1);„          For Index2 := 1 to LENGTH(WordLine) DO„            Write(^H,' ',^H);„          Writeln;„          Write(WordLine)„        end„      end„    end; {CASE InputChar}„  end;„end;„„begin {WordWrap}„{Initialize the Program.}„WordLine  := '';„Index1    := 0;„Index2    := 0;„end.„                                                                                                     7      05-28-9314:08ALL                      SWAG SUPPORT TEAM        WORDWRP3.PAS             IMPORT              28     F…Ãû Var„  S : String;„„Function Wrap(Var st: String; maxlen: Byte; justify: Boolean): String;„  { returns a String of no more than maxlen Characters With the last   }„  { Character being the last space beFore maxlen. On return st now has }„  { the remaining Characters left after the wrapping.                  }„  Const„    space = #32;„  Var„    len      : Byte Absolute st;„    x,„    oldlen,„    newlen   : Byte;„„  Function JustifiedStr(s: String; max: Byte): String;„„    { Justifies String s left and right to length max. if there is more }„    { than one trailing space, only the right most space is deleted. The}„    { remaining spaces are considered "hard".  #255 is used as the Char }„    { used For padding purposes. This will enable easy removal in any   }„    { editor routine.                                                   }„„    Const„      softSpace = #255;„    Var„      jstr      : String;„      len       : Byte Absolute jstr;„    begin„      jstr := s;„      While (jstr[1] = space) and (len > 0) do   { delete all leading spaces }„        delete(jstr,1,1);„      if jstr[len] = space then„        dec(len);                                { Get rid of trailing space }„      if not ((len = max) or (len = 0)) then begin„        x := pos('.',jstr);     { Attempt to start padding at sentence break }„        if (x = 0) or (x =len) then       { no period or period is at length }„          x := 1;                                    { so start at beginning }„        if pos(space,jstr) <> 0 then Repeat        { ensure at least 1 space }„          if jstr[x] = space then                      { so add a soft space }„            insert(softSpace,jstr,x+1);„          x := succ(x mod len);  { if eoln is reached return and do it again }„        Until len = max;        { Until the wanted String length is achieved }„      end; { if not ... }„      JustifiedStr := jstr;„    end; { JustifiedStr }„„„  begin  { Wrap }„    if len <= maxlen then begin                       { no wrapping required }„      Wrap := st;„      len  := 0;„    end else begin„      oldlen := len;                { save the length of the original String }„      len    := succ(maxlen);                        { set length to maximum }„      Repeat                     { find last space in st beFore or at maxlen }„        dec(len);„      Until (st[len] = space) or (len = 0);„      if len = 0 then                   { no spaces in st, so chop at maxlen }„        len := maxlen;„      if justify then„        Wrap := JustifiedStr(st,maxlen)„      else„        Wrap := st;„      newlen :=  len;          { save the length of the newly wrapped String }„      len := oldlen;              { and restore it to original length beFore }„      Delete(st,1,newlen);              { getting rid of the wrapped portion }„    end;„  end; { Wrap }„„begin„  S :=„'By Far the easiest way to manage a database is to create an '+„'index File. An index File can take many Forms and its size will depend '+„'upon how many Records you want in the db. The routines that follow '+„'assume no more than 32760 Records.';„„While length(S) <> 0 do„  Writeln(Wrap(S,60,True));„end.„„Whilst this is tested and known to work on the example String, no further„testing than that has been done.  I suggest you test it a great deal more„beFore being satisfied that it is OK.„„                                                                                                                             8      08-17-9308:51ALL                      SWAG SUPPORT TEAM        Text Wrapping and JustifyIMPORT              28     F…   Uses CRT;„var„  S : string;„„function Wrap(var st: string; maxlen: byte; justify: boolean): string;„  { returns a string of no more than maxlen characters with the last   }„  { character being the last space before maxlen. On return st now has }„  { the remaining characters left after the wrapping.                  }„  const„    space = #32;„  var„    len      : byte absolute st;„    x,„    oldlen,„    newlen   : byte;„„  function JustifiedStr(s: string; max: byte): string;„„    { Justifies string s left and right to length max. If there is more }„    { than one trailing space, only the right most space is deleted. The}„    { remaining spaces are considered "hard".  #255 is used as the char }„    { used for padding purposes. This will enable easy removal in any   }„    { editor routine.                                                   }„„    const„      softSpace = #255;„    var„      jstr      : string;„      len       : byte absolute jstr;„    begin„      jstr := s;„      while (jstr[1] = space) and (len > 0) do   { delete all leading spaces }„        delete(jstr,1,1);„      if jstr[len] = space then„        dec(len);                                { Get rid of trailing space }„      if not ((len = max) or (len = 0)) then begin„        x := pos('.',jstr);     { Attempt to start padding at sentence break }„        if (x = 0) or (x =len) then       { no period or period is at length }„          x := 1;                                    { so start at beginning }„        if pos(space,jstr) <> 0 then repeat        { ensure at least 1 space }„          if jstr[x] = space then                      { so add a soft space }„            insert(softSpace,jstr,x+1);„          x := succ(x mod len);  { if eoln is reached return and do it again }„        until len = max;        { until the wanted string length is achieved }„      end; { if not ... }„      JustifiedStr := jstr;„    end; { JustifiedStr }„„„  begin  { Wrap }„    if len <= maxlen then begin                       { no wrapping required }„      Wrap := st;„      len  := 0;„    end else begin„      oldlen := len;                { save the length of the original string }„      len    := succ(maxlen);                        { set length to maximum }„      repeat                     { find last space in st before or at maxlen }„        dec(len);„      until (st[len] = space) or (len = 0);„      if len = 0 then                   { no spaces in st, so chop at maxlen }„        len := maxlen;„      if justify then„        Wrap := JustifiedStr(st,maxlen)„      else„        Wrap := st;„      newlen :=  len;          { save the length of the newly wrapped string }„      len := oldlen;              { and restore it to original length before }„      Delete(st,1,newlen);              { getting rid of the wrapped portion }„    end;„  end; { Wrap }„„begin„  S :=„'By far the easiest way to manage a database is to create an '+„'index file. An index file can take many forms and its size will depend '+„'upon how many records you want in the db. The routines that follow '+„'assume no more than 32760 records.';„„while length(S) <> 0 do„  writeln(Wrap(S,75,true));„Readkey;„end.„„Whilst this is tested and known to work on the example string, no further„testing than that has been done.  I suggest you test it a great deal more„before being satisfied that it is OK.„„                                                                                                          9      08-27-9322:12ALL                      BRIAN PAPE               Write String in ASM      IMPORT              9      F…   {„BRIAN PAPE„„Ok, I was writing a little program that I was trying to make as small as„possible, so I wrote this little WriteString function.  Since I'm not an„assembly language mogul by any stretch of the imagination, could one of„you assembly wizards out there tell me if this is Ok.  I mean, it works„fine (and saves almost 1k over linking in the writeln code), but I want„to make sure that I'm not trashing a register or something that needs to„be preserved.  Thanks...  BTW, anybody, go ahead and use it if it„doesn't crash!„}„„procedure WriteString(s : string); assembler;„asm„  push ds„  mov  ah, 40h    { DOS fcn call 40h write string to file handle }„„  mov  dx, seg s„  mov  ds, dx„  mov  bx, offset s„„  mov  dx, bx     { now put the offset into dx for the fcn call }„  inc  dx         { plus 1, to avoid the length byte }„  mov  cl, [bx]   { cl is length to write }„  xor  ch, ch„„  mov  bx, 1      { file handle to write to }„  int  21h„  pop  ds„end;„„                                                          10     02-03-9407:05ALL                      MIKE COPELAND            Text Word Wrap           IMPORT              25     F…   „{„   Here's some code I found in this echo a number of years ago - I don't„recall who should get credit for it.  I put it into my own program,„which uses some other Units, and I hope I've sanitized it enough to make„it generic...„„Uses a FASTWRITE routine that can be found in SWAG G.D. 02/01/94 }„„„program WordWrap;„uses CRT;„const„   FKeyCode          = #00;„   Space             = ' ';„   Hyphen            = '-';„   BackSpace         = #08;„   C_R               = #13;„   MaxWordLineLength = 60;„   MAXLINES          = 6;  { Maximum # of lines in "box" }„var„   WordLine  : string[MaxWordLineLength];„   Index1    : byte;„   Index2    : byte;„   InputChar : char;„   LINE      : byte;               { current output line }„   LC        : byte;                        { Line Count }„   I         : Word;„   S1        : string;„   LA        : array[1..MAXLINES] of string[MaxWordLineLength];„begin„  WordLine := ''; Index1 := 0; Index2 := 0; InputChar := Space;„  ClrScr; Write ('Enter text (',MAXLINES:0,' line maximum): ');„  for I := 1 to MAXLINES do  { clear storage array }„    LA[I] := '';„  InputChar := ReadKey;„  LC := 1; LINE := 6; gotoXY (1,20);               { work area }„  while LC <= MAXLINES do„    begin„      case InputChar of„        #13      : begin                { C/R - terminate line }„                     S1 := WordLine;„                     Writeln (S1); LA[LC] := S1; Inc(LC);„                     gotoXY (1,20); ClrEol; WordLine := ''„                   end;„        BackSpace:„          begin„            Write(BackSpace,Space,BackSpace);„            if Length(WordLine) > 0 then Dec(WordLine[0])„          end;„        FKeyCode:                         { flush function key }„          begin„            InputChar := ReadKey; InputChar := Space„          end„        else                                      { valid char }„          begin„            Write(InputChar); WordLine := WordLine+InputChar;„            if (Length(WordLine) >= (MaxWordLineLength - 1)) then„              begin                  { have to do a word-wrap }„                Index1 := MaxWordLineLength-1;„                while ((WordLine[Index1] <> Space) and„                       (WordLine[Index1] <> Hyphen) and„                       (Index1 <> 0))„                  do Dec(Index1);„                if (Index1 = 0) then  {no space was found to split!}„                  Index1 := (MaxWordLineLength-1);    {forces split}„                S1 := Copy(WordLine,1,Index1);„                Delete(WordLine,1,Index1);„                for Index2 := 1 TO LENGTH(WordLine) do„                  Write(BackSpace,Space,BackSpace);„                FastWrite (1,LINE,LONORM,S1); Inc(LINE);„                LA[LC] := S1; Inc(LC);„                gotoXY (1,20) ClrEol; Write(WordLine)„              end„          end„      end;                                          {case InputChar}„      InputChar := ReadKey                  {Get next key from user}„    end;                       {while (InputChar <> CarriageReturn)}„end.„                                              11     02-03-9416:07ALL                      SWAG SUPPORT TEAM        Justification Routine    IMPORT              23     F…   UNIT JUSTIFY;„„INTERFACE„„PROCEDURE JustifyLine (VAR LINE : STRING; Printwidth : BYTE);„„IMPLEMENTATION„„PROCEDURE JustifyLine (VAR LINE : STRING; Printwidth : BYTE);„{ justify line to a length of printwidth by putting extra blanks between„  words, from right to left.  The line currently has one blank between words.}„„VAR„   blanks,               {# of blanks to be inserted}„   gaps,                 {# of gaps between words}„   n,                    {amount to expand 1 gap}„   dest,                 {new place for moved char}„   source : INTEGER;     {source column of that char}„   len    : BYTE ABSOLUTE Line;„„BEGIN {justify}„„           IF (LINE > '') AND (len < printwidth) THEN„                  BEGIN„                  {set hard spaces for indents}„                  source := 1;„                  WHILE (LINE [source] = ' ') AND (source < len) DO„                        BEGIN„                        LINE [source] := #0;„                        INC(source);„                        END;„„                  {count # of gaps between words}„                  gaps := 0;„                  FOR source := 1 TO len DO„                      IF LINE [source] = ' ' THEN gaps := SUCC (gaps);„„                  {find # of blanks needed to stretch the line}„                  blanks := printwidth - len;„                  {shift characters to the right, distributing extra blanks}„                  {between the words (in the gaps)}„                  dest := printwidth;„                  source := len;„                  WHILE gaps > 0 DO„                        BEGIN {expand line}„                        IF LINE [source] <> ' ' THEN„                           BEGIN {shift char}„                           LINE [dest] := LINE [source];   {move char, leave blank}„                           LINE [source] := ' ';„                           END„                        ELSE„                           BEGIN  {leave blanks}„                           {find # of blanks for this gap, skip that many}„                           {(now blank) columns}„                           n := blanks DIV gaps;„                           dest := dest - n;„                           gaps := PRED (gaps);„                           blanks := blanks - n;„                           END;„                        {step to next source and dest characters}„                        source := PRED (source);„                        dest := PRED (dest)„                        END; {expand line}„„                 LINE[0] := CHR(printwidth);„                 FOR source := 1 TO len DO„                     IF LINE [source] = #0 THEN LINE [source] := #32;„                 END;„„        END; {justify procedure}„END.                                                                                                                        12     04-06-9407:44ALL                      SEAN PALMER              7K Text Editor (GHOSTED) SWAG9405            84     F…   {„SEAN PALMER„„> Can anyone (please, it's important) , post here an example of a source„> code that will show a Text File , and let me scroll it (Up , Down ) ?„> Also I need an example of a simple editor.„„Try this For an example. Turbo Pascal 6.0+ source.„Compiles to a 7K Text editor. Neat?„}„„{$A-,B-,D-,E-,F-,G-,I-,L-,N-,O-,R-,S-,V-,X+}„{$M $C00,0,0}„„Program ghostEd; {Ghost Editor v0.4 (C) 1993 Sean L. Palmer}„„Const„  version  = '0.4';„  maxF     = $3FFF;     {only handles small Files!}„  txtColor = $B;„  vSeg     : Word = $B800;„„Var„  nLines   : Byte;„  halfPage : Byte;„  txt      : Array [0..maxF] of Char;„  crs,„  endF,„  pgBase,„  lnBase   : Integer;„  x, y     : Word;„  update   : Boolean;„  theFile  : File;„  ticks    : Word Absolute $40 : $6C;   {ticks happen 18.2 times/second}„„Procedure syncTick;„Var„  i : Word;„begin„  i := ticks;„  Repeat Until i <> ticks;„end;„„Function readKey : Char; Assembler;„Asm„  mov ah, $07„  int $21„end;„„Function keyPressed : Boolean; Assembler;„Asm„  mov ah, $B„  int $21„  and al, $FE„end;„„Procedure moveScrUp(s, d, n : Word); Assembler;„Asm„  mov  cx, n„  push ds„  mov  ax, vSeg„  mov  es, ax„  mov  ds, ax„        mov  si, s„  shl  si, 1„  mov  di, d„  shl  di, 1„  cld„  repz movsw {attr too!}„  pop  ds„ @X:„end;„„Procedure moveScrDn(s, d, n : Word); Assembler;„Asm„  mov  cx, n„  push ds„  mov  ax, vSeg„  mov  es, ax„  mov  ds, ax„  mov  si, s„  add  si, cx„  shl  si, 1„  mov  di, d„  add  di, cx„  shl  di, 1„  std„  repz movsw {attr too!}„  pop  ds„ @X:„end;„„Procedure moveScr(Var s; d, n : Word); Assembler;„Asm„  mov  cx, n„  jcxz @X„  push ds„  mov  ax, vSeg„  mov  es, ax„  mov  di, d„  shl  di, 1„  lds  si, s„  cld„ @L:„  movsb„  inc  di„  loop @L„  pop  ds„ @X:„end;„„Procedure fillScr(d, n : Word; c : Char); Assembler;„Asm„  mov  cx, n„  jcxz @X„  mov  ax, vSeg„  mov  es, ax„  mov  di, d„  shl  di, 1„  mov  al, c„  cld„ @L:„  stosb„  inc  di„  loop @L„ @X:„end;„„Procedure fillAttr(d, n : Word; c : Byte); Assembler;„Asm„  mov  cx, n„  jcxz @X„  mov  ax, vSeg„  mov  es, ax„  mov  di, d„  shl  di, 1„  mov  al, c„  cld„ @L:„  inc  di„  stosb„  loop @L„ @X:„end;„„Procedure cls;„begin„  fillAttr(80, pred(nLines) * 80, txtColor);„  fillScr(80, pred(nLines) * 80, ' ');„end;„„Procedure scrollUp;„begin„  moveScrUp(320, 160, pred(nLines) * 160);„  fillScr(pred(nLines) * 160, 80, ' ');„end;„„Procedure scrollDn;„begin„  moveScrDn(160, 320, pred(nLines) * 320);„  fillScr(160, 80, ' ');„end;„„{put cursor after preceding CR or at 0}„Function scanCrUp(i : Integer) : Integer; Assembler;„Asm„  mov   di, i„  mov   cx, di„  add   di, offset txt„  mov   ax, ds„  mov   es, ax„  std;„  mov   al, $D„  dec   di„  repnz scasb„  jnz   @S„  inc   di„ @S:„  inc   di„  sub   di, offset txt„  mov   ax, di„end;„„{put cursor on next CR or endF}„Function scanCrDn(i:Integer):Integer;Assembler;Asm„  mov   di, i„  mov   cx, endF„  sub   cx, di„  inc   cx„  add   di, offset txt„  mov   ax, ds„  mov   es, ax„  cld„  mov   al, $D„  repnz scasb„  dec   di„  sub   di, offset txt„  mov   ax, di„end;„„Procedure findxy;„begin„  lnBase := scanCrUp(crs);„  x      := crs - lnBase;„  y      := 1;„  pgBase := lnBase;„  While (pgBase > 0) and (y < halfPage) do„  begin„    pgBase := scanCrUp(pred(pgBase));„    inc(y);„  end;„end;„„Procedure display;„Var„  i, j, k, oldY : Integer;„begin„  findXY;„  if update then„  begin„    update := False;„    j := pgBase;„    i := 1;„    While (j <= endf) and (i < pred(nLines)) do„    begin„      k := scanCrDn(j);„      moveScr(txt[j], i * 80, k - j);„      fillScr(i * 80 + k - j, 80 - k + j, ' ');„      fillAttr(i * 80, 80, txtColor);„      j := succ(k);„      inc(i);„    end;„    if i < pred(nLines) then„    begin„      fillScr(i * 80, 80 * pred(nLines - i), 'X');„      fillAttr(i * 80, 80 * pred(nLines - i), 1);„    end;„  end„  else„  begin„    i := scanCrDn(lnBase) - lnBase;„    moveScr(txt[lnBase], y * 80, i);„    fillScr(y * 80 + i, 80 - i, ' ');„  end;„end;„„Procedure title;„Const„  menuStr : String = 'Ghost Editor v' + version + '-(C) Sean Palmer 1993';„begin„  fillAttr(0, 80, $70);„  fillScr(0, 80, ' ');„  MoveScr(MenuStr[1], 1, length(MenuStr));„end;„„Procedure error(s : String);„begin„  fillattr(0, 80, $CE);„  fillScr(0, 80, ' ');„  moveScr(s[1], 1, length(s));„  Write(^G);„  ReadKey;„  title;„end;„„Procedure tooBigErr;„begin„  error('File too big');„end;„„Procedure insChar(c : Char); forward;„Procedure delChar; forward;„Procedure backChar; forward;„„Procedure trimLine;„Var„  i, t, b : Integer;„begin„  i   := crs;„  b   := scanCrDn(crs);„  t   := scanCrUp(crs);„  crs := b;„  While txt[crs] = ' ' do„  begin„    delChar;„    if i > crs then„      dec(i);„    if crs > 0 then„      dec(crs);„  end;„  crs := i;„end;„„Procedure checkWrap(c : Integer);„Var„  i, t, b : Integer;„begin„  b := scanCrDn(c);„  t := scanCrUp(c);„  i := b;„  if i - t >= 79 then„  begin„    i := t + 79;„    Repeat„      dec(i);„    Until (txt[i] = ' ') or (i = t);„    if i = t then„      backChar   {just disallow lines that long With no spaces}„    else„    begin„      txt[i] := ^M;  {change sp into cr, to wrap}„      update := True;„      if (b < endF) and (txt[b] = ^M) and (txt[succ(b)] <> ^M) then„      begin„        txt[b] := ' '; {change cr into sp, to append wrapped part to next„line}         checkWrap(b);  {recursively check next line since it got stuff„added}       end;„    end;„  end;„end;„„Procedure changeLines;„begin„  trimLine;„  update := True;  {signal to display to redraw}„end;„„Procedure insChar(c : Char);„begin„  if endf = maxF then„  begin„    tooBigErr;„    exit;„  end;„  move(txt[crs], txt[succ(crs)], endf - crs);„  txt[crs] := c;„  inc(crs);„  inc(endf);„  if c = ^M then„    changeLines;„  checkWrap(crs);„end;„„Procedure delChar;„begin„  if crs = endf then„    Exit;„  if txt[crs] = ^M then„    changeLines;„  move(txt[succ(crs)], txt[crs], endf - crs);„  dec(endf);„  checkWrap(crs);„end;„„Procedure addLF;„Var„  i : Integer;„begin„  For crs := endF downto 1 do„  if txt[pred(crs)] = ^M then„  begin„    insChar(^J);„    dec(crs);„  end;„end;„„Procedure stripLF;„Var„  i : Integer;„begin„  For crs := endF downto 0 do„  if txt[crs] = ^J then„    delChar;„end;„„Procedure WriteErr;„begin„  error('Write Error');„end;„„Procedure saveFile;„begin„  addLF;„  reWrite(theFile, 1);„  if ioresult <> 0 then„    WriteErr„  else„  begin„    blockWrite(theFile, txt, endf);„    if ioresult <> 0 then„      WriteErr;„    close(theFile);„  end;„end;„„Procedure newFile;„begin„  crs    := 0;„  endF   := 0;„  update := True;„end;„„Procedure readErr;„begin„  error('Read Error');„end;„„Procedure loadFile;„Var„  i, n : Integer;„begin„  reset(theFile, 1);„  if ioresult <> 0 then„    newFile„  else„  begin„    n := Filesize(theFile);„    if n > maxF then„    begin„      tooBigErr;„      n := maxF;„    end;„    blockread(theFile, txt, n, i);„    if i < n then„      readErr;„    close(theFile);„    crs    := 0;„    endf   := i;„    update := True;„    stripLF;„  end;„end;„„Procedure signOff;„Var„  f    : File;„  i, n : Integer;„begin„  assign(f, 'signoff.txt');„  reset(f, 1);„  if ioresult <> 0 then„    error('No SIGNOFF.TXT defined')  {no macro defined}„  else„  begin„    n := Filesize(f);„    blockread(f, txt[endF], n, i);„    if i < n then„      readErr;„    close(f);„    inc(endf, i);„    update := True;„    i := crs;„    stripLF;„    crs := i; {stripLF messes With crs}„  end;„end;„„Procedure goLf;„begin„  if crs > 0 then„    dec(crs);„  if txt[crs] = ^M then„    changeLines;„end;„„Procedure goRt;„begin„  if txt[crs] = ^M then„    changeLines;„  if crs < endf then„    inc(crs);„end;„„Procedure goCtrlLf;„Var„  c : Char;„begin„  Repeat„    goLf;„    c := txt[crs];„  Until (c <= ' ') or (crs = 0);„end;„„Procedure goCtrlRt;„Var„  c : Char;„begin„  Repeat„    goRt;„    c := txt[crs];„  Until (c <= ' ') or (crs >= endF);„end;„„Procedure goUp;„Var„  i : Integer;„begin„  if lnBase > 0 then„  begin„    changeLines;„    lnBase := scanCrUp(pred(lnBase));„    crs := lnBase;„    i := scanCrDn(crs) - crs;„    if i >= x then„      inc(crs, x)„    else„      inc(crs,i);„  end;„end;„„Procedure goDn;„Var„  i : Integer;„begin„  changeLines;„  crs := scanCrDn(crs);„  if crs >= endF then„    Exit;„  inc(crs);„  lnBase := crs;„  i := scanCrDn(crs) - crs;„  if i >= x then„    inc(crs, x)„  else„    inc(crs, i);„end;„„Procedure goPgUp;„Var„  i : Byte;„begin„  For i := halfPage downto 0 do„    goUp;„end;„„Procedure goPgDn;„Var„  i : Byte;„begin„  For i := halfPage downto 0 do„    goDn;„end;„„Procedure goHome;„begin„  crs := scanCrUp(crs);„end;„„Procedure goend;„begin„  crs := scanCrDn(crs);„end;„„Procedure backChar;„begin„  if (crs > 0) then„  begin„    goLf;„    delChar;„  end;„end;„„Procedure deleteLine;„Var„  i : Integer;„begin„  i := scanCrDn(crs);„  crs := scanCrUp(crs);„  if i < endF then„  begin„    move(txt[succ(i)], txt[crs], endf - i);„    dec(endF);„  end;„  dec(endf, i - crs);„  changeLines;„end;„„Procedure flipCursor;„Var„  j, k, l : Word;„begin„  j := succ((y * 80 + x) shl 1);„  l := mem[vSeg : j];   {save attr under cursor}„  mem[vSeg : j] := $7B;„  if not KeyPressed then„    syncTick;„  mem[vSeg : j] := l;„  if not KeyPressed then„    syncTick;„end;„„Procedure edit;„Var„  c : Char;„begin„  Repeat„    display;„    Repeat„      flipcursor;„    Until KeyPressed;„„    c := ReadKey;„    if c = #0 then„      Case ReadKey of„        #59  : signOff;„        #75  : goLf;„        #77  : goRt;„        #115 : goCtrlLf;„        #116 : goCtrlRt;„        #72  : goUp;„        #80  : goDn;„        #83  : delChar;„        #73  : goPgUp;„        #81  : goPgDn;„        #71  : goHome;„        #79  : goend;„      end„    else„      Case c of„        ^[ : saveFile;„        ^H : backChar;„        ^C : {abortFile};„        ^Y : deleteLine;„     else„       insChar(c);„     end;„  Until (c = ^[) or (c = ^C);„end;„„Function getRows : Byte; Assembler;„Asm„  mov  ax, $1130„  xor  dx, dx„  int  $10„  or   dx, dx„  jnz  @S„  mov  dx, 24„ @S: {cga/mda don't have this fn}„  inc  dx„  mov  al, dl„end;„„Var„  oldMode : Byte;„begin„  Asm„    mov ah, $F„    int $10„    mov oldMode, al„  end;  {save old Gr mode}„„  if oldMode = 7 then„    vSeg := $B000;  {check For Mono}„„  nLines := getRows;„  halfPage := pred(nLines shr 1);„  cls;„  title;„„  if paramCount = 0 then„    error('Need Filename as parameter')„  else„  begin„    Asm„      mov bh, 0„      mov dl, 0„      mov dh, nLines„      mov ah, 2„      int $10„    end; {put cursor of}„„    assign(theFile, paramStr(1));„    loadFile;„    edit;„  end;„end.„                                                              13     05-25-9408:24ALL                      JASON KING               Word Wrap                SWAG9405            19     F…   {„BT>Hello All...„„BT>       Ok once again I have reached a brick wall in my program... What I„BT>was trying to do, was to make Word Wrap actully work... Turns out I was„BT>barking up the wrong tree... If you have examples on how to do this... Th„BT>please reply„BT>and let me know...„„What I'm about to describe assumes you either have a loop of„procedure/function that'll read in one line as it works on a line by„line basis....  What I've always done (for wordwrap) is when entering a„line, it stores each character into a holding string that'll contain the„final line, you also have a string that contains the wrapped text, if„the user presses space, you clear the string holding the wrapped text,„and if they reach the end of the line, you erase as many characters as„the length of the string holding the wrapped text...„„Example (untested):„„(uses the CRT unit)„}„„Procedure GetLineWithWrap(var Line,Wrap: String);„Const Cr=#13;„      BS=#8;„      EraseChar=#8+#32+#8;„„Var HoldLine,HoldWrap: String;„    Ch: Char;„    Count: Byte;„„Begin„     HoldWrap:='';„     HoldLine:='';„     if length(line)<>0 then begin„        HoldLine:=Line;„        Write(Line) end;„     Repeat„        While not keypressed do;„        Ch:=Readkey;„        If WhereX=80 and then begin„           For Count:=1 to Length(HoldWrap) Write(EraseChar);„           HoldLine:=Copy(HoldLine,1,Length(HoldLine)-Length(HoldWrap)-1);„           Line:=HoldLine;„           If Ch=#32 then Wrap:='' else Wrap:=HoldWrap+ch;„           Exit End;„        Case Ch of„            #13 : {nothing, but don't want it added to the line};„             #8 : If length(HoldLine)>0 then begin„                     Write(EraseChar);„                     If Length(HoldLine)>1 then„                       HoldLine:=Copy(HoldLine,1,Length(HoldLine)-1)„                       else HoldLine:='';„                     If Length(HoldWrap)>1 then„                       HoldWrap:=Copy(HoldWrap,1,Length(HoldWrap)-1)„                       else HoldWrap:='';„                   End;„             #32 : Begin„                HoldLine:=HoldLine+' ';„                HoldWrap:='' end;„        Else HoldLine:=HoldLine+Ch End;„    Until Ch=#13;„    Line:=HoldLine;„    Wrap:='';„    End;„                                                                          14     05-26-9406:17ALL                      MIKE PERRY               Full Screen Editor       SWAG9405            312    F…   „Unit MPEditor;  { VERSION 1.0  May 14, 1994 }„{  A general full-screen text editor that should compile under varying„   versions of Borland's Turbo Pascal, relying solely on the CRT„   (and System) units.„„ (c) 1994, Michael Perry / Progressive Computer Services, Inc.„            All rights reserved worldwide.„„  LICENSE:  This code is NOT Public Domain; It can be freely„            distributed as long as it is not modified in any„            form.  If you incorporate any part of the code into„            a program, please credit Mike Perry in the program;„            No other remuneration or consideration necessary,„            although it would be nice to get a "thank you" postcard.„            If you have suggestions or enhancements (please do)„            send them to me and I'll make sure that you get„            credit and that this unit will be continually updated.„„    Author: Mike Perry / Progressive Computer Services, Inc.„            PO Box 7638, Metairie, LA 70010 USA„            BBS: (504) 835-0085  FAX: (504) 834-2160„            Fidonet: 1:396/21  Cserve: 71127,2105  AOL: Arpegi0„            Internet: 71127.2105@compuserve.com    PAN: MIKEPERRY„            Unison: MIKEP„„  USAGE:    MPEDITOR manipulates text in an allocated area of memory„            specified by the TXT^ pointer.  To incorporate this unit„            into your program, simply copy your text into the array of„            byte specified by TXT^ and call the appropriate procedures.„            Supported commands:„              Arrow keys for cursor movement, INS, DEL, PgUp, PgDn„              CTRL-(left/right) moves cursor to next word;„              ^Y = delete line,„              ^B = reformat text from cursor to end of paragraph„              Ctrl-PgUp = go to top of file„              Ctrl-PgDn = go to end of file„  NOTES:„  % Statements in the unit which are commented out pertain to features„    and options which are either for demonstration purposes or have„    yet to be implemented; look for updates soon.„  % This editor unit assumes that linefeed characters (#10) are„    stripped from the input prior to editing.  If you import„    data to be edited, make sure you convert CR+LF to CR!!„  % The following routines are critical to performance and if„    implemented in ASM would improve efficiency of the unit:„    GET_LINE_DATA, SET_POSITION, SET_CURSOR„    If you can help, contact me at the addresses at the top.„}„{$R-}   { range checking off - causes error when referencing buffer array }„„{ If you want to implement your own screen i/o routines, look for the„  USEQWIK directive which identifies areas in the program where you can„  make modifications to suit your objective }„{-$DEFINE USEQWIK} { implements FAST direct screen writing / requires }„                   { Eagle Performance Software's QWIK screen units }„                   { available as Shareware }„INTERFACE„„{$IFDEF USEQWIK}„  USES     CRT,Qwik;„{$ELSE}„  USES     CRT;„{$ENDIF}„„CONST„  TEXTMAX:WORD= 40000; { Maximum size of text editing buffer in bytes }„  CR       = 13;       { ordinal value used to indicate a new line }„  SPACE    = 32;       { ordinal value used to indicate a space }„  REFORMAT = 2;        { ordinal value to initiate reformat command / CTRL-B }„  TABSIZE  = 5;        { tab stop every five characters }„„TYPE„  TXT_TYPE  = ARRAY [1..1] OF BYTE;„„VAR„  TXT       : ^TXT_TYPE;    { TEXT BUFFER, pointer to memory block }„„  { operational status variables ------(set during operation)------------- }„  TEXTSIZE  : LONGINT;      { size of txt array in use / max current index }„  POSITION  : LONGINT;      { index of current (cursor) position in TXT array }„  WINTOP    : LONGINT;      { index position in buffer of top of text window }„  XLINE     : BOOLEAN;      { TRUE if cursor position outside of data area }„  INSERTON  : BOOLEAN;      { TRUE indicates insert mode on }„  VROW,„  VCOLUMN   : BYTE;         { VIRTUAL ROW/COLUMN position within editing area }„  WIDTH,„  HEIGHT    : BYTE;         { width and height of current editing window }„  SCRBUMP   : BYTE;         { chars to bump over display / not to exceed„WIDTH! }„  OFFSET    : LONGINT;      { screen display offset, column position to begin„displaying }„{  MARKSTART,„   MARKEND  : LONGINT;      { start/end index of marked text / NOT IMPLEMENTED„}„  { operational configuration vars ----(set by user)----------------------- }„  MARKATTR,                 { marked text attribute }„  BACKATTR,                 { background text window attribute }„  NORMATTR,                 { attribute values for normal & hilighted text }„  BORDATTR  : WORD;         { attribute value for border }„  R1,C1,                    { row,column of upper left coord of edit window }„  R2,C2     : BYTE;         { row,column of lower right coord on edit win }„  MAXCOLUMN : LONGINT;      { maximum line length/column size, 0=No Limit }„{  MAXROW    : LONGINT;      { maximum number of lines allowed, 0=No Limit }„„  { prototypes ------------------------------------------------------------ }„„   {FUNCTION GETINPUT(VAR FUNCTIONKEY:BOOLEAN):BYTE; NEAR }„   {FUNCTION SPACES(COUNT:BYTE):STRING;              NEAR }„   {PROCEDURE CLEAR_TXT;                             NEAR }„  FUNCTION GETTEXTEND:LONGINT;„  FUNCTION INITIALIZE_TXT(VAR PTXT:POINTER;SIZE:LONGINT):BOOLEAN;„  PROCEDURE DISPOSE_TXT(VAR PTXT:POINTER;SIZE:LONGINT);„   {PROCEDURE DRAW_BOX(R1,C1,R2,C2:BYTE);            NEAR }„   {PROCEDURE INITIALIZE_WINDOW(R1,C1,R2,C2:BYTE);   NEAR }„   {PROCEDURE CLEAR_WINDOW;                          NEAR }„   {PROCEDURE CLEAR_LINE;                            NEAR }„   {PROCEDURE BUMP_TXT(COUNT:LONGINT);               NEAR }„   {PROCEDURE DEL_CHARS(COUNT:LONGINT);              NEAR }„   {PROCEDURE GET_LINE_DATA(POS:LONGINT; VAR STARTINDEX,ENDINDEX,COL:LONGINT);}„   {PROCEDURE STUFF_TXT(s:string);                   NEAR }„  FUNCTION WINBOTTOM:LONGINT;„   {PROCEDURE SHOW_LINE;                             NEAR }„  PROCEDURE SHOW_TXT;„  PROCEDURE DISPLAY_TXT(VAR PT:POINTER);„  PROCEDURE SCROLLUP(LINES:BYTE);„  PROCEDURE SCROLLDOWN(LINES:BYTE);„   {PROCEDURE SET_POSITION;                          NEAR }„   {PROCEDURE SET_CURSOR;                            NEAR }„   {PROCEDURE WORD_WRAP(startpoint,endpoint,length:LONGINT);}„   {FUNCTION LINEUP:LONGINT;                         NEAR }„   {FUNCTION LINEDOWN:LONGINT;                       NEAR }„  PROCEDURE READ_TXT(VAR PT:POINTER;FILENAME:STRING;VAR TEXTSIZE:LONGINT);„   {PROCEDURE DIRECTION(C:BYTE);                     NEAR }„   {FUNCTION PARSE_INPUT:BYTE;                       NEAR }„  PROCEDURE SETUP_TEXT_SETTINGS(Row1,Column1,Row2,Column2:BYTE;DRAWBOX:BOOLEAN) ;„  PROCEDURE EDIT(PT:POINTER;VAR RETURNCODE:BYTE);„„IMPLEMENTATION„„(***************************************************************************)„FUNCTION GETINPUT(VAR FUNCTIONKEY:BOOLEAN):BYTE;„{ read keyboard and return character/function key }„VAR CH: CHAR;„BEGIN„  CH:=ReadKey;„  IF (CH=#0) THEN„    BEGIN„      CH:=ReadKey;„      FUNCTIONKEY:=TRUE;„    END„  ELSE FUNCTIONKEY:=FALSE;„  GETINPUT:=ORD(CH);„END;„(***************************************************************************)„FUNCTION SPACES(COUNT:BYTE):STRING;„{ returns COUNT number of spaces }„{ NOTE: Unpredictable results if count exceeds 255!! }„var temp:string;„BEGIN„  TEMP:='';„  WHILE COUNT>0 DO BEGIN„    TEMP:=TEMP+#32;„    DEC(COUNT);„  END;„  SPACES:=TEMP;„END;„(***************************************************************************)„PROCEDURE CLEAR_TXT;„{ zeros the text array & associated values }„BEGIN„  fillchar(txt^,TEXTMAX,0);„  textsize:=0;„  position:=1;„END;„(***************************************************************************)„FUNCTION GETTEXTEND:LONGINT;„{ find the end of text by looking for null character„  %% This is a technique that I use to identify the actual size of„     a text buffer; if you're reading data from a disk structure,„     unless you save the actual size, you'll need to determine it.„     I make sure any unused area in my text buffer is padded with„     nuls }„var I:longint;„BEGIN„  FOR I:=1 TO TEXTMAX DO„    IF TXT^[I]=0 THEN BEGIN„      GETTEXTEND:=I-1;„      EXIT;„    END;„  GETTEXTEND:=TEXTSIZE;„END;„(***************************************************************************)„FUNCTION INITIALIZE_TXT(VAR PTXT:POINTER;SIZE:LONGINT):BOOLEAN;„{ create/allocate memory for text buffer }„BEGIN„  if MaxAvail < SIZE then„    INITIALIZE_TXT:=FALSE     { not enough available memory }„  else BEGIN„    GETMEM(PTXT,SIZE);„    INITIALIZE_TXT:=TRUE;„    TEXTMAX:=SIZE;            { set max size of text }„    TXT:=PTXT;                { establish pointer for routines }„    CLEAR_TXT;                { zero text }„  END;„END;„„(***************************************************************************)„PROCEDURE DISPOSE_TXT(VAR PTXT:POINTER;SIZE:LONGINT);„{ disposes text buffer }„BEGIN„  FREEMEM(PTXT,SIZE);„END;„(***************************************************************************)„PROCEDURE DRAW_BOX(R1,C1,R2,C2:BYTE);„{ surrounds the specified area with a box }„{ NOTE! There are no checks to make sure the box area isn't off the screen!„        and this (and other) routines must be slightly modified if you want„        the text area to fill up the entire screen due to anomolies with„        TP's WINDOW function }„var I:byte;„BEGIN„{$IFDEF USEQWIK}„  { draw horizontal line }„  FOR I:=(C1-1) TO (C2+1) DO BEGIN„    qwrite(R1-1,I,BORDATTR,'ƒ');„    qwrite(R2+1,I,BORDATTR,'ƒ');„  END;„  { draw vertical line }„  FOR I:=(R1-1) TO (R2+1) DO BEGIN„    QWRITE(I,C1-1,BORDATTR,'≥');„    QWRITE(I,C2+1,BORDATTR,'≥');„  END;„  QWRITE(R1-1,C1-1,BORDATTR,'⁄');„  QWRITE(R2+1,C1-1,BORDATTR,'¿');„  QWRITE(R1-1,C2+1,BORDATTR,'ø');„  QWRITE(R2+1,C2+1,BORDATTR,'Ÿ');„{$ELSE}„  TEXTATTR:=BORDATTR;„  { draw horizontal line }„  FOR I:=(C1-1) TO (C2+1) DO BEGIN„    GOTOXY(I,R1-1); WRITE('ƒ');„    GOTOXY(I,R2+1); WRITE('ƒ');„  END;„  { draw vertical line }„  FOR I:=(R1-1) TO (R2+1) DO BEGIN„    GOTOXY(C1-1,I); WRITE('≥');„    GOTOXY(C2+1,I); WRITE('≥');„  END;„  GOTOXY(c1-1,r1-1); WRITE('⁄');„  GOTOXY(c1-1,r2+1); WRITE('¿');„  GOTOXY(c2+1,r1-1); WRITE('ø');„  GOTOXY(c2+1,r2+1); WRITE('Ÿ');„  TEXTATTR:=NORMATTR;„{$ENDIF}„END;„(***************************************************************************)„PROCEDURE INITIALIZE_WINDOW(R1,C1,R2,C2:BYTE);„{ defines text window and clears screen }„BEGIN„{$IFNDEF USEQWIK}„  WINDOW(C1,R1,C2+1,R2);„{$ENDIF}„END;„(***************************************************************************)„PROCEDURE CLEAR_WINDOW;„{ clears the current text window }„BEGIN„{$IFDEF USEQWIK}„  QFILL(r1,c1,HEIGHT,WIDTH,BACKATTR,#32);„{$ELSE}„  textattr:=backattr;„{ since TP forces an unwanted scroll when writing to the lower right corner„  of a window, we create a window 1-column larger and init a smaller one when„  we want to clear the screen, there is an extra column defined in the„  working window so that unwanted scrolls are not accomplished }„  WINDOW(C1,R1,C2,R2);„  CLRSCR;„  WINDOW(C1,R1,C2+1,R2);„{$ENDIF}„END;„(***************************************************************************)„PROCEDURE CLEAR_LINE;„{ clears the current line }„BEGIN„{$IFDEF USEQWIK}„  QFILL(R1+VROW-1,C1,1,WIDTH,BACKATTR,#32);„  { FYI, the arguments for QFILL are:„     QFILL(row,column,rows,columns,attribute,char);  }„{$ELSE}„  TEXTATTR:=BACKATTR;„  WINDOW(C1,R1,C2,R2);„  gotoxy(1,vrow); clreol;„  WINDOW(C1,R1,C2+1,R2);„{$ENDIF}„END;„(***************************************************************************)„PROCEDURE BUMP_TXT(COUNT:LONGINT);„{ moves text at POSITION index over COUNT bytes, for inserting data }„{ this procedure does NOT change, position or cursor indexes }„VAR I:LONGINT;„BEGIN„  inc(textsize,COUNT);„  for i:=textsize downto position do { move everything forward 1 }„    txt^[i]:=txt^[i-COUNT];„END;„(***************************************************************************)„PROCEDURE DEL_CHARS(COUNT:LONGINT);„{ erase COUNT chars at position, shorten text array }„var I:longint;„BEGIN„  FOR I:=POSITION TO (TEXTSIZE-1) DO„    TXT^[I]:=TXT^[I+COUNT];„  DEC(TEXTSIZE,COUNT);„END;„„(***************************************************************************)„PROCEDURE GET_LINE_DATA(POS:LONGINT; VAR STARTINDEX,ENDINDEX,COL:LONGINT);„{ given the array index (position), calculate the start & ending index of the„  current line, also returning VIRTUAL column position on the current line„„  procedure returns:  1,1,1 if at the top of the file;„  procedure returns:  textsize,textsize,1 at bottom of file„„  This is one procedure, that if implemented in ASM would improve the„  overall performance of this unit (I'm open to suggestions).„}„VAR i:longint;„BEGIN„  startindex:=0; endindex:=0; col:=0;„  if pos<1 then exit;               { invalid position }„  if pos>textsize then begin        { at end of text }„    endindex:=textsize+1;„  end else begin„    for i:=pos to textsize do       { find end of line index }„      if txt^[i]=CR then begin      { found CR at end of line }„        endindex:=i;„        i:=textsize;                { force end of loop }„      end;„    if endindex=0 then endindex:=textsize+1;  { last line obviously }„  end;„                                    { find beginning of line index }„  for i:=(endindex-1) downto 1 do   { FOR checks=endvalue, if not increments! }„    if txt^[i]=CR then begin        { found CR at beginning of line }„      startindex:=i+1;              { index of previous CR+1 }„      i:=1;                         { force end of loop }„    end;„  if startindex=0 then startindex:=1;  { begin of line is top of text }„„  col:=pos-startindex+1;            { calculate VIRTUAL column position }„END;„(***************************************************************************)„PROCEDURE STUFF_TXT(s:string);„{ add string/char to txt array, bump POSITION up one }„VAR j,b1,e1,col1:longint; t:byte;„BEGIN„  t:=length(s);„  if ((inserton) or (txt^[position]=CR)) and ((textsize+t)>textmax) then„begin  { no more room }„    write(#7); exit;„  end;„„{ if xline, and text added, make sure to bump position to the end of line }„  IF (XLINE) THEN BEGIN { pad the short line with spaces to the position }„    GET_LINE_DATA(POSITION, b1,e1,col1);„    j:=(offset+vcolumn)-(e1-b1+1);  { number of spaces to pad }„    IF ((textsize+t+j)>textmax) then BEGIN { check for avail space }„      write(#7); exit;„    END;„    bump_txt(j);„    for b1:=position to (position+j-1) do„      txt^[b1]:=SPACE;„    XLINE:=FALSE;„    POSITION:=POSITION+J;„  END;„„  if (inserton) OR (txt^[position]=CR) then„    if (position<=textsize) then begin { insert }„      bump_txt(t);„      FOR J:=1 TO T DO BEGIN„        txt^[position]:=ORD(S[J]);  { add/replace character }„        INC(POSITION);              { move pointer up one }„        INC(VCOLUMN);„      END;„      exit;„    end else begin                  { append / position > textsize }„      FOR J:=1 TO T DO BEGIN„        inc(textsize);„        txt^[textsize]:=ORD(S[J]);„        INC(VCOLUMN);„      END;„      position:=textsize+1;         { position pointer at end of text }„    end„  else if position<=textsize then begin { overwrite }„    FOR J:=1 TO T DO BEGIN„      txt^[position]:=ORD(S[J]);        { overwrite current position }„      inc(position);                    { move pointer one over }„    END;„    INC(VCOLUMN,T);„  end else begin { append }„    if ((textsize+T)>=textmax) then begin  { can't append if buffer full }„      write(#7);„      exit;„    end;„    FOR J:=1 TO T DO BEGIN„      inc(textsize);„      txt^[textsize]:=ORD(S[J]);„    END;„    position:=textsize+1;„    INC(VCOLUMN,T);„  end;„END;„(***************************************************************************)„FUNCTION WINBOTTOM:LONGINT;„{ returns the text array index value of the last character in the text window }„var i:longint; linecount:byte;„BEGIN„  LINECOUNT:=0;„  FOR I:=WINTOP TO TEXTSIZE DO BEGIN„    IF TXT^[I]=CR THEN INC(LINECOUNT);„    IF LINECOUNT=HEIGHT THEN BEGIN { found last line in text window }„      WINBOTTOM:=I;„      EXIT;„    END;„  END; { for loop thru text }„  WINBOTTOM:=TEXTSIZE; { end before last text line found, so text ends in„window }„END;„„(***************************************************************************)„PROCEDURE SHOW_LINE;„{ rewrites the current line to the window }„VAR I,b1,e1,col1:longint; S:STRING;„BEGIN„  GET_LINE_DATA(position, b1,e1,col1);„  IF (B1>TEXTSIZE) THEN BEGIN CLEAR_LINE; EXIT; END; { nothing there }„  col1:=(offset+b1+width-1); if col1>textsize then col1:=textsize; {eol pos}„  S:='';„  for i:=(offset+b1) to col1 {(offset+b1+width-1)} do begin„    if txt^[i]=CR then i:=col1 {(offset+b1+width-1)} { force end }„    else begin„      s:=s+chr(txt^[i]);„    end;„  end;„  CLEAR_LINE;„{$ifdef USEQWIK}„  QWRITE(R1+VROW-1,C1,NORMATTR,S);„  GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„  TEXTATTR:=NORMATTR;„  GOTOXY(1,VROW);  WRITE(S);„  GOTOXY(VCOLUMN,VROW);„{$ENDIF}„END;„(***************************************************************************)„PROCEDURE SHOW_TXT;„{ display text to screen area„  sets VROW and VCOLUMN to match displayed area where position„  is and moves cursor to that location }„var I,R,C,CWIDTH:LONGINT;„BEGIN„  R:=1; C:=1;  { set start row/column }„  CWIDTH:=0;„  CLEAR_WINDOW;„„  { % hide cursor }„  FOR I:=WINTOP TO TEXTSIZE DO BEGIN„    IF (R>HEIGHT) OR (I>TEXTSIZE) THEN begin { check for outside vertical„boundaries OR end }„      {$IFDEF USEQWIK}„        GOTORC(R1+VROW-1,C1+VCOLUMN-1);„      {$ELSE}„        GOTOXY(VCOLUMN,VROW);„      {$ENDIF}„      EXIT;  { done, filled window }„    END;„    IF (TXT^[I]=CR) THEN BEGIN   { -------------- check for carriage return }„      INC(R);   { bump row down }„      CWIDTH:=0;„      C:=1;„{ % IF TXT^[I+1]=10 THEN INC(I);  { check for additional LF / skip over }„„    END ELSE BEGIN   { ----------------------------------- printable char }„      INC(CWIDTH);„      IF CWIDTH>OFFSET THEN       { if screen offset in effect }„        IF C<= WIDTH THEN BEGIN    { if line not off the screen }„{$IFDEF USEQWIK}„          QWRITE(R1+R-1,C1+C-1,NORMATTR,CHR(TXT^[I]));„{$ELSE}„          GOTOXY(C,R); textattr:=normattr;„          WRITE(CHR(TXT^[I]));„{$ENDIF}„          INC(C);„        END else INC(C);  { increment column counter anyway even though not„printed }„     END;„     IF I>TEXTSIZE THEN I:=TEXTSIZE;  { if bumped past, set to end loop }„  END;  { FOR loop }„{$IFDEF USEQWIK}„  GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„  GOTOXY(VCOLUMN,VROW);„{$ENDIF}„  EXIT;„END;„(***************************************************************************)„PROCEDURE DISPLAY_TXT(VAR PT:POINTER);„{ display text, specified by pointer„  can be used by an external viewing routine }„VAR TEMP:POINTER;„BEGIN„  TEMP:=addr(TXT);„  TXT:=PT;„  SHOW_TXT;„  TXT:=TEMP;„END;„(***************************************************************************)„PROCEDURE SCROLLUP(LINES:BYTE);„{ scroll screen up x lines; does not change cursor or text pointer }„var i,b1,e1,col1,LINECOUNT:longint;„BEGIN„  LINECOUNT:=0;„  FOR I:=WINTOP DOWNTO 1 DO BEGIN„    if txt^[i]=CR then begin  { found end of prev line }„       INC(LINECOUNT);„       IF (LINECOUNT=LINES) THEN BEGIN„         GET_LINE_DATA(I, b1,e1,col1);„         WINTOP:=B1;„         EXIT;„       END;„    END; { cr found }„  END; { for loop }„  WINTOP:=1;„END;„(***************************************************************************)„PROCEDURE SCROLLDOWN(LINES:BYTE);„{ scroll screen down x lines, does not change cursor or text pointer }„var i,b1,e1,col1,LINECOUNT:longint;„BEGIN„  linecount:=0;„  for i:=WINTOP to textsize do begin„    if txt^[i]=CR then begin„      { i=index pos of CR of next line }„      inc(linecount);„      if (linecount=lines) {or (i=textsize)} then begin„        WINTOP:=i+1;„        SHOW_TXT;„        EXIT;„      end;  { found specified number of lines }„    end; { if CR found }„  end; { loop thru text }„END;„„(***************************************************************************)„PROCEDURE SET_POSITION;„{ sets POSITION index based on cursor location and WINTOP index }„var I,b1,e1,col1,R,LINECOUNT:longint;„BEGIN„  R:=1; LINECOUNT:=1;„  FOR I:=WINTOP TO TEXTSIZE DO BEGIN„    if (VROW=R) then begin  { line cursor on found }„      GET_LINE_DATA(I, b1,e1,col1);„      IF ((E1-B1+1) < (VCOLUMN+OFFSET)) THEN BEGIN„        POSITION:=E1;„        XLINE:=TRUE;„      END ELSE BEGIN„        POSITION:=B1+VCOLUMN-1;„        XLINE:=FALSE;„      END;„      EXIT;„    end; { cursor line found }„    if txt^[i]=CR then begin„      INC(R);„      INC(LINECOUNT);„    end;„  END; { for loop thru text }„  POSITION:=TEXTSIZE+1;  { assuming cursor at end of text then }„  VROW:=LINECOUNT;  { not sure if this should be here, but takes care„                      of case where scrolling causes most of screen to„                      be past the end of file (where the cursor pos is)„                    }„  GET_LINE_DATA(POSITION, b1,e1,col1);„  IF (VCOLUMN>COL1) THEN XLINE:=TRUE ELSE BEGIN„    POSITION:=B1+VCOLUMN+OFFSET-1;„    XLINE:=FALSE;„  END;„END;„(***************************************************************************)„PROCEDURE SET_CURSOR;„{ finds position and sets VCOLUMN & VROW and OFFSET appropriately in window }„{ ALWAYS sets XLINE to FALSE }„var i,b1,e1,col1,R,C:longint; screenchanged:BOOLEAN;„BEGIN„  R:=1; C:=1; SCREENCHANGED:=FALSE; XLINE:=FALSE;„  FOR I:=WINTOP TO TEXTSIZE+1 DO BEGIN„    IF I=POSITION THEN BEGIN   { found it ------------------------ }„      if (c>offset) and (c<=(offset+width)) then begin  { in window }„        dec(c,offset);„      end else BEGIN„        SCREENCHANGED:=TRUE;„        IF (C<=WIDTH) THEN BEGIN„          OFFSET:=0;„        END ELSE BEGIN„          OFFSET:=(C-WIDTH)+SCRBUMP;„          C:=WIDTH-SCRBUMP;„        END;„      END;„      VCOLUMN:=C;„      VROW:=R;„      IF (SCREENCHANGED) THEN SHOW_TXT else„{$IFDEF USEQWIK}„        GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„        GOTOXY(VCOLUMN,VROW);„{$ENDIF}„      EXIT;„    END; { position found }„  IF TXT^[I]=CR THEN BEGIN„    INC(R); C:=1;„  END ELSE INC(C);„  IF (R>HEIGHT) {OR (R<1)} THEN BEGIN„    GET_LINE_DATA(WINTOP, b1,e1,col1);„    WINTOP:=E1+1;„    R:=HEIGHT;„    SCREENCHANGED:=TRUE;„  END;„ END; { for }„END;„(***************************************************************************)„PROCEDURE WORD_WRAP(startpoint,endpoint,length:LONGINT);„{ word wrap a section of text }„var ccount,i,spacepos,lastcr:longint; showit:boolean;„BEGIN„  IF LENGTH=0 THEN EXIT;  { no length specified so get outta here }„  SPACEPOS:=0; SHOWIT:=FALSE; CCOUNT:=0; LASTCR:=-1;„  FOR I:=STARTPOINT TO (ENDPOINT-1) DO BEGIN„    INC(CCOUNT);„    IF TXT^[I]=SPACE THEN SPACEPOS:=I;„    IF TXT^[I]=CR THEN    { end wrap when to CRs follow, otherwise -> space }„      IF LASTCR=(I-1) THEN BEGIN„        TXT^[I-1]:=CR; { restore prev CR }„        SET_CURSOR;„        SHOW_TXT;„        EXIT;„      END ELSE BEGIN„        TXT^[I]:=SPACE;„        SPACEPOS:=I;„        LASTCR:=I;„      END;„    IF (CCOUNT)>LENGTH THEN BEGIN  { past point }„      IF SPACEPOS=0 THEN BEGIN     { force a CR }„        SPACEPOS:=POSITION; { save pos }„        POSITION:=I;„        BUMP_TXT(1);  { insert 1 byte at position }„        INC(ENDPOINT);„        POSITION:=SPACEPOS; { restore pos }„        TXT^[I]:=CR;„        CCOUNT:=0;„      END ELSE BEGIN„        TXT^[SPACEPOS]:=CR; { turn last space into a CR }„        CCOUNT:=I-SPACEPOS; { calc next line len w/wrap }„      END;„      SHOWIT:=TRUE;„    END; { line past length }„  END; { for }„  IF SHOWIT THEN BEGIN„    SET_CURSOR;„    SHOW_TXT;„  END;„END;„„(***************************************************************************)„FUNCTION LINEUP:LONGINT;„{ returns new index in file, one line up }„{ MOVES cursor on screen as well }„var b1,b2,e1,e2, col1,col2,len1,len2:longint;„BEGIN„  GET_LINE_DATA(position, b1,e1,col1); { get data on current line }„  len1:=e1-b1+1;                       { length of line + CR }„  if b1=1 then BEGIN                   { check for top of text }„    LINEUP:=POSITION; EXIT;„  END;„  GET_LINE_DATA(B1-1,     b2,e2,col2); { get data on previous line }„  len2:=e2-b2+1;„  IF (XLINE) THEN BEGIN„    col2:=b2+vcolumn+offset-1; { in case of move to non-xline, set position }„  END ELSE„    col2:=b2+col1-1;  { index position of one line up, tentative }„„  if col2<1 then col2:=1 else { top of file }„    if (col2>e2) then begin   { previous line shorter than current line }„      col2:=e2;               { make one line up, end of previous line }„      XLINE:=TRUE;„    end else begin„      XLINE:=FALSE;„    end;„  LINEUP:=COL2;„„  IF (WINTOP>col2) THEN BEGIN  { scroll the screen up }„    WINTOP:=B2;„    SHOW_TXT;„  END ELSE DEC(VROW);  { bump cursor up }„{$IFDEF USEQWIK}„  GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„  GOTOXY(VCOLUMN,VROW);„{$ENDIF}„END;„(***************************************************************************)„FUNCTION LINEDOWN:LONGINT;„{ returns new index in file, one line down }„{ MOVES cursor on screen as well }„var b1,b2,e1,e2, col1,col2,len1,len2:longint;„BEGIN„  GET_LINE_DATA(position, b1,e1,col1); { get data on current line }„  len1:=e1-b1+1;                       { calc length of line incl. CR }„  if e1>=textsize then begin           { can't go down on last line }„    LINEDOWN:=POSITION; EXIT;„  end;„  GET_LINE_DATA(e1+1,     b2,e2,col2); { get data on next line }„  len2:=e2-b2+1;„„  IF (XLINE) THEN BEGIN„    col2:=b2+vcolumn+offset-1;   { in case of move to non-xline, set position }„  END ELSE„    col2:=b2+col1-1;   { index position of one line down, tentative }„„  if (col2>e2) then begin  { next line position is past end of next line }„      col2:=e2;            { make one line down, end of next line }„      xline:=TRUE;„    end else begin„      xline:=FALSE;„  end;„  LINEDOWN:=COL2;„„  IF (VROW=HEIGHT) THEN BEGIN   { down off screen, scroll text up }„    SCROLLDOWN(1);  {WINTOP:=B2;}„  END ELSE INC(VROW);  { bump screen down }„{$IFDEF USEQWIK}„  GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„  GOTOXY(VCOLUMN,VROW);„{$ENDIF}„END;„(***************************************************************************)„PROCEDURE READ_TXT(VAR PT:POINTER;FILENAME:STRING;VAR TEXTSIZE:LONGINT);„{ reads text from file into buffer, strips LFs }„{ HORRIBLY SLOW, but not intended to be a real part of this unit }„VAR„    F    :FILE OF BYTE;„    PTXT :^TXT_TYPE;„BEGIN„  PTXT:=PT;„  ASSIGN(F,FILENAME);„  RESET(F);„  TEXTSIZE:=0;„  IF IORESULT<>0 THEN EXIT;„  IF EOF(F) THEN BEGIN CLOSE(F); EXIT; END;„  WHILE NOT(EOF(F)) DO BEGIN„    INC(TEXTSIZE);„    READ(F,PTXT^[TEXTSIZE]);„    if (Ptxt^[textsize]=10) then begin„      dec(textsize);  { remove LFs }„    end;„    IF TEXTSIZE>=TEXTMAX THEN BEGIN„      CLOSE(F);„      EXIT;„    END;„  END;„  CLOSE(F);„END;„„(***************************************************************************)„PROCEDURE DIRECTION(C:BYTE);„{ act on direction keys }„var b1,e1,col1:longint; T:BYTE;„BEGIN„      case C of„       72:begin  { up }„           POSITION:=LINEUP;„         end;„       80:begin  { down }„            POSITION:=LINEDOWN;„          end;„       75:begin  { left }„            if position=1 then begin„              write(#7);„              exit;„            end;„            if (xline) then begin„              dec(vcolumn);„              { check to see if moved onto text }„              get_line_data(position,b1,e1,col1);„              if (offset+vcolumn)=(e1-b1+1) then begin„                xline:=FALSE;„              end;„            end else begin  { not xline }„              if txt^[position-1]=CR then begin      { back up one line? }„                get_line_data(position-1,b1,e1,col1);„                vcolumn:=col1;„                if col1>width then begin { left to prev line off screen }„                  offset:=col1-width+2;„                  vcolumn:=col1-offset;„                  SHOW_TXT;„                end else offset:=0;„                dec(vrow)„              end else begin„                dec(vcolumn);„              end;„              dec(position);„            end; { xline }„            if (vcolumn<1) and (offset>0) then begin„              vcolumn:=1;„              dec(offset);„              SHOW_TXT;„            end;„{$IFDEF USEQWIK}„            GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„            GOTOXY(VCOLUMN,VROW);„{$ENDIF}„          end;„       77:begin  { right }„            if (xline) then begin„              inc(vcolumn);„            end else begin„              inc(position);„              inc(vcolumn);„              if (txt^[position-1]=CR) OR ((position-1)>=TEXTSIZE) then begin„{ at eol }„                dec(position);„                xline:=true;„              end;„            end;„„            IF (MAXCOLUMN>0) AND ((VCOLUMN+OFFSET)>MAXCOLUMN) THEN BEGIN„              GET_LINE_DATA(POSITION,b1,e1,col1);„              IF E1>=TEXTSIZE THEN BEGIN„                DEC(VCOLUMN);„              END ELSE BEGIN„                POSITION:=E1+1;„                SET_CURSOR;„                EXIT;„              END;„            END;„„            if vcolumn>width then begin { moved outside window }„              inc(offset);„              dec(vcolumn);„              SHOW_TXT;„            end;„{$IFDEF USEQWIK}„            GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„            GOTOXY(VCOLUMN,VROW);„{$ENDIF}„          end;„       71:begin  { HOME, to beginning of current line }„            GET_LINE_DATA(POSITION,B1,E1,COL1);„            POSITION:=B1; VCOLUMN:=1;„            IF OFFSET>0 THEN BEGIN„              OFFSET:=0;„              SHOW_TXT;„            END;„{$IFDEF USEQWIK}„            GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„            GOTOXY(VCOLUMN,VROW);„{$ENDIF}„            XLINE:=FALSE;„          end;„       79:begin  { END, to end of current line }„            GET_LINE_DATA(POSITION,B1,E1,COL1);„            POSITION:=E1;„            { calculate offset & cursor position }„            IF (E1-(B1+OFFSET)+1)>WIDTH THEN BEGIN  { off screen }„              offset:=(e1-b1+1)-width+2; {SCRBUMP}„              vcolumn:=width-2; {SCRBUMP}„              SHOW_TXT;„            END ELSE VCOLUMN:=((E1-B1+1)-offset);„{$IFDEF USEQWIK}„            GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„            GOTOXY(VCOLUMN,VROW);„{$ENDIF}„          end;„       73:begin  { PGUP, up one screen }„            IF (WINTOP=1) THEN BEGIN„              POSITION:=1;„              VCOLUMN:=1; VROW:=1;„{$IFDEF USEQWIK}„              GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„              GOTOXY(VCOLUMN,VROW);„{$ENDIF}„            END ELSE BEGIN„              SCROLLUP(HEIGHT);„              SET_POSITION;„              SHOW_TXT;„            END;„          end;„       81:begin  { PGDN, down one screen }„            IF (WINBOTTOM=TEXTSIZE) THEN BEGIN„              POSITION:=TEXTSIZE+1;„              SET_CURSOR;„            END ELSE BEGIN„              SCROLLDOWN(HEIGHT);„              SET_POSITION;„              SHOW_TXT;„            END;„          end;„        82:BEGIN„             INSERTON:=NOT(INSERTON);     { INS toggle insert status }„{ %      IF (INSERTON) THEN GETBLOCKCURSOR ELSE GETUNDERLINECURSOR;}„           END;„        83:BEGIN                        { DEL }„             T:=ORD(TXT^[POSITION]);„             IF POSITION=TEXTSIZE+1 THEN EXIT;„             IF (XLINE) THEN BEGIN   { hitting DEL past eol, special case }„               STUFF_TXT(#0);„               DEC(POSITION);„               DEC(VCOLUMN);„               DEL_CHARS(1);„             END;„             DEL_CHARS(1);„             IF (T=CR) OR (POSITION>=TEXTSIZE) THEN SHOW_TXT ELSE SHOW_LINE;„           END;„       132:begin  { CTRL-PgUP - top of text }„             POSITION:=1; VROW:=1; VCOLUMN:=1; XLINE:=FALSE;„             IF (WINTOP=1) AND (OFFSET=0) THEN„{$IFDEF USEQWIK}„               GOTORC(R1+VROW-1,C1+VCOLUMN-1)„{$ELSE}„               GOTOXY(VCOLUMN,VROW)„{$ENDIF}„             ELSE BEGIN„               WINTOP:=1; OFFSET:=0;„               SHOW_TXT;„             END;„          end;„       115:begin  { CTRL <- }„             if position<3 then exit;„             for col1:=(position-2) downto 1 do„               if (txt^[col1]=SPACE) then begin„                 position:=col1+1;„                 if position<wintop then begin„                   wintop:=1;„ { this could be avoided if set-cursor started at 1 instead of wintop,„   but it would reduce overal performance }„                   set_cursor;„                   show_txt„                 end else„                   set_cursor;„                 exit;„               end;„           end;„       116:begin  { CTRL -> }„             if position>=textsize then exit;„             for col1:=position+1 to textsize do„               if (txt^[col1]=SPACE) then begin„                 position:=col1+1;„                 set_cursor;„                 exit;„               end;„           end;„       118:begin  { CTRL-PgDN - end of text }„             position:=textsize+1;„             SET_CURSOR;„         end;„       67:BEGIN    { F9 }„          END;„      end; { case }„end;„„(***************************************************************************)„FUNCTION PARSE_INPUT:BYTE;„{ main encapsulation of editing routine, read keys and act }„var c         :byte;„    fkey      :boolean;„    leaving   :boolean;„    b1,e1,col1:longint;„{ RETURNS:„      1=ESC„      2=ALT-X„      3=F1„      4=F10„      5=F2„}„BEGIN„  LEAVING:=FALSE;„  REPEAT„    c:=getinput(fkey);„„    IF (C=27) OR ((FKEY) AND (C IN [59,45,60,68])) THEN BEGIN  { exit„conditions }„      IF C=27 THEN PARSE_INPUT:=1 ELSE  { esc }„      IF C=45 THEN PARSE_INPUT:=2 ELSE  { Alt-X }„      IF C=59 THEN PARSE_INPUT:=3 ELSE  { F1 }„      IF C=68 THEN PARSE_INPUT:=4 ELSE  { F10 }„      IF C=60 THEN PARSE_INPUT:=5;      { F2 }„      EXIT;„    END ELSE„    IF (FKEY) THEN BEGIN  { ------------------ eval FNC & CURSOR keys ----- }„      DIRECTION(C);„    END { if function key pressed }„    ELSE BEGIN                      { alphanumeric key - process data }„      CASE C OF                     { check alpha keys }„       REFORMAT:BEGIN               { CTRL-B, 02, REFORMAT }„            GET_LINE_DATA(POSITION,b1,e1,col1);„            WORD_WRAP(B1,TEXTSIZE,MAXCOLUMN);„          END;„       CR:begin                     { carriage return }„            IF (INSERTON) OR (POSITION>TEXTSIZE) THEN BEGIN„              OFFSET:=0;„              INC(VROW);„              IF VROW>HEIGHT THEN BEGIN„                 SCROLLDOWN(1);„                 DEC(VROW);„               END;„               STUFF_TXT(CHR(C));„               VCOLUMN:=1;„               SHOW_TXT;„             end ELSE BEGIN  { enter pressed with overwrite on }„               GET_LINE_DATA(POSITION,B1,E1,COL1);„               POSITION:=E1+1;„               OFFSET:=0;„               SET_CURSOR;„               show_txt;„             END;„           END;„        08:IF POSITION<>1 THEN BEGIN    { backspace }„             IF (XLINE) THEN BEGIN   { can't erase dead zone }„                DEC(VCOLUMN);        { just move cursor left }„                SET_POSITION;„             END ELSE BEGIN„               DEC(POSITION);„               IF TXT^[POSITION]=CR THEN BEGIN { backspace/erase line }„                 DEL_CHARS(1);„                 SET_CURSOR;„                 SHOW_TXT;„               END ELSE BEGIN„                 DEL_CHARS(1);„                 DEC(VCOLUMN);„                 IF (VCOLUMN=0) THEN„                   IF (OFFSET>=SCRBUMP) THEN BEGIN„                     DEC(OFFSET,SCRBUMP); VCOLUMN:=SCRBUMP;„                     SHOW_TXT;„                   END ELSE BEGIN„                     OFFSET:=0; SET_CURSOR;„                     SHOW_TXT;„                   END„                 ELSE SHOW_LINE;„               END;„             END; { xline / else }„{$IFDEF USEQWIK}„             GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„             GOTOXY(VCOLUMN,VROW);„{$ENDIF}„           END;„         09:BEGIN                      { TAB }„              GET_LINE_DATA(POSITION, b1,e1,col1);„              col1:=tabsize-((position-b1) mod tabsize); { spaces to next tab„stop }„              IF (INSERTON) THEN BEGIN„                stuff_txt(SPACES(COL1));„                SHOW_LINE;„              END ELSE BEGIN„                INC(VCOLUMN,COL1);„                IF VCOLUMN>WIDTH THEN BEGIN„                  INC(OFFSET,SCRBUMP);„                  DEC(VCOLUMN,SCRBUMP);„                  SHOW_TXT;„                END;„                IF (POSITION+COL1)>E1 THEN BEGIN„                  POSITION:=E1; XLINE:=TRUE;„                END ELSE begin POSITION:=POSITION+COL1; XLINE:=FALSE; END;„{$IFDEF USEQWIK}„                GOTORC(R1+VROW-1,C1+VCOLUMN-1);„{$ELSE}„                GOTOXY(VCOLUMN,VROW);„{$ENDIF}„              END;„            END;„         25:BEGIN                      { CTRL-Y / ERASE LINE }„              GET_LINE_DATA(POSITION, b1,e1,col1);„              IF E1>TEXTSIZE THEN E1:=E1-B1 ELSE E1:=E1-B1+1;„              POSITION:=B1; { E1:=E1-B1+1; }„              OFFSET:=0; VCOLUMN:=1;„              DEL_CHARS(E1);„              SHOW_TXT;„              IF POSITION>TEXTSIZE THEN POSITION:=TEXTSIZE+1;„            END;„        ELSE BEGIN   {------------------ unspecific alphanumeric char }„          STUFF_TXT(CHR(C));           { store it }„          IF MAXCOLUMN=0 THEN BEGIN    { check for column boundaries }„            IF VCOLUMN>WIDTH THEN BEGIN„              INC(OFFSET,SCRBUMP);„              DEC(VCOLUMN,SCRBUMP);„              SHOW_TXT;„            END;„          END ELSE BEGIN  { limited screen/line size }„            SHOW_LINE;„            IF ((VCOLUMN+OFFSET)>MAXCOLUMN+1) THEN BEGIN  { hit edge limit }„              get_line_data(position,b1,e1,col1);„              word_wrap(b1,textsize,MAXCOLUMN);„            END ELSE BEGIN„              IF VCOLUMN>WIDTH THEN BEGIN { maxcolumn>width but set }„                INC(OFFSET,SCRBUMP);„                DEC(VCOLUMN,SCRBUMP);„                SHOW_TXT;„              END;„            END;„          END;„          SHOW_LINE;„        END;„      END; { case }„    END { alpha key }„  UNTIL LEAVING;„END;„„(***************************************************************************)„PROCEDURE SETUP_TEXT_SETTINGS(Row1,Column1,Row2,Column2:BYTE;DRAWBOX:BOOLEAN);„{ sets appropriate system values for text window }„BEGIN„  R1:=ROW1; C1:=COLUMN1; R2:=ROW2; C2:=COLUMN2;  { set global position of win }„{ % these are arbitrary attribute values - tweak them to suit your tastes }„  NORMATTR:=37; { % }„  BACKATTR:=37; { % }„  BORDATTR:=36; { % }„  OFFSET:=0;„  INSERTON:=TRUE;„  XLINE:=FALSE;„  HEIGHT:=R2-R1+1;  { current height of text window }„  WIDTH:=C2-C1+1;   { current width (in columns) of text window }„  SCRBUMP:=WIDTH DIV 2;„  VROW:=1;          { virtual row and column of cursor inside text window }„  VCOLUMN:=1;„„{ % maxcolumn sets automatic formatting and word wrapping !! }„{  MAXCOLUMN:=WIDTH; { set to 0 to disable word wrap and line length limits }„  MAXCOLUMN:=0;   { no word wrapping }„„  position:=1;„  wintop:=1;„  IF DRAWBOX THEN BEGIN„    DRAW_BOX(R1,C1,R2,C2);„    { DRAW_BOX must be prior to initialize window if not using qwik }„    INITIALIZE_WINDOW(R1,C1,R2,C2);„  END;„END;„(***************************************************************************)„PROCEDURE EDIT(PT:POINTER;VAR RETURNCODE:BYTE);„{ Edit text; assumes text has already been initialized }„BEGIN„  TXT:=PT;    { assign specified text pointer to working name }„  SHOW_TXT;„„  RETURNCODE:=PARSE_INPUT;„{ RETURNCODE the following values based on keys pressed:„      1=ESC„      2=ALT-X„      3=F1„      4=F10„      5=F2„}„END;„(***************************************************************************)„END. { Unit MPEDITOR.PAS }„                                                                                     