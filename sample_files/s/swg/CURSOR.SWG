SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00022         CURSOR HANDLING ROUTINES                                          1      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Cursor SIZE/COLOR        IMPORT              7           {> And how can I hide my cursor ? I know it's something With INT 10 but„> that's all I know...„„Try this:„SType 'C' or 'M' - Color or monchrome display„Size 'S' or 'B' or 'O' cursor small, big, or none (invisible)„}„Uses Dos;„„Procedure CursorSize(SType, Size : Char);„„Var„  Regs : Registers;„  i : Integer;„„begin„  Size := UpCase(Size);„  if UpCase(SType) = 'M' then„    i := 6„  ELSE„   i := 0;„„Regs.AH := $01;„CASE Size of„'O' :„  begin„   Regs.CH := $20;„   Regs.CL := $20;„  end;„'B' :„  begin„   Regs.CH := $0;„   Regs.CL := $7 + i;„  end;„'S' :„  begin„   Regs.CH := $6+i;„   Regs.CL := $7+i;„  end;„end;„Intr($10, Regs);„end;„„begin„  CursorSize('C','B');„  readln;„end.                                                                                       2      05-28-9313:36ALL                      SWAG SUPPORT TEAM        CUSOR Handling #1        IMPORT              22          Unit cursor;„„(*„ *  CURSOR v1.1 - a Unit to provide extended control of cursor shape.„ *„ *  Public Domain 1991 by John Giesbrecht (1:247/128)„ *„ *  Notes:„ *„ *  - This version requires Turbo Pascal 6.0 or later.„ *  - These routines affect only the cursor on page 0.„ *  - This Unit installs an Exit Procedure which restores the cursor„ *    to its original shape when the Programme terminates.„ *)„„Interface„„Procedure cursoroff;„Procedure cursoron;           (* original cursor shape *)„„Procedure blockcursor;„Procedure halfblockcursor;„Procedure linecursor;         (* Default Dos cursor    *)„„Procedure setcursor(startline, endline : Byte);„Procedure getcursor(Var startline, endline : Byte);„„(********************************************************************)„„Implementation„„Const„  mono = 7;„„Var„  origstartline,„  origendline,„  mode : Byte;„  origexitproc : Pointer;„„(********************************************************************)„Procedure setcursor(startline, endline : Byte); Assembler;„„Asm„  mov ah, $01„  mov ch, startline„  mov cl, endline„  int $10„end;„(********************************************************************)„Procedure getcursor(Var startline, endline : Byte); Assembler;„„Asm„  mov ah, $03„  mov bh, $00„  int $10„  les di, startline„  mov Byte ptr es:[di], ch„  les di, endline„  mov Byte ptr es:[di], cl„end;„(********************************************************************)„Procedure cursoroff;„„begin„  setcursor(32, 32);„end;„(********************************************************************)„Procedure cursoron;„„begin„  setcursor(origstartline, origendline);„end;„(********************************************************************)„Procedure blockcursor;„„begin„  if mode = mono„    then setcursor(1, 12)„    else setcursor(1, 7);„end;„(********************************************************************)„Procedure halfblockcursor;„„begin„  if mode = mono„    then setcursor(7, 12)„    else setcursor(4, 7);„end;„(********************************************************************)„Procedure linecursor;„begin„  if mode = mono„    then setcursor(11, 12)„    else setcursor(6, 7);„end;„(********************************************************************)„Procedure restorecursor; Far;„„begin„  system.exitproc := origexitproc;„  cursoron;„end;„(**  I N I T I A L I Z A T I O N  ***********************************)„begin„ getcursor(origstartline, origendline);„ Asm„  mov ah, $0F„  int $10„  mov mode, al„ end;„ origexitproc := system.exitproc;„ system.exitproc := addr(restorecursor);„end.„                                                                                                                      3      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Cursor Handling #2       IMPORT              15          MN> Anyone have any code on hiding the cursor and then bringing it back.„„MN>                               -+- Mike Normand -+-„„„I've seen many replies to this but all suffer the same disadvantage: they all„assume you know the size of the cursor. A little bit debugging BASIC reveals„what's up (by the way, you'll find it described in some good books): you have„to set bit 5 For the start line and the cursor will disappear since this value„is not allowed. To get the cursor back again, clear bit 5 again. Use this„solution, if you Really just want to turn on/off the cursor. CursorOn/CursorOff„do *not* change the cursor shape!!! and do *not* need an external Variable to„manage this.„„The  PUSH BP / POP BP  is needed For some *very* old BIOS versions using CGA/„monochrome :-( display, that trash BP during an INT 10h. If you just want do„support EGA/VGA :-) and better, just push 'em out.„„-----------------------------------------------------„Procedure CursorOff; Assembler;„Asm„    push bp            { For old BIOSs }„    xor  ax, ax„    mov  es, ax„    mov  bh, Byte ptr es:[462h]  { get active page }„    mov  ah, 3„    int  10h           { get cursor Characteristics }„    or   ch, 00100000b„    mov  ah, 1„    int  10h           { set cursor Characteristics }„    pop  bp            { restore bp For old BIOSs }„end;„„Procedure CursorOn; Assembler;„Asm„    push bp            { old BIOSs like this... }„    xor  ax, ax„    mov  es, ax„    mov  bh, Byte ptr es:[462h]  { get active page }„    mov  ah, 3„    int  10h           { get cursor Characteristics }„    and  ch, 00011111b„    mov  ah, 1„    int  10h           { set cursor Characteristics }„    pop  bp            { ...and this, too }„end;„                                                                                 4      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Show/Hide Cursor         IMPORT              4           Uses Crt;„„Var„  Continue : Char;„„Procedure HideCursor; Assembler;„Asm„  MOV   ax,$0100„  MOV   cx,$2607„  INT   $10„end;„„Procedure ShowCursor; Assembler;„Asm„  MOV   ax,$0100„  MOV   cx,$0506„  INT   $10„end;„„begin„  Writeln('See the cursor ?');„  Continue := ReadKey;„  HideCursor;„  Writeln('Gone! ');„  Continue := ReadKey;„  ShowCursor;„end.                                   5      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Cursor Size & Detect     IMPORT              9           {„SEAN PALMER„}„„unit cursor; {Public domain, by Sean Palmer aka Ghost}„„interface„„var„  maxSize : byte;„„procedure setSize(scans : byte);  {set size from bottom, or 0 for off}„procedure detect;     {get max scan lines by reading current cursor}„„implementation„„procedure setSize(scans : byte);„var„  t : byte;„begin„  if scans = 0 then„    t := $20„  else„    t := maxSize - scans;„  asm„    mov ah, 1„    mov bh, 0„    mov ch, t„    mov cl, maxSize„    dec cl„    int $10„  end;„end;„„procedure detect; assembler;„asm  {do NOT call while cursor's hidden}„  mov ah, 3„  mov bh, 0„  int $10„  inc cl„  mov maxSize, cl„end;„„begin„  detect;„end.„„program test;„uses„  cursor;„begin„  writeln(cursor.maxSize);„  cursor.setSize(cursor.maxSize);„  readln;        {block}„  cursor.setSize(0);„  readln;                     {hidden}„  cursor.setSize(cursor.maxSize div 2);„  readln;  {half}„  cursor.setSize(2);„  readln;                     {normal}„end.„                                                                        6      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Cursor Show/Hide #2      IMPORT              5             Procedure HideCursor;  assembler;„  asm„    mov      ah,$01  { Function number }„    mov      ch,$20„    mov      cl,$00„    Int      $10     { Call BIOS }„  end;  { HideCursor }„„„  Procedure RestoreCursor;  assembler;„  asm„    mov      ah,$01  { Function number }„    mov      ch,$06  { Starting scan line }„    mov      cl,$07  { Ending scan line }„    int      $10     { Call BIOS }„  end; { RestoreCursor }„                                                                                                 7      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Find The Cursor          IMPORT              3           Uses„  Dos;„„Procedure FindXY(Var X, Y : Byte; Page : Byte);„{X = Row of Cursor}„{Y = Colum of Cursor}„{Page = Page Nummber}„Var„  Regs : Registers;„begin„  Regs.Ah := 3;„  Regs.Bh := Page;„  intr($10, Regs);„  X := Regs.Dl;„  Y := Regs.Dh;„end;„          8      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Spin The Cursor INPUT    IMPORT              13          Program SpinKey;„„Uses Crt;„(*   ^^^^„     This is only For "beautifying" the stuff. XCrt has the Procedures:„     HideCursor„     ShowCursor„     but they are not Really important, perhaps you have youre own„*)„„Const„  SpinChar : Array [1..4] of Char = ('≥','/','ƒ','\');„„Function ReadKeySpin(Wait : Byte) : Char;„Var„  X,Y  : Byte;„  Num  : Byte;„  Ch   : Char;„begin„  Num := 1;                               (* initialize SpinChars  *)„  X   := WhereX;                          (* Where am I ??         *)„  Y   := WhereY;„  Repeat„    Write(SpinChar[Num]);           (* Spin the Cursor       *)„    GotoXY(X, Y);                   (* Go back               *)„    Delay(Wait);                    (* Wait, it's to fast!   *)„    Write(#32);                     (* Clean Screen          *)„    GotoXY(X, Y);                   (* Go back               *)„    Inc(Num);                       (* Next SpinChar, please *)„    if Num = 5 then Num := 1;       (* I have only 5 Chars   *)„  Until KeyPressed;„  Ch := ReadKey;                        (* Get the pressed Key   *)„  Write(Ch);                            (* and Write it to screen*)„  ReadKeySpin := Ch;                    (* give a result         *)„end;„„Function ReadStringSpin : String;„Var„  Help : String;„  Ch   : Char;„  i    : Byte;„begin„  Help := '';„  Repeat„    Ch := ReadKeySpin(40);„    if Ch <> #13 then Help := Help + Ch;„  Until Ch = #13;„  ReadStringSpin := Help;„  WriteLn;„end;„„Var„  TestString : String;„begin„  TestString := ReadStringSpin;„end.„       9      06-08-9308:22ALL                      SWAG SUPPORT TEAM        Cursor Stuff in ASM      IMPORT              20          (*„===========================================================================„ BBS: Canada Remote Systems„Date: 05-28-93 (05:36)             Number: 8641„From: LOU DUCHEZ                   Refer#: NONE„  To: KURT TAN                      Recvd: NO„Subj: CURSOR CONTROL                 Conf: (58) PASCAL„---------------------------------------------------------------------------„KT>Can someone tell me how to make the cursor in Turbo Pascal disappear and„KT>appear?„„Whah, sher, li'l pardner.  There is *no* function to turn off the cursor„per se in Pascal or among the BIOS interrupts.  However, you can change„the appearance of the cursor, making it span 0 pixels (as opposed to the„usual 2).  And to this purpose, I've included some of my favorite cursor„routines, stored in a prize Unit of mine.„„To define a cursor, you need to store the format in a word.  The standard„cursor for, say, CGA is $8786 (I think); the "6" and "7" say that the„cursor starts at pixel 7 and ends at pixel 6.  The eights mean that there„are eight pixels to be messing with -- honestly that's a guess, I've„never seen it in a book anywhere.  For VGA and Hercules, I'm pretty sure„you have 15 pixels to work with; the normal cursor there is something like„$fefc (something like that -- I'm working off CGA, so it's hard for me to„test that theory).  In either case, no matter the graphics system, a good„way to turn off the cursor is to set it to $ffff.„*)„„procedure cursoff;„const ffff: word = $ffff;„„{ Turns the cursor off.  Stores its format for later redisplaying. }„„begin„  asm„    mov ah, 03h„    mov bh, 00h„    int 10h„    mov crstyp, cx   { global variable -- for later retrieval }„    mov ah, 01h„    mov cx, ffff„    int 10h„    end;„  end;„„„procedure curson;„„{ Turns the cursor back on, using the cursor display previously stored. }„„begin„  asm„    mov ah, 01h„    mov cx, crstyp   { previously-stored cursor format }„    int 10h„    end;„  end;„„„function getcursor: word;„„{ Returns the cursor format. }„„var tempword: word;„begin„  asm„    mov ah, 03h„    mov bh, 00h„    int 10h„    mov tempword,cx„    end;„  getcursor := tempword;„  end;„„„procedure setcursor(curstype: word);„„{ Sets the cursor format. }„„var tempword: word;„begin„  tempword := curstype;„  asm„    mov ah, 01h„    mov cx,tempword„    int 10h„    end;„  end;„„                                                                                                   10     07-16-9306:05ALL                      SWAG SUPPORT TEAM        Cursor Manipulations     IMPORT              15     .]   „{ unit to manipulate the text cursor }„„unit Cursor;„„INTERFACE„„TYPE„„  PCursorRec = ^TCursorShape;„  TCursorShape = record„    Start : byte;„    Stop  : byte;„  end;„„procedure GetCursorShape (var Shape : TCursorShape);„{ Sets the Start and Stop fields of Shape }„„procedure CursorOff;„{ Turns the cursor off }„„procedure NormCursorOn;„{ Turns underscore cursor on }„„procedure BlockCursorOn;„{ Turns block cursor on }„„procedure SetCursorShape (Shape : TCursorShape);„{ Set cursor shape with Start and Stop fields of Shape }„„IMPLEMENTATION„VAR„   VideoMode : BYTE ABSOLUTE $0040 : $0049; { Video mode: Mono=7, Color=0-3 }„„procedure GetCursorShape (var Shape : TCursorShape); assembler;„  asm„    mov ah,$03„    mov bx,$00„    int $10„    les di,Shape„    mov TCursorShape (es:[di]).Start,ch    {es:[di] is Start field of Shape}„    mov TCursorShape (es:[di]).Stop,cl  {es:[di+1] is Stop field of Shape}„  end;„„procedure SetCursorShape; assembler;„  asm„    mov ah,$01             { Service 1, set cursor size }„    mov ch,Shape.Start„    mov cl,Shape.Stop„    int $10„  end;„„procedure CursorOff;  assembler;„  asm„    mov ah,$01„    mov ch,$20„    mov cl,$00„    int $10„  end;„„procedure NormCursorOn;„  var„    Shape : TCursorShape;„  begin„    if VideoMode = 7 then„      begin„        Shape.Start := $0A;„        Shape.Stop  := $0B;„      end„    else„      begin„        Shape.Start := $06;„        Shape.Stop  := $07;„      end;„    SetCursorShape (Shape);„  end;„„procedure BlockCursorOn;„  var„    Shape : TCursorShape;„  begin„    if VideoMode = 7 then„      begin„        Shape.Start := $02;„        Shape.Stop  := $0B;„      end„    else„      begin„        Shape.Start := $02;„        Shape.Stop  := $08;„      end;„    SetCursorShape (Shape);„  end;„„END.                11     08-18-9312:24ALL                      JOSE ALMEIDA             Get Cursor Position      IMPORT              9      .]   { Gets the cursor position for each of the eight display pages.„  Part of the Heartware Toolkit v2.00 (HTcursor.PAS) for Turbo Pascal.„  Author: Jose Almeida. P.O.Box 4185. 1504 Lisboa Codex. Portugal.„          I can also be reached at RIME network, site ->TIB or #5314.„  Feel completely free to use this source code in any way you want, and, if„  you do, please don't forget to mention my name, and, give me and Swag the„  proper credits. }„„PROCEDURE Get_Cursor_Position(Page : byte;„                        var Column,„                               Row : byte);„{ DESCRIPTION:„    Gets the cursor position for each of the eight display pages.„  SAMPLE CALL:„    Get_Cursor_Position(0,Col,Row);„  RETURNS:„„  NOTES:„    Page value must be from 0 to 7 }„„BEGIN { Get_Cursor_Position }„  Column := Succ(Lo(MemW[$0000:$0450 + Page * 2]));„  Row := Succ(Hi(MemW[$0000:$0450 + Page * 2]));„END; { Get_Cursor_Position }„                                                                                                         12     08-27-9320:34ALL                      BRIAN DHATT              GoToXY Replacment        IMPORT              22     .]   {BRIAN DHATT„„> Does anyone have codes/source For replacing GotoXY Procedure?„}„Asm„  MOV AH,$0F                   {To get active page, returns BH}„  INT $10„  MOV Page,BH„end;„„Asm                  {to find current cursor pos in form XX,YY}„  MOV AH,$3           {Equiv of XX:=WhereX, YY:=WhereY         }„  MOV BH,Page„  INT $10„  MOV YY,DH„  MOV XX,DL„end;„„Asm                        {This block moves the cursor to           }„  MOV AH,$02               {XX,YY just like GotoXY(XX,YY)            }„  MOV BH,Page„  MOV DL,XX„  MOV DH,YY„  INT $10„end;„„{„GREG ESTABROOKS„„>Can someone tell me how to make the cursor in Turbo Pascal disappear and„>appear?„}„„Program CursorDemo;              (*  May 27/93, Greg Estabrooks     *)„Uses„  Crt;                        (*  For ReadKey, ClrScr.           *)„Const„  (* Define Cursor Value to make chaning cursor easier *)„  NoCursor      = $2000;„  DefaultCursor = $0607;„  BlockCursor   = $000A;„Var„  Curs : Word;                 (* Stores saved cursor value         *)„  Ch   : Char;„„Procedure SetCursor(Cursor : Word); Assembler;„                    (* Routine to change the shape of the cursor    *)„Asm„  Mov AH,1                      (* Function to change cursor shape   *)„  Mov BH,0                      (* Set Page to 0                     *)„  Mov CX,Cursor                 (* Load new cursor Shape Value       *)„  Int $10                       (* Call Dos                          *)„end;{SetCursor}„„Function GetCursor : Word; Assembler;„                   (* Routine to return Cursor Shape                 *)„Asm„  Mov AH,3                      (* Function to return cursor shape   *)„  Mov BH,0                      (* Set Page to 0                     *)„  Int $10                       (* Call Dos                          *)„  Mov AX,CX                     (* Move Result to proper register    *)„end;{GetCursor}„„begin„  ClrScr;                       (* Clear the screen For demonstration*)„  Curs := GetCursor;            (* Save Current Cursor Value         *)„  Writeln('The Cursor is turned off');„  SetCursor( NoCursor );        (* Turn off the cursor               *)„  Ch := ReadKey;                (* Pause to show user new cursor     *)„  Writeln('The Cursor is a block shape');„  SetCursor( BlockCursor );     (*  Set the cursor to a block        *)„  Ch := ReadKey;„  Writeln('The Cursor is now the normal shape');„  SetCursor( DefaultCursor );   (* Set Default Cursor                *)„  Ch := ReadKey;„„  SetCursor( Curs );            (* Restore cursor to previous style  *)„end.„                                                                                                                              13     08-27-9321:58ALL                      SEAN PALMER              Spinning Cursor          IMPORT              5      .]   {„SEAN PALMER„„This is an example for the cursor I talked about to someone on here...„}„„program spinCursor;„„uses„  crt;„„var„  cursorState : byte;  {0..3}„  i           : integer;„„const„  cursorData : array [0..3] of char = (#30, #17, #31, #16);„„procedure updateCursor;„begin„  cursorState := succ(cursorState) and 3;„  write(cursorData[cursorState], ^H);„end;„„begin„  for i := 1 to 100 do„  begin„    gotoxy(1,1);„    updateCursor;„    gotoxy(1,41);„    delay(100);„  end;„end.„                            14     09-26-9308:49ALL                      MARTIN RICHARDSON        Turn cursor off (ASM)    IMPORT              5      .]   {****************************************************************************„ * Procedure ..... CsrOff„ * Purpose ....... To turn the cursor off„ * Parameters .... None„ * Returns ....... N/A„ * Notes ......... None„ * Author ........ Martin Richardson„ * Date .......... May 13, 1992„ ****************************************************************************}„PROCEDURE CsrOff; ASSEMBLER;„ASM„       MOV  AH, 1„       MOV  CX, 1400h„       INT  10h„END;„„                                                    15     09-26-9308:49ALL                      MARTIN RICHARDSON        Turn cursor on (ASM)     IMPORT              5      .]   {****************************************************************************„ * Procedure ..... CsrOn„ * Purpose ....... To turn the cursor on„ * Parameters .... None„ * Returns ....... N/A„ * Notes ......... None„ * Author ........ Martin Richardson„ * Date .......... May 13, 1992„ ****************************************************************************}„PROCEDURE CsrOn; ASSEMBLER;„ASM„       MOV  AH, 1„       MOV  CX, 0607h„       INT  10h„END;„„                                                       16     09-26-9309:27ALL                      MARTIN RICHARDSON        Set CURSOR Shape         IMPORT              6      .]   {****************************************************************************„ * Procedure ..... SetCursor()„ * Purpose ....... To set the cursor shape„ * Parameters .... nTop       Top line of cursor„ *                 nBottom    Bottom line of cursor„ * Returns ....... N/A„ * Notes ......... None„ * Author ........ Martin Richardson„ * Date .......... May 13, 1992„ ****************************************************************************}„PROCEDURE SetCursor( nTop, nBottom : INTEGER ); ASSEMBLER;„ASM„     MOV  AH, 1„     MOV  CH, BYTE PTR nTop„     MOV  CL, BYTE PTR nBottom„     INT  10h„END;„„                                  17     10-28-9311:29ALL                      LIM FUNG                 CURSOR Control           IMPORT              28     .]   {===========================================================================„Date: 08-27-93 (14:17)„From: LIM FUNG„Subj: cursor control„„WD>Hi All,„WD>   Hey, someone put a couple of little proc. on here which control the„WD>cursor (turn it on/off) and they were written in assembler.  I had a„WD>brain fade and forgot to save the name of the person who created these„WD>routines.  I was wondering if they might know how to get a big cursor„WD>also using assembler.  Also, do they work on monochrome monitors, or was„WD>that what you meant about the 8x8 scan lines?„„Okay, a simple procedure to turn on and off the cursor would be as„follows: }„„„Uses DOS;„„Procedure CursorOn;„Begin„        asm„                mov        ax,0100h„                mov        cx,0607h„                int        10h„        end;„end;„„Procedure CursorOff;„Begin„        asm„                mov        ax,0100h„                mov        cx,2020h„                int        10h„        end;„end;„„end.„„===========================================================================„ BBS: Canada Remote Systems„Date: 10-23-93 (07:59)             Number: 9355„From: LOU DUCHEZ                   Refer#: NONE„  To: JESSE MACGREGOR               Recvd: NO  „Subj: help                           Conf: (1617) L-Pascal„---------------------------------------------------------------------------„JM>I need help I need a function that when I give it a screen coordiante„JM>and it returns the charachter at that coordinate on a text screen„JM>(80x25) and possibly the color...„„Try this:„„-------------------------------------------------------------------------------„„type  videolocation = record                  { video memory locations }„          videodata: char;                    { character displayed }„          videoattribute: byte;               { attributes }„          end;„„---------------„„procedure getvideodata(x, y: byte; var result: videolocation);„„{ Returns the attribute byte of a video character. }„„var vidptr: ^videolocation;„begin„  if memw[$0040:$0049] = 7 then vidptr := ptr($b000, 2*(80*(y-1) + (x-1)))„                           else vidptr := ptr($b800, 2*(80*(y-1) + (x-1)));„  result := vidptr^;„  end;„„-------------------------------------------------------------------------------„„„JM>also, a procedure to make that icky„JM>cursor go away would be greatly appreciated...„„There's not really a procedure to make it "go away", just to change it.„You CAN change it so that it's undisplayable, but you'll want to store„the previous config first.  Like so:„„-------------------------------------------------------------------------------„„var crstyp: word;„„---------------„„procedure cursoff;„const ffff: word = $ffff;„„{ Turns the cursor off.  Stores its format for later redisplaying. }„„begin„  asm„    mov ah, 03h„    mov bh, 00h„    int 10h„    mov crstyp, cx„    mov ah, 01h„    mov cx, ffff„    int 10h„    end;„  end;„„---------------„„procedure curson;„„{ Turns the cursor back on, using the cursor display previously stored. }„„begin„  asm„    mov ah, 01h„    mov cx, crstyp„    int 10h„    end;„  end;„„-------------------------------------------------------------------------------„„How's that, o evil masters?„---„ ˛ KingQWK 1.05 # 182 ˛ "Bob" -- the Doc Savage of holy men„ ˛ RoseMail 2.10·: ILink: PC-Ohio * Cleveland, OH * 216-381-3320„                                                                                                   18     11-02-9305:29ALL                      JEFF HLYWA               ASM Cursor Position      IMPORT              11     .]   {„JEFF HLYWA„„> One more thing, how could I reWrite the GotoXY command For use„> through the comport?„„Ok.. if you are using the Fossil Driver routines you can do this.„}„„Procedure SetCursorPos(XPos, Ypos : Byte); Assembler;„Asm„  SUB  XPos, 1     { Subtract 1 from X Position }„  SUB  YPos, 1		  { Subtract 1 from Y Position }„  MOV  AH, $11„  MOV  DH, YPos„  MOV  DL, XPos„  INT  14h„end;„„{ We subtracted 1 from both the X Position and Y Position because when you„use the SetCursorPos the orgin ( upper left hand corner ) coordinates are„0,0. Using the GotoXY the orgin coordinates are 1,1.  For example : if we„wanted to GotoXY (40,12) using the SetCursorPos Without the subtraction„commands the cursor would be located at (41,13).  Pretty simple }„„{ The follow Procedure gets the current cusor postion }„„Procedure GetCursorPos;„{ Returns then X Coordinate and Y Coordinate (almost like WhereX and WhereY).„You must define X and Y as an Integer or Byte in the Var section of your„Program }„Var„  XCord,„  YCord : Byte;	  { Use temporary coordinates }„begin„  Asm„    MOV  AH, $12„    INT  14h„    MOV  YCord, DH„    MOV  XCord, DL„    ADD  YCord, 1  { Add 1 to the Y Coordinate }„  end;„  X := XCord;	     { Set X and Y }„  Y := YCord;„end;„„                               19     11-02-9317:47ALL                      JON JASIUNAS             Very GOOD Cursor Unit    IMPORT              38     .]   {„From: JON JASIUNAS„Subj: Cursor Stuff„„Here's a bit of code that will hide / unhide the cursor, without using„assembler: }„„uses„  Dos;„„var„  R: Registers;„„procedure HideCursor;„begin   { HideCursor }„  R.AH := $03;    {- Current cursor status }„  Intr($10, R);„  R.AH := $01;    {- Set cursor }„  R.CH := R.Ch or $20;„  Intr($10, R);„end;    { HideCursor }„„procedure ShowCursor;„begin   { ShowCursor }„  R.AH := $03;„  Intr($10, R);„  R.AH := $01;„  R.CH := R.CH and $1F;„  Intr($10, R);„end;    { ShowCursor }„„{ However, if you want to use assembler, you can, and you don't need the„  DOS unit.  Here's my Cursor modification unit (in assembler), if you're„  interested. }„„{****************************„ *     CURSOR.PAS v1.0      *„ *                          *„ *  General purpose cursor  *„ *  manipulation routines   *„ ****************************„„1992-93 - HyperDrive Software„Released into the Public Domain.}„„{$S-,R-,D-}„{$IFOPT O+}„  {$F+}„{$ENDIF}„„unit Cursor;„„{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\}„                                   interface„{/////////////////////////////////////////////////////////////////////////////}„„const„  csLine  = $01;„  csHalf  = $02;„  csBlock = $03;„„procedure DefineCursor(Size: Byte);„procedure GotoXy(X, Y: Byte);„procedure RestoreCursor;„procedure HideCursor;„procedure ShowCursor;„function  CursorHidden: Boolean;„„{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\}„                                 implementation„{/////////////////////////////////////////////////////////////////////////////}„„var„  dcStart, dcEnd: Byte;„„{=============================================================================}„„procedure DefineCursor(Size: Byte);  ASSEMBLER;„asm     { DefineCursor }„  mov   AH, $0F„  int   $10„  cmp   AL, $07„  jne   @Color„„@Mono:„  mov   AH, $03„  int   $10„  cmp   Size, csLine„  je    @MonoL„  cmp   Size, csHalf„  je    @MonoH„  cmp   Size, csBlock„  je    @MonoB„@MonoL:„  mov   CH, $0C„  jmp   @MonoDone„@MonoH:„  mov   CH, $07„  jmp   @MonoDone„@MonoB:„  mov   CH, $00„@MonoDone:„  mov   CL, $0D„  jmp   @Done„„@Color:„  mov   AH, $03„  int   $10„  cmp   Size, csLine„  je    @ColorL„  cmp   Size, csHalf„  je    @ColorH„  cmp   Size, csBlock„  je    @ColorB„@ColorL:„  mov   CH, $06„  jmp   @ColorDone„@ColorH:„  mov   CH, $04„  jmp   @ColorDone„@ColorB:„  mov   CH, $00„@ColorDone:„  mov   CL, $07„„@Done:„  mov   AH, $01„  int   $10„end;    { DefineCursor }„„{-----------------------------------------------------------------------------}„„procedure GotoXy(X, Y: Byte);  ASSEMBLER;„asm     { GotoXy }„  mov   AH, $0F„  int   $10„  mov   AH, $02„  dec   Y„  mov   DH, Y„  dec   X„  mov   DL, X„  int   $10„end;    { GotoXy }„„{-----------------------------------------------------------------------------}„„procedure RestoreCursor;  ASSEMBLER;„asm     { RestoreCursor }„  mov   AH, $01„  mov   CH, dcStart„  mov   CL, dcEnd„  int   $10„end;    { RestoreCursor }„„{-----------------------------------------------------------------------------}„„procedure HideCursor;  ASSEMBLER;„asm     { HideCursor }„  mov   AH, $03„  int   $10„  mov   AH, $01„  or    CH, $20„  int   $10„end;    { HideCursor }„„{-----------------------------------------------------------------------------}„„procedure ShowCursor;  ASSEMBLER;„asm     { ShowCursor }„  mov   AH, $03„  int   $10„  mov   AH, $01„  and   CH, $1F„  int   $10„end;    { ShowCursor }„„{-----------------------------------------------------------------------------}„„function  CursorHidden: Boolean; ASSEMBLER;„asm     { CursorHidden }„„  mov   AH, $03„  int   $10„  cmp   CH, $20„  je    @Hidden„  mov   AL, $00„  jmp   @End„@Hidden:„  mov   AL, $01;„@End:„end;    { CursorHidden }„„{-----------------------------------------------------------------------------}„                                {** PRIVATE **}„{-----------------------------------------------------------------------------}„„procedure SaveCursor;  ASSEMBLER;„asm     { SaveCursor }„  mov   AH, $03„  int   $10„  mov   dcStart, CH„  mov   dcEnd, CL„end;    { SaveCursor }„„{=============================================================================}„{$F+}„„var„  OldExitProc: Pointer;„„procedure NewExitProc;„begin„  ExitProc := OldExitProc;„  RestoreCursor;               {- Restore startup cursor mode }„end;    { NewExitProc }„„{$F-}„{=============================================================================}„„begin   { Cursor }„  OldExitProc := ExitProc;„  ExitProc    := @NewExitProc;„  SaveCursor;                  {- Save startup cursor mode }„end.    { Cursor }„                                                                                            20     05-25-9408:03ALL                      GREG ESTABROOKS          cursor size attributes   SWAG9405            19     .]   „{„ One way to do it is to change the cursor size attributes. Here are some„ routines I use and a little demo program I wrote for another user a„ while back(Gosh almost a year now<g>). Also if your doing a lot of„ screen writing and either don't want the cursor to move or not be„ visible at all you might want to try looking into direct video memory„ writes.„}„„PROGRAM CursorDemo;              (*  May 27/93, Greg Estabrooks     *)„USES CRT;                        (*  For Readkey, Clrscr.           *)„CONST„     (* Define Cursor Value to make chaning cursor easier *)„    NoCursor      = $2000;„    DefaultCursor = $0607;„    BlockCursor   = $000A;„VAR„    Curs :WORD;                 (* Stores saved cursor value         *)„    Ch   :CHAR;„„PROCEDURE SetCursor( Cursor :WORD ); ASSEMBLER;„                     (* Routine to change the shape of the cursor    *)„ASM„  Mov AH,1                      (* Function to change cursor shape   *)„  Mov BH,0                      (* Set Page to 0                     *)„  Mov CX,Cursor                 (* Load new cursor Shape Value       *)„  Int $10                       (* Call Dos                          *)„END;{SetCursor}„„FUNCTION GetCursor :WORD; ASSEMBLER;„                   (* Routine to return Cursor Shape                 *)„ASM„  Mov AH,3                      (* Function to return cursor shape   *)„  Mov BH,0                      (* Set Page to 0                     *)„  Int $10                       (* Call Dos                          *)„  Mov AX,CX                     (* Move Result to proper register    *)„END;{GetCursor}„„BEGIN„  Clrscr;                       (* Clear the screen for demonstration*)„  Curs := GetCursor;            (* Save Current Cursor Value         *)„  Writeln('The Cursor is turned off');„  SetCursor( NoCursor );        (* Turn off the cursor               *)„  Ch := Readkey;                (* Pause to show user new cursor     *)„  Writeln('The Cursor is a block shape');„  SetCursor( BlockCursor );     (*  Set the cursor to a block        *)„  Ch := Readkey;„  Writeln('The Cursor is now the normal shape');„  SetCursor( DefaultCursor );   (* Set Default Cursor                *)„  Ch := Readkey;„„  SetCursor( Curs );            (* Restore cursor to previous style  *)„END.„                               21     05-25-9408:03ALL                      SEAN PALMER              Better Cursor Control    SWAG9405            9      .]   {„A much better more reliable method is just to set the CURRENT cursor's bit„5 to disable it, then mask it back off again...„}„unit cursor; {Public domain, by Sean Palmer}„„interface„„var maxSize:byte;„„ procedure cursorOn;„ procedure cursorOff;„ procedure setSize(scans:byte);  {set size from bottom, or 0 for off}„ procedure detect;     {get max scan lines by reading current cursor}„„implementation„„procedure cursorOn;assembler;asm„ mov ah,3; mov bh,0; int $10; and ch,not $20; mov ah,1; int $10;„ end;„„procedure cursorOff;assembler;asm„ mov ah,3; mov bh,0; int $10; or ch,$20; mov ah,1; int $10;„ end;„„procedure setSize(scans:byte);var t:byte;begin„ if scans=0 then t:=$20 else t:=maxSize-scans;„ asm mov ah,1; mov bh,0; mov ch,t; mov cl,maxSize; dec cl; int $10; end;„ end;„„{call whenever you change text cell height}„procedure detect;assembler;asm  {do NOT call while cursor's hidden}„ mov ah,3; mov bh,0; int $10; inc cl; mov maxSize,cl;„ end;„„begin„ detect;„ end.„                                               22     05-25-9408:10ALL                      LOU DUCHEZ               cursor hiding            SWAG9405            5      .]   „var crstyp: word;„„procedure cursoff;„„{ Turns the cursor off.  Stores its format for later redisplaying. }„„begin„  asm„    mov ah, 03h„    mov bh, 00h„    int 10h„    mov crstyp, cx„    mov ah, 01h„    mov cx, 65535„    int 10h„    end;„  end;„„procedure curson;„„{ Turns the cursor back on, using the cursor display previously stored. }„„begin„  asm„    mov ah, 01h„    mov cx, crstyp„    int 10h„    end;„  end;„„                                                                                             