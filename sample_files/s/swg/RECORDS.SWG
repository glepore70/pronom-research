SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00012         RECORD RELATED ROUTINES                                           1      05-28-9313:55ALL                      SWAG SUPPORT TEAM        BLOCKRW1.PAS             IMPORT              14          {„Does anyone have any examples of how to Write Text to a File using„blockWrite?„}„Program DemoBlockWrite;„„Const„  { Carriage-return + Line-feed Constant. }„  co_CrLf = #13#10;„„Var„  st_Temp : String;„  fi_Temp : File;„  wo_BytesWritten : Word;„„begin„  { Assign 5 lines of Text to temp String. }„  st_Temp := 'Line 1 of Text File' + co_CrLf + 'Line 2 of Text File'„             + co_CrLf + co_CrLf + 'Line 4 of Text File' + co_CrLf +„             ' My name is MUD ' + co_CrLf;„„  assign(fi_Temp, 'TEST.TXT');„  {$I-}„  reWrite(fi_Temp, 1);„  {$I+}„  if (ioresult <> 0) then„  begin„    Writeln('Error creating TEST.TXT File');„    Halt„  end;„  { Write 5 lines of Text to File. }„  BlockWrite(fi_Temp, st_Temp[1], length(st_Temp), wo_BytesWritten);„  { Check For errors writing Text to File. }„  if (wo_BytesWritten <> length(st_Temp)) then„  begin„    Writeln('Error writing Text to File!');„    Halt„  end;„  { Close File. }„  Close(fi_Temp);„  { Attempt to open Text File again. }„  Assign(fi_Temp, 'TEST.TXT');„  {$I-}„  Reset(fi_Temp, 1);„  {$I+}„  if (IOResult <> 0) then„  begin„    Writeln('Error opening TEST.TXT File');„    Halt„  end;„  st_Temp := 'Guy';„  { Position File-Pointer just before the 'MUD' in Text. }„  seek(fi_Temp, 77);„  { Correct my name by overwriting old Text With new. }„  blockWrite(fi_Temp, st_Temp[1], length(st_Temp), wo_BytesWritten);„  { Check For errors writing Text to File. }„  if (wo_BytesWritten <> length(st_Temp)) then„  begin„    Writeln('Error writing Text to File!');„    Halt„  end;„  Close(fi_Temp)„end.„                                                                                                            2      05-28-9313:55ALL                      SWAG SUPPORT TEAM        BLOCKRW2.PAS             IMPORT              51          (* Program to demonstrate BlockRead and BlockWrite    *)„(* routines.                                          *)„Program BlockReadWriteDemo;„Uses„  Crt;„Type„  st20 = String[20];„  st40 = String[40];„  st80 = String[80];„„  rcPersonInfo = Record„                   stFirst : st20;„                   stLast  : st20;„                   byAge   : Byte„                 end;„Const„  coRecSize = sizeof(rcPersonInfo);„„Var„  wototalRecs : Word;„  rcTemp      : rcPersonInfo;„  fiData      : File;„„  (***** Initialize Program Variables.                              *)„  Procedure Init;„  begin„    ClrScr;„    wototalRecs := 0;„    fillChar(rcTemp, coRecSize, 0);„    fillChar(fiData, sizeof(fiData), 0)„  end;        (* Init.                                              *)„„  (***** Handle Program errors.                                     *)„  Procedure ErrorHandler(byErrorNumber : Byte; boHalt : Boolean);„  begin„    Case byErrorNumber of„      1 : Writeln('Error creating new data-File.');„      2 : Writeln('Error writing Record to data-File.');„      3 : Writeln('Record does not exist.');„      4 : Writeln('Error reading Record from data-File.');„      5 : Writeln('Error erasing Record in data-File.')„    end;      (* Case byErrorNumber of                              *)„    if boHalt then„      halt(byErrorNumber)„  end;        (* ErrorHandler.                                      *)„„  (***** Create new data-File to hold Record data.                  *)„  Function CreateDataFile(Var fiData : File) : Boolean;„  begin„    {$I-}„    reWrite(fiData, 1);„    {$I+}„    if (ioresult = 0) then„      CreateDataFile := True„    else„      CreateDataFile := False„  end;        (* CreateDataFile.                                    *)„„  (***** Open data-File.                                            *)„  Procedure OpenDataFile(Var fiData : File; stFileName : st80);„  begin„    assign(fiData, stFileName);„    {$I-}„    reset(fiData, 1);„    {$I+}„    if (ioresult <> 0) then„      begin„        if (CreateDataFile(fiData) = False) then„          ErrorHandler(1, True)„        else„          Writeln('New data-File ', stFileName, ' created.')„      end„    else„      Writeln('Data-File ', stFileName, ' opened.');„    wototalRecs := Filesize(fiData) div coRecSize„  end;        (* OpenDataFile.                                      *)„„  (***** Add a Record to the data-File.                             *)„  Procedure AddRecord(woRecNum : Word; Var rcTemp : rcPersonInfo);„  Var„    woBytesWritten : Word;„  begin„    if (woRecNum > succ(wototalRecs)) then„      woRecNum := succ(wototalRecs);„    seek(fiData, (pred(woRecNum) * coRecSize));„    blockWrite(fiData, rcTemp, coRecSize, woBytesWritten);„    if (woBytesWritten = coRecSize) then„      inc(wototalRecs)„    else„      ErrorHandler(2, True)„  end;        (* AddRecord.                                         *)„„„(***  PART 2     *****)„„  (***** Get a Record from the data-File.                           *)„  Procedure GetRecord(woRecNum : Word; Var rcTemp : rcPersonInfo);„  Var„    woBytesRead : Word;„  begin„    if (woRecNum > wototalRecs)„    or (woRecNum < 1) then„      begin„        ErrorHandler(3, False);„        Exit„      end;„    seek(fiData, (pred(woRecNum) * coRecSize));„    blockread(fiData, rcTemp, coRecSize, woBytesRead);„    if (woBytesRead <> coRecSize) then„      ErrorHandler(4, True)„  end;        (* GetRecord.                                         *)„„  (***** Erase the contents of a data-File Record.                  *)„  Procedure EraseRecord(woRecNum : Word);„  Var„    woBytesWritten : Word;„    rcEmpty        : rcPersonInfo;„  begin„    if (woRecNum > wototalRecs)„    or (woRecNum < 1) then„      begin„        ErrorHandler(3, False);„        Exit„      end;„    fillChar(rcEmpty, coRecSize, 0);„    seek(fiData, (pred(woRecNum) * coRecSize));„    blockWrite(fiData, rcEmpty, coRecSize, woBytesWritten);„    if (woBytesWritten <> coRecSize) then„      ErrorHandler(5, True)„  end;        (* EraseRecord.                                       *)„„  (***** Display a Record's fields.                                 *)„  Procedure DisplayRecord(Var rcTemp : rcPersonInfo);„  begin„    With rcTemp do„      begin„        Writeln;„        Writeln(' Firstname = ', stFirst);„        Writeln(' Lastname  = ', stLast);„        Writeln(' Age       = ', byAge);„        Writeln„      end„  end;        (* DisplayRecord.                                     *)„„  (***** Enter data into a Record.                                  *)„  Procedure EnterRecData(Var rcTemp : rcPersonInfo);„  begin„    Writeln;„    With rcTemp do„      begin„        Write('Enter First-name : ');„        readln(stFirst);„        Write('Enter Last-name  : ');„        readln(stLast);„        Write('Enter Age        : ');„        readln(byAge)„      end;„    Writeln„  end;        (* EnterRecData.                                      *)„„  (***** Obtain user response to Yes/No question.                   *)„  Function YesNo(stMessage : st40) : Boolean;„  Var„    chTemp : Char;„  begin„    Writeln;„    Write(stMessage, ' (Y/N) [ ]', #8#8);„    While KeyPressed do„      chTemp := ReadKey;„    Repeat„      chTemp := upCase(ReadKey)„    Until (chTemp in ['Y','N']);„    Writeln(chTemp);„    if (chTemp = 'Y') then„      YesNo := True„    else„      YesNo := False„  end;        (* YesNo.                                             *)„„  (***** Compact data-File by removing empty Records.               *)„  Procedure PackDataFile(Var fiData : File);„  begin„    (* This one I'm leaving For you to Complete.                    *)„  end;        (* PackDataFile.                                      *)„„(***** PART 3   *****)„              (* Main Program execution block.                      *)„begin„  Init;„  OpenDataFile(fiData, 'TEST.DAT');„  rcTemp.stFirst := 'Bill';„  rcTemp.stLast  := 'Gates';„  rcTemp.byAge   := 36;„  DisplayRecord(rcTemp);„  AddRecord(1, rcTemp);„  rcTemp.stFirst := 'Phillipe';„  rcTemp.stLast  := 'Khan ';„  rcTemp.byAge   := 39;„  DisplayRecord(rcTemp);„  AddRecord(2, rcTemp);„  GetRecord(1, rcTemp);„  DisplayRecord(rcTemp);„  EraseRecord(1);„  GetRecord(1, rcTemp);„  DisplayRecord(rcTemp);„  EnterRecData(rcTemp);„  AddRecord(1, rcTemp);„  DisplayRecord(rcTemp);„  close(fiData);„  if YesNo('Erase the Record data-File ?') then„    erase(fiData)„end.„„„                  3      05-28-9313:55ALL                      SWAG SUPPORT TEAM        MANYRECS.PAS             IMPORT              13          {„>Okay, I've got the need to load about 3000 Records, at 73 Bytes a piece,„>into active memory.  It'd be preferred to have it as an Array of„>Records, which is what I'm using now (only at 1000 Records though).„„>When I do this I get Structure too Large.  Is there any way that I can„>load all of these Records into memory, For sorting, editing, deleting„>and adding new entries (which is easy With an Array).„„}„Const„     MaxItems  = 3000 ;„„Type TItem =„     Record„          { 73 Bytes Record }„          Dum  : Array[1..73] of Byte ;„     end ;„     PItem = ^TItem ;„„     TItemArray = Array[1..MaxItems] of PItem ;„„Var  i    : Integer ;„     Arr  : TItemArray ;„„begin„     For i:=1 to MaxItems Do New(Arr[i]) ;„„     { Now, can use all those items in memory }„„     For i:=1 to MaxItems Do Dispose(Arr[i]) ;„end.„„{„„note that the set of data will occupy :„„3000*4 Bytes in DS            12000 Bytes„3000*80 Bytes in the heap    240000 Bytes„                             ------„                             252000 Bytes of memory...„„The '80' in the second line is due to the fact that TP 6's heap manager„allocates heap space by multiples of 8 Bytes, thus 73 Bytes result in„80 Bytes allocs. Reducing it to 72 Bytes would save 8*3000=24000 Bytes.„„Anyway, this is not Real safe Programming, and you should prefer using a„File, unleast you are Really sure that :„- you won't have more than 3000 Records,„- any machine your Program will run onto has enough memory.„}                                                               4      05-28-9313:55ALL                      SWAG SUPPORT TEAM        RECINFO1.PAS             IMPORT              64          >Can anyone tell me how I can delete a Record from a File?„„Two ways.„„1) Mark the Record With a value that tells your Program that„   Record is classified as deleted. (Most DB Programs work this„   way)„„2) Read the WHOLE File in, one Record at a time. Copy these„   Records into the new File. While you are copying, ignore any„   Record(s) you want to delete.„„   Once the copy is Complete, delete the old File and rename the„   new to the old Filename...„„You could also open the File as unTyped :-), and use blockRead to read big„chunks Until you've read (recSize * number of Records beFore bad one) Bytes,„and blockWrite to Write them out to the temp File.  This might be faster,„depending on the number of Records and how big they are.„„> How would I pack a File of Records to save space?„„    if you have seen other posts by me about packing Database Type„Files, you will see I normally recommend against it.„„I usually go With a "Deleted" indicator and Records marked as„deleted are re-used. It is my personnal experience that such Files„normally grow in size Until they reach a balanced state. A state in„which the File does not grow anymore and where balance is reached„between Additions and Deletions.„„if you Really want to pack it then,„„    1- Build a list of deleted Records„    2- take the last Record in the File„    3- Keep a note that that Record is now empty„    4- OverWrite the FIRST DELETED Record's space With it„    5- Repeat steps 2-4 Until all deleted Records have been filled.„    6- Seek to the first Record marked empty, this should be the last„       one you moved.„       or you could simply seek to Record_COunt since the File should„       now contain no empty space all valid Records should be at the„       head of the File and thus seeking to Record_Count ensures you„       of being positionned at the very end.„    7- Truncate the File there by using the Truncate command.„    8- Be sure to close and re-open the File beFore any more processing„       so that Directory and FAT are updated.„„„> Could someone please give me an example of a good way (the best way?) to„> delete Records from a Typed File?  My only guess, after looking at all„> of the TP documentation, and my one TP book, is that I will have to read„> the File, and Write a new File, excluding the "deleted" Record.  This„> will require another (identical) Type statment, and File Variable, etc.,„> and will require me to then rename the smaller File...„>„> Isn't there a more efficient way????„„YES THERE IS!!!„„Modify your Record to this:„„Type„  My_Record = Record„    Deleted : Boolean;„    < Rest of your usual stuff >„  end;„„    Now if you use index Files, create an index File With the DELETED„field as the key to that index.„„Pseudo code ahead:„„    Adding a Record:„        1- Set index to DELETED„        2- Go to first Record„        3- Is it deleted„        4- Yes, use it as our new Record„            4a Change the Deleted field to False;„            4b Write our new Record to this one overwriting it.„        5- No, Add a new phisical Record to the File,„            5a Remember to Set Deleted to False on this one„            5b Write our Record to the new Record.„„    Deleting a Record:„        1- Go to Record,„        2- Read it in„        3- Set the deleted field to True.„            { This allows UnDeleting a Record With it's original data}„„    Listing Records:„        Remember to skip deleted Records.„„you will soon find that using this management method your applications„will perForm at speeds vastly faster than others. Simply because the„File is never moved, truncated etc.. Eliminating fragentation on the„disk. You will also find that as you open new databases, they will„quickly grow and then attain a stable size where new Records are mostly„reusing deleted Records.„„    This is how my dBase applications are handled. Our last project„While I was at the Justice Departement was re-written to use this„principle of management instead of using dBase's Pack and delete„routines. The efficiency was greatly augmented both in speed and in disk„occupation. We no longer needed to perForm unfragmentation routines„periodically and we also could reverse any error our users might have„commited.„„    By adding additionnal info such as deletion date, user ID that„requested the delete etc... we were able to offer options that were not„available beFore. An added benefit was that we didn't need to reindex„the whole database. Affected Index Files were open during operations and„were thus opdated on the fly. So our Deleted index was allways uptodate.„Generating a message when physical space was added to the database, we„were able to perForm defragementation only when Really needed. and those„operations were greatly shortened in time because 98% of the database„was allready defragmentated.„„It's the sensible way to do it, and it can be done in any language.„„{------------------------------------------------------------------------}„„>   Can someone tell me how to search through a Typed File.„>   Example:„>      Type Dummy = Record„>                     Name : String„>                     Age  : Integer„>                   end;„>           DummyFile = File of Dummy;„„>   How could I find a Record that has AGE = 20 ?„„Do something like this:„„Var„  PersonRecord : Dummy;„„Procedure searchForAge(PersonsAge: Integer);„begin„   ... Open the File ...„   Seek(DummyFile, 0);        {start at beginning of File}„   PersonRecord.Age:= 1000;   {Init to unused value}„   While not(Eof) and (PersonRecord.Age <> PersonsAge) do„   begin„       Read(DummyFile, PersonRecord);„   end;„   ... Close the File ...„end;„„„This might work:„ Type„   rec = Record„     age: Integer;„     etc...„   end;„ Var„   f: File of rec;„   r: rec;„ begin„   assign(f, 'FileNAME.EXT');„   reset(f, sizeof(rec));           (* have to indicate Record size *)„„   While not eof(f) do begin„     blockread(f, r, 1);            (* read one rec from f into r *)„     if r.age = 20 then„       (* do something interesting *)„   end;„   close(f);„ end.„„The trick is to inForm the runtime library of the size of each Record in the„File; you do this in the call to reset.  Blockread takes a File, an unTyped„buffer, and the number of Records to read.„„„„„„>I know that this is probably as common as the "I want to Write a BBS",„>and "*.MSG structures" :) but haven't seen anything lately (and I've„>been reading this For quite some time) about tips on searching Records„>in a File.  Any tips/routines on fast searching, or ways to set up the„>Record For fast searching?  Thanks.„„   Well, you're kinda restricting yourself by saying, "in a File".  That means„you have a File of some Type, and you're pretty-much confined to the ways„appropriate For that File Type.  However, there are some things you can do„which will make processing the data faster and more efficient:„ 1. For Text Files:„   a. use large buffers (SetTextBuf Procedure)„   b. establish an Index For the Records on the File, and use random i/o to„access specific Records.  Thgis does not imply reading all the Records each„time you "search it", but you must have some "key" or order in that File from„which you can assign and index key.  This is a large subject, and to go„further, I'd have to know more about your File.„   c. have the File (be of) fixed Records, sort on some key field, and use a„binary search/random read scheme to search For Records.  Also pretty„Complicated in Implementation...„  2. Random Files:„    There are many options here, and are mostly dependant on the File order and„data content/Record size.„„   Finally,  suggest you read the entire File into memory (using Heap, Pointer„access, etc.), and do all your work in memory.  The above ideas are appropriate„For very large Files, but anything under 450K can be stored in you system„memory and used there, I'll bet.  Once in memory, you can even sort the data in„some fashion and use some fancy searching techniques, too.„„„„„                                                                                       5      05-28-9313:55ALL                      SWAG SUPPORT TEAM        RECSORT.PAS              IMPORT              18          {„ ... would anyone know how-to sort a Record With 5 thing in it one of„ which is "NAME"...I want to sort each Record in the Array by name and„ can't figure it out....my Array name is LabelS and my Record name is„ SofT...„}„„Program sort_Records;„„Type„  index_Type = 1..100;„  soft_Type = Record„                name,„                street,„                city: String[20];„                state: String[2];„                zip: Integer„              end; { Record }„  Labels_Type = Array[index_Type] of soft_Type;„„Var„  Labels: Labels_Type; { an Array of Records }„  index,„  count: index_Type;„  f: Text; { a File on disk holding your Records, we assume 100 }„„{ ******************************************** }„Procedure get_Records(Var f: Text;„                      Var Labels: Labels_Type); Var„  counter: index_Type;„„begin { get_Records }„  For counter := 1 to 100 do„    begin„      With Labels[counter] do„        readln(f, name, street, city, state, zip);„    end;„end;  { get_Records }„„{ ******************************************** }„Procedure sort_em(Var Labels: Labels_Type);„„Var„  temp: soft_Type;    { a Single Record }„  counter,„  counter2,„  min_index: Integer;„„begin { sort_em }„  For counter := 1 to 99 do { 99 not 100 }„    begin„      min_index := counter;„      For counter2 := counter + 1 to 100 do„        if Labels[counter2].name < Labels[counter].name„          then„            min_index := counter;„      temp := Labels[min_index];„      Labels[min_index] := Labels[counter];„      Labels[counter] := temp„    end;„end;  { sort_em }„„{ ******************************************** }„„Procedure Write_Labels(Var Labels: Labels_Type;„                       Var f: Text);„Var„  counter: index_Type;„„begin { Write_Labels }„  For counter := 1 to 100 do„    begin„      With Labels[counter] do„        Writeln(f, name, street, city, state, zip);„    end;„end;  { Write_Labels }„„{ ******************************************** }„„begin { main }„  assign(f, 'DATAFile.DAT'); { or whatever it is on your disk }„  reset(f);„  get_Records(f, Labels);„  sort_em(Labels);„  reWrite(f);„  Write_Labels(Labels, f);„  close(f)„end. { main }„              6      05-28-9313:55ALL                      SWAG SUPPORT TEAM        RECSRCH.PAS              IMPORT              22          {„HAGEN LEHMANN„> Can someone help me make a search Procedure that will read„> from a Record format, from the disk!!!„„The easiest way to search a Record in a File is to read the Records from File„and compare them With the Record that is to be searched.„„if you simply want to search For a String then I've got something For you. ;-)„Look at this Function:„}„Function Search(SearchFor : String; FileName  : String) : LongInt;„Var„  F               : File;„  Pos,Dummy       : LongInt;„  BufSize,ReadNum : Word;„  Buffer          : ^Byte;„  Found           : Boolean;„„  Function SearchString(Var Data; Size : Word; Str  : String) : LongInt;„  Var„    S     : String;„    Loop  : LongInt;„    Found : Boolean;„    L     : Byte Absolute Str;„  begin„    Loop  := -1;„    Found := False;„    if L > 0 Then   { I don't search For empty Strings, I'm not crazy }„    Repeat„      Inc(Loop);„      { convert buffer into String }„      Move(Mem[Seg(Data) : Loop], Mem[Seg(S) : Ofs(S) + 1], L + 1);„      S[0] := Char(L);„      if S = Str Then„        Found := True;             { search For String }„    Until Found Or (Loop = Size - L);„    if Found Then„      SearchString := Loop   { that's the File position }„    else„      SearchString := -1;    { I couldn't find anything }„  end;„„begin„  Search := -1;„  if MaxAvail > 65535 Then„    BufSize := 65535   { check available heap }„  else„    BufSize := MaxAvail;„  if (BufSize > 0) And (BufSize > Length(SearchFor)) Then„  begin„    GetMem(Buffer, BufSize);               { reserve heap For buffer }„    Assign(F, FileName);„    Reset(F, 1);                                         { open File }„    if IOResult = 0 Then„    begin„      Pos   := 0;„      Found := False;„      Repeat„        BlockRead(F, Buffer^, BufSize, ReadNum);          { read buffer }„        if ReadNum > 0 Then                             { anything ok? }„        begin„          Dummy := SearchString(Buffer^, ReadNum, SearchFor);„          if Dummy <> -1 Then                   { String has been found }„          begin„            Found := True;                            { set found flag }„            Inc(Pos, Dummy);„          end„          else„          begin„            Inc(Pos, ReadNum - Length(SearchFor));„            Seek(F, Pos);                       { set new File position }„          end;„        end;„      Until Found Or (ReadNum <> BufSize);„      if Found Then„        Search := Pos            { String has been found }„      else„        Search := -1;         { String hasn't been found }„      Close(F);„    end;„    Release(Buffer);                        { release reserved heap }„  end;„end;„„                                            7      05-28-9313:55ALL                      SWAG SUPPORT TEAM        VARIANT.PAS              IMPORT              15          {* Program that works!„** Shows use of Variant Records.„** roleplaying Type implemented.„*}„Uses Crt;„Type„  CharType = (Warrior, Wizard);„  CharacterType = Record„                    Name: String[16];„                    Health, MaxHealth: Integer;„                    Char: CharType;„                    Case CharType of„                      Warrior: ( DamagetoHit: Integer);„                      Wizard : ( Spell, MaxSpell: Integer);„                  end;„„Var„  Character: CharacterType;„  S: String;„„begin„„  { select Character Type }„  Writeln;„  Writeln('Select Character Type:');„  Writeln(' [ 1 ] Warrior');„  Writeln(' [ 2 ] Wizard');„  Readln(S);„„  With Character do„   begin„     if S = '1' then Character.Char := Warrior else„       Character.Char := Wizard;„„     { set fixed Variables }„     Write('Enter Character name: ');„     Readln(Name);„     Write('Enter Character health value: ');„     Readln(MaxHealth);„     Health := MaxHealth;„     { set Variant Variables }„     Case Char of„       Warrior: begin„                  Write('Enter ', Name, '''s hit value: ');„                  Readln(Character.DamagetoHit);„                end;„       Wizard:  begin„                  Write('Enter ', Name, '''s spell value: ');„                  Readln(MaxSpell);„                  Spell := MaxSpell;„                end;„     end;„   end;„„  With Character do     { display Character info }„    begin„      { fixed Variables }„      Writeln;„      Writeln('*** Your Character:');„      Writeln('    Name: ', Name);„      Writeln('  Health: ', Health,'/',MaxHealth);„      { Variant Variables }„      Case Char of„        Warrior: Writeln('     Hit: ', DamagetoHit);„        Wizard:  Writeln('   Spell: ', Spell, '/', MaxSpell);„      end;„    end;„end.„                     8      05-31-9307:13ALL                      SWAG SUPPORT TEAM        Fast Delete Typed RecordsIMPORT              9           BG>JB>A method that I have successfully used to delete records in place is„BG>JB>to...„„  'Scuse me for butting in, but I have another approach which will„  preserve your record order. I will present it for a file of records„  the total size of which is less than 64K. The routine may easily be„  adapted for large files:„„procedure del_rec(fname : string;target : longint;rec_size : longint);„type„  t_buf=array[1..65520] of byte;„„var„  f : file;„  buf : t_buf;„  n : word;„„begin„  new(buf);„  assign(f,fname);  { open your file }„  reset(f,1);„  blockread(f,buf,sizeof(buf),n);„  close(f);„„  move(buf[succ(target)*rec_size],buf[target*rec_size],n-(target*rec_size));„  dec(n,rec_size);„  rewrite(f,1);„  blockwrite(f,buf,n);„  close(f);„  dispose(buf);„end;„---„ * The Right Place (tm) BBS/Atlanta - 404/476-2607 SuperRegional Hub„ * PostLink(tm) v1.05  TRP (#564) : RelayNet(tm)„---„ ˛ OLX 2.1 TD ˛ I just steal 'em, I don't explain 'em.„                                                                          9      08-27-9321:14ALL                      DANIEL HEFLEY            Delete Record Routine    IMPORT              13     6Å   {„DANIEL HEFLEY„„> according to all references I've read, the only way to delete Records„> in ANY File is to copy the good Records to a new File, skipping over„> the ones you want deleted, delete the original File, and rename the new„> one to the original name.  A long way of doing it, but I don't know of„> any other.„„ No.....You could:„}„„Procedure DelRec(RecIdx : LongInt);„Var„  Count,„  RecNo : LongInt;„  IFile : File of ItemRec;„  Item : ItemRec;„„begin„  Assign(IFile,'Tmp.Dat'); Reset(f);   { assuming it exists }„  Seek(IFile,idx);                     { assuming recidx exists }„  RecNo := FileSize(f) - idx - 1;„  For Count := idx to RecNo do„  begin„    Seek(IFile,Count+1);„    Read(IFile,Item);        { read next rec }„    Seek(IFile,Count);„    Write(IFile,Item);       { overide prev rec }„  end;„  Seek(IFile,RecNo);                       { seek to last Record }„  Truncate(IFile);                     { truncate rest of File }„  Close(IFile);„end;„„{„> Of course, you could cheat like I do...when I create a File With„> Records, every one of them has one Boolean field called ACTIVE_REC,„> which is forced to True when the Record is created.  if the user wants„> to delete the Record, ACTIVE_REC becomes False and the Program ignores„> the Record.  Eventually, you'll have to use the above„> copy-delete-rename Procedure, but it sure saves time if you're just„> deleting one Record!„„When you initialize new Variables....find the Non Active Record and assign„your File index Variable to that record!„}              10     08-27-9321:14ALL                      STEVE ROGERS             Another Delete Routine   IMPORT              8      6Å   {„STEVE ROGERS„„>A method that I have successfully used to delete Records in place is to...„„  'Scuse me For butting in, but I have another approach which will„  preserve your Record order. I will present it For a File of Records„  the total size of which is less than 64K. The routine may easily be„  adapted For large Files:„}„„Procedure del_rec(fname : String; target : LongInt; rec_size : LongInt);„Type„  t_buf = Array[1..65520] of Byte;„Var„  f   : File;„  buf : ^t_buf;„  n   : Word;„begin„  new(buf);„  assign(f, fname);  { open your File }„  reset(f, 1);„  blockread(f, buf^, sizeof(buf^), n);„  close(f);„„  move(buf^[succ(target) * rec_size],„       buf^[target * rec_size], n - (target * rec_size));„  dec(n, rec_size);„  reWrite(f, 1);„  blockWrite(f, buf^, n);„  close(f);„  dispose(buf);„end;„                                                                                        11     01-27-9411:53ALL                      MAYNARD PHILBROOK        Records in ASM           IMPORT              14     6Å   {„ To access record fields in Assembler you should define a Register to the„ofset of the variable s or Record..„Example:„}„Type MyRec = Record„       Hi :Byte;„       Lo :Word;„       S :String[90];„      End;„Var„ Yup :MyRec;„Begin„asM„       Mov     DI, Seg Yup;„       Push    DI;     { Save it just incase folloing code uses DI }„       { do what evr code you wish }„       Pop     DI      { Get back our pointer }„       Mov     [DI+MyRec.Hi], AL;      { Lets say AL was the reg u want }„       Mov     [DI+RyRec.Lo], BX;„       { Ect }„{       ....„Remember, if you enter an assembler rountine that passes a Array of Records„then you must Load AX with the size of Your Record, Take the Array Pointer„Index Times The AX using the MUL instructions then SubTrace the Size of the„Record from the AX which would be the Results fo the multiply and then add„that to the DI for a Total Offset to the correct Record;„Example:„ I want Record # 2„}„Procedure Test( AR:Array[1..4] of MyRec);„ Begin„  ASm„   Mov Di, Offset AR;„   Mov AX, TypeOF(MyRec);      { This generates the Size of the Record }„   MUL AX, 2;                  { I want to times it by 2 }„   SUB AX, TypeOf(MyRec);„   ADD DI,AX;„   { Now the DI pointers to the start of the #2 Record }„{ Of course this Record is on the stack in this example;„ Use a Globel methd or use the VAr in the Parms.„it you use VAR then the Address must be gotten indirectly.„Example:„}  LES  DI, AR;         { THis Loads the Address fo the Array from the STactk„ { Then you go through you same multipy stuff }„                                                                                                                  12     01-27-9412:22ALL                      ALBERT DORREPAAL         Finding Records          IMPORT              8      6Å   {„> What is the best way to Find a record in a file of Records?„> Can one seek to the specified record, or do you need to„> read each record in the file and check a field for the„> proper value?„„If you want a search on one field, you better create a sorted index-file where„you can search on a btree-kind of way.„„Something like this:„}„RecFile : Record =„             Deleted: Boolean;„             Name   : String[15];„             Descrip: String[25];„             RText  : Array[0..39] of String[82];„          End;„„IdxFile : Record =„             Name : String[15];  {same as in RecFile}„             Recnum : Word;      {record.no. in RecFile}„          End;„„Var Rfile : File of RecFile;„    Ifile : File of IdxFile;„{„If you keep your index-file sorted, you can search quikly for a name in the„index and a Seek(Rfile, Ifile.Recnum) gives you the record.„}„                             