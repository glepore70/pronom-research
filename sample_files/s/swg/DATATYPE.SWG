SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00018         DATA TYPE & COMPARE ROUTINES                                      1      05-28-9313:37ALL                      SWAG SUPPORT TEAM        BIGARRAY.PAS             IMPORT              11     ^~eL {„>Do you know if the 64k Array limit still holds True when compiling„>under protected mode in BP7?„„>...The answer is yes, however the limit is 64K (or 65,521 Bytes„>to be more exact  ie: < 65,535 Bytes) per data element. (ie: You„>can create an Array of 1..N of 64K elements, using an Array of„>Pointers.)„„>But you can do *that* in Real mode.„„  ...Yes, but try building something like this:„}„Uses„  Crt;„„Type„  ar_64K   = Array[1..65521] of Byte;„  po_ar64K = ^ar_64K;„  ar_Po64K = Array[1..200] of po_ar64K;„„Var„  by_Index : Byte;„  Buffer   : ar_Po64K;„„begin„  ClrScr;„  by_Index := 0;„  While (MaxAvail > SizeOf(ar_64K)) do„  begin„    Inc(by_Index);„    New(Buffer[by_Index]);„    GotoXY(1,1);„    ClrEol;„    Write('Maximum Memory Available: ', MaxAvail);„    Delay(300);„  end;„end.„{„  ...Using the DPMI HEAP (and calling the correct DPMI Function„  to use your hard disk as virtual memory, unless you do have„  16Mb in your PC) you can allocate all 200 64K chunks of memory.„  With the "Real mode" HEAP, you'd be lucky to be able to allocate„  9 of these 64K chunks.„„  ...It also means that you can use this DPMI HEAP to run HUGE .EXE's,„  as it can be used For either CODE or DATA. So you can forget about„  overlays, as you won't need them anymore.„}„          2      05-28-9313:37ALL                      SWAG SUPPORT TEAM        BIGHEAP.PAS              IMPORT              33     ^~Ëö {    ...Here is a demo Program that will read-in up to 15,000 Records„    onto the HEAP memory pool.„}„„{$A+,B-,D+,E-,F-,G-,I+,L+,N-,O-,P-,Q+,R+,S+,T-,V-,X-,Y-}„{$M 4096,0,655360}„„Program Large_Array_Structure_Demo;„„Type„              (* Type definitions.                                    *)„  st_8    = String[8];„  inar_4  = Array[0..4] of Integer;„„  rc_zlog = Record„              date      : String[8];„              userbaud  : inar_4;„              active    : Integer;„              calls     : Integer;„              newusers  : Integer;„              pubpost   : Integer;„              privpost  : Integer;„              netpost   : Integer;„              criterr   : Integer;„              uploads   : Integer;„              downloads : Integer;„              uk        : LongInt;„              dk        : LongInt„            end;„„Const„              (* Maximum number of Records to read-in.                *)„  co_rcMax   = 15000;„              (* Byte size of 1 Record.                               *)„  co_rcSize  = sizeof(rc_zlog);„„Type„              (* Pointer of zlog Record Type.                         *)„  porc_zlog  = ^rc_zlog;„              (* Array of 15,000 of zlog-Record Pointers.             *)„  poar_15K   = Array[1..co_rcMax] of porc_zlog;„„Var„              (* Use to store "ioresult" value.                       *)„  by_Error          : Byte;„              (* Loop control Variable.                               *)„  wo_Index,„              (* Total number of Records in the data File.            *)„  wo_RecTotal,„              (* Number of Bytes read using "BlockRead" routine.      *)„  wo_BytesRead      : Word;„              (* Pointer to mark the bottom of the HEAP.              *)„  po_HeapBottom     : Pointer;„              (* Array of 15,000 zlog-Record Pointers.                *)„  poar_RcBuffer     : poar_15K;„              (* File Variable to be assigned to the data File.       *)„  fi_Data           : File;„„begin„              (* Try to open the data File.                           *)„  assign(fi_Data, 'ZLOG.DAT');„  {$I-}„  reset(fi_Data, 1);„  {$I+}„              (* Check For File errors.                               *)„  by_Error := ioresult;„  if (by_Error <> 0) then„  begin„    Writeln('Error ', by_Error, ' opening ZLOG.DAT File');„    halt„  end;„„              (* Calculate the number of Records in data File.        *)„  wo_RecTotal := (Filesize(fi_Data) div co_rcSize);„              (* Initialize loop control Variable.                    *)„  wo_Index := 1;„              (* Record the address of the HEAP "bottom".             *)„  mark(po_HeapBottom);„              (* While free memory is greater than size of 1 Record   *)„  While (maxavail > co_rcSize)„              (* And, not all Records have been read in...            *)„  and   (wo_Index < wo_RecTotal)„              (* And, less than maximum number of Records to read-in. *)„  and   (wo_Index < co_rcMax) do„  begin„            (* Allocate room For 1 Record on the HEAP.              *)„    new(poar_RcBuffer[wo_Index]);„            (* Read 1 Record from data File into new HEAP Variable. *)„    blockread(fi_Data, poar_RcBuffer[wo_Index]^, co_rcSize, wo_BytesRead);„            (* Check For "BlockRead" error.                         *)„    if (wo_BytesRead <> co_rcSize) then„    begin„      Writeln('BLOCKREAD error!');„      halt„    end;„            (* Advance loop control Variable by 1.                  *)„    inc(wo_Index)„  end;„              (* Close the data File.                                 *)„  close(fi_Data);„              (* Display the amount of free HEAP memory left.         *)„  Writeln('Free HEAP memory = ', maxavail, ' Bytes');„              (* Display the number of Records read onto the HEAP.    *)„  Writeln('Records placed on the HEAP = ', wo_Index);„              (* Release all the HEAP memory used to store Records.   *)„  release(po_HeapBottom);„              (* Display the amount of free HEAP memory left, again.  *)„  Writeln('Free HEAP memory = ', maxavail, ' Bytes');„„end.„                                     3      05-28-9313:37ALL                      SWAG SUPPORT TEAM        BOOLS.PAS                IMPORT              15     ^~ÃN {„  This is a small Unit I wrote when I got tired of writing great gobs„  of nested "if thens" or pages of parenthetic blobs.„  With this Unit you can Write as many Boolean expressions„  as you like as a block of Boolean.„  True mode:„       all interior expressions must be True For the block to be True.„       if one interior expression is False then the block is False.„  False mode:„       all interior expressions must be False For the block to be False.„       if one interior expression is True then the block is True.„  Any ideas on enhancing it?„}„Uses„  Crt;„„Const„  AllBool  : Boolean = True;„  BoolMode : Boolean = True;„„Var„  S : String;„„Procedure SetBool(Mode : Boolean);„begin„  AllBool  := Mode;„  BoolMode := Mode;„end;„„Procedure Bool(Expression : Boolean);„begin„  if ((BoolMode) and (not Expression)) then„    AllBool := False;„  if ((not BoolMode) and (Expression)) then„    AllBool := True;„end;„„begin„  ClrScr;„  S := '1 This is the best there is \.';      {init. String}„  SetBool(True);                {set checkmode For all True}„  Bool( Length(s) > 4 );        {series of Boolean expressions}„  Bool( s[3] in ['A'..'Z'] );„  Bool( Ord(s[1]) - 48 < 10 );„  Bool( Pos('This', s) > 0 );„  Bool( s[Length(s)] = '.');„  Bool( 2 + 3 = 5);„  if AllBool then„    Writeln('1. All expressions are True')„  else„    Writeln('1. At least one expression is False');„„  SetBool(False);              {set checkmode For all False}„  Bool( Length(s) > 44 );      {series of Boolean expressions}„  Bool( s[3] in ['a'..'z'] );„  Bool( Ord(s[1]) - 48 > 10 );„  Bool( Pos('This', s) = 0 );„  Bool( s[Length(s)] = 'g');„  Bool( 2 + 3 = 4);„  if not AllBool then„    Writeln('2. All expressions are False')„  else„    Writeln('2. At least one expression is True');„  Readln;„end.„   4      05-28-9313:37ALL                      SWAG SUPPORT TEAM        COMPARE.PAS              IMPORT              4      ^~Ø {„SEAN PALMER„„generic compare Function...„make sure to keep garbage out of Strings (by filling With #0„before storing the Strings) and you can compare ANY data With this.„}„„Function equal(Var m1, m2; siz : Word) : Boolean; Assembler;„Asm„  push ds„  cld„  les di, m1„  lds si, m2„  mov cx, siz„  xor al, al„  repe cmpsb„  jne @S„  inc al„ @S:„  pop ds„end;„                         5      05-28-9313:37ALL                      SWAG SUPPORT TEAM        FUNCPARA.PAS             IMPORT              7      ^~. This is legal syntax For Turbo/Borland Pascal v.6 and above:„„Type„  MathFunc = Function (x:Real):Real;„„  Function MyFunc(x:Real):Real;„  begin„    MyFunc:=2 * Sin(x) + Cos(x);„  end;„„  Function YetAnother(x:Real):Real;„  begin„    YetAnother:=Sqr(x) + x/2 + 1;„  end;„„  Function AreaUnder(f:MathFunc; Lo, Hi:Real; Steps:Integer):Real;„  Var„    sum,„    x,„    dx  : Real;„    i   : Integer;„  begin„    dx:=(Hi-Lo)/Steps;„    sum:=0;„    x:=Lo;„    For i:=1 to Steps„    do begin„      sum:=sum + f(x);„      x:=x + dx;„    end;„  end;„„  begin„    Writeln(AreaUnder(MyFunc, 0, 2*PI, 360));„    Writeln(AreaUnder(YetAnother, -1,1, 100));„  end.„„                                                                                                                     6      05-28-9313:37ALL                      SWAG SUPPORT TEAM        MULTITYP.PAS             IMPORT              16     ^~>ˇ {„>Is is Possible to have a File of Two different Record Types?„>How would one do this? I have seen it done..„„First, don't Declare the Type of the File, just use a Type or File.„„Declare Pointer Variables For each Type that the Record can be.   if you want„the Record to hold a Value that says what the Record Type is, then device an„ID scheme, and make sure the ID Variables are physically located at the same„Position in both Records.„„„Read that data into a buffer Record With BlockRead.  Assign the Typed„Pointers to that buffer, and process away....„}„„Type„  onerec = Record  { Record size is 98 Bytes }„    id : Byte;   { We will set ID = 1 For onerec }„    Username : String[80];„    Phone : String[15];„  end;„  anotherrec = Record  { Length is 163 Bytes }„    id : Byte; {We will set ID = 2 For anotherrec }„    ADDRESS1 : String[80];„    ADDRESS2 : String[80];„  end;„„Var„  ONE : ^ONEREC;„  AnotHER : ^AnotHERREC;„  Buffer : Array[1..163] of Char;   { The size of the largest Record }„  F : File;„  NumRead : Word;„  ID : Byte Absolute Buffer;   { ID points to the first Char begin}„begin„  Assign(F,'FileNAME');„  Reset(F,SizeOf(Buffer));„  One := @BUFFER;„  AnotHER := @BUFFER;„  BlockRead(F,BUFFER,SIZEof(BUFFER),NUMRead);„  While NumRead > 0 Do„  begin„    Case ID of„      1 :„        begin„          WriteLn('Record is of Type ONE');„          WriteLn('USERNAME: ',ONE^.USERNAME);„          WriteLn('Phone: ',ONE^.Phone);„        end;„      2 :„        begin„          WriteLn('Record is of Type AnotHER');„          WriteLn('Address Line 1 = ',AnotHER^.ADDRESS1);„          WriteLn('Address Line 2 = ',AnotHER^.ADDRESS2);„        end;„      else„        WriteLn('Unidentified Record Type');„    end; { of Case }„    BlockRead(F,BUFFER,SIZEof(BUFFER),NUMRead);„  end;„  Close(F);„end.„„                                                                                                                   7      05-28-9313:37ALL                      SWAG SUPPORT TEAM        SAVEDATA.PAS             IMPORT              11     ^~¸π {„>I have a question about Typed Constants.  By this I mean the„>following declaration:„>„>  Const„>    Example : Byte = 1;„>„>What are the advantages to this?„„  ...One of the advantages to using "Typed Constants", is that it„  allows you to initalize Variables at CompILE-TIME (ie: When you„  Compile your source-code into an .EXE), instead of RUN-TIME.„  (ie: When your Program is actually running.)„„  ...Another advantage is that "Typed Constants" within Functions/„  Procedures keep their data between calls.„}„„Procedure SaveData({input} Var DataBuffer : byar_Data);„Const„  bo_FileOpen : Boolean = False;„begin„  if (bo_FileOpen = False) then„    begin„      assign(fi_Data, st_DataName);„      {$I-}„      reset(fi_Data, 1);„      {$I+}„      Check_For_IO_Error;„      bo_FileOpen := True„    end;„  blockWrite(fi_Data, DataBuffer, sizeof(DataBuffer));„  Check_For_IO_Error„end;„„{„  ...The Procedure above would only open the data-File once,„  and all Repeat calls to this Procedure would just Write„  there data to the File. (ie: The Boolean "Typed-Constant"„  bo_FileOpen would only be False the first time this routine„  executed. The next time this routine executed bo_FileOpen„  would be equal to True.)„}„„                                                          8      05-28-9313:37ALL                      SWAG SUPPORT TEAM        TYPECAST.PAS             IMPORT              24     ^~ò (*„> Hi, I am a begginer Programer (I taught myself) and I am writing a„> sort of "matching Program" my problem is: is there a way to give to„> Variable two values of diffent Types (a Variable called X1 would„> have one Char Type and hold a Integer value at the same time)?„„ Yes.  There is more than one way to do this, using Turbo Pascal.„„ The most familiar way is by using the "Type-transfer" Functions:„„            orD()           { transfer Char value to Word|Integer   }„            CHR()           { transfer Word|Integer to Char         "„„ Similar to this, there is also "Type-casting."  to use this method„ you just put the Variable to be changed inside of brackets that„ specify the Type wanted (see example below).„„ A third way is to use "free unions," which look like Records. Again,„ the example code, below, is the best way to show you.„„ Experiment With this example code.  if you still have problems„ after, show me an example of what you are trying to do ...„*)„„(*******************************************************************)„ Program Example;               { Compiler: Turbo & Quick Pascal    }„                                { Feb.17.1993, Greg Vigneault       }„„ { Examples of Type-transfer, Type-cast, and free unions ...        }„„ Type   CharInt = Record                        { the free union    }„                    Case Word of„                        0   : ( Ch  : Char );„                        1   : ( Int : Integer );„                  end;„„ Var    myVar   :CharInt;                       { a free union Var  }„        bVar    :Byte;                          { unsigned 8-bit    }„        cVar    :Char;                          { a Character       }„        iVar    :Integer;                       { signed 16-bit     }„        wVar    :Word;                          { unsigned 16-bit   }„ begin„ {  examples using "Type-transfer" Functions ...                    }„„    bVar := 65;           WriteLn( bVar );      { Byte value        }„    cVar := CHR( bVar );  WriteLn( cVar );      { displays 'A'      }„    iVar := orD( cVar );  WriteLn( iVar );      { Char to Integer   }„„ {  examples using "Type-casting" ...                               }„„    cVar := Char( bVar );  WriteLn( cVar );     { cast Char to Byte }„    bVar := Byte( cVar );  WriteLn( bVar );     { cast Byte to Char }„    iVar := Integer( cVar );  WriteLn( iVar );  { Char to Integer   }„„ { examples using a "free union" ...                                }„„    myVar.Ch := 'A';                            { assign as Char    }„    WriteLn( myVar.Int );                       { display Integer   }„    myVar.Int := 48;                            { assign Integer    }„    WriteLn( myVar.Ch );                        { display Char '0'  }„„ end {Example}.„(*******************************************************************)„                                                                                                 9      05-28-9313:37ALL                      SWAG SUPPORT TEAM        TYPECST2.PAS             IMPORT              8      ^~)r  > Yes LongInts are as you say from approx -2bil to +2bil.  I'd„ > say what is happening here is that you are adding two„ > Integers & assigning the result to a LongInt.  Consider the„ > following :-„„ > Var„ >    v1, v2 : Integer;„ >    Res    : LongInt;„„ > begin„ >      v1 := 30000;„ >      v2 := 30000;„ >      Res := v1 + v2;„ > end;„„ > This will not give Res = 60000, because as Far as I am aware„ > TP only does Type promotion to the RHE Until the actual„ > assignment operation.  What this means is that the sum of v1„ > & v1 must yield an Integer since the largest Type to contain„ > each is an Integer.  Adding two Integer 30000 numbers„ > together caUses an overflow & ends up being a random-ish„ > number, usually negative.  So what must be done here is„ > Typecasting.  This should fix it :-„„ >      Res := LongInt(v1) + LongInt(v2);„                                              10     05-28-9313:37ALL                      SWAG SUPPORT TEAM        TYPEFILE.PAS             IMPORT              8      ^~º  ->> You could also open the File as unTyped :-), and use blockRead to„ ->> read big chunks Until you've read (recSize * number of Records beFore„„ PW>       Can I do this even if the File is a Typed File to begin with?  How„ PW> would I do it?  Thanks For the info.„„„You can close it and reopen it, just use two Variables:„„  Var„    uf:   File;„    tf:   File of gummi_bear;„„„  begin„    assign(tf, 'TEST.FIL');„    reset(tf);„    .„    .                   (* do whatever you need the Typed File For *)„    .„    close(tf);„    assign(uf, 'TEST.FIL');„    reset(uf, 1);       (* tell runtime lib that rec size is one Byte *)„    .„    .                   (* now it's unTyped, you can use blockread to *)„    .                   (* read an arbitrary number of Bytes *)„    close(uf);„  end;„„                                                                                                     11     05-28-9313:37ALL                      SWAG SUPPORT TEAM        UNTYPED.PAS              IMPORT              9      ^~85 {„> It would be Really nifty if it were possible to have InVar be„> unTyped in the Function, so that the call would pass the Type,„> but I can't figure this one out.„„Here is a small sample of code that demonstrates how to do what (I„think) you're wanting to do:„}„„Type„  TypeID = (tByte, tInt, tLong, tReal, tStr);„„Procedure MultiType(Var InVar; InType : TypeID);„„Var„  b : Byte Absolute InVar;„  w : Integer Absolute InVar;„  i : LongInt Absolute InVar;„  r : Real Absolute InVar;„  s : String Absolute InVar;„„begin„  Case InType of„    tByte : WriteLn('Byte = ',b);„    tInt  : WriteLn('Integer = ',w);„    tLong : WriteLn('LongInt = ',i);„    tReal : WriteLn('Real = ',r);„    tStr  : WriteLn('String = ',s);„    else    WriteLn('Unknown Type!');„  end;„end;„„{„of course, the above is just an example and it doesn't actually„do anything useful, but you should be able to adapt it to suit„your purposes.„}„„                                                                                                             12     05-28-9313:37ALL                      SWAG SUPPORT TEAM        VARARRAY.PAS             IMPORT              8      ^~W« {„>   I'm trying to figure out a way to declair a Variable, such as an„>   Array, and I don't know the size Until I've loaded the Program.„>   I've tried stuff like........„>„>   Type„>       Buf : Array[1..1000] of Char;„>   Var„>       Buffer : ^Buf„>   begin„>     Getmem(Buffer,xxx)„„„Here's how:„}„„{$R-} { <-- essential For this trick }„„Type„  tFlexArray = Array[1..1] of Integer;„„Var„  pFlexArray : ^tFlexArray;„  NumofElements,i : Integer;„„begin„  Write('How many elements do you want in the Array?  ');„  readln(NumofElements);„  getmem(pFlexArray, (NumofElements * sizeof(Integer)));„  For i := 1 to NumofElements do„    pFlexArray^[i] := i;„„  Write('Test which element?  (Will contain same value as index)  ');„  readln(i);„  Writeln('Element ',i,' contains ',pFlexArray^[i]);„end.„                                                                                                   13     05-28-9313:37ALL                      SWAG SUPPORT TEAM        VARARRY2.PAS             IMPORT              10     ^~Lª {„>  I'm trying to figure out a way to declair a Variable, such as an„>  Array, and I don't know the size Until I've loaded the Program.„>  I've tried stuff like........„>  Type„>      Buf : Array[1..1000] of Char;„>  Var„>      Buffer : ^Buf„>  begin„>    Getmem(Buffer,xxx)„}„„Type„  TElement = LongInt ;     { Here use your own }„„Const„  MaxElement = 65500 div Sizeof(TElement) ;„„Type„  TElementArray = Array[1..MaxElement] of TElement ;„  PElementArray = ^TElementArray ;„„Var„  i    : Word ;„  Elms : PElementArray ;„„begin„  Write('How many of ''em do you feel like using ? :') ;„  ReadLn(i) ;„  if i>MaxElement then„  begin„    WriteLn('That''s more than I can hold, sorry...') ;„    Halt(1) ;„  end ;„  GetMem(Elms, i*Sizeof(TElement)) ;„„  { Now, use Elms^[1] to Elms^[i] }„„  FreeMem(Elms, i*Sizeof(TElement)) ;„end.„„{„Please note that the previous allows you to keep range checking on, but that„does not garanty you any security : access to an element which's index is„greater than i would cause no RTE, but writing to it will quite mess up things„in memory...„}                                                                            14     01-27-9411:53ALL                      HOLGER DAEHRE            Large Arrays             IMPORT              18     ^~åc {„> In a program I am writing I need to create a very large array to store„> infomation in I need an array[1..4096] of string and turbo pascal will„„Try my unit. My unit uses a TEMSStream to store the information.„Look at the demo how to store your 4096 strings.„}„„(* Unit LongArray - large arrays in EMS„   PUBLIC DOMAIN  1993 by Holger Daehre 2:248/317.88„   Running: TP 6.0 or above. *)„„Unit LongArr;„„Interface„„Uses  Objects;„„Var„   Lo_element,ElementSize:LongInt;„„(* Create_Array creates  Array[Low..High] of Size *)„Procedure Create_Array(Var ps:pStream;Low,High,Size:LongInt);„„(* Read_Array loads one element from INDEX into Buf *)„Procedure Read_Array(Var ps:pStream;Index:LongInt;Var Buf);„„(* Write_Array stores the information of Buf in Index *)„Procedure Write_Array(Var ps:pStream;Index:LongInt;Var Buf);„„(* Dispose_Array releases the allocated EMS memory *)„Procedure Dispose_Array(Var ps:pStream);„„Implementation„„Procedure Create_Array(Var ps:pStream;Low,High,Size:LongInt);„Var„   Elements,ArraySize:LongInt;„Begin„   Lo_element:=Low;„   Elements:=High-Low+1;„   ArraySize:=Elements * Size;„   ElementSize:=Size;„   ps := New(pEMSStream, Init(ArraySize,ArraySize));„   If ps^.status <> stOk Then„    Begin„      Dispose(ps, Done);„      ps := NIL;„    End;„End;„„Procedure Read_Array(Var ps:pStream;Index:LongInt;Var Buf);„Begin„ If ps<>nil Then„ Begin„  ps^.Seek((Index-Lo_element)*ElementSize);„  ps^.Read(Buf,ElementSize);„ End;„End;„„Procedure Write_Array(Var ps:pStream;Index:LongInt;Var Buf);„Begin„ If ps<>nil Then„ Begin„  ps^.Seek((Index-Lo_element)*ElementSize);„  ps^.Write(Buf,ElementSize);„ End;„End;„„procedure Dispose_Array(Var ps:pStream);„Begin„ Dispose(ps,Done);„ ps:=NIL;„End;„„End.„„„„„Program LongArrayDemo;„Uses Objects,LongArr;„Var MyArr:PStream;„    S:String;„    I:Word;„Begin„  Create_Array(MyArr,0,4096,SizeOf(String));„  If MyArr=nil Then„  Begin„   WriteLn('Couldn''t create array in EMS');„   Halt;„  End;„  S:='This is a TEST !';„  For I:=0 To 4096 Do  Write_Array(MyArr,I,S);„  s:='';„  Randomize;„  Read_Array(MyArr,Random(4096),S);„  WriteLn(S);„  Dispose_Array(MyArr);„End.„                                          15     01-27-9411:59ALL                      MARK OUELLET             Double Words             IMPORT              23     ^~Ü› {„> I'm trying to read a record from a file of byte. One of the variables in„> read is the record is a 4 byte unsigned integer (DWORD). Since the„> filetype doesn't allow me to read a dword at once I have to construct it„> myself.„> Could somebody please tell me how to construct my dword?„„Type„  DWORD = record„    case byte of„      0 : (Full : longint);„      1 : (HiWord, LoWord : word);„      2 : (Hw_HiByte, Hw_LoByte, Lw_HiByte, Lw_LoByte : byte);„      3 : (FourBytes : array[0..3] of byte);„    end;„„Here is an example:„}„„{$A+,B-,D+,E-,F+,G+,I+,L+,N+,O+,P+,Q+,R+,S+,T+,V-,X+,Y+}„{$M 1024,0,655360}„uses„  crt;„„Type„  DWord = record„    case byte of„      0 : (Full : longint);„      1 : (HiWord, LoWord : word);„      2 : (Hw_HiByte, Hw_LoByte, Lw_HiByte, Lw_LoByte : byte);„      3 : (FourBytes : array[0..3] of byte);„      4 : (TwoWords : array[0..1] of word);„    end;„„var„	F       : file of longint;„  B       : file of byte;„  MyDword : Dword;„  MyLong  : longint;„  MyWord  : word;„  MyByte,„  Index   : byte;„„begin„	clrscr;„	assign(F, 'MyLong.dat');„  rewrite(F);„  MyLong := $12345678;„  write(F, MyLong);„  MyLong := 0;„  Close(F);„  assign(B, 'MyLong.dat');„  reset(B);„  Seek(B, 0);  { Go back to first record in file}„  for Index := 0 to 3 do„		read(B, MyDword.Fourbytes[Index]);„  writeln($12345678);„	writeln(MyDword.Full);„  writeln;„  writeln(MyDword.HiWord);„  writeln(MyDword.LoWord);„	writeln;„  writeln(MyDword.Hw_HiByte);„  writeln(MyDword.Hw_LoByte);„  writeln(MyDword.Lw_HiByte);„  writeln(MyDword.Lw_LoByte);„	writeln;„  for Index := 0 to 3 do„  	writeln(MyDword.FourBytes[Index]);„  writeln;„  for Index := 0 to 1 do„  	writeln(MyDword.TwoWords[Index]);„„  Close(B);„  reset(F);„  while keypressed do readkey;„	readkey;„  Seek(F, 0);  { Go back to first record in file}„	read(F, MyDword.Full);„  ClrScr;„  writeln($12345678);„	writeln(MyDword.Full);„  writeln;„  writeln(MyDword.HiWord);„  writeln(MyDword.LoWord);„	writeln;„  writeln(MyDword.Hw_HiByte);„  writeln(MyDword.Hw_LoByte);„  writeln(MyDword.Lw_HiByte);„  writeln(MyDword.Lw_LoByte);„	writeln;„  for Index := 0 to 3 do„  	writeln(MyDword.FourBytes[Index]);„  writeln;„  for Index := 0 to 1 do„  	writeln(MyDword.TwoWords[Index]);„  close(F);„  while keypressed do readkey;„	readkey;„end.„„{„Compiled and Tested with BP 7.x„„It will, write a file of Longint, write 12345678 Hex to it, read it as a„file of byte, display most representation of it, then close it and„reopen it as a file of LongInt again read one longint and again display„the representations of it.„„PS. There is a pause after the first display (Read as a file of bytes),„any key presents the second display (Read as a file of bytes), and„another pause to allow you to see that it does display the same thing.„Any key then terminates the program.„}  16     01-27-9412:10ALL                      STEVEN TALLENT           Inverse Ordinal Types    IMPORT              8      ^~›6 (*„> is there any way to write an inverse Ord function for any type?„„> Type Color = (RED, BLUE, GREEN, VIOLET, PURPLE);„> Var Whatever : Color;„„> Begin„>   Writeln ('Red: ',Ord(Red); { Will print Red: 0 }„>   Writeln ('Inverse of Ord of Red:,InvOrd(0,Color); { Should spit out RED }„> End.„„> For the function I had this in mind:„„> Function InvOrd(TypeOrd : Integer; SpecifyType : SomeType) : SomeType;„> Begin„>   { What goes here? }„> End.„„In a running program, variables are not really accessed by name, but by„address,  and their names don't show up in the final EXE.  The only way„I know to do such a thing is to add:„*)„„Const„  Red    = 1;„  Purple = 5;„  InvOrd : Array [Red..Purple] of String[6] =„      ('Red', 'Blue', 'Green', 'Violet', 'Purple');„„{ And then access this array like: }„begin„  WriteLn('Inverse of Ord of Red:', InvOrd[Red]);„end.„                                  17     01-27-9412:12ALL                      MAYNARD PHILBROOK        Moving Number Data       IMPORT              6      ^~ic {„To shift a LongInt or Pointer into another Word do this..„„The HoBitsToShift is the number of Bits you want to move„the way i did it you get the upper half of the LongInt first...„}„„Function Shitftit(Var MyLongInt : LongInt) : Word;„Var„  Count  : Byte;„  TShift : Word;„Begin„  TShift := 0;„  For Count := 1 to HowBitsToShift Do„  Begin„    Tshit := (Tshit Shl 1);„    If MyLongInt and $80000000 <> 0 Then„      TShift := (TShift or $01);„    MyLongInt := (MyLongInt Shl 1);„  End;„  ShiftIt := TShift;„End;„„                                                                                                                               18     01-27-9412:24ALL                      JANOS SZAMOSFALVI        Variable Number ParameterIMPORT              15     ^~Á {„|≥-> You can allocate some memory and put all your parameters there, then„|≥-> pass a pointer which points to this memory block.  You have to„|≥-> setup some convention if you want to pass different types, or„|≥-> parameters with different length.„|≥„|≥Well how do I do that in Pascal- I really think that I might be better„|≥off making the function in C and then compiling it out to an object file„|≥and then linking it into pascal„„Mixed language programming is tricky and difficult unless the„compilers explicitely support it.„„|≥but I am not sure that that will even„|≥work I might just abandon Pascal and learn C„„Good luck!  <evil grin>„„|≥(even though the SYNTAX rules for C are based on Pascal anyhow)„                                          ^^^^^^^^^^^^^^^„Hmmmm.....„„Anyway, here's a quick and dirty example (untested) about passing„pointers and variable # of parameters.„}„PROGRAM Pass_Pointer;     {Compiled with TP _3.01A_}„„TYPE„   Short_String = STRING[15];„„CONST„   max_count  = 13;„   terminator : Short_String = #0#0#0#0#0#0#0#0#0#0#0#0#0#0#0;„„TYPE„   String_Array = ARRAY [0..max_count] OF Short_String;„   Pointer = ^String_Array;„„VAR„   star : Pointer;„   sstr : Short_String;„   count, i : INTEGER;„„PROCEDURE Receiver (P : pointer);„BEGIN„   i := 0;„   WHILE (P^[i] <> terminator) AND (i < max_count) DO BEGIN„      writeln(P^[i]);„      i := i + 1;„   END;„END;„„BEGIN„   count := 0;„   New (star);„   REPEAT„      write('Enter a short string: ');„      readln(sstr);„      star^[count] := sstr;„      count := count + 1;„   UNTIL (sstr = '') OR (count >= max_count);„„   IF count < max_count THEN„      star^[count - 1] := terminator;„„   Receiver(star);„END.„                                                                                                  