SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00021         TEXT/GRAPHICS COLORS                                              1      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Change Background Colors IMPORT              6      ^◊⁄• {„>Hello, I am writing an application that is some what color„>coordinated. I would like to have the background changed (usually„>black) to one of the background colors without affecting the„>foreground (so I do not have to reWrite the foreground screen).  So„}„„Uses„  Dos;„„Procedure ChangeBG(Color : Byte);„Var i : Word;„begin„  For i := 0 to 3999 do„    If Odd(i) then„      Mem[$b800:i] := (Mem[$b800:i] and 15) or ((Color and 7) shl 4)„end;„„Var„  ColChar : String;„begin„  ColChar := ParamStr(1);„  ChangeBg(Ord(ColChar[1]));„end.                                                                                                       2      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Colors Bits              IMPORT              21     ^◊îﬁ {„MICHAEL NICOLAI„„> I need to extract the foreground color (black) and the background color„> (cyan) and insert them into vars for another procedure, that calls a„> picklist with Fg,Bg attributes. I can't change the way the procedure/„> function works, so I need to feed it =my= colors in =its= format.„>„„Do you know the format of the attribute-byte? If not, here it is:„„ Bit  7 6 5 4 3 2 1 0„      B b b b I f f f„„B   - 0 do not blink„      1 character is blinking„„bbb - backgroundcolor (3 Bit, giving you a total of 8 different values.)„„I   - 0 foregroundcolor is not intensified„      1 foregroundcolor is intensified„„fff - foregroundcolor (3 Bit + I, giving you a total of 16 different values.)„„„If you now want to extract the fore- or backgroundcolor you can easily do„that by performing an AND with either 70h, 0Fh or 07h.„„The operator AND (if you don't know it):„„   AND  a b | x      a & b = x   (or in Pascal: x := a and b;„       ---------„        0 0 | 0„        0 1 | 0„        1 0 | 0„        1 1 | 1„„As you see, only when b is set to 1, the value in a is "getting through".„„For example: a = 1011000111010111, b = 0001011011110110„then„„                   1011000111010111„                 & 0001011011110110„                --------------------„                   0001000011010110„„When you look at it for a while you will see that, only where there is a 1„in the lower number, the value in the upper number is represented in the„result. Hence, you can use the AND operator to mask a portion of a number.„„Now, let's get back to your colors: You mentioned 48 or NORM.„48 decimal equals to 00110000b. That is 'Not Blink', 'Color 3 for„Background', 'Color 0 for Foreground' and 'Foregroundcolor not intensified'.„„What do you get, if you perform NORM & 70h? Let's see:„„          NORM   00110000„        &  70h   01110000„      ---------------------„                 00110000      (= Backgroundcolor or Bg)„„Not much you think, hm? Ok, but that has to do with the initial number NORM.„You will see "the light" as we proceed. :-)„„Now, let us perform NORM & 0Fh:„„          NORM   00110000„        &  0Fh   00001111„      ---------------------„                 00000000      (= Foregroundcolor WITH I)„„and NORM & 07h:„„          NORM   00110000„        &  07h   00000111„      ---------------------„                 00000000      (= Foregroundcolor WITHOUT I)„„„Hm, somewhat NORM was a bad choice as an example. But if you try it with„other values you will see how easy it is to "get a few bits out of a byte"!„}„„                       3      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Detect Display Type      IMPORT              3      ^◊Mƒ {„> know a good, easy way to detect mono/color?„}„„Program CheckDisplay;„Var„  Display: Byte Absolute $40:$10;„„begin„  if ((Display and $30) = $30) then„    Writeln('Monochrome display')„  ELSE„    Writeln('Color display');„end.„                          4      05-28-9313:34ALL                      SWAG SUPPORT TEAM        DOS Colors               IMPORT              9      ^◊aU {„> I want to be able to read a users Text Attrib and store them so i can„> restore them when my Program ends.  How can I do this?„„It seems strange you would only want to save Text attribute and„not the Dos screen, but that is what you ask -- as I understand it.„„You need to read the attribute of Character at or one column„beFore the current cursor position, directly from the screen. Something„like this should do:„}„„Uses„  Crt;„„Function UserAttr: Byte;„Var VSeg: Word;„begin„  if LastMode = 7 then„    VSeg := $B000          { Monochrome }„  else„    VSeg := $B800;         { Color }„  if (WhereX = 1) and (WhereY = 1) then„    UserAttr := Hi(MemW[VSeg:0])„  else„    UserAttr := Hi(MemW[VSeg:(WhereX -1) + (MemW[$40:$4A] * (WhereY -1)) -2]);„end;„„(*„BeFore returning to Dos, Write one space With given attribute and„backspace over it (this will cause Dos to continue in the same color):„„TextAttr := OldAttr;    { OldAttr initialized at Program startup }„Write(#20#8);„*)„„                                          5      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Get Palette              IMPORT              9      ^◊a {„> Is it Possible to find out what the colors are that are„> currently being used? I don't know how else to phrase it, I„> know you can find out the Values of the Various pixels on„> the screen. But how can I find out the Various red, green„> and blue Values that correspond to the specific color?„„}„„Procedure ReadPalette(Start,Finish:Byte;P:Pointer);„Var„  I,„  NumColors   :  Word;„  InByte      :  Byte;„begin„  P := Ptr (Seg(P^),Ofs(P^)+Start*3);„  NumColors := (Finish - Start + 1) * 3;„„  Port [$03C7] := Start;„„  For I := 0 to NumColors do begin„    InByte := Port [$03C9];„    Mem [Seg(P^):Ofs(P^)+I] := InByte;„    end;„„end;„„{„> But, how do I find out exactly what color #200 is? It must„> be held in memory some place. Can anyone supply a Procedure,„> Function or some insight into this?„„     You would just supply the Start as 200, finish as 200, and Ptr P would„point to your data... You could easily Change this routine to Supply only one„color as Variables if needed.... Hope this helped..„}            6      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Get VGA Palette          IMPORT              11     ^◊0	 {„>A VGA's screen values can be found by defining something like:„„>   VGAScreen : Array[1..64000] of Byte Absolute $A000:0000„„>But, how do I find out exactly what color #200 is? It must be held in memory„>some place. Can anyone supply a Procedure, Function or some„„I've written this short Program quite a While ago For some testing,„it should compile and work ok. Just note that it Uses slow BIOS„Function, it's not a good choice For fast palette animations but„otherwise works fine.„}„„Program Palette256;„Uses Dos;„„Type„  VGAColour = Record„    RByte, GByte, BByte : Byte;„  end;„„  VGAPal = Array[0..$FF] of VGAColour;„„Var„  Palette : VGAPal;„  i : Byte;„„Procedure GetVGAPal(Var Pal : VGAPal);„Var„  CPUregs : Registers;„begin„with CPUregs do„  begin„  ax:=$1017;„  bx:=$00;„  cx:=$100;„  es:=Seg(Pal);„  dx:=Ofs(Pal);„  end;„  Intr($10,CPUregs);„end; {GetVGAPal}„„Procedure SVMode(vmod : Byte);„Var„  CPUregs : Registers;„begin„CPUregs.ah:=0;„CPUregs.al:=vmod;„Intr($10,CPUregs);„end; {SVMode}„„begin„SVMode($13);„GetVGAPal(Palette);„SVMode($02);„for i:=0 to $FF do„  Writeln('Entry ',i:3,' Red : ',Palette[i].RByte:3,' Green : ',„           Palette[i].GByte:3,' Blue : ',Palette[i].BByte:3);„end.„                                                                        7      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Hi Intensity Colors      IMPORT              8      ^◊Â• Program HiBack; {Demonstrate use of "High-Intensity" bgd colors}„„Uses Crt, Dos;„„Var„  Fgd,Bgd : Integer;„  Regs : Registers;„„Procedure EnableHighBgd;„begin„  Regs.ax:=$1003;„  Regs.bx:=0;„  Intr($10,Regs);„end; {Procedure EnableHighBgd}„„Procedure DisableHighBgd;„begin„  Regs.ax:=$1003;„  Regs.bx:=1;„  Intr($10,Regs);„end; {Procedure DisableHighBgd}„„Procedure ShowAllCombos;„begin„  TextMode(CO80);„  For Fgd := 0 to 15 DO„  begin„   TextColor(Fgd);„    For Bgd := 0 to 15 DO„    begin„      TextAttr := Fgd + (16 * Bgd);„      Write(' Hi ');„    end;„    Writeln;„  end;„  TextAttr := 15;„end; {Procedure ShowAllCombos}„„begin„  ShowAllCombos;„  Writeln; Write('Press return...'); Readln;„  EnableHighBgd;„  Writeln; Write('Press it again...'); Readln;„  DisableHighBgd;„  Writeln; Write('One last time...'); Readln;„end.„                                                                   8      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Hi Intensity Colors #2   IMPORT              5      ^◊ïî {„> I have seen a lot of applications that use highintensity background„> colors in Text mode.  How do they do it??????„}„„Uses Crt ;„„Procedure DisableHiBackGround(SetHi : Boolean); Assembler;„Asm„     Mov  AX, $1003„     Mov  BL, SetHi„     Int  $10„end ;„„begin„     ClrScr;„     TextAttr := White + (LightRed ShL 4);„     DisableHiBackGround(True) ;„     Write('Blinking...[Enter]') ;„     ReadLn ;„     DisableHiBackGround(False) ;„     Write('      WOW !!!     ') ;„     ReadLn ;„end.„                     9      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Hi Inetnsity Colors #3   IMPORT              16     ^◊ºÔ {„I have seen a lot of applications that use highintensity background„colors in Text mode.  How do they do it??????„}„„Program HighInt; {  91-5-30  Robert Mashlan„   Public Domain„„   The following Program is an example of how to set the CrtC controller„   in in order that high intensity backgrounds may be displayed instead„   of blinking Characters, or use the the EGA/VGA BIOS to do the same„   thing.„}„„Uses„   Dos, Crt;„„Const„   HighIntesity = Blink;  (* high intesity attribute mask *)„„„Procedure HighIntensity( state : Boolean );„(* enables or disables high intensity background colors *)„„Const„   BlinkBit   = $20;  (* For mode select port, bit 5 *)„   ModeSelofs = 4;    (* offset from CrtC port base *)„„Var„   R : Registers;„   (* BIOS data area Variables *)„   CrtMode     : Byte Absolute $0040:$0065; (* current CrtC mode *)„   CrtPortBase : Word Absolute $0040:$0063; (* CrtC port base addr *)„„   Function EgaBios : Boolean;„   { test For the existance of EGA/VGA BIOS }„   Var R : Registers;„   begin„      With R do begin„         AH := $12;„         BX := $ff10;„         Intr($10,R);„         EgaBios := BX <> $ff10;„      end;„   end;„„begin„   if EgaBios then With R do begin  (* use EGA/VGA BIOS Function *)„      R.AX := $1003;„      if state then BL := 0„               else BL := 1;„      Intr($10,R);„   end else begin  (* Program CGA/MDA/Herc CrtC controller *)„      if state then  CrtMode := CrtMode and not BlinkBit„               else  CrtMode := CrtMode or BlinkBit;„      Port[ CrtPortBase + ModeSelofs ] := CrtMode;„   end;„end;„„„begin„   HighIntensity(True);„   if LastMode = 7 then„      TextAttr := $80 + $7E„    else„      Textattr := $80 + $6D;„   ClrScr;„   TextBackGround(green);„   GotoXY(20,11);„   Writeln('What do you think of this background?');„   GotoXY(1,25);„   Repeat Until ReadKey <> #0;„   HighIntensity(False);„   ClrScr;„end.„                                 10     05-28-9313:34ALL                      SWAG SUPPORT TEAM        Hi Intensity Colors #4   IMPORT              7      ^◊ {„ I have seen a lot of applications that use highintensity„ background colors in Text mode.  How do they do it??????„„if you are using an EGA/VGA adapter then you can try :-„}„„Procedure SelectIntensity(Intense:Boolean);„Var„  R : Registers;„„begin„  if Intense then„    R.BL := 0„  else„    R.BL := 1;„  R.AX := $1003;„  Intr($10, R);„end;„„{„ TextBackGround wont do anything higher than 8 without blinking.„ I want to be able to use colors like Black on Yellow and„ things like that.  Anyone have any ideas???„„Now, if you call "SelectIntensity(True)" then you can use high intensity„background colours.  to display, say White On Darkgray, you can use„"White+Darkgray*16" as your Textattr.„}                                                                          11     05-28-9313:34ALL                      SWAG SUPPORT TEAM        Hi Intensity Colors #5   IMPORT              5      ^◊zÿ {„> How would I implement the high intensity colors For the TextBACKGROUND„> Procedure in the Crt Unit?„}„„Procedure LightEGAVGA(TurnOn : Boolean);„Var Regs : Registers;„begin„  Regs.AH := $10;„  Regs.AL := $03;„  Regs.BL := Byte(TurnOn);„  Int($10,Regs);„end;„„Procedure LightHGC(TurnOn : Boolean);„begin„  if TurnOn then Port[$3b8] := $29„  else           Port[$3b8] := $09;„end;„„Procedure LightCGA(TurnOn : Boolean);„begin„  if TurnOn then Port[$3d8] := $29„  else           Port[$3d8] := $09;„end;„„        12     05-28-9313:34ALL                      SWAG SUPPORT TEAM        Palette Control          IMPORT              56     ^◊i» {„ Hello, could somone tell me how to fade a screen out..„}„„{ --------------------------------------------------------------------- }„{ Palette Unit (Text and Graphics modes)                                }„{ Author: Geoff Watts, 27-07-92                                         }„{ Usable Procedures:                                                    }„{   fadeup    -- fade the palette up                                    }„{   fadedown  -- fade the palette down                                  }„{   getpal256 -- fill the parameter Pal With the palette values         }„{   setpal256 -- fill the palette values With the parameter Pal         }„{   cpuType   -- determines wether the cpu is 8086/88 or different      }„{ --------------------------------------------------------------------- }„„Unit Palette;„Interface„Uses Dos;„{ structure in which the palette inFormation is stored }„Type„  PaletteType = Array[0..255,1..3] of Byte; { 256 Red/Green/Blue (RGB)    }„Var„  OlPlt  : PaletteType;                     { internal palette structure  }„                                            { which contains the standard }„                                            { palette                     }„  SetPal256: Procedure (Var Pal : PaletteType); { the Procedure determined    }„                                                { at run time                 }„{ Forward declarations }„Procedure SetPal86 (Var Pal : PaletteType);„Procedure SetPal286 (Var Pal : PaletteType);„Procedure FadeUp;„Procedure FadeDown;„Function  CpuType : Boolean;„Implementation„{„    GetPal256:„        Load Pal Structure With the 256 RGB palette„        values.„}„Procedure GetPal256 (Var Pal : PaletteType);„Var„  loope : Word;„begin„  port[$3C7] := 0;„  { when a read is made on port $3C9 it increment port $3C7 so no changing }„  { of the register port ($3C7) needs to be perFormed here                 }„  For loope := 0 to 255 do„    begin„      Pal[loope,1] := port[$3C9];   { Read red value   }„      Pal[loope,2] := port[$3C9];   { Read green value }„      Pal[loope,3] := port[$3C9];   { Read blue value  }„    end;„end;„{„    SetPal86:„        Loads the palette Registers With the values in„        Pal.„    86/88 instructions.„}„Procedure SetPal86 (Var Pal : PaletteType);„begin„  Asm„    push    ds      { preserve segment Registers }„    push    es„    mov cx,256 * 3  { 256 RBG values             }„    mov dx,03DAh„    { by waiting For the retrace to end it avoids static }„    { when the palette is altered                        }„@retrace1:„    in  al,dx       { wait For no retrace        }„    and al,8        { check For retrace          }„    jnz @retrace1   { so loop Until it goes low  }„@retrace2:„    in  al,dx       { wait For retrace           }„    and al,8        { check For retrace          }„    jz  @retrace2   { so loop Until it goes high }„    lds si, Pal     { ds:si = @Pal               }„    mov dx,3c8h     { set up For a blitz-white   }„    mov al,0        { from this register         }„    cli             { disable interrupts         }„    out dx,al       { starting register          }„    inc dx          { set up to update DAC       }„    cld             { clear direction flag       }„@outnext:„    { the following code is what I have found to be the  }„    { most efficient way to emulate the "rep outsb"      }„    { instructions on the 8086/88                       }„    lodsb               { load al With ds:[si]       }„    out dx,al           { out al to port in dx       }„    loop    @outnext    { loop cx times              }„    sti                 { end of critical section    }„    pop es„    pop ds              { restore segment Registers  }„  end;„end;„{$G+}       { turn on 286 instruction generation }„„{ --------------------------------------------------------------------- }„{ Palette Unit (Text and Graphics modes)                                }„{ --------------------------------------------------------------------- }„{„    SetPal286:„        Loads the palette Registers With the values in„        Pal.„    286+ instructions.„}„Procedure SetPal286 (Var Pal : PaletteType);„begin„  Asm„    push    ds      { preserve segment Registers }„    push    es„    mov cx,256 * 3  { 256 RBG values             }„    mov dx,03dah„    { by waiting For the retrace to end it avoids static }„    { when the palette is altered                        }„@retrace1:„    in  al,dx       { wait For no retrace        }„    and al,8        { check For retrace          }„    jnz @retrace1   { so loop Until it goes low  }„@retrace2:„    in  al,dx       { wait For retrace           }„    and al,8        { check For retrace          }„    jz  @retrace2   { so loop Until it goes high }„    lds si, Pal     { ds:si = @Pal               }„    mov dx,3c8h     { set up For a blitz-white   }„    mov al,0        { from this register         }„    cli             { disable interrupts         }„    out dx,al       { starting register          }„    inc dx          { set up to update DAC       }„    cld             { clear direction flag       }„    rep outsb       { 768 multiple out's         }„                    { rapid update acheived      }„    sti             { end of critical section    }„    pop es„    pop ds          { restore segment Registers  }„  end; { Asm }„end; { SetPal286 }„{$G-}               { turn off 286 instructions }„{„    fadedown:„        fades the palette down With little or no static„}„Procedure fadedown;„Var„  Plt     : PaletteType;„  i, j, k : Integer;„begin„  plt := olplt;„  For k := 0 to 63 do„    begin„      For j := 0 to 255 do„    For i := 1 to 3 do„          if Plt[j,i] <> 0 then„            dec(Plt[j,i]);      { decrease palette numbers gradually }„      SetPal256(Plt);           { gradually fade down the palette    }„    end;„end;„{„    fadeup:„        fades the palette up With little or no static„}„Procedure fadeup;„Var„  Plt     : PaletteType;„  i, j, k : Integer;„begin„  GetPal256(Plt);           { Load current palette }„  For k := 1 to 63 do„    begin„      For j := 0 to 255 do„        For i := 1 to 3 do„          if Plt[j,i] <> OlPlt[j,i] then„            inc(Plt[j,i]);      { bring palette back to the norm }„        SetPal256(Plt);         { gradually fades up the palette }„                                { to the normal values           }„    end;„end;„{„    CpuType:„        determines cpu Type so that we can use 286 instructions„}„Function CpuType : Boolean;„Var cpu : Byte;„begin„  Asm„    push sp„    pop  ax„    cmp  sp,ax                  { stack Pointer treated differently on }„    je   @cpu8086               { the 8086 Compared to all others      }„    mov  cpu,0„    jmp  @cpufound„@cpu8086:„    mov cpu,1„@cpufound:„  end; { Asm }„  cpuType := (cpu = 1);„end;„begin„  { determine the cpu Type so that we can use faster routines }„  if CpuType then„    SetPal256 := SetPal286„  else„    SetPal256 := SetPal86;„  { load the standard palette }„  GetPal256(OlPlt);„end.„                                                            13     05-28-9313:34ALL                      SWAG SUPPORT TEAM        Palette Control #2       IMPORT              33     ^◊‰ Unit palette;„{$O+}„Interface„„Uses Dos,Crt;„„Procedure Set_palette(slot:Word; sred,sgreen,sblue : Byte);„Procedure Get_palette(Var slot,gred,ggreen,gblue : Byte);„Procedure fade_in(dly : Word ; dvsr : Byte);   {Delay (ms),divisor (10-64)}„Procedure fade_out(dly : Word ; dvsr : Byte);„Procedure restore_palette;„Procedure swap_color(first,last:Byte);„Function VGASystem: Boolean;„Procedure remap;„Procedure restoremap;„„Const„  sl     : Array[0..15] of Byte =(0,1,2,3,4,5,20,7,56,57,58,59,60,61,62,63);„  v_red  : Array[0..15] of Byte =(0,0,0,0,42,42,42,42,21,21,21,21,63,63,63,63);„  v_green: Array[0..15] of Byte =(0,0,42,42,0,0,21,42,21,21,63,63,21,21,63,63);„  v_blue : Array[0..15] of Byte =(0,42,0,42,0,42,0,42,21,63,21,63,21,63,21,63);„„Var„  s_red, s_green, s_blue : Array[0..15] of Real;„„Implementation„„Procedure disable_refresh;„Var„  regs : Registers;„begin„  With regs do„  begin„    AH:=$12;„    BL:=$36;„    AL:=$01;„  end;„  Intr($10,regs);„end;„„Procedure enable_refresh;„Var„  regs : Registers;„begin„  With regs do„  begin„    AH:=$12;„    BL:=$36;„    AL:=$00;„  end;„  Intr($10,regs);„end;„„Function VGASystem: Boolean;„{}„Var  Regs : Registers;„begin„  With Regs do„  begin„    Ax := $1C00;„    Cx := 7;„    Intr($10,Regs);„    If Al = $1C then  {VGA}„    begin„      VGASystem := True;„      Exit;„    end;„    Ax := $1200;„    Bl := $32;„    Intr($10,Regs);„    If Al = $12 then {MCGA}„    begin„      VGASystem := True;„      Exit;„    end;„  end; {with}„end; {of func NoSnowSystem}„„Procedure remap;„Var„  regs : Registers;„  idx  : Byte;„begin„  if VGASystem then„  begin„    With regs do„    begin„      AL:=0;„      AH:=11;„    end;„    For idx:=0 to 15 do„    begin„      regs.BH:=idx;„      regs.BL:=idx;„      Intr($10,Regs);„    end;„  end;„end;„„Procedure restoremap;„Var„  regs : Registers;„  idx  : Byte;„begin„  if VGASystem then„  begin„    With regs do„    begin„      AL:=0;„      AH:=11;„    end;„    For idx:=0 to 15 do„    begin„      regs.BH:=sl[idx];„      regs.BL:=idx;„      Intr($10,Regs);„    end;„  end;„end;„„Procedure Set_palette(slot:Word; sred,sgreen,sblue : Byte);„Var„  regs : Registers;„begin„  With regs do„  begin„    AL:=$10;„    AH:=$10;„    BX:=slot;„    DH:=sred;„    CH:=sgreen;„    CL:=sblue;„  end;„  Intr($10,Regs);„end;„„Procedure Get_palette(Var slot,gred,ggreen,gblue : Byte);„Var„  regs : Registers;„begin„  With regs do„  begin„    AL:=21;„    AH:=16;„    BX:=slot;„  end;„  Intr($10,Regs);„  With regs do„  begin„    gred:=DH;„    ggreen:=CH;„    gblue:=CL;„  end;„end;„„Procedure restore_palette;„Var index:Byte;„begin„  For index:=0 to 15 do„      set_palette(sl[index],v_red[index],v_green[index],v_blue[index]);„end;„Procedure fade_out(dly : Word ; dvsr : Byte);„Var index,idx : Byte;„begin„  For index:=0 to 15 do„  begin„    s_red[index]:=v_red[index];„    s_green[index]:=v_green[index];„    s_blue[index]:=v_blue[index];„  end;„  For idx:=1 to dvsr do„  begin„    For index:=0 to 15 do„    begin„      set_palette(sl[index],trunc(s_red[index]),trunc(s_green[index]),trunc(s_blue[index]));„      s_red[index]:=s_red[index]-(v_red[index]/dvsr);„      s_green[index]:=s_green[index]-(v_green[index]/dvsr);„      s_blue[index]:=s_blue[index]-(v_blue[index]/dvsr);„    end;„    Delay(dly)„  end;„end;„„Procedure fade_in(dly : Word ; dvsr : Byte);„Var index,idx2:Byte;„begin„  FillChar(s_red,Sizeof(S_red),#0);„  FillChar(s_green,Sizeof(S_green),#0);„  FillChar(s_blue,Sizeof(s_blue),#0);„  For idx2:=1 to dvsr do„  begin„    For index:=0 to 15 do„    begin„      set_palette(sl[index],trunc(s_red[index]),trunc(s_green[index]),trunc(s_blue[index]));„      s_red[index]:=s_red[index]+(v_red[index]/dvsr);„      s_green[index]:=s_green[index]+(v_green[index]/dvsr);„      s_blue[index]:=s_blue[index]+(v_blue[index]/dvsr);„    end;„  Delay(dly);„  end;„end;„„Procedure swap_color(first,last:Byte);„Var f1,f2,f3,l1,l2,l3:Byte;„begin„  Get_Palette(sl[first],f1,f2,f3);„  Get_Palette(sl[last],l1,l2,l3);„  Set_Palette(sl[first],l1,l2,l3);„  Set_Palette(sl[last],f1,f2,f3);„end;„„begin„  restoremap;„end.„                   14     05-28-9313:34ALL                      SWAG SUPPORT TEAM        Palette Control #3       IMPORT              81     ^◊–n Unit Palette;„„Interface„„Type„  PalType     =  Array [0..768] of Byte;„Var„  FadePal     :  Array [0..768] of Real;„  Fadeend,„  FadeStep,„  FadeCount,„  FadeStart   :  Byte;„  FadeToPal   :  ^PalType;„  DoneFade    :  Boolean;„„Procedure GetPCXPalettePas (PCXBuf,P:Pointer;PalOffset:Word);„Procedure GetPCXPaletteAsm (PCXBuf,P:Pointer;PalOffset:Word);„„Procedure WritePalettePas  (Start,Finish:Byte;P:Pointer);„Procedure WritePaletteAsm  (Start,Finish:Byte;P:Pointer);„„Procedure ReadPalettePas   (Start,Finish:Byte;P:Pointer);„Procedure ReadPaletteAsm   (Start,Finish:Byte;P:Pointer);„„Procedure SetupFade        (Start,Finish:Byte;P:Pointer;Step:Byte);„Procedure FadePalette;„Procedure Oreo             (Start,Finish:Integer);„„Implementation„„Procedure CLI; Inline ($FA);„Procedure STI; Inline ($FB);„„Procedure SetupFade (Start,Finish:Byte;P:Pointer;Step:Byte);„Var„  CurPal           :  Array [0..767] of Byte;„  ToPal            :  ^PalType;„  I,PalOfs,„  NumColors        :  Word;„  RealStep,„  RealToColor,„  RealCurColor     :  Real;„begin„  ToPal := Ptr (Seg(P^),Ofs(P^));„  ReadPaletteAsm (0,255,@CurPal);„  PalOfs := Start * 3;„  NumColors := (Finish - Start + 1) * 3;„„  RealStep := Step;„„  For I := 0 to NumColors-1 do begin„    RealCurColor := CurPal [PalOfs+I];„    RealToColor  :=  ToPal^[PalOfs+I];„    FadePal [PalOfs+I] := (RealCurColor - RealToColor) / RealStep;„    end;„„  FadeStep  := 0;„  FadeCount := Step;„  FadeStart := Start;„  Fadeend   := Finish;„  FadeToPal := P;„  DoneFade  := False;„end;„„Procedure FadePalette;„Var„  I,„  PalOfs,„  NumColors   :  Word;„  CurPal      :  Array [0..767] of Byte;„  Fact,„  RealToColor :  Real;„begin„  Inc (FadeStep);„  Fact := FadeCount - FadeStep;„  NumColors := (Fadeend - FadeStart + 1) * 3;„  ReadPaletteAsm (0,255,@CurPal);„  PalOfs := FadeStart * 3;„„  For I := 0 to NumColors - 1 do begin„    RealToColor := FadeToPal^[PalOfs+I];„    CurPal[PalOfs+I] := Round (RealToColor + Fact * FadePal[PalOfs+I]);„    end;„„  WritePaletteAsm (FadeStart,Fadeend,@CurPal);„  DoneFade := FadeStep = FadeCount;„end;„„Procedure Oreo (Start,Finish:Integer);„Var„  I,PalOfs    :  Word;„  CurPal      :  Array [0..767] of Byte;„  Red,„  Blue,„  Green       :  Real;„  Gray        :  Byte;„begin„  ReadPaletteAsm (0,255,@CurPal);„„  For I := Start to Finish do begin„    PalOfs := I * 3;„    Red   := CurPal[PalOfs + 0];„    Green := CurPal[PalOfs + 1];„    Blue  := CurPal[PalOfs + 2];„„    Gray := Round ((0.30 * Red) + (0.59 * Green) + (0.11 * Blue));„„    CurPal[PalOfs + 0] := Gray;„    CurPal[PalOfs + 1] := Gray;„    CurPal[PalOfs + 2] := Gray;„    end;„  WritePaletteAsm (Start,Finish,@CurPal);„end;„„Procedure GetPCXPalettePas (PCXBuf,P:Pointer;PalOffset:Word);„Var„  I      :  Word;„  InByte :  Byte;„begin„  PCXBuf := Ptr (Seg(PCXBuf^),Ofs(PCXBuf^)+PalOffset);„  For I := 0 to 767 do begin„    InByte := Mem [Seg(PCXBuf^):Ofs(PCXBuf^)+I];„    InByte := InByte shr 2;„    Mem [Seg(P^):Ofs(P^)+I] := InByte;„    end;„end;„„Procedure WritePalettePas (Start,Finish:Byte;P:Pointer);„Var„  I,„  NumColors   :  Word;„  InByte      :  Byte;„begin„  P := Ptr (Seg(P^),Ofs(P^)+Start*3);„  NumColors := (Finish - Start + 1) * 3;„„  CLI;„„  Port [$03C8] := Start;„„  For I := 0 to NumColors do begin„    InByte := Mem [Seg(P^):Ofs(P^)+I];„    Port [$03C9] := InByte;„    end;„„  STI;„end;„„Procedure ReadPalettePas (Start,Finish:Byte;P:Pointer);„Var„  I,„  NumColors   :  Word;„  InByte      :  Byte;„begin„  P := Ptr (Seg(P^),Ofs(P^)+Start*3);„  NumColors := (Finish - Start + 1) * 3;„„  CLI;„„  Port [$03C7] := Start;„„  For I := 0 to NumColors do begin„    InByte := Port [$03C9];„    Mem [Seg(P^):Ofs(P^)+I] := InByte;„    end;„„  STI;„end;„„Procedure GetPCXPaletteAsm (PCXBuf,P:Pointer;PalOffset:Word);„Assembler;„Asm„    push ds„„    lds  si,PCXBuf„    mov  ax,PalOffset„    add  si,ax„„    les  di,P„„    mov  cx,768„  @@1:„    lodsb„    shr  al,1„    shr  al,1„    stosb„    loop @@1„„    pop  ds„end;„„Procedure WritePaletteAsm (Start,Finish:Byte;P:Pointer); Assembler;„Asm„    push ds„„    lds  si,P„„    cld„„    xor  bh,bh               { P^ points to the beginning of the palette }„    mov  bl,Start            { data.  Since we can specify the Start and }„    xor  ax,ax               { Finish color nums, we have to point our }„    mov  al,Start            { Pointer to the Start color.  There are 3 }„    shl  ax,1                { Bytes per color, so the Start color is: }„    add  ax,bx               {   Palette Ofs = @P + Start * 3 }„    add  si,ax               { ds:si -> offset in color data }„„    xor  ch,ch               { Next, we have to determine how many colors}„    mov  cl,Finish           { we will be updating.  This simply is: }„    sub  cl,Start            {    NumColors = Finish - Start + 1 }„    inc  cx„„(*„    push      es„    push      dx„    push      ax„„    xor       ax,ax                    { get address of status register }„    mov       es,ax                    {   from segment 0 }„    mov       dx,3BAh                  { assume monochrome addressing }„    test      Byte ptr es:[487h],2     { is mono display attached? }„    jnz       @@11                     { yes, address is OK }„    mov       dx,3DAh                  { no, must set color addressing }„  @@11:„    in        al,dx                    { read in status }„    jmp       @@21„  @@21:„    test      al,08h                   { is retrace on> (if ON, bit = 1) }„    jz        @@13                     { no, go wait For start }„  @@12:„                                       { yes, wait For it to go off }„    in        al,dx„    jmp       @@22„  @@22:„    test      al,08h                   { is retrace off? }„    jnz       @@12                     { no, keep waiting }„  @@13:„    in        al,dx„    jmp       @@23„  @@23:„    test      al,08h                   { is retrace on? }„    jz        @@13                     { no, keep on waiting }„„    pop       ax„    pop       dx„    pop       es               *)„„    mov  al,Start            { We are going to bypass the BIOS routines }„    mov  dx,03C8h            { to update the palette Registers.  For the }„    out  dx,al               { smoothest fades, there is no substitute }„„    cli                      { turn off interrupts temporarily }„    inc  dx„„  @@1:„    lodsb                    { Get the red color Byte }„    jmp  @@2                 { Delay For a few clock cycles }„  @@2:„    out  dx,al               { Write the red register directly }„„    lodsb                    { Get the green color Byte }„    jmp  @@3                 { Delay For a few clock cycles }„  @@3:„    out  dx,al               { Write the green register directly }„„    lodsb                    { Get the blue color Byte }„    jmp  @@4                 { Delay For a few clock cycles }„  @@4:„    out  dx,al               { Write the blue register directly }„„    loop @@1„„    sti                      { turn interrupts back on }„    pop  ds„end;„„Procedure ReadPaletteAsm (Start,Finish:Byte;P:Pointer); Assembler;„Asm„    les  di,P„„    cld„„    xor  bh,bh               { P^ points to the beginning of the palette }„    mov  bl,Start            { buffer.  We have to calculate where in the}„    xor  ax,ax               { buffer we need to start at.  Because each  }„    mov  al,Start            { color has three Bytes associated With it }„    shl  ax,1                { the starting ofs is:            }„    add  ax,bx               {   Palette Ofs = @P + Start * 3  }„    add  si,ax               { es:di -> offset in color data   }„„    xor  ch,ch               { Next, we have to determine how many   colors}„    mov  cl,Finish           { we will be reading.  This simply is:  }„    sub  cl,Start            {    NumColors = Finish - Start + 1     }„    inc  cx„„    mov  al,Start            { We are going to bypass the BIOS routines }„    mov  dx,03C7h            { to read in from the palette Registers.   }„    out  dx,al               { This is the fastest method to do this.   }„    mov  dx,03C9h„„    cli                      { turn off interrupts temporarily          }„„  @@1:„    in   al,dx               { Read in the red color Byte               }„    jmp  @@2                 { Delay For a few clock cycles             }„  @@2:„    stosb                    { Store the Byte in the buffer             }„„    in   al,dx               { Read in the green color Byte             }„    jmp  @@3                 { Delay For a few clock cycles             }„  @@3:„    stosb                    { Store the Byte in the buffer             }„„    in   al,dx               { Read in the blue color Byte              }„    jmp  @@4                 { Delay For a few clock cycles             }„  @@4:„    stosb                    { Store the Byte in the buffer             }„    loop @@1„„    sti                      { turn interrupts back on                  }„end;„„end.„{„„**********************************************„Here's the testing Program„**********************************************„}„Program MCGATest;„„Uses„  Crt,Dos,MCGALib,Palette;„„Var„  Stop,„  Start       :  LongInt;„  Regs        :  Registers;„  PicBuf,„  StorageBuf  :  Pointer;„  FileLength  :  Word;„  Pal,„  BlackPal    :  Array [1..768] of Byte;„„Const„  NumTimes    = 100;„„Procedure LoadBuffer (S:String;Buf:Pointer);„Var„  F           :  File;„  BlocksRead  :  Word;„begin„  Assign (F,S);„  Reset (F,1);„  BlockRead (F,Buf^,65000,FileLength);„  Close (F);„end;„„Procedure Pause;„Var„  Ch     :  Char;„begin„  Repeat Until KeyPressed;„  While KeyPressed do Ch := ReadKey;„end;„„Procedure Control;„begin„  SetGraphMode ($13);„„  LoadBuffer ('E:\NAVAJO.PCX',PicBuf);„„  GetPCXPaletteAsm (PicBuf,@Pal,FileLength-768);„  WritePalettePas (0,255,@Pal);„  DisplayPCX (0,0,PicBuf);„„  FillChar (BlackPal,SizeOf(BlackPal),0);„  Pause;„„  SetupFade (0,255,@BlackPal,20);„  Repeat FadePalette Until DoneFade;„  Pause;„„  SetupFade (0,255,@Pal,20);„  Repeat FadePalette Until DoneFade;„  Pause;„„  Oreo (0,255);„  Pause;„„  SetupFade (0,255,@Pal,20);„  Repeat FadePalette Until DoneFade;„  Pause;„end;„„Procedure Init;„begin„  GetMem (PicBuf,65500);„end;„„begin„  Init;„  Control;„end.„„                                                            15     05-28-9313:34ALL                      SWAG SUPPORT TEAM        Some More Palette ControlIMPORT              15     ^◊¬œ {„>The utility I wrote, just Writes the contents of the $A000 from one to„>63999 (ya know 320x200), to a File.  then I bring it to an Array, and„>then I try to reWrite it to the video.  HOWEVER, I noticed that the„>palette inFormation is incorrect.  Is there any way to fix this, since„>it comes out in a messed up color.„„How about writing also the palette info to the File ? You're probably„BlockWriting, so this should not be a big problem. You just have to„fetch the palette info through inT $10, Function $1017 :„}„„Type„  TCouleurVGA =„    Record„      Rouge,„      Vert,„      Bleu   : Byte ;„    end ;„„  TPaletteVGA = Array[0..255] of TCouleurVGA ;„„Procedure LitPalette(Var p : TPaletteVGA) ; Assembler ;„Asm„  { Lecture table couleurs }„  Mov       AX, $1017„  Mov       BX, 0„  Mov       CX, 256„  LES       DX, p„  Int       $10„end ;„„{„The reverse :„}„„Procedure AffectePalette(Var Palette : TPaletteVGA) ; Assembler ;„Asm„  Mov     AX, $1012„  Xor     BX, BX„  Mov     CX, 256„  LES     DX, Palette„  Int     $10„end ;„„{„>Also, I have successfully written color cycling, by changing each color„>index in a loop.  Only problem is that you can see it 'redrawing'.  Is„>there anyway ot change them all simultaneously, instead of a loop?  I am„>working in Pascal, using bits and chunks of Inline Asm.„„I'm _not_ sure the following is the answer you expect :„}„„Procedure AffectePaletteDeA(Var Palette ; De, A : Integer) ; Assembler ;„Asm„  Mov     AX, $1012„  Mov     BX, De„  Mov     CX, A„  Sub     CX, BX„  Inc     CX„  LES     DX, Palette„  Int     $10„end ;„„Var„  Pal  : TPaletteVGA ;„„begin„  { Here, fill the colors you need }„  { Say, you modified colors 37 to 124 into Pal Array }„  AffectePaletteDeA(Pal[37], 37, 124) ;„end.„„                                          16     05-28-9313:34ALL                      SWAG SUPPORT TEAM        Setting Text Attr        IMPORT              6      ^◊§ {YZ> Does anyone know how to "extract" the foreground and background„YZ> colours from TextAttr?„}„„    Foreground := TextAttr and $0f;„    Background := (TextAttr and $f0) shr 4;„„{A few days ago, I read a message from someone who was trying to extract„foreground and background colors from one Byte Variable. I have since„lost the mail packet, and forgotten the user's name, but here's a„routine that will do that anyways. Hope it gets to the person who was„asking For it......„}„Procedure GetColors(Color : Byte; Var BackGr : Byte; Var ForeGr : Byte);„begin„  BackGr := Color shr 4;„  ForeGr := Color xor (Background shl 4);„end;„„       17     05-28-9313:34ALL                      SWAG SUPPORT TEAM        Background/Foreground    IMPORT              3      ^◊∆h YZ> Does anyone know how to "extract" the Foreground and„YZ> background colours from„YZ> TextAttr?„„or, For simplicity, use:„„  FC := TextAttr MOD 16;„  BC := TextAttr div 16;„„                                                                               18     06-22-9309:17ALL                      SWAG SUPPORT TEAM        Select HIGH Back Colors  IMPORT              16     ^◊•ù PROGRAM HighBack;„„USES Dos,Crt;„„TYPE„  AttrType = (Blinking,HighInt);„„PROCEDURE SelectAttribute(Attribute: AttrType);„VAR„  Reg  :Registers;„BEGIN„  Reg.ah := $10;„  Reg.al := 3;„  CASE Attribute OF„    HighInt  : Reg.bl := 0;„    Blinking : Reg.bl := 1„    END;„  Intr($10,Reg)„  END;„„PROCEDURE SetBackground(BG: Byte);„BEGIN„  BG := (BG AND $F) SHL 4; {Limit to range 0 - 15, then shift up}„  Crt.TextAttr := (Crt.TextAttr MOD 16) + BG;„  END;„„PROCEDURE SetForeground(FG: Byte);„BEGIN„  FG := (FG AND $F);                      {Limit to range 0 - 15}„  Crt.TextAttr := (Crt.TextAttr AND $F0) + FG;„  END;„„FUNCTION GetBackground: Byte;„BEGIN„  GetBackground := Crt.TextAttr DIV 16;„  END;„„FUNCTION GetForeground: Byte;„BEGIN„  GetForeground := Crt.TextAttr MOD 16;„  END;„„CONST„  Flip : Integer = 0;„  BGM : Byte = Black;„  FGM : Byte = White;„VAR„  BG, FG : Byte;„  A : Char;„„BEGIN„„{Initialize screen}„  TextMode(CO80);„  TextBackGround(BGM);„  TextColor(FGM);„  ClrScr;„„{Display demo color combinations}„  GotoXY(35,1);WriteLn('Foreground');„  Write('Background   ');„  FOR FG := 0 TO $F DO Write(FG:3,' ');„  WriteLn;WriteLn;„„  FOR BG:= 0 TO $F DO BEGIN                {Cycle through colors}„    SetBackground(BGM);„    Write(BG:5,'       ');„    SetBackground(BG);„    FOR FG := 0 TO $F DO BEGIN„      SetForeground(FG);                {Adjust FG for visibilty}„      Write(Crt.TextAttr:4);„      END;„    WriteLn;„    END;„„  GotoXY(18,25);                                  {Create prompt}„  SetBackground(LightCyan);„  SetForeground(Black);„  Write('Press <Esc> to quit, any other key to swap attributes');„„  A := ' ';                             {Loop to swap attributes}„  WHILE Ord(A) <> 27 DO BEGIN„    CASE Flip OF„       0 : SelectAttribute(HighInt);„      -1 : SelectAttribute(Blinking);„      END;„    Flip := NOT Flip;„    A := ReadKey;„    END;„  TextMode(CO80);„  ClrScr„  END.„           19     08-18-9312:25ALL                      JOSE ALMEIDA             Complete color constants IMPORT              90     ^◊d „UNIT HTcolors;„„{ Complete set of all color attributes contants by their own names.„  Part of the Heartware Toolkit v2.00 (HTcolors.PAS) for Turbo Pascal.„  Author: Jose Almeida. P.O.Box 4185. 1504 Lisboa Codex. Portugal.„          I can also be reached at RIME network, site ->TIB or #5314.„  Feel completely free to use this source code in any way you want, and, if„  you do, please don't forget to mention my name, and, give me and Swag the„  proper credits. }„„INTERFACE„„const„„  { black background }„„  BlackOnBlack            : byte = $00;„  BlueOnBlack             : byte = $01;„  GreenOnBlack            : byte = $02;„  CyanOnBlack             : byte = $03;„  RedOnBlack              : byte = $04;„  MagentaOnBlack          : byte = $05;„  BrownOnBlack            : byte = $06;„  LtGrayOnBlack           : byte = $07;„  DkGrayOnBlack           : byte = $08;„  LtBlueOnBlack           : byte = $09;„  LtGreenOnBlack          : byte = $0A;„  LtCyanOnBlack           : byte = $0B;„  LtRedOnBlack            : byte = $0C;„  LtMagentaOnBlack        : byte = $0D;„  YellowOnBlack           : byte = $0E;„  WhiteOnBlack            : byte = $0F;„„  { blue background }„„  BlackOnBlue             : byte = $10;„  BlueOnBlue              : byte = $11;„  GreenOnBlue             : byte = $12;„  CyanOnBlue              : byte = $13;„  RedOnBlue               : byte = $14;„  MagentaOnBlue           : byte = $15;„  BrownOnBlue             : byte = $16;„  LtGrayOnBlue            : byte = $17;„  DkGrayOnBlue            : byte = $18;„  LtBlueOnBlue            : byte = $19;„  LtGreenOnBlue           : byte = $1A;„  LtCyanOnBlue            : byte = $1B;„  LtRedOnBlue             : byte = $1C;„  LtMagentaOnBlue         : byte = $1D;„  YellowOnBlue            : byte = $1E;„  WhiteOnBlue             : byte = $1F;„„  { green background }„„  BlackOnGreen            : byte = $20;„  BlueOnGreen             : byte = $21;„  GreenOnGreen            : byte = $22;„  CyanOnGreen             : byte = $23;„  RedOnGreen              : byte = $24;„  MagentaOnGreen          : byte = $25;„  BrownOnGreen            : byte = $26;„  LtGrayOnGreen           : byte = $27;„  DkGrayOnGreen           : byte = $28;„  LtBlueOnGreen           : byte = $29;„  LtGreenOnGreen          : byte = $2A;„  LtCyanOnGreen           : byte = $2B;„  LtRedOnGreen            : byte = $2C;„  LtMagentaOnGreen        : byte = $2D;„  YellowOnGreen           : byte = $2E;„  WhiteOnGreen            : byte = $2F;„„  { cyan background }„„  BlackOnCyan             : byte = $30;„  BlueOnCyan              : byte = $31;„  GreenOnCyan             : byte = $32;„  CyanOnCyan              : byte = $33;„  RedOnCyan               : byte = $34;„  MagentaOnCyan           : byte = $35;„  BrownOnCyan             : byte = $36;„  LtGrayOnCyan            : byte = $37;„  DkGrayOnCyan            : byte = $38;„  LtBlueOnCyan            : byte = $39;„  LtGreenOnCyan           : byte = $3A;„  LtCyanOnCyan            : byte = $3B;„  LtRedOnCyan             : byte = $3C;„  LtMagentaOnCyan         : byte = $3D;„  YellowOnCyan            : byte = $3E;„  WhiteOnCyan             : byte = $3F;„„  { red background }„„  BlackOnRed              : byte = $40;„  BlueOnRed               : byte = $41;„  GreenOnRed              : byte = $42;„  CyanOnRed               : byte = $43;„  RedOnRed                : byte = $44;„  MagentaOnRed            : byte = $45;„  BrownOnRed              : byte = $46;„  LtGrayOnRed             : byte = $47;„  DkGrayOnRed             : byte = $48;„  LtBlueOnRed             : byte = $49;„  LtGreenOnRed            : byte = $4A;„  LtCyanOnRed             : byte = $4B;„  LtRedOnRed              : byte = $4C;„  LtMagentaOnRed          : byte = $4D;„  YellowOnRed             : byte = $4E;„  WhiteOnRed              : byte = $4F;„„  { magenta background }„„  BlackOnMagenta          : byte = $50;„  BlueOnMagenta           : byte = $51;„  GreenOnMagenta          : byte = $52;„  CyanOnMagenta           : byte = $53;„  RedOnMagenta            : byte = $54;„  MagentaOnMagenta        : byte = $55;„  BrownOnMagenta          : byte = $56;„  LtGrayOnMagenta         : byte = $57;„  DkGrayOnMagenta         : byte = $58;„  LtBlueOnMagenta         : byte = $59;„  LtGreenOnMagenta        : byte = $5A;„  LtCyanOnMagenta         : byte = $5B;„  LtRedOnMagenta          : byte = $5C;„  LtMagentaOnMagenta      : byte = $5D;„  YellowOnMagenta         : byte = $5E;„  WhiteOnMagenta          : byte = $5F;„„  { brown background }„„  BlackOnBrown            : byte = $60;„  BlueOnBrown             : byte = $61;„  GreenOnBrown            : byte = $62;„  CyanOnBrown             : byte = $63;„  RedOnBrown              : byte = $64;„  MagentaOnBrown          : byte = $65;„  BrownOnBrown            : byte = $66;„  LtGrayOnBrown           : byte = $67;„  DkGrayOnBrown           : byte = $68;„  LtBlueOnBrown           : byte = $69;„  LtGreenOnBrown          : byte = $6A;„  LtCyanOnBrown           : byte = $6B;„  LtRedOnBrown            : byte = $6C;„  LtMagentaOnBrown        : byte = $6D;„  YellowOnBrown           : byte = $6E;„  WhiteOnBrown            : byte = $6F;„„  { light gray background }„„  BlackOnLtGray           : byte = $70;„  BlueOnLtGray            : byte = $71;„  GreenOnLtGray           : byte = $72;„  CyanOnLtGray            : byte = $73;„  RedOnLtGray             : byte = $74;„  MagentaOnLtGray         : byte = $75;„  BrownOnLtGray           : byte = $76;„  LtGrayOnLtGray          : byte = $77;„  DkGrayOnLtGray          : byte = $78;„  LtBlueOnLtGray          : byte = $79;„  LtGreenOnLtGray         : byte = $7A;„  LtCyanOnLtGray          : byte = $7B;„  LtRedOnLtGray           : byte = $7C;„  LtMagentaOnLtGray       : byte = $7D;„  YellowOnLtGray          : byte = $7E;„  WhiteOnLtGray           : byte = $7F;„„  {˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙}„„  { black background blinking }„„  BlackOnBlackBlink       : byte = $80;„  BlueOnBlackBlink        : byte = $81;„  GreenOnBlackBlink       : byte = $82;„  CyanOnBlackBlink        : byte = $83;„  RedOnBlackBlink         : byte = $84;„  MagentaOnBlackBlink     : byte = $85;„  BrownOnBlackBlink       : byte = $86;„  LtGrayOnBlackBlink      : byte = $87;„  DkGrayOnBlackBlink      : byte = $88;„  LtBlueOnBlackBlink      : byte = $89;„  LtGreenOnBlackBlink     : byte = $8A;„  LtCyanOnBlackBlink      : byte = $8B;„  LtRedOnBlackBlink       : byte = $8C;„  LtMagentaOnBlackBlink   : byte = $8D;„  YellowOnBlackBlink      : byte = $8E;„  WhiteOnBlackBlink       : byte = $8F;„„  { blue background blinking }„„  BlackOnBlueBlink        : byte = $90;„  BlueOnBlueBlink         : byte = $91;„  GreenOnBlueBlink        : byte = $92;„  CyanOnBlueBlink         : byte = $93;„  RedOnBlueBlink          : byte = $94;„  MagentaOnBlueBlink      : byte = $95;„  BrownOnBlueBlink        : byte = $96;„  LtGrayOnBlueBlink       : byte = $97;„  DkGrayOnBlueBlink       : byte = $98;„  LtBlueOnBlueBlink       : byte = $99;„  LtGreenOnBlueBlink      : byte = $9A;„  LtCyanOnBlueBlink       : byte = $9B;„  LtRedOnBlueBlink        : byte = $9C;„  LtMagentaOnBlueBlink    : byte = $9D;„  YellowOnBlueBlink       : byte = $9E;„  WhiteOnBlueBlink        : byte = $9F;„„  { green background blinking }„„  BlackOnGreenBlink       : byte = $A0;„  BlueOnGreenBlink        : byte = $A1;„  GreenOnGreenBlink       : byte = $A2;„  CyanOnGreenBlink        : byte = $A3;„  RedOnGreenBlink         : byte = $A4;„  MagentaOnGreenBlink     : byte = $A5;„  BrownOnGreenBlink       : byte = $A6;„  LtGrayOnGreenBlink      : byte = $A7;„  DkGrayOnGreenBlink      : byte = $A8;„  LtBlueOnGreenBlink      : byte = $A9;„  LtGreenOnGreenBlink     : byte = $AA;„  LtCyanOnGreenBlink      : byte = $AB;„  LtRedOnGreenBlink       : byte = $AC;„  LtMagentaOnGreenBlink   : byte = $AD;„  YellowOnGreenBlink      : byte = $AE;„  WhiteOnGreenBlink       : byte = $AF;„„  { cyan background blinking }„„  BlackOnCyanBlink        : byte = $B0;„  BlueOnCyanBlink         : byte = $B1;„  GreenOnCyanBlink        : byte = $B2;„  CyanOnCyanBlink         : byte = $B3;„  RedOnCyanBlink          : byte = $B4;„  MagentaOnCyanBlink      : byte = $B5;„  BrownOnCyanBlink        : byte = $B6;„  LtGrayOnCyanBlink       : byte = $B7;„  DkGrayOnCyanBlink       : byte = $B8;„  LtBlueOnCyanBlink       : byte = $B9;„  LtGreenOnCyanBlink      : byte = $BA;„  LtCyanOnCyanBlink       : byte = $BB;„  LtRedOnCyanBlink        : byte = $BC;„  LtMagentaOnCyanBlink    : byte = $BD;„  YellowOnCyanBlink       : byte = $BE;„  WhiteOnCyanBlink        : byte = $BF;„„  { red background blinking }„„  BlackOnRedBlink         : byte = $C0;„  BlueOnRedBlink          : byte = $C1;„  GreenOnRedBlink         : byte = $C2;„  CyanOnRedBlink          : byte = $C3;„  RedOnRedBlink           : byte = $C4;„  MagentaOnRedBlink       : byte = $C5;„  BrownOnRedBlink         : byte = $C6;„  LtGrayOnRedBlink        : byte = $C7;„  DkGrayOnRedBlink        : byte = $C8;„  LtBlueOnRedBlink        : byte = $C9;„  LtGreenOnRedBlink       : byte = $CA;„  LtCyanOnRedBlink        : byte = $CB;„  LtRedOnRedBlink         : byte = $CC;„  LtMagentaOnRedBlink     : byte = $CD;„  YellowOnRedBlink        : byte = $CE;„  WhiteOnRedBlink         : byte = $CF;„„  { magenta background blinking }„„  BlackOnMagentaBlink     : byte = $D0;„  BlueOnMagentaBlink      : byte = $D1;„  GreenOnMagentaBlink     : byte = $D2;„  CyanOnMagentaBlink      : byte = $D3;„  RedOnMagentaBlink       : byte = $D4;„  MagentaOnMagentaBlink   : byte = $D5;„  BrownOnMagentaBlink     : byte = $D6;„  LtGrayOnMagentaBlink    : byte = $D7;„  DkGrayOnMagentaBlink    : byte = $D8;„  LtBlueOnMagentaBlink    : byte = $D9;„  LtGreenOnMagentaBlink   : byte = $DA;„  LtCyanOnMagentaBlink    : byte = $DB;„  LtRedOnMagentaBlink     : byte = $DC;„  LtMagentaOnMagentaBlink : byte = $DD;„  YellowOnMagentaBlink    : byte = $DE;„  WhiteOnMagentaBlink     : byte = $DF;„„  { brown background blinking }„„  BlackOnBrownBlink       : byte = $E0;„  BlueOnBrownBlink        : byte = $E1;„  GreenOnBrownBlink       : byte = $E2;„  CyanOnBrownBlink        : byte = $E3;„  RedOnBrownBlink         : byte = $E4;„  MagentaOnBrownBlink     : byte = $E5;„  BrownOnBrownBlink       : byte = $E6;„  LtGrayOnBrownBlink      : byte = $E7;„  DkGrayOnBrownBlink      : byte = $E8;„  LtBlueOnBrownBlink      : byte = $E9;„  LtGreenOnBrownBlink     : byte = $EA;„  LtCyanOnBrownBlink      : byte = $EB;„  LtRedOnBrownBlink       : byte = $EC;„  LtMagentaOnBrownBlink   : byte = $ED;„  YellowOnBrownBlink      : byte = $EE;„  WhiteOnBrownBlink       : byte = $EF;„„  { light gray background blinking }„„  BlackOnLtGrayBlink      : byte = $F0;„  BlueOnLtGrayBlink       : byte = $F1;„  GreenOnLtGrayBlink      : byte = $F2;„  CyanOnLtGrayBlink       : byte = $F3;„  RedOnLtGrayBlink        : byte = $F4;„  MagentaOnLtGrayBlink    : byte = $F5;„  BrownOnLtGrayBlink      : byte = $F6;„  LtGrayOnLtGrayBlink     : byte = $F7;„  DkGrayOnLtGrayBlink     : byte = $F8;„  LtBlueOnLtGrayBlink     : byte = $F9;„  LtGreenOnLtGrayBlink    : byte = $FA;„  LtCyanOnLtGrayBlink     : byte = $FB;„  LtRedOnLtGrayBlink      : byte = $FC;„  LtMagentaOnLtGrayBlink  : byte = $FD;„  YellowOnLtGrayBlink     : byte = $FE;„  WhiteOnLtGrayBlink      : byte = $FF;„„„„IMPLEMENTATION„„„„END. { HTcolors.PAS }„„„                                                                   20     05-25-9408:01ALL                      STEVEN DEBRUYN           Change Colors            SWAG9405            13     ^◊   „PROGRAM Change_Color;„USES Crt;„VAR Tel, Tel2 : Byte;„„(**********************************************************************)„(*   Copyright for this procedure by Steven Debruyn 1994              *)„(*   Hereby donated to Public Domain                                  *)„(*   Feel free to put this in the SWAG if you think it's any good     *)„(**********************************************************************)„PROCEDURE Say(Zin : String);„VAR Kleur : Byte;„     Code : Integer;„     Zin1 : String;„     Zin2 : String;„  TempZin : String;„   Gedaan : Boolean;„BEGIN„  WHILE Pos('\\',Zin) <> 0 DO BEGIN„    Zin1 := Copy(Zin, Pos('\\',Zin)+2, Pos('\\',Zin)+Pos(' ',Zin)-4);„    Val(Zin1,Kleur,Code);„    TextAttr:= Kleur;„    Zin2 := Copy(Zin, Pos('\\',Zin)+Length(Zin1)+2,Length(Zin));„    TempZin := Copy(Zin2, Pos(' ',Zin2), Pos('\\',Zin2)-1);„    Write(TempZin);„    Zin := Copy(Zin2, Pos(TempZin,Zin2)+Length(TempZin), Length(Zin2));„  END;„  WriteLn;„END;„„BEGIN„  TextAttr:=0;„  ClrScr;„  Say('\\5 Hello\\9 World out there,\\79 this is a test\\154 !\\');„  Say('\\14 I can change color\\23 and \\220 background.\\138 and'+„      ' BLINK at the same time.\\');„  Say('\\15 Press\\11 [\\14 ENTER\\11 ]\\');„  ReadLn;„  ClrScr;„  Tel2:=1;„  FOR Tel := 1 TO 255 DO„  BEGIN„    TextAttr := Tel;„    WriteLn('This is Color : ',Tel);„    Inc(Tel2);„    IF Tel2 = 24 THEN„    BEGIN„      ReadLn;„      TextAttr:=0;„      ClrScr;„      Tel2 := 1;„    END;„  END„END.„                                                               21     05-26-9406:18ALL                      MICHAEL HOENIE           Color Codes              SWAG9405            21     ^◊   {„ √ƒ>I would like to implement color codes into my on-line doors.  You know„ √ƒ>the type that Wildcat or PCB have.  The @ codes.  Does anyone have a„ √ƒ>routine that would (I assume) read in a file bite by bite and when it„ √ƒ>comes across the @ char it would read the next 3 bits and determine what„ √ƒ>action to take?„„Hi Larry! Sure do have one for 'ya!„„Try this one out for size. It can be optimized to be smaller, but as an„example, this one works for sure! You'll have to incorporate it into your„code to dump out to the modem (no problem I hope!)„„Give this a try: }„„  type„    string255=string[255];„„  procedure outgoing(stream:string255; ret:integer);„  var„    _retval:integer;„    out,out1:string[5];„  begin„    for _retval:=1 to length(stream) do„      begin„        out:=copy(stream,_retval,1);„        case out[1] of„          '@':begin { COLOR CODE    ---> @X1F or other }„                out1:=copy(stream,_retval+2,1);„                case out1[1] of„                  '0':textbackground(0);„                  '1':textbackground(1);„                  '2':textbackground(2);„                  '3':textbackground(3);„                  '4':textbackground(4);„                  '5':textbackground(5);„                  '6':textbackground(6);„                  '7':textbackground(7);„                  '8':textbackground(8);„                  '9':textbackground(9);„                  'A':textbackground(10);„                  'B':textbackground(11);„                  'C':textbackground(12);„                  'D':textbackground(13);„                  'E':textbackground(14);„                  'F':textbackground(15);„                end;„                out1:=copy(stream,_retval+3,1);„                case out1[1] of„                  '0':textcolor(0);„                  '1':textcolor(1);„                  '2':textcolor(2);„                  '3':textcolor(3);„                  '4':textcolor(4);„                  '5':textcolor(5);„                  '6':textcolor(6);„                  '7':textcolor(7);„                  '8':textcolor(8);„                  '9':textcolor(9);„                  'A':textcolor(10);„                  'B':textcolor(11);„                  'C':textcolor(12);„                  'D':textcolor(13);„                  'E':textcolor(14);„                  'F':textcolor(15);„                end;„                _retval:=_retval+3;„              end;„          else write(out[1]);„        end;„      end;„    if ret=2 then writeln;„  end;„„                                                                            