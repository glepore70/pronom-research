SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00013         INPUT AND FIELD ENTRY ROUTINES                                    1      05-31-9308:59ALL                      GAYLE DAVIS              Simple Field Input       IMPORT              23     3&« uses„  crt;„type„  input_data = record„                 st               : string;  { The string to be input }„                 col,row,                         { position of input }„                 attr,                              { color of input  }„                 flen             : byte;   { maximum length of input }„                 prompt           : string[40];„               end;„const„  NumberOfFields = 3;„  BackSpace  = $08;„  Enter      = $0d;„  Escape     = $1b;„  space      = $20;„„var„  InputField : array[1..NumberOfFields] of input_data;„  x          : byte;„  Done       : boolean;„  field      : byte;„„„Procedure SetInputField(VAR inpRec   : Input_data;„                            S        : STRING;„                            C,R      : Byte;„                            A,L      : Byte;„                            P        : String);„„BEGIN„With inpRec DO„     BEGIN„     St  := S;„     Col := C;„     Row := R;„     Attr := A;„     fLen := L;„     Prompt := P;„     END;„END;„„„procedure GetStr(var inprec: input_data; var f: byte; var finished: boolean);„  var„    spstr  : string; { just a string of spaces }„    x,y,„    oldattr: byte;„    ch     : char;„    chval  : byte absolute ch;„    len    : byte absolute inprec;„  begin„    with inprec do begin„      FillChar(spstr,sizeof(spstr),32); spstr[0] := chr(flen);„      y := row; x := col + length(prompt);„      oldattr := TextAttr; finished := false;„      gotoXY(col,row); write(prompt);„      TextAttr := attr;„      repeat„        gotoXY(x,y); write(st,copy(spstr,1,flen-len)); gotoXY(x+len,y);„        ch := ReadKey;„        case chval of„          0         : ch := ReadKey;„          Enter     : begin„                        inc(f);„                        if f > NumberOfFields then f := 1;„                        TextAttr := oldattr;„                        exit;„                      end;„          BackSpace : if len > 0 then„                        dec(len);„          Escape    : begin  { the escape key is the only way to halt }„                        finished := true;„                        TextAttr := oldattr;„                        exit;„                      end;„          32..255   : if len <> flen then begin„                        inc(len);„                        st[len] := ch;„                      end;„        end; { case }„      until false;  { procedure only exits via exit statements }„    end; { with }„  end; { GetStr }„„begin„  Clrscr;„  SetInputField(InputField[1],'',12,10,31,20,'Your Name    : ');„  SetInputField(InputField[2],'',12,11,31,20,'Your Address : ');„  SetInputField(InputField[3],'',12,12,31,20,'City,State   : ');„  field := 1;„  repeat„    GetStr(InputField[field],field,Done);„  until Done;„end.„                                                                    2      06-08-9308:24ALL                      SWAG SUPPORT TEAM        General Input with Color IMPORT              18     3“x { General STRING input routine with Color prompt and input }„„USES DOS,Crt;„„TYPE„    CharSet = Set OF Char;„„VAR„    Name : STRING;„„procedure QWrite( Column, Line , Color : byte; S : STRING );„„var„   VMode  : BYTE ABSOLUTE $0040 : $0049; { Video mode: Mono=7, Color=0-3 }„   NumCol : WORD ABSOLUTE $0040 : $004A; { Number of CRT columns (1-based) }„   VSeg   : WORD;„   OfsPos : integer;  { offset position of the character in video RAM }„   vPos   : integer;„   sLen   : Byte ABSOLUTE S;„„Begin„  If VMode in [0,2,7] THEN VSeg := $B000 ELSE VSeg := $B800;„  OfsPos   := (((pred(Line) * NumCol) + pred(Column)) * 2);„  FOR vPos := 0 to pred(sLen) do„      MemW[VSeg : (OfsPos + (vPos * 2))] :=„                     (Color shl 8) + byte(S[succ(vPos)])„End;„„Function GetString(cx,cy,cc,pc : Byte; Default,Prompt : String; MaxLen : Integer;OKSet :„charset):string;„„{ cx = Input Column }„{ cy = Input Row    }„{ cc = Input Color  }„{ pc = Prompt Color }„„const„  BS                 = ^H;„  CR                 = ^M;„  iPutChar           = #249;„  ConSet             : CharSet = [BS,CR];„var„  TStr               : string;„  TLen,X,i           : Integer;„  Ch                 : Char;„begin„  {$I-} { turn off I/O checking }„  TStr := '';„  TLen := 0;„  Qwrite(cx,cy,pc,Prompt);„  X := cx + Length(Prompt);„  For i := x to (x + Maxlen - 1) do„    Qwrite(i,cy,cc,iputChar);„  Qwrite(x,cy,cc,Default);„  OKSet := OKSet + ConSet;„  repeat„    Gotoxy(x,cy);„    repeat„      ch := readkey„    until Ch in OKSet;„    if Ch = BS then begin„      if TLen > 0 then begin„        TLen := TLen - 1;„        X := X - 1;„        QWrite(x,cy,cc,iPutChar);„      end„    end„    else if (Ch <> CR) and (TLen < MaxLen) then begin„      QWrite(x,cy,cc,Ch);„      TLen := TLen + 1;„      TStr[TLen] := Ch;„      X := X + 1;„    end„  until Ch = CR;„  If Tlen > 0„    Then Begin„           TStr[0] := chr(Tlen);„           Getstring := TStr„         End„    Else Getstring := Default;„  {$I+}„end;„„„BEGIN„   ClrScr;„   Name := Getstring(16,5,79,31,'GOOD OLE BOY','Enter Name : ',25,['a'..'z','A'..'Z',' ']);„   GOTOXY(16,7);„   WriteLn('Name : ',Name);„   Readkey;„END.„„                        3      06-22-9309:18ALL                      SWAG SUPPORT TEAM        OOP Line Editor          IMPORT              49     3e' „{ A good line editor object }„„UNIT EditObj; {  Object_Line_Editor  }„„INTERFACE„„USES Crt, KeyBd;„„TYPE„  LineEdit = OBJECT„    Pos, XPos, YPos : Integer;„    EdLine : String;„    PROCEDURE InitEdit( X, Y: Integer; LineIn: String );„    FUNCTION  GetLine: String;„  END;„„VAR„   Kbd: KeyBoard;   {<<<========== Global definition of OBJECT}„„{***************************************************************}„                        IMPLEMENTATION„{***************************************************************}„„{-------------------------------------------------„- Name   : InitEdit                              -„- Purpose: Set up editor, display line onscreen  -„-------------------------------------------------}„„PROCEDURE LineEdit.InitEdit;„  BEGIN„    EdLine := LineIn;„    Pos  := Ord( LineIn[0] ) + 1;„    XPos := X;„    YPos := Y;„    GotoXY( X, Y );„    Write( LineIn );„  END;„„{-------------------------------------------------„- Name   : GetLine                               -„- Purpose: Process keying from user              -„-          Maximum 80 characters accepted        -„-------------------------------------------------}„„FUNCTION  LineEdit.GetLine;„  VAR„    KeyFlags : Byte;„    Ch: Char;„    FunctKey, Finish: Boolean;„  BEGIN„    Finish := FALSE;„    REPEAT„      IF Kbd.GetKey( KeyFlags, FunctKey, Ch ) THEN BEGIN„        IF FunctKey THEN„          CASE Ch OF„{ HOME   }  #$47: Pos := 1;„{ END    }  #$4F: Pos := Ord( EdLine[0] ) + 1;„{ RIGHT  }  #$4D: BEGIN„                    IF Pos < 80 THEN Inc( Pos );„                    IF Pos > Ord( EdLine[0] ) THEN„                      Insert( ' ', EdLine, Pos );„                    END;„{ LEFT   }  #$4B: IF Pos > 1  THEN Dec( Pos );„{ DELETE }  #$53: IF Pos <= Ord( EdLine[0] ) THEN„                     Delete( EdLine, Pos, 1 );„            END {CASE Ch}„          ELSE {IF}„            CASE Ch OF„{ BS }        #$08: IF Pos > 1 THEN BEGIN„                      Delete( EdLine, Pos-1, 1 );„                      Dec( Pos );„                      END;„{ ENTER }     #$0D: Finish := TRUE;„              ELSE BEGIN„                IF( ( KeyFlags AND $80 ) <> $80 )„                   THEN Insert( Ch, EdLine, Pos )„                   ELSE EdLine[Pos] := Ch;„                IF Pos > Ord( EdLine[0] ) THEN„                   EdLine[0] := Chr( Pos );„                IF Pos < 80 THEN Inc( Pos );„                END     {CASE CH ELSE}„              END;    {CASE Ch}„        GotoXY( XPos, YPos );„        Write( EdLine, ' ' );„        GotoXY( XPos+Pos-1, YPos );„        END;  {IF Kbd.GetKey}„      UNTIL Finish;„      GetLine := EdLine;„    END;„„END.„„„{  KEYBOARD UNIT }„UNIT Keybd;  { Keybd.PAS / Keybd.TPU }„„INTERFACE„„USES Crt, Dos;„„TYPE„  CType = ( UBAR, BLOCK );„  Keyboard = OBJECT„    ThisCursor: CType;„    PROCEDURE InitKeyBd;„    PROCEDURE SetCursor( Cursor: CType );„    FUNCTION  GetCursor: CType;„    FUNCTION  GetKbdFlags: Byte;„    FUNCTION  GetKey( VAR KeyFlags: Byte; VAR FunctKey: Boolean;„                                        VAR Ch: Char ): Boolean;„  END;„„{***************************************************************}„                      IMPLEMENTATION„{***************************************************************}„„„{Keyboard}„„{-------------------------------------------------„- Name   : InitKeyBd                             -„- Purpose: Set the cursor to underline style     -„-          and empty keyboard buffer             -„-------------------------------------------------}„„PROCEDURE Keyboard.InitKeyBd;„  VAR„    Ch : Char;„  BEGIN„    SetCursor( UBAR );„    WHILE( KeyPressed ) DO Ch := ReadKey;„  END;„„{-------------------------------------------------„- Name   : SetCursor                             -„- Purpose: Modify number of lines for cursor     -„-------------------------------------------------}„„PROCEDURE Keyboard.SetCursor;„  VAR„    Regs: Registers;„  BEGIN„    CASE Cursor OF„      UBAR:  Regs.Ch := 6;„      BLOCK: Regs.Ch := 1;„    END;„    Regs.CL := 7;„    Regs.AH := 1;„    Intr( $10, Regs );„  END;„„{-------------------------------------------------„- Name   : GetKbdFlags                           -„- Purpose: Monitor the Insert key                -„- Output : Shift key status flag byte            -„-------------------------------------------------}„„FUNCTION  Keyboard.GetKbdFlags: Byte;„  VAR„    Regs: Registers;„  BEGIN„    (* FOR enhanced keyboards: AH := $12 *)„    (* FOR normal keyboards:   AH := $02 *)„    Regs.AH := $12;„    Intr( $16, Regs );„    IF( Regs.AX AND $80 = $80 ) THEN SetCursor( BLOCK )„                                ELSE SetCursor( UBAR );„    GetKbdFlags := Regs.AX;„  END;„„{-------------------------------------------------„- Name   : GetCursor                             -„- Purpose: Query current cursor state            -„-------------------------------------------------}„„FUNCTION  Keyboard.GetCursor;„  BEGIN„    GetCursor := ThisCursor;„  END;„„{-------------------------------------------------„- Name   : GetKey                                -„- Purpose: Get a keypress contents if any        -„-          Updates a function keypressed flag    -„-------------------------------------------------}„„FUNCTION  Keyboard.GetKey;„  VAR„    Result : Boolean;„  BEGIN„    Result := KeyPressed;„    FunctKey := FALSE;„    Ch := #$00;       {Use this to check for Function key press}„    IF Result THEN BEGIN„      Ch := ReadKey;„      IF( KeyPressed AND ( Ch = #$00 ) ) THEN BEGIN„        Ch := ReadKey;„        FunctKey := TRUE;„        END;„      END;„    KeyFlags := GetKbdFlags;„    GetKey := Result;„    END;„„END.„„{   DEMO PROGRAM  }„„PROGRAM EditDemo;„„{-------------------------------------------------„-  Show off example of global object use         -„-------------------------------------------------}„„USES Crt, EditObj;„„VAR„   Editor: LineEdit;           {Instantiation of LineEdit OBJECT}„   ResultStr: String;„BEGIN„   ClrScr;„   WITH Editor DO„   BEGIN„      InitEdit( 1, 10, 'Edit this sample line');„      ResultStr := GetLine;„      GotoXY( 1, 15 );„      WriteLn( ResultStr );„   END;„   ReadLn;„END.„                                4      06-22-9309:30ALL                      BOB GIBSON               General Purpos Line Edit IMPORT              46     3
‡ (****************************************************************)„(*                         N_EditLn                             *)„(*                                                              *)„(*    General Purpose line editor, based on EDITLN by Borland   *)„(*          Modified for use with multiple lines by             *)„(*                 Bob Gibson of BGShareWare                    *)„(*                                                              *)„(****************************************************************)„„unit N_EditLn;„{$D-,I-,S-}„interface„uses Scrn;„„const„  NULL = #0;„  BS = #8;„  LF = #10;„  CR = #13;„  ESC = #27;„  Space = #32;„  Tab = ^I;„„  { The following constants are based on the scheme used by the scan key„    function to convert a two key scan code sequence into one character„    by adding 128 to the ordinal value of the second character.„  }„  F1 = #187;„  F2 = #188;„  F3 = #189;„  F4 = #190;„  F5 = #191;„  F6 = #192;„  F7 = #193;„  F8 = #194;„  F9 = #195;„  F10 = #196;„  UpKey = #200;„  DownKey = #208;„  LeftKey = #203;„  RightKey = #205;„  PgUpKey = #201;„  PgDnKey = #209;„  HomeKey = #199;„  EndKey = #207;„  InsKey = #210;„  DelKey = #211;„  M : Word = 0;„var„  O, N, R, P : byte;„  Ch : Char;„  T : String;„„type„  CharSet = set of char;„„procedure EditLine(var S     : String;„		       Len, X, Y : byte;„		       LegalChars,„		       Term  : CharSet;„		   var TC    : Char    );„{  EditLn implements a line editor that supports WordStar commands„   as well as left-right arrow keys , Home, End, back space, etc.„   Paramaters:„     S : String to be edited„     Len : Maximum characters allowed to be edited„     X, Y : Starting x an y cordinates„     LegalChars : Set of characters that will be accepted„     Term : Set of characters that will cause EditLine to Exit„	    (Note LegalChars need not contain Term)„     TC : Character that caused EditLn to exit„}„„function ScanKey : char;„{ Reads a key from the keyboard and converts 2 scan code escape„  sequences into 1 character. }„„implementation„{$L keys}„Function KeyPressed : Boolean ; External;„Function ReadKey : Char ; External;„„function ScanKey : char;„{ Reads a key from the keyboard and converts 2 scan code escape„  sequences into 1 character. }„„var„  Ch : Char;„begin„  Ch := ReadKey;„  if (Ch = #0) {and KeyPressed} then„  begin„    Ch := ReadKey;„    if ord(Ch) < 128 then„      Ch := Chr(Ord(Ch) + 128);„  end;„  ScanKey := Ch;„end; { ScanKey }„„procedure EditLine(var S : String;„		   Len, X, Y : byte;„		   LegalChars, Term  : CharSet;„		   var TC    : Char);„{  EditLn implements a line editor that supports WordStar commands„   as well as left-right arrow keys , Home, End, back space, etc.„   Paramaters:„     S : String to be edited„     Len : Maximum characters allowed to be edited„     X, Y : Starting x an y cordinates„     LegalChars : Set of characters that will be accepted„     Term : Set of characters that will cause EditLine to Exit„	    (Note LegalChars need not contain Term)„     TC : Character that caused EditLn to exit„}„{$V-}„„begin„  PXY(X,Y);„  PWrite(S);„  P := Y - 1;„  N := Y;„  O := X;„  Y := 1;„  M := 0;„  Mem[$40:$17] := (Mem[$40:$17] AND $7F);„  repeat„    If ((Mem[$40:$17] AND $80) = $80) Then SetCursor(0,7) Else SetCursor(6,7);„    If (Y+P) > 80 Then Begin„       Inc(X);„       P := 0;„       End;„    PXY(X,Y+P);„    Ch := ScanKey;„    if not (Upcase(Ch) in Term) then„      case Ch of„	#32..#126 : if (M < Len) and„		       (ch in LegalChars) then„		    begin„		      P := succ(P);„		      M := succ(M);„                      If ((Mem[$40:$17] AND $80) = $80) Then„                        Delete(S,M,1);„                      If ((Mem[$40:$17] AND $80) <> $80) Then„                         If Length(S) = Len Then Delete(S,Len,1);„                      Insert(Ch,S,M);„		      T := Copy(S,M,Len);„		      PWrite(T);„		    end„		    Else Writeln(^G);„	^S, LeftKey : if M > 0 then Begin„			If P < 1 Then Begin„			   P := 80;„			   Dec(X);„			   End;„			P := pred(P);„			M := pred(M);„			End;„	^D, RightKey : if M < Length(S) then Begin„			 P := succ(P);„			 M := succ(M);„			 End;„	 HomeKey : Begin„			M := M - P;„			P := 0;„			End;„	 EndKey : Begin„			M := M + (79 - P);„			P := 79;„			If M > Length(S) Then Begin„			   P := P - (M - Length(S));„			   M := Length(S);„			   End;„			End;„	 UpKey : If X > O Then Begin„			Dec(X);„			M := M - 80;„			End;„	 DownKey : If (M+80) < Length(S) Then Begin„			Inc(X);„			M := M + 80;„			If M > Length(S) Then Begin„			   P := P - (M - Length(S));„			   M := Length(S);„			   End;„			End;„	 DelKey  : if M < Length(S) then„		       begin„			 Delete(S,M + 1,1);„			 T := Copy(S,M+1,Len);„			 T := T + ' ';„			 PWrite(T);„		       end;„	 BS : if M > 0 then„		 begin„		   Delete(S,M,1);„		   T := Copy(S,M,Len);„		   If (Y+P-1) < 1 Then Begin„		      Dec(X);„		      P := (81-Y);„		      PXY(X,P);„		      End„		   Else PXY(X,Y+P-1);„		   T := T + ' ';„		   PWrite(T);„		   P := pred(P);„		   M := pred(M);„		 end;„	 F9 : Begin„		  X := O;„		  Y := 1;„		  For R := 1 To Len Do PWrite(' ');„		  P := 0;„		  S := '';„		  M := 0;„		  End;„      else;„    end;  {of case}„  until UpCase(Ch) in Term;„  SetCursor(6,7);„  PXY(X,Y+P);„  M := Length(S);„  For R := 1 To (Len-M) Do PWrite('');„  TC := Upcase(Ch);„end; { EditLine }„„end.„„USE XX34 to decode this object code.  You MUST Have it to use this unit„Also, you will need the SCRN.PAS from the SCREEN.SWG packet.„„„*XX3401-000092-070293--68--85-59342--------KEYS.OBJ--1-OF--1„U+M+-2h3KJAuZUQ+++F1HoF3F7U5+0UI++6-+G4E5++++Ed9FJZEIYJHIoJ2++++-p73„EIF9FJY7+++pc-U++E++h+5B3bHug+51JMjgh+TB6MjZLQD6WU6++5E+„***** END OF XX-BLOCK *****„„„                                                                      5      08-27-9321:28ALL                      SEAN PALMER              A Simple Input Routine   IMPORT              20     3´o {„SEAN PALMER„„> name:_______________) problem, how do you make a field where you„> define the max Chars in the field and doNOT let the person Type more„> than that.  stop the users keyboard at the last Char in this Case its„> 78 Chars max and the field looks like this„„Try this. Send it a default value, the length of the field, and a set of„Char containing all the valid Characters For the field.„„}„Uses uInput,Crt;„„Function getName : String;„Const„  nameMax = 20;„Var„  Count    : Integer;„  attrsave : Byte;„begin„  GotoXY(12, 2);„  Write('ENTER NAME:');„  attrsave := TextAttr;„  TextColor(0);„  TextBackground(7);„  GotoXY(26, 2);„  for Count := 1 to nameMax do„    Write(' ');  {draw inverse field}„  GotoXY(26, 2);„  getName  := input('Nobody', nameMax, ['A'..'Z','a'..'z','.',' ']);„  Textattr := attrsave;„end;„„{----------}„„{uInput}„{by Sean Palmer}„{released to the public domain}„ {2237 Lincoln St.}„ {Longmont, CO 80501}„{Alms gladly accepted! 8) }„„Unit uInput;„{$B-,I-,N-,O-,R-,S-,V-,X-}„„Interface„„{tCharSet is used to specify Function keys to the input routine}„Type„  tCharSet = set of Char;„„Function isKey : Boolean;„Inline(„ $B4/$B/   {mov ah,$B}„ $CD/$21/  {int $21}„ $24/$FE); {and al,$FE}„„Function getKey : Char;„Inline(„ $B4/7/    {mov ah,7}„ $CD/$21); {int $21}„„Function input(default : String; maxCh : Byte; cs : tCharSet) : String;„„Implementation„„Function input(default : String; maxCh : Byte; cs : tCharSet) : String;„Var„  p : Byte;„  c : Char;„  s : String[255];„begin„  s := default;„  Repeat„    c := getKey;„    if c = #0 then„      c := Char(Byte(getKey) or $80);„    Case c of„      ^H :„        if s[0] <> #0 then„        begin„          Write(^H, ' ', ^H);„          dec(s[0]);„        end;„      #127 :„        begin„          For p := length(s) downto 1 do„            Write(^H, ' ', ^H);„            s[0] := #0;„          end;„      ^M : ; {don't beep}„      ' '..'~' :„        if length(s) < maxCh then„        begin„          Write(c);„          inc(s[0]);„          s[Byte(s[0])] := c;„        end„        else„          Write(^G);„„      else„        if c in cs then„        begin„          s[1] := c;„          s[0] := #1;„          c    := ^M;„        end„        else„          Write(^G);„    end;„  Until (c = ^M) or (c = ^[);„„  if c = ^[ then„    input := default„  else„    input := s;„„end;„„end.„„                                                                       6      10-28-9311:32ALL                      RANDALL WOODMAN          Generalize Input         IMPORT              40     3ä} {===========================================================================„Date: 10-02-93 (06:28)„From: RANDALL WOODMAN„Subj: Input„„{->>>>GetString<<<<--------------------------------------------}„{                                                              }„{ Filename : GETSTRIN.SRC -- Last Modified 7/14/88             }„{                                                              }„{ This is a generalized string-input procedure.  It shows a    }„{ field between vertical bar characters at X,Y, with any       }„{ string value passed initially in XString left-justified in   }„{ the field.  The current state of XString when the user       }„{ presses Return is returned in XString.  The user can press   }„{ ESC and leave the passed value of XString undisturbed, even  }„{ if XString was altered prior to his pressing ESC.            }„{                                                              }„{     From: COMPLETE TURBO PASCAL 5.0  by Jeff Duntemann       }„{    Scott, Foresman & Co., Inc. 1988   ISBN 0-673-38355-5     }„{--------------------------------------------------------------}„„PROCEDURE GetString(    X,Y      : Integer;„                    VAR XString  : String80;„                        MaxLen   : Integer;„                        Capslock : Boolean;„                        Numeric  : Boolean;„                        GetReal  : Boolean;„                    VAR RValue   : Real;„                    VAR IValue   : Integer;„                    VAR Error    : Integer;„                    VAR Escape   : Boolean);„„VAR I,J        : Integer;„    Ch         : Char;„    Cursor     : Char;„    Dot        : Char;„    BLength    : Byte;„    ClearIt    : String80;„    Worker     : String80;„    Printables : SET OF Char;„    Lowercase  : SET OF Char;„    Numerics   : SET OF Char;„    CR         : Boolean;„„„BEGIN„  Printables := [' '..'}'];               { Init sets }„  Lowercase  := ['a'..'z'];„  IF GetReal THEN Numerics := ['-','.','0'..'9','E','e']„    ELSE Numerics := ['-','0'..'9'];„  Cursor := '_'; Dot := '.';„  CR := False; Escape := False;„  FillChar(ClearIt,SizeOf(ClearIt),'.');  { Fill the clear string  }„  ClearIt[0] := Chr(MaxLen);              { Set clear string to MaxLen }„„                                { Convert numbers to string if required:  }„  IF Numeric THEN               { Convert zero values to null string: }„    IF (GetReal AND (RValue = 0.0)) OR„       (NOT GetReal AND (IValue = 0)) THEN XString := ''„    ELSE                        { Convert nonzero values to string equiv: }„      IF GetReal THEN Str(RValue:MaxLen,XString)„        ELSE Str(IValue:MaxLen,XString);„„                                          { Truncate string value to MaxLen }„  IF Length(XString) > MaxLen THEN XString[0] := Chr(MaxLen);„  GotoXY(X,Y); Write('|',ClearIt,'|');    { Draw the field  }„  GotoXY(X+1,Y); Write(XString);„  IF Length(XString)<MaxLen THEN„    BEGIN„      GotoXY(X + Length(XString) + 1,Y);„      Write(Cursor)                       { Draw the Cursor }„    END;„  Worker := XString;      { Fill work string with input string     }„„  REPEAT                  { Until ESC or (CR) entered }„                          { Wait here for keypress:   }„    WHILE NOT KeyPressed DO BEGIN {NULL} END;„    Ch := ReadKey;„„    IF Ch IN Printables THEN              { If Ch is printable... }„      IF Length(Worker) >= MaxLen THEN UhUh ELSE„        IF Numeric AND (NOT (Ch IN Numerics)) THEN UhUh ELSE„          BEGIN„            IF Ch IN Lowercase THEN IF Capslock THEN Ch := Chr(Ord(Ch)-32);„            Worker := CONCAT(Worker,Ch);„            GotoXY(X+1,Y); Write(Worker);„            IF Length(Worker) < MaxLen THEN Write(Cursor)„          END„    ELSE   { If Ch is NOT printable... }„      CASE Ord(Ch) OF„       8,127 : IF Length(Worker) <= 0 THEN UhUh ELSE„                  BEGIN„                    Delete(Worker,Length(Worker),1);„                    GotoXY(X+1,Y); Write(Worker,Cursor);„                    IF Length(Worker) < MaxLen-1 THEN Write(Dot);„                  END;„„       13 : CR := True;          { Carriage return }„„       24 : BEGIN                { CTRL-X : Blank the field }„              GotoXY(X+1,Y); Write(ClearIt);„              Worker := '';      { Blank out work string }„            END;„„       27 : Escape := True;      { ESC }„       ELSE UhUh                 { CASE ELSE }„    END; { CASE }„„  UNTIL CR OR Escape;            { Get keypresses until (CR) or }„                                 { ESC pressed }„  GotoXY(X + 1,Y); Write(ClearIt);„  GotoXY(X + 1,Y); Write(Worker);„  IF CR THEN                     { Don't update XString if ESC hit }„    BEGIN„      XString := Worker;„      IF Numeric THEN            { Convert string to Numeric values }„        CASE GetReal OF„          True  : Val(Worker,RValue,Error);„          False : Val(Worker,IValue,Error)„        END { CASE }„      ELSE„        BEGIN„          RValue := 0.0;„          IValue := 0„        END„    END„END;  { GETString }„  7      01-27-9412:04ALL                      JEFF FANJOY              Key Input Routine        IMPORT              73     3   > Does anyone know how to make the input line a certain number of lines„> only!...sya the user only gets to us 3 characters....„„Here is the input routine that I use for all of my programs.  You may„not need it so precise, so you can cut out anything you don't feel is„necessary but here goes:„}„„UNIT KeyInput;„„INTERFACE„„USES CRT,CURSOR;„„PROCEDURE GetInput(VAR InStr;                    {String Passed}„                       WhatWas: String;          {Old value to Remember}„                       Len: Byte;                {Length of String Max=255}„                       XPosition,                {X Cursor Position}„                       YPosition,                {Y Cursor Position}„                       BackGroundColor,          {Background Color}„                       ForeGroundColor: Integer; {Foreground Color}„                       BackGroundChar: Char;     {Echoed Character on BkSp}„                       Caps: Boolean);           {CAPS?}„IMPLEMENTATION„„PROCEDURE GetInput(VAR InStr;„                       WhatWas: String;„                       Len: Byte;„                       XPosition,„                       YPosition,„                       BackGroundColor,„                       ForeGroundColor: Integer;„                       BackGroundChar: Char;„                       Caps: Boolean);„„CONST„   BkSp: Char = Chr($08);„„VAR„   InsertKey: Byte Absolute $0040:$0017;„   Temp: String;„   Ch2,„   C: Char;„   A,„   U,„   B: Byte;„   FirstChar,„   InsertOn,„   NoAdd: Boolean;„   NewString: String Absolute InStr;„„BEGIN„   InsertKey := InsertKey OR $80; {changes to insert mode}„   IF (InsertKey AND $80 > 0) THEN„    BEGIN„       InsertOn := TRUE;„       ShowCursor;„    END„   ELSE„    BEGIN„       InsertOn := FALSE;„       BigCursor;„    END;„   FirstChar := TRUE;„   NewString := '';„   Temp := '';„   GotoXY(XPosition,YPosition);„   TextBackGround(BackGroundColor);„   TextColor(ForeGroundColor);„   FOR U := 1 TO Len DO„    BEGIN„       Write(BackGroundChar); {shows how many characters are available}„    END;„   GotoXY(XPosition,YPosition);„   C := Chr($00); {null character input}„   TextBackGround(ForeGroundColor);„   TextColor(BackGroundColor);„   NewString := WhatWas; {starts with previous value in memory}„   Write(NewString); {writes previous value to screen for editing}„   B := Length(WhatWas);„   A := B;„   TextBackGround(BackGroundColor);„   TextColor(ForeGroundColor);„   WHILE (C <> Chr($0D)) AND (C <> Chr($1B)) DO {not CR or ESC}„    BEGIN„       NoAdd := FALSE;„       IF Caps THEN C := UpCase(ReadKey) {if Caps read uppercase else...}„       ELSE C := ReadKey;„       CASE C OF„          Chr($08): IF B >= 1 THEN {backspace}„                     BEGIN„                        IF FirstChar THEN„                         BEGIN„                            FirstChar := FALSE;„                            GotoXY(XPosition,YPosition);„                            Write(NewString);„                         END;„                        Delete(NewString,B,1);„                        Write(BkSp,BackGroundChar,BkSp);„                        Dec(B);„                        GotoXY(XPosition+B,WhereY);„                        FOR U := B TO Length(NewString) DO„                         BEGIN„                            IF B <> U THEN Temp := Temp + NewString[U]„                            ELSE Temp := '';„                         END;„                        Write(Temp);„                        FOR U := Length(NewString)+1 TO Len DO„                         BEGIN„                            Write(BackGroundChar);„                         END;„                        GotoXY(XPosition+B,WhereY);„                        NoAdd := TRUE;„                        Dec(A);„                     END;„          Chr($1B): BEGIN {Escape}„                       NoAdd := TRUE;„                       NewString := WhatWas;„                    END;„          Chr($19): BEGIN {^Y = clear the editing line}„                       NoAdd := TRUE;„                       NewString := '';„                       GotoXY(XPosition,YPosition);„                       FOR U := 1 TO Len DO„                        BEGIN„                           Write(BackGroundChar);„                        END;„                       FirstChar := FALSE;„                       GotoXY(XPosition,YPosition);„                       B := 0;„                       A := 0;„                    END;„          Chr($0D): NoAdd := TRUE; {enter <CR>}„          Chr($00): BEGIN {extended keys always start with null character}„                       NoAdd := TRUE;„                       IF FirstChar THEN„                        BEGIN„                           FirstChar := FALSE;„                           GotoXY(XPosition,YPosition);„                           Write(NewString);„                        END;„                       C := UpCase(ReadKey);„                       CASE C OF„                          Chr(77): BEGIN {right arrow}„                                    IF B <= Length(NewString)-1 THEN„                                     BEGIN„                                        GotoXY(XPosition+B+1,WhereY);„                                        Inc(B);„                                     END;„                                 END;„                          Chr(75): BEGIN {left arrow}„                                      IF B >= 1 THEN„                                       BEGIN„                                          GotoXY(XPosition+B-1,WhereY);„                                          Dec(B);„                                       END;„                                   END;„                          Chr(71): BEGIN {home}„                                      GotoXY(XPosition,YPosition);„                                      B := 0;„                                   END;„                          Chr(79): BEGIN {end}„                                      GotoXY(XPosition+Length(NewString),YPosition);„                                      B := Length(NewString);„                                   END;„                          Chr(82): BEGIN {insert}„                                      IF InsertOn THEN„                                       BEGIN„                                          InsertOn := FALSE;„                                          BigCursor;„                                       END„                                      ELSE„                                       BEGIN„                                          InsertOn := TRUE;„                                          ShowCursor;„                                       END;„                                   END;„                          Chr(83): BEGIN {del}„                                      IF (B < Length(NewString)) AND (B >= 0) THEN„                                       BEGIN„                                          Delete(NewString,B+1,1);„                                          FOR U := B TO Length(NewString) DO„                                           BEGIN„                                              IF U <> B THEN Temp := Temp + NewString[U]„                                              ELSE Temp := '';„                                           END;„                                          GotoXY(XPosition+B,WhereY);„                                          Write(Temp);„                                          Write(BackGroundChar);„                                          GotoXY(XPosition+B,WhereY);„                                          Dec(A);„                                       END;„                                   END;„                       END;„                       WHILE Keypressed DO C := ReadKey;„                    END;„       END;„       IF ((A < Len) AND (NoAdd = FALSE) AND (C <> Chr($08))) OR ((FirstChar) AND„          (NOT(NoAdd)) AND (C <> Chr($08))) THEN„        BEGIN„           IF FirstChar THEN {if first character typed is a real character,then„                             string is removed to start new one else...}„            BEGIN„               Delete(NewString,1,Length(NewString));„               GotoXY(XPosition,YPosition);„               B := 0;„               A := 0;„               FOR U := 1 TO Len DO„                BEGIN„                   Write(BackGroundChar);„                END;„               GotoXY(XPosition,YPosition);„               FirstChar := FALSE;„            END;„           Inc(B);„           Inc(A);„           IF InsertOn THEN„            BEGIN„               Insert(C,NewString,B);„               FOR U := B TO Length(NewString) DO„                BEGIN„                   IF B <> U THEN Temp := Temp + NewString[U]„                   ELSE Temp := '';„                END;„               GotoXY(XPosition+B-1,WhereY);„               Write(C);„               Write(Temp);„               GotoXY(XPosition+B,WhereY);„            END„           ELSE„            BEGIN„               Insert(C,NewString,B);„               Delete(NewString,B+1,1);„               Write(C)„            END;„        END;„    END;„    TextBackGround(0);„END;„„„BEGIN„END.„„                                                                                                                 8      01-27-9412:13ALL                      BERNIE PALLEK            Masked Input             IMPORT              22     3   {„>  The text on the screen would be something like:„>  What is your phone number? (   )   -„>                              ^^^ ^^^ ^^^^„>  But text could only be entered at the marked locations.  As soon as one„>  section is full it would move to the one beside it but read in a different„>  variable..„„How about this: (it's tested, BTW)„}„„USES Crt;„„VAR„  ts : String;„„PROCEDURE MaskedReadLn(VAR s : String; mask : String; fillCh : Char);„{ in 'mask', chars with A will only accept alpha input, and chars„  with 0 will only accept numeric input; spaces accept anything }„VAR ch : Char; sx, ox, oy : Byte;„BEGIN„  s := ''; ox := WhereX; oy := WhereY; sx := 0;„  REPEAT„    Inc(sx);„    IF (mask[sx] IN ['0', 'A']) THEN„      Write(fillCh)„    ELSE IF (mask[sx] = '_') THEN„      Write(' ')„    ELSE Write(mask[sx]);„  UNTIL (sx = Length(mask));„  sx := 0;„  WHILE (NOT (mask[sx + 1] IN [#32, '0', 'A']))„  AND (sx < Length(mask)) DO BEGIN„    Inc(sx);„    s := s + mask[sx];„  END;„  GotoXY(ox + sx, oy);„  REPEAT„    ch := ReadKey;„    IF (ch = #8) THEN BEGIN„      IF (Length(s) > sx) THEN BEGIN„        IF NOT (mask[Length(s)] IN [#32, '0', 'A']) THEN BEGIN„          REPEAT„            s[0] := Chr(Length(s) - 1);„            GotoXY(WhereX - 1, WhereY);„          UNTIL (Length(s) <= sx) OR (mask[Length(s)] IN [#32, '0', 'A']);„        END;„        s[0] := Chr(Length(s) - 1); GotoXY(WhereX - 1, WhereY);„        Write(fillCh); GotoXY(WhereX - 1, WhereY);„      END ELSE BEGIN„        Sound(440);„        Delay(50);„        NoSound;„      END;„    END ELSE IF (Length(s) < Length(mask)) THEN BEGIN„      CASE mask[Length(s) + 1] OF„        '0' : IF (ch IN ['0'..'9']) THEN BEGIN„                Write(ch);„                s := s + ch;„              END;„        'A' : IF (UpCase(ch) IN ['A'..'Z']) THEN BEGIN„                Write(ch);„                s := s + ch;„              END;„        #32 : BEGIN„                Write(ch);„                s := s + ch;„              END;„      END;„      WHILE (Length(s) < Length(mask))„      AND (NOT (mask[Length(s) + 1] IN [#32, '0', 'A'])) DO BEGIN„        IF (mask[Length(s) + 1] = '_') THEN s := s + ' ' ELSE„          s := s + mask[Length(s) + 1];„        GotoXY(WhereX + 1, WhereY);„      END;„    END;„  UNTIL (ch IN [#13, #27]);„END;„„BEGIN„  ClrScr;„  Write('Enter phone number: ');„  MaskedReadLn(ts, '(000)_000-0000', '_');„  WriteLn;„  Write('Enter postal code: ');„  MaskedReadLn(ts, 'A0A_0A0', '_');„  WriteLn;„END.„„{„It can be improved with colours and such stuff, but it may suit your„needs without enhancement.  If you have questions about how this works,„feel free to ask.„}„„                                        9      02-03-9409:58ALL                      LOU DUCHEZ               DATABOX.PAS              IMPORT              121    3   unit databox;„„{ This is a unit to let you open data-entry boxes on the screen for quick 'n'„  easy data entry.  It operates on variables of type "string", "integer",„  "word", "byte", "longint" and "boolean".  There are two main routines to„  call here:„„    OpenBox(x, y, data, temp, type) -- to open a data entry box on the screen„    ReadBoxes -- to read all data entry boxes„„  The parameters for "OpenBox":„    x, y -- the coordinates where the box should appear on the screen„    data -- the variable you want to do data entry on„    type -- an character indicating what type of variable you're working on.„            Valid "types" are:„„            'S' -- String            'I' -- Integer„            'W' -- Word              'L' -- LongInt„            'Y' -- Byte              'B' -- Boolean„„    temp -- a string "template" indicating the size of the data entry„            field and the data acceptable at each position.  The following„            characters mean the following:„„            'X' -- accept any character                 ( strings )„            '!' -- accept any character, but capitalize ( strings )„            '9' -- accept only digits and minus signs   ( numeric )„            'T' -- accept only 'T' and 'F'              ( boolean )„            'Y' -- accept only 'T', 'F', 'Y' and 'N'    ( boolean )„„            All of these template characters are valid on strings.  For„            numeric fields, the whole template gets converted to all 9's;„            for boolean, the template will either be a single 'T' or 'Y'„            (it defaults to 'T').„„    Examples:„„      OpenBox(12, 10, counter, '99999', 'I');„„      -- is for an integer variable "counter".  It opens a data entry box at„         position (12, 10), and is five characters across.„„      OpenBox(1, 14, yes_or_no, 'Y', 'b')„„      -- opens a data entry box for a boolean variable "yes_or_no", and will„         accept only a "Y" or an "N" as input.„„      OpenBox(1, 25, namestring, '!XXXXXXXXXXXXXXXX', 's')„„      -- opens a data entry box for a string variable "namestring"; it will„         automatically capitalize the first letter, and accept every other„         character entered "as is".„„    When you have opened all your data boxes, call "ReadBoxes" to allow„    the user to actually input into the boxes.  Once you are done, the„    boxes "close" so you can't do any more data entry on them.  There is„    also a "ClearBoxes" procedure to manually "close" open boxes, and a„    "Qwrite" procedure for doing direct video writes.„„    Oh, I'm Lou Duchez, and if you could leave my name somewhere in the„    code I'd appreciate it.  I'll never be rich off of public domain code„    like this, so at least help me get famous ...„  }„{„-------------------------------------------------------„}„interface„„const boxforeground: byte = 1;„      boxbackground: byte = 7;„„procedure qwrite(x, y: byte; s: string; f, b: byte);„procedure openbox(x, y: byte; var data; template: string; datatype: char);„procedure clearboxes;„procedure readboxes;„{„-------------------------------------------------------„}„implementation„uses crt;       { for "checkbreak" and "readkey" functions }„„const maxboxes = 255;     { open up to 255 data boxes simultaneously }„„type boxrecord = record   { holds all the data we need }„     x, y: byte;          { position to display on screen }„     template: string;    { describes size and type of data field }„     dataptr: pointer;    { points to data }„     datatype: char;      { type of data we're pointing to }„     end;„„var boxes: array[1 .. maxboxes] of ^boxrecord;  { all the data boxes }„    boxcount, thisbox, boxpos, boxlength: byte;„    boxstring: string;„    boxmodified: boolean;„{„-------------------------------------------------------„}„procedure qwrite(x, y: byte; s: string; f, b: byte);  { direct video writes }„„{ x, y: coordinates to display string at }„{ s: the string to display }„{ f, b: the foreground and background colors to display in }„„type  videolocation = record           { video memory locations }„        videodata: char;               { character displayed }„        videoattribute: byte;          { attributes }„        end;„„var cnter: byte;„    videosegment: word;„    vidptr: ^videolocation;„    videomode: byte absolute $0040:$0049;„    scrncols: byte absolute $0040:$004a;„    monosystem: boolean;„begin„„{ Find the memory location where the string will be displayed at, according to„  the monitor type and screen location.  Then associate the pointer VIDPTR with„  that memory location: VIDPTR is a pointer to type VIDEOLOCATION.  Insert the„  screen data and attribute; now go to the next character and video location. }„„  monosystem := (videomode = 7);„  if monosystem then videosegment := $b000 else videosegment := $b800;„  vidptr := ptr(videosegment, 2*(scrncols*(y - 1) + (x - 1)));„  for cnter := 1 to length(s) do begin„    vidptr^.videoattribute := (b shl 4) + f;„    vidptr^.videodata := s[cnter];„    inc(vidptr);„    end;„  end;„{„-------------------------------------------------------„}„procedure movecursor(boxnum, position: byte);          { Positions cursor. }„var tmpx, tmpy: byte;„begin„  tmpx := (boxes[boxnum]^.x - 1) + (position - 1);„  tmpy := (boxes[boxnum]^.y - 1);„  asm„    mov ah, 02h           { Move cursor here.  I don't use GOTOXY because it }„    mov bh, 00h           { is window-dependent. }„    mov dh, tmpy„    mov dl, tmpx„    int 10h„    end;„  end;„{„-------------------------------------------------------„}„procedure openbox(x, y: byte; var data; template: string; datatype: char);„var i: byte;„    datastring, tempstring: ^string;„begin„  if boxcount < maxboxes then begin   { If we have room for another data }„    inc(boxcount);                    { box, allocate memory for it from }„    new(boxes[boxcount]);             { the heap and fill its fields. }„    boxes[boxcount]^.x := x;„    boxes[boxcount]^.y := y;„    boxes[boxcount]^.dataptr := @data;„    boxes[boxcount]^.template := template;„    boxes[boxcount]^.datatype := upcase(datatype);„    case upcase(datatype) of„„    { "Fix" data entry template as needed.  Make sure the string data and„      the template are of the same length.  Numeric templates should consist„      of all 9's.  Boolean templates should be either 'Y' or 'T'. }„„      'S': begin„             datastring := boxes[boxcount]^.dataptr;„             tempstring := addr(boxes[boxcount]^.template);„             while length(datastring^) < length(tempstring^) do„                   datastring^ := datastring^ + ' ';„             while length(tempstring^) < length(datastring^) do„                   tempstring^ := tempstring^ + ' ';„             end;„      'W', 'I', 'L', 'Y': for i := 1 to length(template) do„                          boxes[boxcount]^.template[i] := '9';„      'B': begin„             boxes[boxcount]^.template[0] := #1;„             if not (boxes[boxcount]^.template[1] in ['Y', 'T']) then„                boxes[boxcount]^.template := 'T';„             end;„      end;„    end;„  end;„{„-------------------------------------------------------„}„procedure clearboxes;           { Free up all memory for "box" data. }„begin„  while boxcount > 0 do begin„    dispose(boxes[boxcount]);„    dec(boxcount);„    end;„  end;„{„-------------------------------------------------------„}„procedure fixstring(boxnumber: byte);   { Adjusts string for displaying }„var i: byte;                            { so that each character adheres to }„begin                                   { the corresponding template char. }„  for i := 1 to length(boxstring) do„    case upcase(boxes[boxnumber]^.template[i]) of„      'X': ;„      '!': boxstring[i] := upcase(boxstring[i]);„      '9': if not (boxstring[i] in ['-', '0' .. '9']) then boxstring[i] := ' ';„      'T': case upcase(boxstring[i]) of„           'Y', 'T': boxstring[i] := 'T';„           'N', 'F': boxstring[i] := 'F';„           else boxstring[i] := ' ';„           end;„      'Y': case upcase(boxstring[i]) of„           'Y', 'T': boxstring[i] := 'Y';„           'N', 'F': boxstring[i] := 'N';„           else boxstring[i] := ' ';„           end;„      end;„  qwrite(boxes[boxnumber]^.x, boxes[boxnumber]^.y, boxstring,„         boxforeground, boxbackground);„  end;„{„-------------------------------------------------------„}„procedure displaybox(boxnumber: byte); { Convert data to string and display. }„var lentemplate: byte;„    pntr: pointer;„begin„  pntr := boxes[boxnumber]^.dataptr;„  lentemplate := length(boxes[boxnumber]^.template);„  case boxes[boxnumber]^.datatype of„    'S':  boxstring := string(pntr^);„    'I':  str(integer(pntr^): lentemplate, boxstring);„    'W':  str(word(pntr^):    lentemplate, boxstring);„    'Y':  str(byte(pntr^):    lentemplate, boxstring);„    'L':  str(longint(pntr^): lentemplate, boxstring);„    'B':  if boolean(pntr^) then boxstring := 'T' else boxstring := 'F';„    end;„    fixstring(boxnumber);„  end;„{„-------------------------------------------------------„}„procedure deletekey;    { delete: remove character at cursor and shift over }„var i: byte;„begin„  boxmodified := true;„  for i := boxpos to boxlength - 1 do  boxstring[i] := boxstring[i + 1];„  boxstring[boxlength] := ' ';„  end;„„procedure backspace;        { backspace: back up one and delete if we're }„begin                       { still in the same box }„  boxpos := boxpos - 1;„  if boxpos = 0 then begin„    dec(thisbox);„    boxpos := 255;„    end„   else deletekey;„  end;„„{ Enter, Tab, and Shift-Tab move you to the beginning of prev/next box }„„procedure enterkey;   begin inc(thisbox); boxpos := 1; end;„procedure tab;        begin inc(thisbox); boxpos := 1; end;„procedure reversetab; begin dec(thisbox); boxpos := 1; end;„„{ PgUp, PgDn, Esc take you out of editing; "Esc" indicates that the„  "current" box should not be updated }„„procedure pageup;     begin thisbox := 0; end;„procedure pagedown;   begin thisbox := 0; end;„procedure esckey;     begin thisbox := 0; boxmodified := false; end;„„{ Up / Down }„„procedure moveup;     begin dec(thisbox); end;„procedure movedown;   begin inc(thisbox); end;„„procedure moveleft;   { Move left; if we go too far left, move up }„begin„  dec(boxpos);„  if (boxpos = 0) then begin„    boxpos := 255;„    moveup;„    end;„  end;„„procedure moveright;  { Move right; if we go too far right, move down }„begin„  inc(boxpos);„  if (boxpos > boxlength) then begin„    boxpos := 1;„    movedown;„    end;„  end;„„procedure literalkey(keyin: char);  { accept character into field }„var i: byte;„    goodkey, insmode: boolean;„    keyboardstat: byte absolute $0040:$0017;„begin„  case upcase(boxes[thisbox]^.template[boxpos]) of   { does char match tmplt? }„    '9': goodkey := (keyin in ['-', '0'..'9']);„    'T': goodkey := (upcase(keyin) in ['T', 'F']);„    'Y': goodkey := (upcase(keyin) in ['T', 'F', 'Y', 'N']);„    else goodkey := true;„    end;„  if goodkey then begin             { character matches template -- use it }„    boxmodified := true;„    insmode := (keyboardstat and $80 = $80);„    if insmode then begin„      i := length(boxstring);       { "Insert" mode: make space for new char }„      while i > boxpos do begin„        boxstring[i] := boxstring[i - 1];„        dec(i);„        end;„      end;„    boxstring[boxpos] := keyin;     { enter character and move to the right }„    moveright;„    end;„  end;„{„-------------------------------------------------------„}„procedure readbox;  { get data input on the box specified by THISBOX }„var keyin: char;„    startingbox, i: byte;„    pntr: pointer;„    dummyint: integer;„    numstring: string;„begin„  boxmodified := false;             { "housekeeping" here }„  startingbox := thisbox;„  displaybox(thisbox);„  boxlength := length(boxstring);„  if boxpos > boxlength then boxpos := boxlength;   { cursor positioning }„  if boxpos < 1 then boxpos := 1;„  while (thisbox = startingbox) and„        (boxpos >= 1) and (boxpos <= boxlength) do begin  { process field }„    fixstring(startingbox);„    movecursor(startingbox, boxpos);„    keyin := readkey;                         { Interpret keystrokes here }„    case keyin of„       #0:  case readkey of„              #15:  reversetab;„              #72:  moveup;„              #73:  pageup;„              #75:  moveleft;„              #77:  moveright;„              #80:  movedown;„              #81:  pagedown;„              #83:  deletekey;„              end;„       #8:  backspace;„       #9:  tab;„      #13:  enterkey;„      #27:  esckey;„      else  literalkey(keyin);„      end;„    end;„  if boxmodified then begin       { If data was changed, update variable }„„    { This section handles numeric decoding.  Since "Val" gets real uppity„      if there are spaces in the middle of your string, these couple loops„      isolates the first section of the data entry string surrounded by„      spaces.  Then "Val" processes that part. }„„    i := 1;„    while (i <= length(boxstring)) and (boxstring[i] = ' ') do inc(i);„    numstring[0] := #0;„    while (i <= length(boxstring)) and (boxstring[i] <> ' ') do begin„      inc(numstring[0]);„      numstring[length(numstring)] := boxstring[i];„      inc(i);„      end;„    pntr := boxes[startingbox]^.dataptr;„„    { Put the updated data back into its original variable. }„„    case boxes[startingbox]^.datatype of„      'S': string(pntr^) := boxstring;„      'I': val(numstring, integer(pntr^), dummyint);„      'W': val(numstring, word(pntr^),    dummyint);„      'Y': val(numstring, byte(pntr^),    dummyint);„      'L': val(numstring, longint(pntr^), dummyint);„      'B': boolean(pntr^) := (upcase(boxstring[1]) = 'Y') or„                             (upcase(boxstring[1]) = 'T');„      end;„    end;„„  { Do a final data display. }„„  displaybox(startingbox);„  movecursor(startingbox, boxlength + 1);„  end;„{„-------------------------------------------------------„}„procedure readboxes;          { gets data input on all boxes }„var oldcheckbreak: boolean;„begin„  oldcheckbreak := checkbreak;„  checkbreak := false;„  for thisbox := 1 to boxcount do displaybox(thisbox);  { display data boxes }„  thisbox := 1;„  boxpos := 1;„  while (thisbox >= 1) and (thisbox <= boxcount) do readbox;„  clearboxes;„  checkbreak := oldcheckbreak;„  end;„{„-------------------------------------------------------„}„begin               { initialize to "no boxes" }„  boxcount := 0;„  end.„„==============================================================================„TEST PROGRAM:„==============================================================================„program datatest;„uses databox, crt;„„var i: integer;    s: string;     w: word;„    b: boolean;    l: longint;    y: byte;„„begin„  clrscr;„  i := 10;              openbox(1, 1, i, '999999', 'i');„  w := 10;              openbox(1, 3, w, '999999', 'w');„  s := 'SpamBurger';    openbox(1, 5, s, '!xxxxxxxxxxxxxxx', 's');„  readboxes;„  gotoxy(1, 18);  writeln(i);  writeln(w);  writeln(s);„„  b := false;           openbox(1, 7, b, 'Y', 'b');„  l := 10;              openbox(1, 9, l, '9999999999', 'l');„  y := 20;              openbox(1,11, y, '9999999999', 'y');„  readboxes;„  gotoxy(1, 21);  writeln(b);  writeln(l);  writeln(y);„  end.„                                                                                                            10     05-25-9408:13ALL                      JUSTIN FERGUSON          FergSoft! ReadLn         SWAG9405            61     3   {„        Ok, y'all, here's a function I've been working on for a while, and„        I thought I'd post it for everybody.  It's a modified ReadLn„        routine, and while there's no guarantees, <What's new?>, I _think_„        it's bug free. <Crossing fingers>  If y'all want to use it, go„        ahead, but I would like some credit, 'cuz it took me a while.  Just„        credit FergSoft!, Artificial Reality, Whizard, or Justin Ferguson.„        It's fairly well commented, but just throw any questions you may„        have my way...„„--- Cut Here ---„}„„unit FSRead;„„{------------------------------------------------------------------------}„{„      FergSoft! ReadLn Routine:„„                By Justin Ferguson of FergSoft!,„                a. k. a. Whizard of Artificial Reality.„„      FSReadLn reads a string of specified length, at specified„      location, in specified colors, terminated by TAB or Enter.„„      Feel free to use this little unit anywhere y'all want, just give„      credit for it.„„„                                Thanx, Whizard„„                                                                         }„{------------------------------------------------------------------------}„„INTERFACE„„uses Crt;„„Function FSReadLn (X,                                         {X Location}„                   Y,                                         {Y Location}„                   FC,                                  {Foreground Color}„                   BC,                                  {Background Color}„                   StrLength : Byte;  {Length of string to input.  Will be„                                       padded with spaces (#32).         }„„                   Default : String       {Default string, leave '' for no„                                           default                       }„                    ) : String;„„{------------------------------------------------------------------------}„„IMPLEMENTATION„„Function FSReadLn (X, Y, FC, BC, StrLength : Byte; Default : String)„                                                                 : String;„„var Temp : String;                      {Temporary string}„    Location : Byte;                    {Current location in string}„    QuitFlag, InsFlag : Boolean;        {Flags}„    Ch : Char;                          {Current Character}„    Z : Integer;                        {Temp variable}„    Cursor : Word absolute $0040:$0060; {Cursor format}„„begin„     QuitFlag := False;„     InsFlag := True;„„     For Z := 1 to 255 do               {Clear string to spaces}„         Temp[Z] := ' ';„„     For Z := 1 to Length(Default) do   {Set to default string}„         Temp[Z] := Default[Z];„„     Temp[0] := Chr(StrLength);         {Set length of string}„     Location := 1;„     Ch := #1;„     Temp[StrLength + 1] := #32;„     GotoXY(X, Y);„     Write(Temp);„„     Repeat„           Case Ch of„                #32..#127 : begin                    {Regular ASCII}„                              If InsFlag = False then„                                begin„                                  If Location <= StrLength then„                                    begin„                                      Location := Location + 1;„                                      Temp[Location] := Ch;„                                    end;„                                  end„                                else„                                  begin„                                    If Location <= StrLength then„                                      begin„                                        For Z := StrLength - 1 downto„                                                           Location do„                                          Temp[Z + 1] := Temp[Z];„„                                          Temp[Location] := Ch;„                                          Location := Location + 1;„                                      end;„                                  end;„                            end;„                #27       : begin                              {ESC}„                              For Z := 1 to StrLength do„                                Temp[Z] := ' ';„                              Location := 1;„                            end;„                #9, #13   : QuitFlag := True;           {Tab}{Enter}„                #8        : begin                        {Backspace}„                              If Location > 1 then„                                begin„                                  Location := Location - 1;„                                    For Z := Location to StrLength do„                                      begin„                                        Temp[Z] := Temp[Z + 1];„                                      end;„                                end;„                            end;„„                #0        : begin     {Extended keys... }„                              Ch := ReadKey;„                              Case Ch of„„                                #75 : begin             {Left arrow}„                                        If Location > 1 then„                                          Location := Location - 1;„                                      end;„                                #77 : begin            {Right arrow}„                                        If Location < (StrLength - 1) then„                                          Location := Location + 1;„                                      end;„                                #71 : Location := 1;          {Home}„                                #79 : Location := StrLength;   {End}„                                #82 : If InsFlag = True     {Insert}„                                        then„                                          begin„                                            InsFlag := False;„                                            asm„                                               MOV AH, $01„                                               MOV CX, $0F„                                               INT $10„                                            end;„                                          end„                                        else„                                          begin„                                            InsFlag := True;„                                            asm„                                               MOV AH, $01„                                               MOV CL, $07„                                               MOV CH, $06„                                               INT $10„                                            end;„                                          end;„                                                            {Delete}„                                #83 : For Z := Location to StrLength do„                                        Temp[Z] := Temp[Z + 1];„                              end;„                            end;„                end;„„           Temp[StrLength + 1] := #32;„           GotoXY(X, Y);„           Write(Temp);„„           TextColor(12);„           GotoXY(79, 25);„           If InsFlag = True then Write('I') else Write(' ');„              {Note:  Take out above 3 lines to not put an insert„               status 'I' at the bottom of the screen             }„„           TextColor(FC);„           TextBackground(BC);„           GotoXY(X + Location - 1, Y);„           If QuitFlag <> True then Ch := ReadKey;„„     until QuitFlag = True;„„     Temp[0] := Chr(StrLength);„end;„„{--------------------------------------------------------------------------}„„begin„end.„                                                  11     05-25-9408:20ALL                      RICHARD FURMAN           Readline Function        SWAG9405            17     3   {„The Readln statement can't really be used here, because this interchange is„taking place in Graphics mode.  I am writing a Graphics application that„does take user input„}„Function KBString:String; {* Gets string from keyboard using Scankey *}„         Var„           bu,X,Inchar:Integer;„           STRBUFF:STRING;„         begin„         STRBUFF := '';„         X:=20;„          Repeat„               Inchar := Scankey;„               IF FK and (Inchar = 60) then„                  Begin„                       Cancel := True;„                       Exit;„                  End;„               setcolor(0);„               setlinestyle (0,0,1);„               Rectangle(15,70,X+5,90);„               setcolor(BLDCLR);„               If Not FK  then outtextxy (x,77,CHR(INCHAR));„               If inchar <> 8 then„                  Begin„                       X := X+ Textwidth(CHR(INCHAR));„                       setcolor(txtclr);„                       Rectangle(15,70,X+5,90);„                  End„               else„               begin„                  setcolor(0);„                  setlinestyle (0,0,1);„                  Rectangle(15,70,X+5,90);„                  x:=x-textwidth(Strbuff[length(strbuff)]);„                  outtextxy(X,77,strbuff[length(strbuff)]);„                  setcolor(txtclr);„                  Rectangle(15,70,x+5,90);„                  Delete(Strbuff,Length(Strbuff),1);„                  setcolor(BLDCLR);„               End;„               If (Not FK) and (Inchar <> 8)  then STRBUFF := STRBUFF +„                                                      CHR(Inchar);„          Until inchar = 13;„         Delete(strBuff,Length(StrBuff),1);„         setcolor(txtclr);„         KBString := STRBUFF;„         End;„„This code snippet should give you some ideas on getting user input.  BTW„SCANKEY is a function I wrote to read the keyboard.  You should be able to„use READKEY in its place.  This routine also features the ability to edit„with the backspace key.  I hope it helps.„                              12     05-26-9410:58ALL                      RICHARD GRIFFIN          Simple Entry Routine     SWAG9405            84     3   unit GS_KeyI;„„{      Written by  Richard F Griffin„„       1 December 1988, (Released to the public domain)„„       1110 Magnolia Circle„       Papillion, Nebraska  68128„„       CIS 75206.231„„   This unit allows you to set data entry routines quickly and simply.„   It also gives the programmer the capability to override the entry„   routine and use another procedure to handle function keys.„„}„„„interface„„uses crt, dos;„„type„   GS_KeyI_str80 = string[80];„„var„   GS_KeyI_Chr : char;„   GS_KeyI_Fuc,„   GS_KeyI_Esc : boolean;„   GS_KeyI_Hlp : pointer;„   GS_KeyI_Psn : integer;„„Function GS_KeyI_Get : char;„„procedure GS_KeyI_Key(wait : boolean;Fldcnt,x,y : integer);„„function GS_KeyI_T(waitcr: boolean;Fl,X,Y,B:integer;CTitl,„                 CVal:GS_KeyI_str80) : GS_KeyI_str80;„„function GS_KeyI_I(waitcr:boolean;Fl,x,y,B:integer;„                CTitl:GS_KeyI_str80;XVal,l,h:integer) : integer;„„function GS_KeyI_R(waitcr:boolean;Fl,x,y,B:integer;CTitl:GS_KeyI_str80;„                          XVal,l,h:real;d:integer) : real;„„implementation„„var„   Big_String : GS_KeyI_str80;„„{$F+}„procedure GS_KeyI_Dum;„begin„   write(#7);„end;„{$F-}„„{„   This procedure is an Inline far call.  The address is inserted by„   GS_KeyI_Call based on the address in GS_KeyI_Hlp.  This address is„   initially to GS_KeyI_Dum, but may be changed by the using program.„„   ex:  GS_KeyI_Hlp := @MyProcedure„„   The procedure will be called when a special function key (F1, F2,„   Home, RtArrow, etc.) is pressed during data entry.  The using procedure„   may then use GS_KeyI_Chr to find which key was pressed.  It is up to the„   using program to ensure the screen and window sizes are properly restored.„   The programmer must ensure that the $F+ option is used in the procedure„   to force a Far Return.„„        -----------      DO NOT MODIFY THIS ROUTINE        ------------„}„„procedure GS_KeyI_Jmp;„begin„   InLine ($9A/$00/$00/$00/$00);       {CALLF [GS_KeyI_Hlp]}„end;„„{„   Inserts a Far Call address for GS_KeyI_Jmp.„   Works in TP 4 and 5.„}„„procedure GS_KeyI_Call;„begin„   MemW[seg(GS_KeyI_Jmp):ofs(GS_KeyI_Jmp)+11] := ofs(GS_KeyI_Hlp^);„   MemW[seg(GS_KeyI_Jmp):ofs(GS_KeyI_Jmp)+13] := seg(GS_KeyI_Hlp^);„   GS_KeyI_Jmp;„end;„„Function GS_KeyI_Get : char;„var ch: char;„begin„  Ch := ReadKey;„  If (Ch = #0) then  { it must be a function key }„  begin„    Ch := ReadKey;„    GS_KeyI_Fuc := true;„  end„  else GS_KeyI_Fuc := false;„  GS_KeyI_Get := Ch;„end;„„procedure GS_KeyI_Key(wait : boolean;Fldcnt,x,y : integer);„Var„   Big_S : GS_KeyI_str80;„   i : integer;„begin„   Big_s := '';„   GS_KeyI_Psn := 0;„   gotoxy(x,y);„   Repeat„      GS_KeyI_Chr := GS_KeyI_Get;„      GS_KeyI_Esc := false;„      if not GS_KeyI_Fuc then„      begin„         case GS_KeyI_Chr of„            #08        : begin„                            If GS_KeyI_Psn > 0 then„                            begin„                               GS_KeyI_Psn := GS_KeyI_Psn - 1;„                               gotoxy(x+GS_KeyI_Psn,y);„                               write('_');„                               gotoxy(x+GS_KeyI_Psn,y);„                               delete(Big_S,length(Big_S),1);„                            end else„                            begin„                               write('_');„                               gotoxy(x+GS_KeyI_Psn,y);„                            end;„                         end;„            ' '..'}'   : begin„                            if (GS_KeyI_Psn = Fldcnt) and (wait) then„                                write(#7)„                            else begin„                               if GS_KeyI_Psn = 0 then„                               begin„                                  for i := 1 to Fldcnt do write('_');„                                  gotoxy(x,y);„                               end;„                               GS_KeyI_Psn := GS_KeyI_Psn + 1;„                               write(GS_KeyI_Chr);„                               Big_S := Big_S + GS_KeyI_Chr;„                            end;„                         end;„            #27        : begin„                            Big_S := ' ';„                            GS_KeyI_Esc := true;„                         end;„         end;„      end else„      begin„         GS_KeyI_Call;„         gotoxy(x+GS_KeyI_Psn,y);„      end;„   until (GS_KeyI_Chr in [#13,#27]) or ((GS_KeyI_Psn = Fldcnt) and (not wait));„   Big_String := Big_S;„end;„„{ The GS_KeyI_T function will process an input from the keyboard and display„  it on the screen in a specified location.  The length of the input field is„  given, as well as a default entry.  The default entry is optionally shown„  on the screen.„„  Parameter descriptions are:„„        1  Boolean flag to determine whether to wait for a carriage return„           once the field is full.„„        2  Length of input field.„„        3  Horizontal location to start.„„        4  Vertical position to start.„„        5  Vertical line to place default value.  Should be 0 to inhibit„           display of default.  Will usually be the same as (4).„„        6  The prompt to place on the screen prior to the data entry field.„           Should be '' if no prompt.„„        7  Default value.„„}„„„function GS_KeyI_T(waitcr: boolean;Fl,X,Y,B:integer;CTitl,„                   CVal:GS_KeyI_str80) : GS_KeyI_str80;„var„   i : integer;„begin„  GS_KeyI_T := '';„  gotoxy(x,y);„  write(CTitl);„  for i := 1 to Fl do write('_');„  if B <> 0 then„  begin„     gotoxy(x+length(CTitl),B);„     write(CVal);„  end;„  GS_KeyI_Key(waitcr,FL,x+length(CTitl),y);„  if Big_String = '' then Big_String := CVal;„  if GS_KeyI_Esc then Big_String := ' ';„  gotoxy(x+length(CTitl),y);„  write(Big_String,'':Fl-length(Big_String));„  if (B <> 0) and (B <> Y) then„  begin„     gotoxy(x+length(CTitl),B);„     write('':length(CVal));„  end;„  GS_KeyI_T := Big_String;„end;„„{ The GS_KeyI_I function will accept an integer from the keyboard and display„  it on the screen in a specified location.  The length of the input field is„  given, as well as a default entry.  The default entry is optionally shown„  on the screen.  A range of acceptable values is also specified.„„  Parameter descriptions are:„„        1  Boolean flag to determine whether to wait for a carriage return„           once the field is full.„„        2  Length of input field.„„        3  Horizontal location to start.„„        4  Vertical position to start.„„        5  Vertical line to place default value.  Should be 0 to inhibit„           display of default.  Will usually be the same as (4).„„        6  The prompt to place on the screen prior to the data entry field.„           Should be '' if no prompt.„„        7  Default value.„„        8  Lowest value acceptable.„„        9  Highest value acceptable.„„}„„„function GS_KeyI_I(waitcr:boolean;Fl,x,y,B:integer;„                CTitl:GS_KeyI_str80;XVal,l,h:integer) : integer;„Var„   Cod, q, i : integer;„   CVal : GS_KeyI_str80;„„begin„   str(XVal:Fl,CVal);„   Cod := 1;„   while Cod <> 0 do„   begin„      Big_String := GS_KeyI_T(waitcr,Fl,X,Y,B,CTitl,CVal);„      if GS_KeyI_Esc then„      begin„         GS_KeyI_I := XVal;„         Exit;„      end;„      if Big_String[length(Big_String)] = ' ' then„         Big_String := 'z';„      for i := 1 to length(Big_String) do„         if Big_String[i] = ' ' then Big_String[i] := '0';„      val(Big_String,q,Cod);„      if Cod <> 0 then„      begin„         write(chr(7));„      end else„      begin„         if (q < l) or (q > h) then„         begin„            Cod := 1;„            write(chr(7));„         end;„      end;„   end;„   GS_KeyI_I := q;„end;„„„{ The GS_KeyI_R function will accept a real number from the keyboard and„  display it on the screen in a specified location.  The length of the„  input field is given, as well as a default entry.  The default entry„  is optionally shown on the screen.  A range of acceptable values is„  also specified.„„  Parameter descriptions are:„„        1  Boolean flag to determine whether to wait for a carriage return„           once the field is full.„„        2  Length of input field.„„        3  Horizontal location to start.„„        4  Vertical position to start.„„        5  Vertical line to place default value.  Should be 0 to inhibit„           display of default.  Will usually be the same as (4).„„        6  The prompt to place on the screen prior to the data entry field.„           Should be '' if no prompt.„„        7  Default value.„„        8  Lowest value acceptable.„„        9  Highest value acceptable.„„       10  Number of decimal places.„„}„„„function GS_KeyI_R(waitcr:boolean;Fl,x,y,B:integer;CTitl:GS_KeyI_str80;„                          XVal,l,h:real;d:integer) : real;„Var„   Cod, i : integer;„   CVal : GS_KeyI_str80;„   r : real;„„begin„   str(XVal:Fl:d,CVal);„   Cod := 1;„   while Cod <> 0 do„   begin„      Big_String := GS_KeyI_T(waitcr,Fl,X,Y,B,CTitl,CVal);„      if GS_KeyI_Esc then„      begin„         GS_KeyI_R := XVal;„         Exit;„      end;„      if Big_String[length(Big_String)] = ' ' then„         Big_String := 'z';„      for i := 1 to length(Big_String) do„         if Big_String[i] = ' ' then Big_String[i] := '0';„      val(Big_String,r,Cod);„      if Cod <> 0 then„      begin„         write(chr(7));„      end else„      begin„         if (r < l) or (r > h) then„         begin„            Cod := 1;„            write(chr(7));„         end;„      end;„   end;„   gotoxy(x+length(CTitl),y);„   str(r:Fl:d,Big_String);„   write(Big_String,'':Fl-length(Big_String));„   GS_KeyI_R := r;„end;„„begin„   GS_KeyI_Hlp := @GS_KeyI_Dum;„end.„„{----------------   DEMO PROGRAM ------------------------ }„„program KeyIDemo;„„uses crt, dos, GS_KeyI;„„var„   lin  : string[80];„   numi : integer;„   numr : real;„„{$F+}„procedure tst;„begin„   window(1,20,80,24);„   ClrScr;„   gotoxy(20,1);„   case GS_KeyI_Chr of„      #59 : write('Function Key F1 Pressed');„      #60 : write('Function Key F2 Pressed');„      #61 : write('Function Key F3 Pressed');„      #62 : write('Function Key F4 Pressed');„      #71 : write('The Home Key was Pressed');„      #79 : write('The End Key was Pressed');„   else„      write(#7);„   end;„   window(1,1,80,25);„end;„{$F-}„„begin„   clrscr;„   GS_KeyI_Hlp := @tst;„   lin := GS_KeyI_T(true, 8,10,1,1,'Enter Text Field: ','empty');„   numi := GS_KeyI_I(true, 2,10,2,2,'Enter Integer Field (0-50): ',0,0,50);„   numr:= GS_KeyI_R(true, 6,10,3,3,'Enter Real Field (0-99.99): ',0,0,99.99,2);„end.                                                                                                           13     05-26-9411:03ALL                      ROBERT MASHLAN           Small Input Routines     SWAG9405            79     3   Unit InputUn;„„{ This is a small unit with crash proof user input routines and some„  string formating functions. Compile the DemoInput program for more„  information on how to use these functions.„„   Robert Mashlan [71160,3067]  3/11/89 }„„Interface„„Uses Crt;„„const„   DefaultSet = [' '..'}'];„„Var„   InverseOn    : boolean;„   UpcaseOn     : boolean;„   ValidCharSet : set of char;„„Procedure Inverse;„Procedure UnderLine;„Procedure Normal;„Procedure Goback;„Function ReadString( Prompt : string; Width : byte; var Escape : boolean ) : string;„Function ReadNum( Prompt : real; Width : byte; var Escape : boolean ) : real;„Function ReadInt( Prompt : longint; Width : byte; var Escape : boolean ) : longint;„Function Left( AnyString : string; Width : byte ) : string;„Function Center( AnyString : string; Width : byte ) : string;„„Implementation„„const„   esc = #27;„„Procedure Inverse;„begin„   textbackground(white);„   textcolor(black);„end;„„Procedure UnderLine;„begin„   textbackground(white);„   textcolor(blue);„end;„„Procedure Normal;„begin„   textbackground(black);„   textcolor(white);„end;„„„Procedure Goback;„begin„   GotoXY(WhereX,WhereY-1);„   ClrEol;„end;„„Function Left( AnyString : string; Width : byte ) : string;„var„   len  : byte absolute AnyString;„   loop : byte;„begin„   while length( AnyString ) < Width do„      AnyString:=AnyString+' ';„   len:=Width;      { truncate AnyString if Needed }„   Left:=AnyString;„end;„„Function Center( AnyString : string; Width : byte ) : string;„begin„   repeat„      if length( AnyString ) < Width„         then AnyString:=AnyString+' ';„      if length( AnyString ) < Width„         then AnyString:=' '+AnyString;„   until length( AnyString ) >= Width;„   Center:=AnyString;„end;„„„Function ReadString( Prompt : string; Width : byte; var Escape : boolean ) : string;„var„   NewString    : string;„   InKey,InKey2 : char;„   Start        : byte;„   index        : integer;„   InsertMode   : boolean;„„   Procedure Display;„   begin„      GotoXY(Start,WhereY);„      if InverseOn„         then Inverse;„      write(left(NewString,Width));„      if InverseOn„         then Normal;„      GotoXY(Start+index,WhereY);„   end;„„   Procedure StripSpaces( var AnyString : string );„   { decrease length of AnyString until a character until a char other than a space is found }„   begin„      while AnyString[ ord(AnyString[0]) ]=' ' do„         dec(AnyString[0]);„   end; { Procedure }„„„„begin„   InsertMode:=false;„   Start:=WhereX;„   index:=0;„   NewString:=Prompt;„   Display;„   index:=1;„   if UpCaseOn„      then Inkey:=UpCase(ReadKey)„      else InKey:=ReadKey;„   if InKey=#0„      then begin„         InKey2:=ReadKey;„         if InKey2 in [#77,#82]„            then NewString:=Prompt„            else NewString:='';„         if Inkey2=#82„            then begin„               InsertMode:=true;„               index:=0;„            end;„      end { then }„      else if InKey in ValidCharSet„         then NewString:=InKey„         else begin„            NewString:='';„            index:=0;„         end;„   if InKey=esc„      then begin„         ReadString:=Prompt;„         Escape:=true;„         ValidCharSet:=defaultSet;„         exit;„      end;„   if InKey=#13„      then begin„         Escape:=false;„         ReadString:=Prompt;„         ValidCharSet:=DefaultSet;„         exit;„      end;„   Display;„   repeat„     if UpCaseOn„        then Inkey:=Upcase(readkey)„        else InKey:=ReadKey;„     if (InKey in ValidCharSet)„       then begin„           if not InsertMode„              then Delete(NewString,index+1,1);„           insert(InKey,NewString,index+1);„           if index<> Width then inc(index)„        end;„     if (length(NewString)<>0) and (InKey=#8)  { backspace }„        then begin„           Delete(NewString,index,1);„           if index<>0„              then dec(index);„        end;„     if InKey=#0„        then begin„           InKey:=ReadKey;„           case InKey of„              #77 : if (index<>length(NewString)) and (' ' in ValidCharSet)„                     then inc(index)„                     else if (index+1<>Width) and (' ' in ValidCharSet)„                        then begin„                           NewString:=NewString+' ';„                           inc(index);„                        end;„              #75 : if index<>0„                       then if length(NewString)+1<>index„                          then dec(index)„                          else if NewString[index]=' '„                             then begin„                                NewString[0]:=succ(NewString[0]);„                                dec(index);„                             end„                             else dec(index);„              #83 : if length(NewString)>0 then Delete(NewString,index+1,1);„              #82 : if InsertMode„                       then InsertMode:=false„                       else InsertMode:=true;„           end; { case }„        end; { then }„     if Length(NewString)>width then dec( NewString[0] );„     if index >= width then dec(index);„     Display;„   until (InKey=#13) or (InKey=esc);„   ValidCharSet:=DefaultSet;„   if not ( (InKey=esc) or (length(NewString)=0))„      then begin„         StripSpaces(NewString);„         ReadString:=NewString„      end„      else ReadString:=Prompt;„   if InKey=esc„      then Escape:=true„      else Escape:=false;„„end; { Procedure }„„Function ReadNum( Prompt : real; Width : byte; var Escape : boolean ) : real;„var„   NewString : string;„   code      : integer;„   OldNum    : real;„   Start     : byte;„begin„   OldNum:=Prompt;„   Start:=WhereX;„   repeat„      GotoXY(Start,WhereY);„      str( Prompt:0:2, NewString );„      ValidCharSet:=['0'..'9','.','-',' '];„      NewString:=ReadString( NewString, Width, Escape );„      val(NewString,Prompt,code);„   until Escape or (code=0);„   if Escape or (code<>0)„      then ReadNum:=OldNum„      else ReadNum:=Prompt;„end;„„Function ReadInt( Prompt : longint; Width : byte; var Escape : boolean ) : longint;„var„   NewString : string;„   code      : integer;„   OldNum    : longint;„   Start     : byte;„begin„   OldNum:=Prompt;„   Start:=WhereX;„   repeat„      GotoXY(Start,WhereY);„      str( Prompt, NewString );„      ValidCharSet:=['0'..'9','-',' '];„      NewString:=ReadString( NewString, Width, Escape );„      val(NewString,Prompt,code);„   until Escape or (code=0);„   if Escape„      then ReadInt:=OldNum„      else ReadInt:=Prompt;„end;„„begin„   InverseOn:=true;„   UpcaseOn:=false;„   ValidCharSet:=DefaultSet;„end.„„{ -----------------------------   DEMO PROGRAM ----------------------- }„Program DemoInputUnit;„„Uses„   Crt, InputUn;„„var„   InKey     : char;„   AnyString : string;„   AnyInt    : longint;„   AnyNum    : real;„   Escape    : boolean;„„begin„   ClrScr;„   writeln;„   Inverse;„   writeln(' Text in Inverse mode ');„   writeln;„   Underline;„   writeln(' Text in Underline mode ( if using a monochrome monitor)');„   writeln;„   normal;„   writeln(' Back to normal ');„   writeln;„   writeln(' The GoBack procedure is used...(press any key)................ ');„   Inkey:=readkey;„   goback;„   writeln(' To erase a line and write a new one  (press any key) ');„   InKey:=readkey;„   ClrScr;„   writeln(' The ReadString function takes 3 parameters');„   writeln(' Function ReadString( Prompt : string; width : byte; var Escape : boolean )');„   writeln('                                                                    : string;');„   writeln(' Prompt is the string that is first put into the edit field.');„   writeln(' This is the string that the function returns if the function is exited with');„   writeln(' an Esc at any time, or a return while it is there.');„   writeln(' This prompt may be edited if the right arrow or the insert key is pressed');„   writeln(' on the first input, otherwise the prompt will disappear.  The return key ');„   writeln(' will input all the visible characters in the field and exit the function.');„   writeln(' The Del, left and right arrow keys work as does the backspace.');„   writeln(' The Ins key toggles the insert mode where new characters are inserted ');„   writeln(' instead of written over.  It is initially off.');„   writeln(' Esc will also exit the function, return the prompt as the result and set ');„   writeln(' the Escape parameter to true (otherwise set to false with a return');„   writeln(' the width parameter sets the maximum length of the string');„   writeln(' This field is highlighted in Inverse. It may be turned off by setting the');„   writeln(' InverseOn to true. Another Global varible that affects this function is');„   writeln(' ValidCharSet which is initially set to the set of all printable characters.');„   writeln(' You can change it before calling this function, and is reset to the ');„   writeln(' DefaultSet const after calling it.  The InverseOn varible will convert');„   writeln(' all letters to uppercase if set to true. It is initially set to false');„   writeln;„   repeat„      write('Input a string->');„      AnyString:=ReadString('This is your prompt',20,escape);„      writeln;„      goback;„      if escape„         then write(' Escape Exit  ');„      writeln('Your string is ''',AnyString,'''');„      inkey:=readkey;„      goback;„      write('Input an integer ( ReadInt )->');„      AnyInt:=ReadInt(123,5,Escape);„      writeln;„      goback;„      if escape„         then write(' Escape Exit  ');„      writeln('Your integer is ',AnyInt);„      if escape then exit;„      inkey:=readkey;„      goback;„      write('Input a real number ( ReadNum )->');„      AnyNum:=ReadNum(1.23,8,escape);„      writeln;„      goback;„      if escape„         then write(' Escape Exit  ');„      writeln('Your Number is ',AnyNum:0:5);„      if escape then exit;„      if not escape„         then begin„            Inkey:=readkey;„            goback;„         end;„   until escape;„end.„„„„„„                                         