SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00019         ARCHIVE HANDLING                                                  1      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Get Archive ID           IMPORT              19     ÆQùÔ {„ > I'm looking For descriptions of the formats of headers in„ > all popular archive Files, ie .ZIP, .ARC, .LZH, .ARJ, etc.„ > I just want to be able to read the headers of all of these„ > archives, not necessarily manipulate them.  Anyone know„ > where such can be had?„„Here's a Program that will determine most of the major archive Types.„I've made a couple of additions, but the original source was from„a message on this echo...the original author's name has since been„lost.  To use the Procedure, just call it as follows:„ If GetArcType(FileName.Ext)=Zip then....„}„„Uses„  Dos;„„Type„  ArcType = (FileError, Unknown, Zip, Zoo, Arc, Lzh, Pak, Arj);„„Function GetArcType(FName : String) : ArcType;„Var„  ArcFile : File of Byte;„  i       : Integer;„  Gat     : ArcType;„  c       : Array[1..5] of Byte;„begin„  Assign(ArcFile, FName);„  {$I-}„  Reset(ArcFile);„  {$I+}„  if IOResult <> 0 then„    Gat := FileError„  else„  if FileSize(ArcFile) < 5 then„    Gat := FileError„  else„  begin„    For i := 1 to 5 do„      Read(ArcFile, c[i]);„    Close(ArcFile);„    if ((c[1] = $50) and (c[2] = $4B)) then„      Gat := Zip„    else„    if ((c[1] = $60) and (c[2] = $EA)) then„      Gat := Arj„    else„    if ((c[4] = $6c) and (c[5] = $68)) then„      Gat := Lzh„    else„    if ((c[1] = $5a) and (c[2] = $4f) and (c[3] = $4f)) then„      Gat := Zoo„    else„    if ((c[1] = $1a) and (c[2] = $08)) then„      Gat := Arc„    else„    if ((c[1] = $1a) and (c[2] = $0b)) then„      Gat := Pak„    else„      Gat := Unknown;„  end;„„  GetArcType := Gat;„end;„„Var„  FileName : String;„  Return   : ArcType;„  {ArcType = (FileError,Unknown,Zip,Zoo,Arc,Lzh,Pak,Arj)}„„„begin„ if ParamCount = 1 then„ begin„   FileName := ParamStr(1);„   Return   := GetArcType(FileName);„   Case Return of„     ARJ     : Writeln(FileName, ' = ARJ ');„     PAK     : Writeln(FileName, ' = PAK ');„     LZH     : Writeln(FileName, ' = LZH ');„     ARC     : Writeln(FileName, ' = ARC ');„     ZOO     : Writeln(FileName, ' = ZOO ');„     ZIP     : Writeln(FileName, ' = ZIP ');„     UNKNOWN : Writeln(FileName, ' = Unknown!')„     else„       Writeln('File Not Found');„   end;„ end {IF}„ else„  Writeln('No parameter');„end.„                                                                                                   2      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Display Archive Files    IMPORT              73     ÆQÿ{ {„   Hmmmm, I thought I responded to you on this before.  Whether I did or„not, I will post what I did before (in the next two messages), but I„don't want to post the entire Program - I'm building a ShareWare„progream I plan to market, and I don't think I should give it _all_„away.  The code I post is pertinent to reading the headers and Filename„info in the Various archive Types, and I Really think you can work out„the rest without much trouble.  If you can't, please post a specific„question...„}„„Const„      BSize    = 4096;                                      { I/O Buffer Size }„      HMax     = 512;                                   { Header Maximum Size }„Var„      I,J,K        : Integer;„      CT,RC,TC     : Integer;„      RES          : Word;                                   { Buffer Residue }„      N,P,Q        : LongInt;„      C            : LongInt;                                 { Buffer Offset }„      FSize        : LongInt;                                     { File Size }„      DEVICE       : Char;                                      { Disk Device }„      F            : File;„      SNAME        : String;„      DATE         : String[8];                  { formatted date as YY/MM/DD }„      TIME         : String[5];                  {     "     time as HH:MM    }„      DirInfo      : SearchRec;                       { File name search Type }„      SR           : SearchRec;                       { File name search Type }„      DT           : DateTime;„      PATH         : PathStr;„      DIR          : DirStr;„      FNAME        : NameStr;„      EXT          : ExtStr;„      Regs         : Registers;„      BUFF         : Array[1..BSize] of Byte;„„Procedure FDT (LI : LongInt);                       { Format Date/Time fields }„begin„  UnPackTime (LI,DT);„  DATE := FSI(DT.Month,2)+'/'+FSI(DT.Day,2)+'/'+Copy(FSI(DT.Year,4),3,2);„  if DATE[4] = ' ' then DATE[4] := '0';„  if DATE[7] = ' ' then DATE[7] := '0';„  TIME := FSI(DT.Hour,2)+':'+FSI(DT.Min,2);„  if TIME[4] = ' ' then TIME[4] := '0';„end;  { FDT }„„Procedure  MY_FFF;„Var I,J,K : LongInt;„„(**************************** ARJ Files Processing ***************************)„Type ARJHead = Record„                 FHeadSize : Byte;„                 ArcVer1,„                 ArcVer2   : Byte;„                 HostOS,„                 ARJFlags,„                 Method    : Byte;   { MethodType = (Stored, LZMost, LZFast); }„                 R1,R2     : Byte;„                 Dos_DT    : LongInt;„                 CompSize,„                 UCompSize,„                 CRC       : LongInt;„                 ENP, FM,„                 HostData  : Word;„               end;„Var ARJ1     : ARJHead;„    ARJId    : Word;                                     { 60000, if ARJ File }„    HSize    : Word;                                            { Header Size }„Procedure GET_ARJ_ENTRY;„begin„  FillChar(ARJ1,SizeOf(ARJHead),#0); FillChar(BUFF,BSize,#0);„  Seek (F,C-1); BlockRead(F,BUFF,BSIZE,RES);        { read header into buffer }„  Move (BUFF[1],ARJId,2);  Move (BUFF[3],HSize,2);„  if HSize > 0 then„    With ARJ1 do„      begin„        Move (BUFF[5],ARJ1,SizeOf(ARJHead));„        I := FHeadSize+5; SNAME := B40;„        While BUFF[I] > 0 do Inc (I);„        I := I-FHeadSize-5;„        Move (BUFF[FHeadSize+5],SNAME[1],I); SNAME[0] := Chr(I);„        FSize := CompSize; Inc (C,HSIZE);„      end;„end;  { GET_ARJ_ENTRY }„„Procedure DO_ARJ (FN : String);„begin„  Assign (F,FN); Reset (F,1); C := 1;„  GET_ARJ_ENTRY;                                            { Process File„Header }„  Repeat„    Inc(C,FSize+10);„    GET_ARJ_ENTRY;„    if HSize > 0 then„      begin„        Inc (WPX); New(SW[WPX]);       { store Filename info in dynamic Array }„        With SW[WPX]^ do„          begin„            FSplit (SNAME,DIR,FNAME,EXT); F := FNAME; E := Copy(EXT+'    ',1,4)„            SIZE := ARJ1.UCompSize;„            RType := 4; D_T := ARJ1.Dos_DT; ANUM := ADX; VNUM := VDX;„            ADD_CNAME;„          end;„        Inc (CCT); SSL; Inc (ARCS[ADX]^.COUNT)„      end;„  Until HSize <= 0;„  Close (F);„end;  { DO_ARJ }„„(**************************** ZIP Files Processing ***************************)„Type ZIPHead = Record„                 ExtVer : Word;„                 Flags  : Word;„                 Method : Word;„                 Fill1  : Word;„                 Dos_DT        : LongInt;„                 CRC32         : LongInt;„                 CompSize      : LongInt;„                 UCompSize     : LongInt;„                 FileNameLen   : Word;„                 ExtraFieldLen : Word;„               end;„Var ZIPCSize : LongInt;„    ZIPId    : Word;„    ZIP1     : ZIPHead;„Procedure GET_ZIP_ENTRY;„begin„  FillChar(ZIP1,SizeOf(ZIPHead),#0); Move (BUFF[C+1],ZIPId,2);„  if ZIPId > 0 then„    begin„      Move (BUFF[C+1],ZIP1,SizeOf(ZIPHead));„      Inc (C,43); SNAME := '';„      With ZIP1 do„        begin„          Move (BUFF[C],SNAME[1],FileNameLen); SNAME[0] := Chr(FileNameLen);„          FSize := CompSize;„        end;„    end;„end;  { GET_ZIP_ENTRY }„„Procedure DO_ZIP (FN : String);„Const CFHS : String[4] = 'PK'#01#02;          { CENTRAL_File_HEADER_SIGNATURE }„      ECDS : String[4] = 'PK'#05#06;        { end_CENTRAL_DIRECTORY_SIGNATURE }„Var S4     : String[4];„    FOUND  : Boolean;„    QUIT   : Boolean;                            { "end" sentinel encountered }„begin„--- GOMail v1.1 [DEMO] 03-09-93„ * Origin: The Private Reserve - Phoenix, AZ (602) 997-9323 (1:114/151)„<<<>>>„„„Date: 03-23-93 (22:30)              Number: 16806 of 16859 (Echo)„  To: EDDIE BRAITER                 Refer#: NONE„From: MIKE COPELAND                   Read: NO„Subj: FORMAT VIEWER - PART 2 of     Status: PUBLIC MESSAGE„Conf: F-PASCAL (1221)            Read Type: GENERAL (+)„„(**************************** ARC Files Processing ***************************)„Type ARCHead = Record„                 ARCMark   : Char;„                 ARCVer    : Byte;„                 FN        : Array[1..13] of Char;„                 CompSize  : LongInt;„                 Dos_DT    : LongInt;„                 CRC       : Word;„                 UCompSize : LongInt;„               end;„Const ARCFlag : Char = #26;                                        { ARC mark }„Var WLV   : LongInt;                               { Working LongInt Variable }„    ARC1  : ARCHead;„    QUIT  : Boolean;                             { "end" sentinel encountered }„„Procedure GET_ARC_ENTRY;„begin„  FillChar(ARC1,SizeOf(ARCHead),#0); L := SizeOf(ARCHead);„  Seek (F,C); BlockRead (F,BUFF,L,RES);„  Move (BUFF[1],ARC1,L);„  With ARC1 do„    if (ARCMark = ARCFlag) and (ARCVer > 0) then„      begin„        SNAME := ''; I := 1;„        While FN[I] <> #0 do„          begin„            SNAME := SNAME+FN[I]; Inc(I)„          end;„        WLV := (Dos_DT Shr 16)+(Dos_DT Shl 16);              { flip Date/Time }„        FSize := CompSize;„      end;„    QUIT := ARC1.ARCVer <= 0;„end;  { GET_ARC_ENTRY }„„Procedure DO_ARC (FN : String);„begin„  Assign (F,FN); Reset (F,1); C := 0;„  Repeat„    GET_ARC_ENTRY;„    if not QUIT then„      begin„        Inc (WPX); New(SW[WPX]);       { store Filename info in dynamic Array }„        With SW[WPX]^ do„          begin„            FSplit (SNAME,DIR,FNAME,EXT); F := FNAME; E := Copy(EXT+'    ',1,4)„            SIZE := ARC1.UCompSize; RType := 4;                   { comp File }„            D_T := WLV; ANUM := ADX; VNUM := VDX;„            ADD_CNAME;„          end;„        Inc (CCT); SSL; Inc (ARCS[ADX]^.COUNT)„      end;„    Inc (C,FSize+SizeOf(ARCHead))„  Until QUIT;„  Close (F);„end;  { DO_ARC }„„(************************* LZH Files Processing ******************************)„Type LZHHead = Record„                 HSize       : Byte;„                 Fill1       : Byte;„                 Method      : Array[1..5] of Char;„                 CompSize    : LongInt;„                 UCompSize   : LongInt;„                 Dos_DT      : LongInt;„                 Fill2       : Word;„                 FileNameLen : Byte;„                 FileName    : Array[1..12] of Char;„               end;„„Var LZH1     : LZHHead;„„Procedure GET_LZH_ENTRY;„begin„  FillChar(LZH1,SizeOf(LZHHead),#0); FillChar (DT,SizeOf(DT),#0);„  L := SizeOf(LZHHead);„  Seek (F,C); BlockRead (F,BUFF,L,RES);„  Move (BUFF[1],LZH1,L);„  With LZH1 do„    if HSize > 0 then„      begin„        Move (FileNameLen,SNAME,FileNameLen+1);„        UnPackTime (Dos_DT,DT);„        FSize := CompSize;„      end„    else QUIT := True„end;  { GET_LZH_ENTRY }„„Procedure DO_LZH (FN : String);„begin„  Assign (F,FN); Reset (F,1);„  FSize := FileSize(F); C := 0; QUIT := False;„  Repeat„    GET_LZH_ENTRY;„    if not QUIT then„      begin„        Inc (WPX); New(SW[WPX]);       { store Filename info in dynamic Array }„        With SW[WPX]^ do„          begin„            FSplit (SNAME,DIR,FNAME,EXT); F := FNAME; E := Copy(EXT+'    ',1,4)„            SIZE := LZH1.UCompSize;„            RType := 4; ANUM := ADX; VNUM := VDX; D_T := LZH1.Dos_DT;„            ADD_CNAME;„          end;„        Inc (CCT); SSL; Inc (ARCS[ADX]^.COUNT)„      end;„    Inc (C,FSize+LZH1.HSize+2)„  Until QUIT;„  Close (F);„end;  { DO_LZH }„                              3      05-28-9313:33ALL                      SWAG SUPPORT TEAM        String Compression       IMPORT              22     ÆQﬁÜ {You won't get that sort of compression from my routines, but here„they are anyway.  When testing, you'll get best compression if you„use English and longish Strings.„}„Unit Compress;„„Interface„„Const„  CompressedStringArraySize = 500;  { err on the side of generosity }„„Type„  tCompressedStringArray = Array[1..CompressedStringArraySize] of Byte;„„Function GetCompressedString(Arr : tCompressedStringArray) : String;„„Procedure CompressString(st : String; Var Arr : tCompressedStringArray;„                         Var len : Integer);„  { converts st into a tCompressedStringArray of length len }„„Implementation„„Const„  FreqChar : Array[4..14] of Char = 'etaonirshdl';„  { can't be in [0..3] because two empty bits signify a space }„„„Function GetCompressedString(Arr : tCompressedStringArray) : String;„Var„  Shift : Byte;„  i : Integer;„  ch : Char;„  st : String;„  b : Byte;„„  Function GetHalfNibble : Byte;„  begin„    GetHalfNibble := (Arr[i] shr Shift) and 3;„    if Shift = 0 then begin„      Shift := 6;„      inc(i);„    end else dec(Shift,2);„  end;„„begin„  st := '';„  i := 1;„  Shift := 6;„  Repeat„    b := GetHalfNibble;„    if b = 0 then„      ch := ' '„    else begin„      b := (b shl 2) or GetHalfNibble;„      if b = $F then begin„        b := GetHalfNibble shl 6;„        b := b or GetHalfNibble shl 4;„        b := b or GetHalfNibble shl 2;„        b := b or GetHalfNibble;„        ch := Char(b);„      end else„        ch := FreqChar[b];„    end;„    if ch <> #0 then st := st + ch;„  Until ch = #0;„  GetCompressedString := st;„end;„„Procedure CompressString(st : String; Var Arr : tCompressedStringArray;„                         Var len : Integer);„{ converts st into a tCompressedStringArray of length len }„Var„  i : Integer;„  Shift : Byte;„„  Procedure OutHalfNibble(b : Byte);„  begin„    Arr[len] := Arr[len] or (b shl Shift);„    if Shift = 0 then begin„      Shift := 6;„      inc(len);„    end else dec(Shift,2);„  end;„„  Procedure OutChar(ch : Char);„  Var„    i : Byte;„    bych : Byte Absolute ch;„  begin„    if ch = ' ' then„      OutHalfNibble(0)„    else begin„      i := 4;„      While (i<15) and (FreqChar[i]<>ch) do inc(i);„      OutHalfNibble(i shr 2);„      OutHalfNibble(i and 3);„      if i = $F then begin„        OutHalfNibble(bych shr 6);„        OutHalfNibble((bych shr 4) and 3);„        OutHalfNibble((bych shr 2) and 3);„        OutHalfNibble(bych and 3);„      end;„    end;„  end;„„begin„  len := 1;„  Shift := 6;„  fillChar(Arr,sizeof(Arr),0);„  For i := 1 to length(st) do OutChar(st[i]);„  OutChar(#0);  { end of compressed String signaled by #0 }„  if Shift = 6„    then dec(len);„end;„„end.„                          4      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Code for LZH.PAS         IMPORT              167    ÆQ=G „Unit LZH;„„ {$A+,B-,D-,E-,F-,I+,L-,N-,O-,R-,S-,V-}„„(*„ * LZHUF.C English version 1.0„ * Based on Japanese version 29-NOV-1988„ * LZSS coded by Haruhiko OKUMURA„ * Adaptive Huffman Coding coded by Haruyasu YOSHIZAKI„ * Edited and translated to English by Kenji RIKITAKE„ * Translated from C to Turbo Pascal by Douglas Webb   2/18/91„ *    Update and bug correction of TP version 4/29/91 (Sorry!!)„ *)„„{„     This Unit allows the user to commpress data using a combination of„   LZSS Compression and adaptive Huffman coding, or conversely to deCompress„   data that was previously Compressed by this Unit.„„     There are a number of options as to where the data being Compressed/„   deCompressed is coming from/going to.„„    In fact it requires that you pass the "LZHPack" Procedure 2 procedural„  parameter of Type 'GetProcType' and 'PutProcType' (declared below) which„  will accept 3 parameters and act in every way like a 'BlockRead'/'BlockWrite'„  Procedure call. Your 'GetProcType' Procedure should return the data„  to be Compressed, and Your 'PutProcType' Procedure should do something with„  the Compressed data (ie., put it in a File).  In Case you need to know (and„  you do if you want to deCompress this data again) the number of Bytes in the„  Compressed data (original, not Compressed size) is returned in 'Bytes_Written'.„„  GetBytesProc = Procedure(Var DTA; NBytes:Word; Var Bytes_Got : Word);„  „  DTA is the start of a memory location where the inFormation returned should„  be.  NBytes is the number of Bytes requested.  The actual number of Bytes„  returned must be passed in Bytes_Got (if there is no more data then 0„  should be returned).„„  PutBytesProc = Procedure(Var DTA; NBytes:Word; Var Bytes_Got : Word);„„  As above except instead of asking For data the Procedure is dumping out„  Compressed data, do somthing With it.„„„    "LZHUnPack" is basically the same thing in reverse.  It requires„  procedural parameters of Type 'PutProcType'/'GetProcType' which„  will act as above.  'GetProcType' must retrieve data Compressed using„  "LZHPack" (above) and feed it to the unpacking routine as requested.„  'PutProcType' must accept the deCompressed data and do something„  withit.  You must also pass in the original size of the deCompressed data,„  failure to do so will have adverse results.„„„     Don't Forget that as procedural parameters the 'GetProcType'/'PutProcType'„  Procedures must be Compiled in the 'F+' state to avoid a catastrophe.„„„„}„„{ note: All the large data structures For these routines are allocated when„  needed from the heap, and deallocated when finished.  So when not in use„  memory requirements are minimal.  However, this Unit Uses about 34K of„  heap space, and 400 Bytes of stack when in use. }„„„Interface„„Type„„„  PutBytesProc = Procedure(Var DTA; NBytes : Word; Var Bytes_Put : Word);„  GetBytesProc = Procedure(Var DTA; NBytes : Word; Var Bytes_Got : Word);„„„„Procedure LZHPack(Var Bytes_Written : LongInt;„                      GetBytes : GetBytesProc;„                      PutBytes : PutBytesProc);„„„Procedure LZHUnpack(TextSize : LongInt;„                    GetBytes : GetBytesProc;„                    PutBytes : PutBytesProc);„„„Implementation„„Const„  Exit_OK = 0;„  Exit_FAILED = 1;„„  { LZSS Parameters }„  N = 4096;                            { Size of String buffer }„  F = 60;                              { Size of look-ahead buffer }„  THRESHOLD = 2;„  NUL = N;                             { end of tree's node  }„„  { Huffman coding parameters }„  N_Char = (256 - THRESHOLD + F);„„  { Character code (:= 0..N_Char-1) }„  T = (N_Char * 2 - 1);                { Size of table }„  R = (T - 1);                         { root position }„„  { update when cumulative frequency }„  { reaches to this value }„  MAX_FREQ = $8000;„„{„ * Tables For encoding/decoding upper 6 bits of„ * sliding dictionary Pointer„ }„„  { encoder table }„  p_len : Array[0..63] of Byte =„  ($03, $04, $04, $04, $05, $05, $05, $05,„   $05, $05, $05, $05, $06, $06, $06, $06,„   $06, $06, $06, $06, $06, $06, $06, $06,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $08, $08, $08, $08, $08, $08, $08, $08,„   $08, $08, $08, $08, $08, $08, $08, $08);„„  p_code : Array[0..63] of Byte =„  ($00, $20, $30, $40, $50, $58, $60, $68,„   $70, $78, $80, $88, $90, $94, $98, $9C,„   $A0, $A4, $A8, $AC, $B0, $B4, $B8, $BC,„   $C0, $C2, $C4, $C6, $C8, $CA, $CC, $CE,„   $D0, $D2, $D4, $D6, $D8, $DA, $DC, $DE,„   $E0, $E2, $E4, $E6, $E8, $EA, $EC, $EE,„   $F0, $F1, $F2, $F3, $F4, $F5, $F6, $F7,„   $F8, $F9, $FA, $FB, $FC, $FD, $FE, $FF);„„  { decoder table }„  d_code : Array[0..255] of Byte =„  ($00, $00, $00, $00, $00, $00, $00, $00,„   $00, $00, $00, $00, $00, $00, $00, $00,„   $00, $00, $00, $00, $00, $00, $00, $00,„   $00, $00, $00, $00, $00, $00, $00, $00,„   $01, $01, $01, $01, $01, $01, $01, $01,„   $01, $01, $01, $01, $01, $01, $01, $01,„   $02, $02, $02, $02, $02, $02, $02, $02,„   $02, $02, $02, $02, $02, $02, $02, $02,„   $03, $03, $03, $03, $03, $03, $03, $03,„   $03, $03, $03, $03, $03, $03, $03, $03,„   $04, $04, $04, $04, $04, $04, $04, $04,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $06, $06, $06, $06, $06, $06, $06, $06,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $08, $08, $08, $08, $08, $08, $08, $08,„   $09, $09, $09, $09, $09, $09, $09, $09,„   $0A, $0A, $0A, $0A, $0A, $0A, $0A, $0A,„   $0B, $0B, $0B, $0B, $0B, $0B, $0B, $0B,„   $0C, $0C, $0C, $0C, $0D, $0D, $0D, $0D,„   $0E, $0E, $0E, $0E, $0F, $0F, $0F, $0F,„   $10, $10, $10, $10, $11, $11, $11, $11,„   $12, $12, $12, $12, $13, $13, $13, $13,„   $14, $14, $14, $14, $15, $15, $15, $15,„   $16, $16, $16, $16, $17, $17, $17, $17,„   $18, $18, $19, $19, $1A, $1A, $1B, $1B,„   $1C, $1C, $1D, $1D, $1E, $1E, $1F, $1F,„   $20, $20, $21, $21, $22, $22, $23, $23,„   $24, $24, $25, $25, $26, $26, $27, $27,„   $28, $28, $29, $29, $2A, $2A, $2B, $2B,„   $2C, $2C, $2D, $2D, $2E, $2E, $2F, $2F,„   $30, $31, $32, $33, $34, $35, $36, $37,„   $38, $39, $3A, $3B, $3C, $3D, $3E, $3F);„„  d_len : Array[0..255] of Byte =„  ($03, $03, $03, $03, $03, $03, $03, $03,„   $03, $03, $03, $03, $03, $03, $03, $03,„   $03, $03, $03, $03, $03, $03, $03, $03,„   $03, $03, $03, $03, $03, $03, $03, $03,„   $04, $04, $04, $04, $04, $04, $04, $04,„   $04, $04, $04, $04, $04, $04, $04, $04,„   $04, $04, $04, $04, $04, $04, $04, $04,„   $04, $04, $04, $04, $04, $04, $04, $04,„   $04, $04, $04, $04, $04, $04, $04, $04,„   $04, $04, $04, $04, $04, $04, $04, $04,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $05, $05, $05, $05, $05, $05, $05, $05,„   $06, $06, $06, $06, $06, $06, $06, $06,„   $06, $06, $06, $06, $06, $06, $06, $06,„   $06, $06, $06, $06, $06, $06, $06, $06,„   $06, $06, $06, $06, $06, $06, $06, $06,„   $06, $06, $06, $06, $06, $06, $06, $06,„   $06, $06, $06, $06, $06, $06, $06, $06,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $07, $07, $07, $07, $07, $07, $07, $07,„   $08, $08, $08, $08, $08, $08, $08, $08,„   $08, $08, $08, $08, $08, $08, $08, $08);„„  getbuf : Word = 0;„  getlen : Byte = 0;„  putlen : Byte = 0;„  putbuf : Word = 0;„  TextSize : LongInt = 0;„  codesize : LongInt = 0;„  printcount : LongInt = 0;„  match_position : Integer = 0;„  match_length : Integer = 0;„„„Type„  FreqType = Array[0..T] of Word; „  FreqPtr = ^FreqType;„  PntrType = Array[0..pred(T + N_Char)] of Integer;„  pntrPtr = ^PntrType;„  SonType = Array[0..pred(T)] of Integer;„  SonPtr = ^SonType;„  TextBufType = Array[0..N + F - 2] of Byte;„  TBufPtr = ^TextBufType;„  WordRay = Array[0..N] of Integer;„  WordRayPtr = ^WordRay;„  BWordRay = Array[0..N + 256] of Integer;„  BWordRayPtr = ^BWordRay;„„Var„  Text_buf : TBufPtr;„  lson, dad : WordRayPtr;„  rson : BWordRayPtr;„  freq : FreqPtr;                      { cumulative freq table }„„{„ * pointing parent nodes.„ * area [T..(T + N_Char - 1)] are Pointers For leaves„ }„  prnt : pntrPtr;„„  { pointing children nodes (son[], son[] + 1)}„  son : SonPtr;„„„  Procedure InitTree;                  { Initializing tree }„  Var„    i : Integer;„  begin„    For i := N + 1 to N + 256 do„      rson^[i] := NUL;                 { root }„    For i := 0 to N do„      dad^[i] := NUL;                  { node }„  end;„„„  Procedure InsertNode(R : Integer);   { Inserting node to the tree }„  Var„    tmp, i, p, cmp : Integer;„    key : TBufPtr;„    c : Word;„  begin„    cmp := 1;„    key := @Text_buf^[R];„    p := succ(N) + key^[0];„    rson^[R] := NUL;„    lson^[R] := NUL;„    match_length := 0;„    While match_length < F do„      begin„        if (cmp >= 0) then„          begin„            if (rson^[p] <> NUL) then„              p := rson^[p]„            else„              begin„                rson^[p] := R;„                dad^[R] := p;„                Exit;„              end;„          end„        else„          begin„            if (lson^[p] <> NUL) then„              p := lson^[p]„            else„              begin„                lson^[p] := R;„                dad^[R] := p;„                Exit;„              end;„          end;„        i := 0;„        cmp := 0;„        While (i < F) and (cmp = 0) do„          begin„            inc(i);„            cmp := key^[i] - Text_buf^[p + i];„          end;„        if (i > THRESHOLD) then„          begin„            tmp := pred((R - p) and pred(N));„            if (i > match_length) then„              begin„                match_position := tmp;„                match_length := i;„              end;„            if (match_length < F) and (i = match_length) then„              begin„                c := tmp;„                if (c < match_position) then„                  match_position := c;„              end;„          end;„      end;                             { While True do }„    dad^[R] := dad^[p];„    lson^[R] := lson^[p];„    rson^[R] := rson^[p];„    dad^[lson^[p]] := R;„    dad^[rson^[p]] := R;„    if (rson^[dad^[p]] = p) then„      rson^[dad^[p]] := R„    else„      lson^[dad^[p]] := R;„    dad^[p] := NUL;                    { remove p }„  end;„„„  Procedure DeleteNode(p : Integer);   { Deleting node from the tree }„  Var„    q : Integer;„  begin„    if (dad^[p] = NUL) then„      Exit;                            { unregistered }„    if (rson^[p] = NUL) then„      q := lson^[p]„    else if (lson^[p] = NUL) then„      q := rson^[p]„    else„      begin„        q := lson^[p];„        if (rson^[q] <> NUL) then„          begin„            Repeat„              q := rson^[q];„            Until (rson^[q] = NUL);„            rson^[dad^[q]] := lson^[q];„            dad^[lson^[q]] := dad^[q];„            lson^[q] := lson^[p];„            dad^[lson^[p]] := q;„          end;„        rson^[q] := rson^[p];„        dad^[rson^[p]] := q;„      end;„    dad^[q] := dad^[p];„    if (rson^[dad^[p]] = p) then„      rson^[dad^[p]] := q„    else„      lson^[dad^[p]] := q;„    dad^[p] := NUL;„  end;„„  { Huffman coding parameters }„„  Function GetBit(GetBytes : GetBytesProc) : Integer; { get one bit }„  Var„    i : Byte;„    i2 : Integer;„    result : Word;„  begin„    While (getlen <= 8) do„      begin„        GetBytes(i, 1, result);„        if result = 1 then„          i2 := i„        else i2 := 0;„        getbuf := getbuf or (i2 shl (8 - getlen));„        inc(getlen, 8);„      end;„    i2 := getbuf;„    getbuf := getbuf shl 1;„    dec(getlen);„    GetBit := Integer((i2 < 0));„  end;„„„  Function GetByte(GetBytes : GetBytesProc) : Integer; { get a Byte }„  Var„    j : Byte;„    i, result : Word;„  begin„    While (getlen <= 8) do„      begin„        GetBytes(j, 1, result);„        if result = 1 then„          i := j„        else„          i := 0;„        getbuf := getbuf or (i shl (8 - getlen));„        inc(getlen, 8);„      end;„    i := getbuf;„    getbuf := getbuf shl 8;„    dec(getlen, 8);„    GetByte := Integer(i shr 8);„  end;„„„  Procedure Putcode(l : Integer; c : Word;„                    PutBytes : PutBytesProc); { output c bits }„  Var„    Temp : Byte;„    Got : Word;„  begin„    putbuf := putbuf or (c shr putlen);„    inc(putlen, l);„    if (putlen >= 8) then„      begin„        Temp := putbuf shr 8;„        PutBytes(Temp, 1, Got);„        dec(putlen, 8);„        if (putlen >= 8) then„          begin„            Temp := lo(putbuf);„            PutBytes(Temp, 1, Got);„            inc(codesize, 2);„            dec(putlen, 8);„            putbuf := c shl (l - putlen);„          end„        else„          begin„            putbuf := putbuf shl 8;„            inc(codesize);„          end;„      end;„  end;„„„  { initialize freq tree }„„  Procedure StartHuff;„  Var„    i, j : Integer;„  begin„    For i := 0 to pred(N_Char) do„      begin„        freq^[i] := 1;„        son^[i] := i + T;„        prnt^[i + T] := i;„      end;„    i := 0;„    j := N_Char;„    While (j <= R) do„      begin„        freq^[j] := freq^[i] + freq^[i + 1];„        son^[j] := i;„        prnt^[i] := j;„        prnt^[i + 1] := j;„        inc(i, 2);„        inc(j);„      end;„    freq^[T] := $ffff;„    prnt^[R] := 0;„  end;„„„  { reConstruct freq tree }„„  Procedure reConst;„  Var„    i, j, k, tmp : Integer;„    F, l : Word;„  begin„    { halven cumulative freq For leaf nodes }„    j := 0;„    For i := 0 to pred(T) do„      begin„        if (son^[i] >= T) then„          begin„            freq^[j] := succ(freq^[i]) div 2; {@@ Bug Fix MOD -> div @@}„            son^[j] := son^[i];„            inc(j);„          end;„      end;„    { make a tree : first, connect children nodes }„    i := 0;„    j := N_Char;„    While (j < T) do„      begin„        k := succ(i);„        F := freq^[i] + freq^[k];„        freq^[j] := F;„        k := pred(j);„        While F < freq^[k] do„          dec(k);„        inc(k);„        l := (j - k) shl 1;„        tmp := succ(k);„        move(freq^[k], freq^[tmp], l);„        freq^[k] := F;„        move(son^[k], son^[tmp], l);„        son^[k] := i;„        inc(i, 2);„        inc(j);„      end;„    { connect parent nodes }„    For i := 0 to pred(T) do„      begin„        k := son^[i];„        if (k >= T) then„          begin„            prnt^[k] := i;„          end„        else„          begin„            prnt^[k] := i;„            prnt^[succ(k)] := i;„          end;„      end;„  end;„„„  { update freq tree }„„  Procedure update(c : Integer);„  Var„    i, j, k, l : Integer;„  begin„    if (freq^[R] = MAX_FREQ) then„      begin„        reConst;„      end;„    c := prnt^[c + T];„    Repeat„      inc(freq^[c]);„      k := freq^[c];„      { swap nodes to keep the tree freq-ordered }„      l := succ(c);„      if (k > freq^[l]) then„        begin„          While (k > freq^[l]) do„            inc(l);„          dec(l);„          freq^[c] := freq^[l];„          freq^[l] := k;„          i := son^[c];„          prnt^[i] := l;„          if (i < T) then prnt^[succ(i)] := l;„          j := son^[l];„          son^[l] := i;„          prnt^[j] := c;„          if (j < T) then prnt^[succ(j)] := c;„          son^[c] := j;„          c := l;„        end;„      c := prnt^[c];„    Until (c = 0);                     { Repeat it Until reaching the root }„  end;„„„Var„  code, len : Word;„„  Procedure EncodeChar(c : Word; PutBytes : PutBytesProc);„  Var„    i : Word;„    j, k : Integer;„  begin„    i := 0;„    j := 0;„    k := prnt^[c + T];„    { search connections from leaf node to the root }„    Repeat„      i := i shr 1;„ {„	if node's address is odd, output 1„	else output 0„	}„      if Boolean(k and 1) then inc(i, $8000);„      inc(j);„      k := prnt^[k];„    Until (k = R);„    Putcode(j, i, PutBytes);„    code := i;„    len := j;„    update(c);„  end;„„„  Procedure EncodePosition(c : Word; PutBytes : PutBytesProc);„  Var„    i, j : Word;„  begin„    { output upper 6 bits With encoding }„    i := c shr 6;„    j := p_code[i];„    Putcode(p_len[i], j shl 8, PutBytes);„    { output lower 6 bits directly }„    Putcode(6, (c and $3f) shl 10, PutBytes);„  end;„„„  Procedure Encodeend(PutBytes : PutBytesProc);„  Var„    Temp : Byte;„    Got : Word;„  begin„    if Boolean(putlen) then„      begin„        Temp := lo(putbuf shr 8);„        PutBytes(Temp, 1, Got);„        inc(codesize);„      end;„  end;„„„  Function DecodeChar(GetBytes : GetBytesProc) : Integer;„  Var„    c : Word;„  begin„    c := son^[R];„    {„     * start searching tree from the root to leaves.„     * choose node #(son[]) if input bit = 0„     * else choose #(son[]+1) (input bit = 1)„    }„    While (c < T) do„      begin„        c := c + GetBit(GetBytes);„        c := son^[c];„      end;„    c := c - T;„    update(c);„    DecodeChar := Integer(c);„  end;„„„  Function DecodePosition(GetBytes : GetBytesProc) : Word;„  Var„    i, j, c : Word;„  begin„    { decode upper 6 bits from given table }„    i := GetByte(GetBytes);„    c := Word(d_code[i] shl 6);„    j := d_len[i];„    { input lower 6 bits directly }„    dec(j, 2);„    While j <> 0 do„      begin„        i := (i shl 1) + GetBit(GetBytes);„        dec(j);„      end;„    DecodePosition := c or i and $3f;„  end;„„„  { Compression }„„  Procedure InitLZH;„  begin„    getbuf := 0;„    getlen := 0;„    putlen := 0;„    putbuf := 0;„    TextSize := 0;„    codesize := 0;„    printcount := 0;„    match_position := 0;„    match_length := 0;„    new(lson);„    new(dad);„    new(rson);„    new(Text_buf);„    new(freq);„    new(prnt);„    new(son);„  end;„„„  Procedure endLZH;„  begin„    dispose(son);„    dispose(prnt);„    dispose(freq);„    dispose(Text_buf);„    dispose(rson);„    dispose(dad);„    dispose(lson);„  end;„„„  Procedure LZHPack(Var Bytes_Written : LongInt;„                        GetBytes : GetBytesProc;„                        PutBytes : PutBytesProc);„  Var„    ct : Byte;„    i, len, R, s, last_match_length : Integer;„    Got : Word;„  begin„    InitLZH;„    TextSize := 0;                     { rewind and rescan }„    StartHuff;„    InitTree;„    s := 0;„    R := N - F;„    fillChar(Text_buf^[0], R, ' ');„    len := 0;„    Got := 1;„    While (len < F) and (Got <> 0) do„      begin„        GetBytes(ct, 1, Got);„        if Got <> 0 then„          begin„            Text_buf^[R + len] := ct;„            inc(len);„          end;„      end;„    TextSize := len;„    For i := 1 to F do„      InsertNode(R - i);„    InsertNode(R);„    Repeat„      if (match_length > len) then„        match_length := len;„      if (match_length <= THRESHOLD) then„        begin„          match_length := 1;„          EncodeChar(Text_buf^[R], PutBytes);„        end„      else„        begin„          EncodeChar(255 - THRESHOLD + match_length, PutBytes);„          EncodePosition(match_position, PutBytes);„        end;„      last_match_length := match_length;„      i := 0;„      Got := 1;„      While (i < last_match_length) and (Got <> 0) do„        begin„          GetBytes(ct, 1, Got);„          if Got <> 0 then„            begin„              DeleteNode(s);„              Text_buf^[s] := ct;„              if (s < pred(F)) then„                Text_buf^[s + N] := ct;„              s := succ(s) and pred(N);„              R := succ(R) and pred(N);„              InsertNode(R);„              inc(i);„            end;„        end;„      inc(TextSize, i);„      While (i < last_match_length) do„        begin„          inc(i);„          DeleteNode(s);„          s := succ(s) and pred(N);„          R := succ(R) and pred(N);„          dec(len);„          if Boolean(len) then InsertNode(R);„        end;„    Until (len <= 0);„    Encodeend(PutBytes);„    endLZH;„    Bytes_Written := TextSize;„  end;„„„  Procedure LZHUnpack(TextSize : LongInt;„                      GetBytes : GetBytesProc;„                      PutBytes : PutBytesProc);„  Var„    c, i, j, k, R : Integer;„    c2, a : Byte;„    count : LongInt;„    Put : Word;„  begin„    InitLZH;„    StartHuff;„    R := N - F;„    fillChar(Text_buf^[0], R, ' ');„    count := 0;„    While count < TextSize do„      begin„        c := DecodeChar(GetBytes);„        if (c < 256) then„          begin„            c2 := lo(c);„            PutBytes(c2, 1, Put);„            Text_buf^[R] := c;„            inc(R);„            R := R and pred(N);„            inc(count);„          end„        else„          begin„            i := (R - succ(DecodePosition(GetBytes))) and pred(N);„            j := c - 255 + THRESHOLD;„            For k := 0 to pred(j) do„              begin„                c := Text_buf^[(i + k) and pred(N)];„                c2 := lo(c);„                PutBytes(c2, 1, Put);„                Text_buf^[R] := c;„                inc(R);„                R := R and pred(N);„                inc(count);„              end;„          end;„      end;„    endLZH;„  end;„„„end.„„                                                                                                                            5      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Test for LZH Code        IMPORT              22     ÆQ– „Program LZHTest;„Uses„  LZH;„„Const„  MaxBuf = 4096;                       { Must be bigger than the biggest chunk being asked For. }„„Type„  BufType = Array[1..MaxBuf] of Byte;„  BufPtr = ^BufType;„„Var„  InBuf, OutBuf : BufPtr;„  inFile, OutFile : File;„  s : String;„  Bytes_Written : LongInt;„  Size : LongInt;„  Temp : Word;„„„  {$F+}„  Procedure GetBlock(Var Target; NoBytes : Word; Var Actual_Bytes : Word);„  Const„    Posn : Word = 1;„    Buf : Word = 0;„  Var„    Temp : Word;„  begin„    if (Posn > Buf) or (Posn + NoBytes > succ(Buf)) then„      begin„        if Posn > Buf then„          begin„            blockread(inFile, InBuf^, MaxBuf, Buf);„            Write('+');„          end„        else„          begin„            move(InBuf^[Posn], InBuf^[1], Buf - Posn);„            blockread(inFile, InBuf^[Buf - Posn], MaxBuf - (Buf - Posn), Temp);„            Buf := Buf - Posn + Temp;„            Write('+');„          end;„        if Buf = 0 then„          begin„            Actual_Bytes := 0;„            Writeln;„            Exit;„          end;„        Posn := 1;„      end;„    move(InBuf^[Posn], Target, NoBytes);„    inc(Posn, NoBytes);„    if Posn > succ(Buf) then„      Actual_Bytes := NoBytes - (Posn - succ(Buf))„    else Actual_Bytes := NoBytes;„  end;„„„  Procedure PutBlock(Var Source; NoBytes : Word; Var Actual_Bytes : Word);„  Const„    Posn : Word = 1;„  Var„    Temp : Word;„  begin„    if NoBytes = 0 then                { Flush condition }„      begin„        blockWrite(OutFile, OutBuf^, pred(Posn), Temp);„        Exit;„      end;„    if (Posn > MaxBuf) or (Posn + NoBytes > succ(MaxBuf)) then„      begin„        blockWrite(OutFile, OutBuf^, pred(Posn), Temp);„        Posn := 1;„      end;„    move(Source, OutBuf^[Posn], NoBytes);„    inc(Posn, NoBytes);„    Actual_Bytes := NoBytes;„  end;„„  {$F-}„„begin„  if (paramcount <> 3) then„    begin„      Writeln('Usage:lzhuf e(Compression)|d(unCompression) inFile outFile');„      halt(1);„    end;„  s := paramstr(1);„  if not(s[1] in ['D', 'E', 'd', 'e']) then„    halt(1);„  assign(inFile, paramstr(2));„  reset(inFile, 1);„  assign(OutFile, paramstr(3));„  reWrite(OutFile, 1);„  new(InBuf);„  new(OutBuf);„  if (upCase(s[1]) = 'E') then„    begin„      Size := Filesize(inFile);„      blockWrite(OutFile, Size, sizeof(LongInt));„      LZHPack(Bytes_Written, GetBlock, PutBlock);„      PutBlock(Size, 0, Temp);„    end„  else„    begin„      blockread(inFile, Size, sizeof(LongInt));„      LZHUnPack(Size, GetBlock, PutBlock);„      PutBlock(Size, 0, Temp);„    end;„  dispose(OutBuf);„  dispose(InBuf);„  close(inFile);„  close(OutFile);„end.„„                                                   6      05-28-9313:33ALL                      SWAG SUPPORT TEAM        View LZH File            IMPORT              33     ÆQñ Program lzhview;„„Uses„  Dos, Crt;„„Const„  BSize = 4096;                                  { I/O Buffer Size }„„Type LZHHead = Record„                 HSize      : Byte;„                 Fill1      : Byte;„                 Method     : Array[1..5] of Char;„                 CompSize   : LongInt;„                 UCompSize  : LongInt;„                 Dos_DT     : LongInt;„                 Fill2      : Word;„                 FileNameLen: Byte;„                 FileName   : Array[1..12] of Char;„               end;„„Var LZH1       : LZHHead;„    DT         : DateTime;„    FSize,L,C  : LongInt;„    F          : File;„    BUFF       : Array[1..BSize] of Byte;„    DATE       : String[8];                { formatted date as YY/MM/DD }„    TIME       : String[6];                {     "     time as HH:MM }„    RES        : Word;„    DIR        : DirStr;„    FNAME      : NameStr;„    EXT        : ExtStr;„    LZHString,„    SName      : String;„    QUIT       : Boolean;„    SW         : Pointer;„„Function upper(st:String):String;„Var i : Integer;„begin„  For i := 1 to length(st) do st[i] :=upcase(st[i]);„  upper := st;„end;„„Function ord_to_str(i:LongInt;j:Byte):String;„Var c:String;„begin„  str(i,c);„  While length(c)<j do c:=' '+c;„  ord_to_str:=c;„end;„„Procedure FDT(LI:LongInt); { Format Date/Time (time With AM PM) fields }„Var t_ext : String;„begin„  UnPackTime (LI,DT);„  DATE := ord_to_str(DT.Month,2)+'/'+ord_to_str(DT.Day,2)+'/'„         +ord_to_str(DT.Year mod 100,2);„  if DATE[1] = ' ' then DATE[1] := '0';„  if DATE[4] = ' ' then DATE[4] := '0';„  if DATE[7] = ' ' then DATE[7] := '0';„  if DT.Hour in [0..11] then t_ext:='a' else t_ext:='p';„  if DT.Hour in [13..24] then Dec(DT.Hour,12);„  TIME := ord_to_str(DT.Hour,2)+':'+ord_to_str(DT.Min,2);„  if TIME[1] = ' ' then TIME[1] := '0';„  if TIME[4] = ' ' then TIME[4] := '0';„  TIME:=TIME+t_ext;„end;  { FDT }„„Procedure GET_LZH_ENTRY;„begin„  FillChar(LZH1,SizeOf(LZHHead),#0);„  FillChar (DT,SizeOf(DT),#0);„  L := SizeOf(LZHHead);„  Seek (F,C); BlockRead (F,BUFF,L,RES);„  Move (BUFF[1],LZH1,L);„  With LZH1 do„    if HSize > 0 then„      begin„        Move (FileNameLen,SNAME,FileNameLen+1);„        UnPackTime (Dos_DT,DT);„        FSize := CompSize„      end„    else QUIT := True„end;  { GET_LZH_ENTRY }„„Procedure DO_LZH (FN : String);„Var fnstr, LZHMeth : String;„    fls,totu,totc : LongInt;„begin„  totu:=0; totc:=0; fls:=0;„  Assign (F,FN);„  {$I-} Reset (F,1); {$I+}„  if Ioresult<>0 then„    begin„      Writeln(upper(FN)+' not found');„      Exit;„    end;„  FSize := FileSize(F);„  C := 0;„  QUIT := False;„  Writeln('LZH File : '+upper(FN));„  Writeln;„  Writeln('  Filename    OrigSize  CompSize   Method     Date  '„  +'   Time');„  Writeln('------------  --------  --------  --------  --------'„  +'  ------');„  Repeat„    GET_LZH_ENTRY;„    if not QUIT then„      begin„        FSplit (SNAME,DIR,FNAME,EXT);„        fnstr:=FNAME+EXT;„        While length(fnstr)<12 do insert(' ',fnstr,length(fnstr)+1);„        FDT(LZH1.Dos_DT);„        inc(totu,lzh1.ucompsize);„        inc(totc,lzh1.compsize);„        inc(fls,1);„        Case LZH1.Method[4] of       {normally only 0,1 or 5}„          '0' : LZHMeth:='Stored  ';„          '1' : LZHMeth:='Frozen 1';„          '2' : LZHMeth:='Frozen 2';„          '3' : LZHMeth:='Frozen 3';„          '4' : LZHMeth:='Frozen 4';„          '5' : LZHMeth:='Frozen 5';„        else LZHMeth:=' Unknown';„        end;„        LZHString:=Fnstr+'  '+ord_to_str(LZH1.UCompsize,8)+'  '+„                   ord_to_str(LZH1.Compsize,8)+'  '+lzhmeth+'  '„                   +DATE+'  '+TIME;„        Writeln(LZHString);„      end;„    Inc (C,FSize+LZH1.HSize+2)„  Until QUIT;„  Close (F);„  Writeln('------------  --------  --------  --------  --------'„  +'  -----');„  Writeln(ord_to_str(fls,5)+' Files   '+ord_to_str(totu,8)+'  '„  +ord_to_str(totc,8));„end;  { DO_LZH }„„begin„  ClrScr;„  do_lzh('whatever.lzh');  { <-- place Filename here }„end.„„{„Note the changes in the date processing and compression method display.„Thanks again For the code.„}                         7      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Testing for PKLITE File  IMPORT              10     ÆQ\> {„ > Your approach (as all similar ones I have seen so Far) has a major„ > drawback: you can't use PKLITE, TinYPROG, LZEXE afterwards to„ > squeeze them down in size, as the offsets of the Program change.„ > Has anyone come up With a another approach circumventing this?„„Yes, you can store it at the end of the .EXE File ( after the„code ) With the following routine :„}„„Function CodeLenOnDisk( FName : String ) : LongInt;„Var ImageInfo : Record„                  ExeID     : Array[ 0..1 ] of Char;„                  Remainder : Word;„                  Size : Word„                end;„    F        : File;„begin„  Assign( F, FName );„  Reset( F, 1 );„  if Ioresult <> 0 then Exit;„  BlockRead( F, ImageInfo, Sizeof( ImageInfo ));„  if ImageInfo.ExeID <> 'MZ' then Exit;„  CodeLenOnDisk := LongInt( ImageInfo.size-1 )*512 + ImageInfo.Remainder;„end;„„{„With this one, you can determine the end of the code in your .EXE File,„and then Write other data there, Drawback : This Dosen't work in network„environments or With shared .EXE Files. I'd recommend an external passWord„File, and there storing a hash of the passWord.„}„                           8      05-28-9313:33ALL                      SWAG SUPPORT TEAM        SHOW ARJ Archive Files   IMPORT              15     ÆQ– „Program ReadArj;„Uses„ Crt,„ Search;„„Const„  ArjID = #96#234;„„Type„  Array10 = Array[1..10] of Byte;„  Array12 = Array[1..12] of Char;„„  AFileRec = Record„               FileDate       : LongInt;„               CompressedSize : LongInt;„               originalSize   : LongInt;„               DudSpace       : Array10;„               FileName       : Array12„             end;„„  Array60K = Array[1..61440] of Byte;„„Var„  Buffer : Array60K;„„  ArjFileRec : AFileRec;„„  ArjFileSize,„  ArjRecStart,„  ArjRecStop,„  Index,„  Index1 : LongInt;„„  ArjFile : File;„„begin„  ClrScr;„  fillChar(Buffer, sizeof(Buffer), 0);„  fillChar(ArjFileRec, sizeof(ArjFileRec), 0);„  ArjFileSize := 0;„  ArjRecStart := 1;„  ArjRecStop := 0;„  assign(ArjFile, 'TEST.ARJ');„  {$I-}„  reset(ArjFile, 1);„  {$I+}„  if (ioresult <> 0) then„    begin„      Writeln(' ERRor OPENinG TEST.ARJ');„      halt(255)„    end;„  ArjFileSize := Filesize(ArjFile);„  Index := ArjFileSize - 50;„  blockread(ArjFile, Buffer, Index);„  close(ArjFile);„  Index1 := 50;„  ArjFileRec.Filename := '            ';„  While ((Index1 + 33) < ArjFileSize) do„    begin„      ArjRecStart := StrPos(Buffer[Index1], Index, ArjID) + 11;„      ArjRecStop := StrPos(Buffer[Index1 + ArjRecStart + 22], 13, #0);„      move(Buffer[ArjRecStart + Index1], ArjFileRec, (ArjRecStop + 21));„      With ArjFileRec do„        begin„          Writeln(' ',FileName, '  Compressed size = ', CompressedSize:6,„                    '  original size = ', originalSize:6);„          FileName := '            ';„          inc(Index1, CompressedSize + ArjRecStop + ArjRecStart);„          dec(Index, CompressedSize + ArjRecStop + ArjRecStart)„        end„    end„end.„„                                                                                            9      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Test String Compression  IMPORT              24     ÆQÈ Program TestComp;  { tests Compression }„„{ kludgy test of Compress Unit }„„Uses Crt, Dos, Compress;„„Const„  NumofStrings = 5;„„Var„  ch : Char;„  LongestStringLength,i,j,len : Integer;„  Textfname,Compfname : String;„  TextFile : Text;„  ByteFile : File;„  CompArr : tCompressedStringArray;„  st : Array[1..NumofStrings] of String;„  Rec : SearchRec;„  BigArr : Array[1..5000] of Byte;„  Arr : Array[1..NumofStrings] of tCompressedStringArray;„„begin„  Writeln('note:  No I/O checking in this test.');„  Write('Test <C>ompress or <U>nCompress? ');„  Repeat„    ch := upCase(ReadKey);„  Until ch in ['C','U',#27];„  if ch = #27 then halt;„  Writeln(ch);„  if ch = 'C' then begin„    Writeln('Enter ',NumofStrings,' Strings:');„    LongestStringLength := 0;„    For i := 1 to NumofStrings do begin„      Write(i,': ');„      readln(st[i]);„      if length(st[i]) > LongestStringLength then„        LongestStringLength := length(st[i]);„    end;„    Writeln;„    Writeln('Enter name of File to store unCompressed Strings in.');„    Writeln('ANY EXISTinG File With THIS NAME WILL BE OVERWRITTEN.');„    readln(Textfname);„    assign(TextFile,Textfname);„    reWrite(TextFile);„    For i := 1 to NumofStrings do„      Writeln(TextFile,st[i]);„    close(TextFile);„    Writeln;„    Writeln('Enter name of File to store Compressed Strings in.');„    Writeln('ANY EXISTinG File With THIS NAME WILL BE OVERWRITTEN.');„    readln(Compfname);„    assign(ByteFile,Compfname);„    reWrite(ByteFile,1);„    For i := 1 to NumofStrings do begin„      CompressString(st[i],CompArr,len);„      blockWrite(ByteFile,CompArr,len);„    end;„    close(ByteFile);„    FindFirst(Textfname,AnyFile,Rec);„    Writeln;„    Writeln;„    Writeln('Size of Text File storing Strings: ',Rec.Size);„    Writeln;„    Writeln('Using Typed Files, a File of Type String[',„             LongestStringLength,„             '] would be necessary.');„    Writeln('That would be ',„             (LongestStringLength+1)*NumofStrings,„             ' long, including length Bytes.');„    Writeln;„    FindFirst(Compfname,AnyFile,Rec);„    Writeln('Size of the Compressed File: ',Rec.Size);„    Writeln;„    Writeln('Now erase the Text File, and run this Program again, choosing');„    Writeln('<U>nCompress to show that the Compression retains all info.');„  end else begin                        { ch = 'U' }„    Write('Name of Compressed File: ');„    readln(Compfname);„    assign(ByteFile,Compfname);„    reset(ByteFile,1);„    blockread(ByteFile,BigArr,Filesize(ByteFile));„    close(ByteFile);„    For j := 1 to NumofStrings do begin„      i := 1;„      While BigArr[i] <> 0 do inc(i);„      move(BigArr[1],Arr[j],i);„      move(BigArr[i+1],BigArr[1],sizeof(BigArr));„    end;„    For i := 1 to NumofStrings do„      st[i] := GetCompressedString(Arr[i]);„    For i := 1 to NumofStrings do„      Writeln(st[i]);„  end;„end.„                                                            10     05-28-9313:33ALL                      SWAG SUPPORT TEAM        ARJ File Viewer          IMPORT              53     ÆQ†ª {„Author: Steve Wierenga„ARJ Viewer„}„{Hello All:„I am releasing these Units to the public domain.  They are Units to view Arj,„Lzh, and Zip Files.  They are by no means professional, and probably have some„bugs.  If you use these in your Programs and feel like giving me credit, I„won't Object...  Here goes: }„„Unit ArjV;„„(**) Interface (**)„„Uses„  Dos,Crt;„„Type„  AFHeader = Record  { ArjFileHeader }„    HeadID,„    HdrSize   : Word;„    HeadSize,„    VerNum,„    MinVerNum,„    HostOS,„    ArjFlag,„    Method,„    FType,„    Reserved  : Byte;„    FileTime,„    PackSize,„    OrigSize,„    FileCRC   : LongInt;„    FilePosF,„    FileAcc,„    HostData  : Word;„  end;„„Var„  ff     : Integer;„  b      : Byte;„  f      : File;„  sl     : LongInt;„  NR     : Word;„  FHdr   : ^AFHeader;„  s,sss  : String;„  Method : String[8];„  l      : String[80];„  Z,„  totalu,„  totalc : LongInt;„  x,d    : LongInt;„  Dt1,dt2: DateTime;„  i,e    : Integer;„  registered : Boolean;„„Procedure ArjView(ArjFile : String);„Function GAN(ArjFile : String): String;„„(**) Implementation (**)„„Procedure Terminate;„begin„  Write('ARCHPEEK could not find specified File.„  Aborting...');„  Halt;„end;„„Procedure ArjView(ArjFile : String);„begin„  New(FHdr);„  Assign(f, arjFile);„  {$I-}„  Reset(F, 1);                     { Open File }„  {$I+}„  If IOResult <> 0 then„    Terminate; { Specified File exists?}„  registered := False;             { Unregistered }„  if not registered then„  begin„    Writeln('ArchPeek 0.01Alpha [UNREGISTERED] Copyright 1993 Steve Wierenga');„    Delay(200);„  end;„  SL := 0;z := 0;TotalU := 0; TotalC := 0;   { Init  Variables }„  sss := GAN(ArjFile);                       { Get the Arj Filename }„  Writeln('Arj FileName: ',SSS);„  Write('   Name           Length      Size       Saved     Method     Date Time      ');„  WriteLn('____________________________________________________________________________');„  ff := 0;„  Repeat„    ff := ff + 1;„    Seek(F,SL);„    BlockRead(F,FHdr^,SizeOf(AFHeader),NR);     { Read the header }„    If (NR = SizeOf(AFHeader)) Then„    begin„      s := '';„      Repeat„        BlockRead(F,B,1);               { Get Char For Compressed Filename }„        If B <> 0 Then„          s := s + Chr(b);              { Put Char in String }„      Until B = 0;                      { Until no more Chars }„      Case Length(S) Of                 { Straighten out String }„        0  : s := s + '            ';„        1  : S := s + '           ';„        2  : s := s + '          ';„        3  : S := S + '         ';„        4  : S := S + '        ';„        5  : S := S + '       ';„        6  : S := S + '      ';„        7  : S := S + '     ';„        8  : S := S + '    ';„        9  : S := S + '   ';„        10 : S := S + '  ';„        11 : S := S + ' ';„        12 : S := S;„      end;„      z := z + 1;„      UnPackTime(FHdr^.FileTime,dt2);  { Get the time of compressed File }„      Case FHdr^.Method Of             { Get compression method }„        0 : Method := 'Stored  ';„        1 : Method := 'Most    ';„        2 : Method := '2nd Most';„        3 : Method := '2nd Fast';„        4 : Method := 'Fastest ';„      end;„      Write( ' ',S,FHdr^.OrigSize:9,FHdr^.PackSize:10);„      { Write Filesizes }„      If ff > 1 then„        { Don't get first Arj File in Arj File }„        Write( (100-FHdr^.PackSize/FHdr^.OrigSize*100):9:0,'%',Method:15)„         { Write ratios, method }„        Else„          Write( Method:25);„      Case dt2.month of               { Show date of compressed File }„        1..9   : Write( '0':4,dt2.month);„        10..12 : Write( dt2.month:4);„      end;„      Write( '/');„      Case dt2.day of„        1..9   : Write( '0',dt2.day);„        10..31 : Write( dt2.day);„      end;„      Write( '/');„      Case dt2.year of„        1980 : Write( '80');„        1981 : Write( '81');„        1982 : Write( '82');„        1983 : Write( '83');„        1984 : Write( '84');„        1985 : Write( '85');„        1986 : Write( '86');„        1987 : Write( '87');„        1988 : Write( '88');„        1989 : Write( '89');„        1990 : Write( '90');„        1991 : Write( '91');„        1992 : Write( '92');„        1993 : Write( '93');„        1994 : Write( '94');„        1995 : Write( '95');„        1996 : Write( '96');„      end;„      Case dt2.hour of                          { Show time of compressed File }„        0..9   : Write( '0':2,dt2.hour,':');„        10..23 : Write( dt2.hour:3,':');„      end;„      Case dt2.min of„        0..9   : Write( '0',dt2.min,':');„        10..59 : Write( dt2.min,':');„      end;„      Case dt2.sec of„        0..9   : Writeln( '0',dt2.sec);„        10..59 : Writeln( dt2.sec);„      end;„      TotalU := TotalU + FHdr^.OrigSize; { Increase total uncompressed size }„      TotalC := TotalC + FHdr^.PackSize; { Increase total compressed size }„      Repeat„        BlockRead(F,B,1);„      Until b = 0;„      BlockRead(F,FHdr^.FileCRC,4);      { Go past File CRC }„      BlockRead(f,NR,2);„      Sl := FilePos(F) + FHdr^.PackSize; { Where are we in File? }„    end;„„  Until (FHdr^.HdrSize = 0);  { No more Files? }„  GetFTime(F,x);„  UnPackTime(x,dt1);„  WriteLn('============================================================================');„  Write( (z-1):4,' Files',TotalU:12,TotalC:10,(100-TotalC/TotalU*100):9:0,'%');„  Case dt1.month of                  { Get date and time of Arj File }„    1..9   : Write( '0':19,dt1.month);„    10..12 : Write( dt1.month:20);„  end;„  Write( '/');„  Case dt1.day of„    1..9   : Write( '0',dt1.day);„    10..31 : Write( dt1.day);„  end;„  Write( '/');„  Case dt1.year of„    1980 : Write( '80');„    1981 : Write( '81');„    1982 : Write( '82');„    1983 : Write( '83');„    1984 : Write( '84');„    1985 : Write( '85');„    1986 : Write( '86');„    1987 : Write( '87');„    1988 : Write( '88');„    1989 : Write( '89');„    1990 : Write( '90');„    1991 : Write( '91');„    1992 : Write( '92');„    1993 : Write( '93');„    1994 : Write( '94');„    1995 : Write( '95');„    1996 : Write( '96');„  end;„  Case dt1.hour of„    0..9   : Write( '0':2,dt1.hour,':');„    10..23 : Write( dt1.hour:3,':');„  end;„  Case dt1.min of„    0..9   : Write( '0',dt1.min,':');„    10..59 : Write( dt1.min,':');„  end;„  Case dt1.sec of„    0..9   : Writeln( '0',dt1.sec);„    10..59 : Writeln( dt1.sec);„  end;„  Close(f);„  Dispose(FHdr);  { Done }„end;„„Function GAN(ARJFile:String): String;„Var„  Dir  : DirStr;„  Name : NameStr;„  Exts : ExtStr;„begin„  FSplit(ARJFile,Dir,Name,Exts);„  GAN := Name + Exts;„end;„„end.„                                                                            11     05-28-9313:33ALL                      SWAG SUPPORT TEAM        LZH File Viewer          IMPORT              57     ÆQ[, {„Author: Steve Wierenga„LZH Viewer„}„„Unit Lzhv;„(**) Interface (**)„Uses„  Dos,Crt;„„Type„  FileheaderType = Record  { Lzh File header }„    Headsize,„    Headchk   : Byte;„    HeadID    : packed Array[1..5] of Char;„    Packsize,„    Origsize,„    Filetime  : LongInt;„    Attr      : Word;„    Filename  : String[12];„    f32       : PathStr;„    dt        : DateTime;„  end;„„Var„  Fh         : FileheaderType;„  Fha        : Array[1..sizeof(FileheaderType)] of Byte Absolute fh;„  crc        : Word;   { CRC value }„  crcbuf     : Array[1..2] of Byte Absolute CRC;„  crc_table  : Array[0..255] of Word; { Table of CRC's }„  inFile     : File; { File to be processed }„  registered : Boolean; { Is registered? }„„Procedure Make_crc_table; { Create table of CRC's }„Function  Mksum : Byte;     { Get CheckSum }„Procedure ViewLzh(LZHFile : String);  { View the File }„Function  GAN(LZHFile : String) : String;  { Get the LZH Filename }„„„(**) Implementation (**)„Procedure Terminate; { Exit the Program }„begin„  Write('ARCHPEEK could not find specified File. Aborting...');„  Halt;„end;„„Procedure Make_crc_table;„Var„  i,„  index,„  ax    : Word;„  carry : Boolean;„begin„  index := 0;„  Repeat„    ax := index;„    For i := 1 to 8 do„    begin„      carry := odd(ax);„      ax := ax shr 1;„      if carry then„        ax := ax xor $A001;„    end;„    crc_table[index] := ax;„    inc(index);„  Until index > 255;„end;„„{ use this to calculate the CRC value of the original File }„{ call this Function afer reading every Byte from the File }„Procedure calccrc(data : Byte);„Var„  index : Integer;„begin„  crcbuf[1] := crcbuf[1] xor data;„  index := crcbuf[1];„  crc := crc shr 8;„  crc := crc xor crc_table[index];„end;„„„Function Mksum : Byte;  {calculate check sum For File header }„Var„  i : Integer;„  b : Byte;„begin„  b := 0;„  For i := 3 to fh.headsize+2 do„    b := b+fha[i];„  mksum := b;„end;„„Procedure viewlzh(LZHFile : String); { View the LZH File }„Var„  l1,l2,„  oldFilepos,„  a,b,a1,b1,„  totalorig,„  totalpack : LongInt;„  count,z   : Integer;„  numread,„  i, year1,„  month1,„  day1,„  hour1,„  min1,„  sec1      : Word;„  s1        : String[50];„  s2        : String[20];„  l         : String[80];„  sss       :  String;„begin„  registered  :=  False; { Unregistered }„  if not registered then { Registered? }„  begin„    Writeln('ArchPeek 0.01Alpha [UNREGISTERED] Copyright 1993 Steve Wierenga');„    Delay(200);„  end;„  assign(inFile,LZHFile);„  {$I-}„  reset(inFile,1);   { Open LZH File }„  {$I+}„  If IOResult <> 0 then„    Terminate;   { Specified File exists? }„  sss :=  GAN(LZHFile);  { Get Filename of LZH File }„  Writeln( 'Lzh FileName: ',sss);„  WriteLn( '    Name           Length      Size  Saved    Date      Time    ');„  WriteLn('__________________________________________________________');„  oldFilepos := 0;       { Init Variables }„  count := 1;„  z  := 0;„  a1 := 0;„  Repeat„    z  :=  z + 1;„    seek(inFile,oldFilepos);                              {„    Goto start of File}„    blockread(inFile,fha,sizeof(FileheaderType),numread); {„    Read Fileheader}„    oldFilepos := oldFilepos+fh.headsize+2+fh.packsize;   {„    Where are we? }„    i := Mksum; { Get the checksum }„    if fh.headsize <> 0 then„    begin„      if i <> fh.headchk then„      begin„        Writeln('Error in File. Unable to read.  Aborting...');„        Close(inFile);„        Exit;„      end;„      Case Length(Fh.FileName) Of          { Straigthen out String }„        1  : Fh.FileName  :=  Fh.FileName + '           ';„        2  : Fh.FileName  :=  Fh.FileName + '          ';„        3  : Fh.FileName  :=  Fh.FileName + '         ';„        4  : Fh.FileName  :=  Fh.FileName + '        ';„        5  : Fh.FileName  :=  Fh.FileName + '       ';„        6  : Fh.FileName  :=  Fh.FileName + '      ';„        7  : Fh.FileName  :=  Fh.FileName + '     ';„        8  : Fh.FileName  :=  Fh.FileName + '    ';„        9  : Fh.FileName  :=  Fh.FileName + '   ';„        10 : Fh.FileName  :=  Fh.FileName + '  ';„        11 : Fh.FileName  :=  Fh.FileName + ' ';„        12 : Fh.FileName  :=  Fh.FileName + '';„      end;„      UnPackTime(Fh.FileTime,Fh.DT);„      a1 := a1 + Fh.OrigSize;            { Increase Uncompressed Size }„      Write('       ', fh.Filename : 2, fh.origsize : 9, fh.packSize : 10,„                   (100 - fh.packSize / fh.origSize * 100) : 5 : 0, '%');„       { Display info }„      Case fh.dt.month of  { Get date and time }„        1..9   : Write( '0':4,fh.dt.month);„        10..12 : Write( ' ',fh.dt.month:4);„      end;„      Write( '/');„      Case fh.dt.day of„        1..9   : Write( '0',fh.dt.day);„        10..31 : Write( fh.dt.day);„      end;„      Write( '/');„      Case fh.dt.year of„        1980 : Write( '80');„        1981 : Write( '81');„        1982 : Write( '82');„        1983 : Write( '83');„        1984 : Write( '84');„        1985 : Write( '85');„        1986 : Write( '86');„        1987 : Write( '87');„        1988 : Write( '88');„        1989 : Write( '89');„        1990 : Write( '90');„        1991 : Write( '91');„        1992 : Write( '92');„        1993 : Write( '93');„        1994 : Write( '94');„        1995 : Write( '95');„        1996 : Write( '96');„      end;„      Case fh.dt.hour of„        0..9   : Write( '0':3,fh.dt.hour,':');„        10..23 : Write( ' ',fh.dt.hour:3,':');„      end;„      Case fh.dt.min of„        0..9   : Write( '0',fh.dt.min,':');„        10..59 : Write( fh.dt.min,':');„      end;„      Case fh.dt.sec of„        0..9   : Writeln( '0',fh.dt.sec);„        10..59 : Writeln( fh.dt.sec);„      end;„    end;„  Until   (fh.headsize=0);„  Writeln( '===========================================================');„  GetFTime(inFile,l1);„  UnPackTime(l1,fh.dt);„  Write( '  ', z, ' Files  ', a1 : 12, FileSize(inFile) : 10,„          (100 - FileSize(inFile) / a1 * 100) : 5 : 0, '%');„  Case fh.dt.month of„    1..9   : Write( '0':4,fh.dt.month);„    10..12 : Write( ' ',fh.dt.month:4);„  end;„  Write( '/');„  Case fh.dt.day of„    1..9   : Write( '0',fh.dt.day);„    10..31 : Write( fh.dt.day);„  end;„  Write( '/');„  Case fh.dt.year of„    1980 : Write( '80');„    1981 : Write( '81');„    1982 : Write( '82');„    1983 : Write( '83');„    1984 : Write( '84');„    1985 : Write( '85');„    1986 : Write( '86');„    1987 : Write( '87');„    1988 : Write( '88');„    1989 : Write( '89');„    1990 : Write( '90');„    1991 : Write( '91');„    1992 : Write( '92');„    1993 : Write( '93');„    1994 : Write( '94');„    1995 : Write( '95');„    1996 : Write( '96');„  end;„  Case fh.dt.hour of„    0..9   : Write( '0':3,fh.dt.hour,':');„    10..23 : Write( ' ',fh.dt.hour:3,':');„  end;„  Case fh.dt.min of„    0..9   : Write( '0',fh.dt.min,':');„    10..59 : Write( fh.dt.min,':');„  end;„  Case fh.dt.sec of„    0..9   : Writeln( '0',fh.dt.sec);„    10..59 : Writeln( fh.dt.sec);„  end;„end;„„Function GAN(LZHFile : String): String;„Var„  Dir  : DirStr;„  Name : NameStr;„  Exts : ExtStr;„begin„  FSplit(LZHFile,Dir,Name,Exts);„  GAN := Name + Exts;„end;„„„end.„„                                                                                                 12     05-28-9313:33ALL                      SWAG SUPPORT TEAM        Zip File Viewer          IMPORT              36     ÆQdß {„Author: Steve Wierenga„ZIP Viewer„}„„Unit ZipV;„„(**) Interface (**)„„Uses„  Dos,Crt;„Procedure ZipView(ZIPFile:String);„Function GAN(ZIPFile : String) : String;„„(**) Implementation (**)„„Procedure Terminate;„begin„  Write('ARCHPEEK could not find specified File. Aborting...');„  Halt;„end;„„Procedure ZipView(ZIPFile : String);  { View the ZIP File }„Const„  SIG = $04034B50;                  { Signature }„Type„  ZFHeader = Record                 { Zip File Header }„    Signature  : LongInt;„    Version,„    GPBFlag,„    Compress,„    Date,Time  : Word;„    CRC32,„    CSize,„    USize      : LongInt;„    FNameLen,„    ExtraField : Word;„  end;„„Var„  z       : Integer;„  x,„  totalu,„  totalc  : LongInt;„  Hdr     : ^ZFHeader;„  F       : File;„  S,sss   : String;„  own     : Text;„  dt1     : DateTime;„  l       : String[80];„  registered : Boolean;  { Is registered? }„„Const„  CompTypes : Array[0..7] of String[9] =„              ('Stored ','Shrunk   ','Reduced1','Reduced2','Reduced3',„               'Reduced4','Imploded ','Deflated');„  { Method used to compress }„  r = #196;„  q = #205;„„begin„  z := 0; totalu := 0; totalc := 0; { Init Variables }„  registered := False; { Unregistered }„  if not registered then   { Is registered? }„  begin„    Writeln('ArchPeek 0.01Alpha [UNREGISTERED] Copyright 1993 Steve Wierenga');„    Delay(200);„  end;„  New(Hdr);„  Assign(F,ZIPFile);„  {$I-}„  Reset(F,1);                   { Open File }„  {$I+}„  If IOResult <> 0 then Terminate;  { Couldn't open Zip File }„  sss := GAN(ZipFile);              { Get the Zip Filename }„  Writeln('Zip FileName: ',sss);„  WriteLn( '   Name           Length      Size  Saved Method');„  WriteLn(r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,„          r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r);„  Repeat„    FillChar(S,SizeOf(S), #0);  { Pad With nulls }„    BlockRead(F,Hdr^,SizeOf(ZFHeader));„    { Read File Header }„    BlockRead(F,Mem[Seg(S) : Ofs(S) + 1], Hdr^.FNameLen);„    s[0] := Chr(Hdr^.FNameLen);„    Case Length(S) Of    { Straighten String }„     0  : s := s + '            ';„     1  : S := s + '           ';„     2  : s := s + '          ';„     3  : S := S + '         ';„     4  : S := S + '        ';„     5  : S := S + '       ';„     6  : S := S + '      ';„     7  : S := S + '     ';„     8  : S := S + '    ';„     9  : S := S + '   ';„     10 : S := S + '  ';„     11 : S := S + ' ';„     12 : S := S;„    end;„      If (Hdr^.Signature = Sig) Then { Is a header }„    begin„      z := z + 1;„      WriteLn(S,Hdr^.USize:9,Hdr^.CSize:10,(100-Hdr^.CSize/Hdr^.USize*100):5:0,'%',„              CompTypes[Hdr^.Compress]:16);„      Inc(TotalU,Hdr^.USize);  { Increment size uncompressed }„      Inc(TotalC,Hdr^.CSize);  { Increment size compressed }„    end;„    Seek(F,FilePos(F) + Hdr^.CSize + Hdr^.ExtraField);„  Until Hdr^.Signature <> SIG; { No more Files }„  GetFTime(F,x);„  UnPackTime(x,DT1);„  WriteLn(q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,„          q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q);„  Write( z:4,' Files ',TotalU:12,TotalC:10,(100-TotalC/TotalU*100):5:0,'%');„  Case dt1.month of        { Get Zip File date and time }„    1..9   : Write( '0':4,dt1.month);„    10..12 : Write( dt1.month:4);„  end;„  Write( '/');„  Case dt1.day of„    1..9   : Write( '0',dt1.day);„    10..31 : Write( dt1.day);„  end;„  Write( '/');„  Case dt1.year of„    1980 : Write( '80');„    1981 : Write( '81');„    1982 : Write( '82');„    1983 : Write( '83');„    1984 : Write( '84');„    1985 : Write( '85');„    1986 : Write( '86');„    1987 : Write( '87');„    1988 : Write( '88');„    1989 : Write( '89');„    1990 : Write( '90');„    1991 : Write( '91');„    1992 : Write( '92');„    1993 : Write( '93');„    1994 : Write( '94');„    1995 : Write( '95');„    1996 : Write( '96');„  end;„  Case dt1.hour of„    0..9   : Write( '0':3,dt1.hour,':');„    10..23 : Write( dt1.hour:3,':');„  end;„  Case dt1.min of„    0..9   : Write( '0',dt1.min,':');„    10..59 : Write( dt1.min,':');„  end;„  Case dt1.sec of„    0..9   : Writeln( '0',dt1.sec);„    10..59 : Writeln( dt1.sec);„  end;„  Close(F);„  Dispose(Hdr);„end;„„„Function GAN(ZIPFile:String): String;„Var„  Dir  : DirStr;„  Name : NameStr;„  Exts : ExtStr;„begin„  FSplit(ZIPFile,Dir,Name,Exts);„  GAN := Name + Exts;„end;„„end.„                                                                                                                  13     09-26-9310:14ALL                      IAN HUNTER               LZW Compression Unit     IMPORT              74     ÆQ£! (*„From: IAN HUNTER„Subj: LZW Compression Unit„*)„„Unit IHLZW;„  {- Unit to handle data compression }„Interface„Const„  StackOverFlow = 1;„  DeniedWrite = 2;„Type„  GetCharFunc = Function (Var Ch : Char) : Boolean;„  PutCharProc = Procedure (Ch : Char);„  LZW = Object„          GetChar : GetCharFunc;„          PutChar : PutCharProc;„          LastError : Word;„          Constructor Init;„          Function Get_Hash_Code (PrevC, FollC : Integer) : Integer;„          Procedure Make_Table_Entry (PrevC, FollC: Integer);„          Procedure Initialize_String_Table;„          Procedure Initialize;„          Function Lookup_String (PrevC, FollC : Integer) : Integer;„          Procedure Get_Char (Var C : Integer);„          Procedure Put_Char (C : Integer);„          Procedure Compress;„          Procedure Decompress;„          End;„„Implementation„Const„  MaxTab   = 4095;„  No_Prev  = $7FFF;„  EOF_Char = -2;„  End_List = -1;„  Empty    = -3;„„Type„  AnyStr = String;„  String_Table_Entry = Record„    Used : Boolean;„    PrevChar : Integer;„    FollChar : Integer;„    Next : Integer;„    End;„„Var„  String_Table : Array [0..MaxTab] Of String_Table_Entry;„  Table_Used     : Integer;„  Output_Code    : Integer;„  Input_Code     : Integer;„  If_Compressing : Boolean;„„Constructor LZW.Init;„Begin„  LastError := 0;„End;„„Function LZW.Get_Hash_Code (PrevC, FollC : Integer) : Integer;„Var„  Index  : Integer;„  Index2 : Integer;„Begin„  Index := ((PrevC SHL 5) XOR FollC) AND MaxTab;„  If (Not String_Table [Index].Used)„    Then„      Get_Hash_Code := Index„    Else„      Begin„        While (String_Table[Index].Next <> End_List) Do„          Index := String_Table[Index].Next;„        Index2 := (Index + 101) And MaxTab;„        While (String_Table[Index2].Used) Do„          Index2 := Succ (Index2) AND MaxTab;„        String_Table[Index].Next := Index2;„        Get_Hash_Code := Index2;„      End;„End;„„Procedure LZW.Make_Table_Entry (PrevC, FollC: Integer);„Begin„  If (Table_Used <= MaxTab )„    Then„      Begin„         With String_Table [Get_Hash_Code (PrevC , FollC)] Do„           Begin„             Used     := True;„             Next     := End_List;„             PrevChar := PrevC;„             FollChar := FollC;„           End;„         Inc (Table_Used);„(*„         IF ( Table_Used > ( MaxTab + 1 ) ) THEN„            BEGIN„               WRITELN('Hash table full.');„            END;„*)„      End;„End;„„Procedure LZW.Initialize_String_Table;„Var„  I : Integer;„Begin„  Table_Used := 0;„  For I := 0 to MaxTab Do„    With String_Table[I] Do„      Begin„        PrevChar := No_Prev;„        FollChar := No_Prev;„        Next := -1;„        Used := False;„      End;„  For I := 0 to 255 Do„    Make_Table_Entry (No_Prev, I);„End;„„Procedure LZW.Initialize;„Begin„  Output_Code := Empty;„  Input_Code := Empty;„  Initialize_String_Table;„End;„„Function LZW.Lookup_String (PrevC, FollC: Integer) : Integer;„Var„  Index  : Integer;„  Index2 : Integer;„  Found  : Boolean;„Begin„  Index := ((PrevC Shl 5) Xor FollC) And MaxTab;„  Lookup_String := End_List;„  Repeat„    Found := (String_Table[Index].PrevChar = PrevC) And„             (String_Table[Index].FollChar = FollC);„    If (Not Found)„      Then„        Index := String_Table [Index].Next;„  Until Found Or (Index = End_List);„  If Found„    Then„      Lookup_String := Index;„End;„„Procedure LZW.Get_Char (Var C : Integer);„Var„  Ch : Char;„Begin„  If Not GetChar (Ch)„    Then„      C := EOF_Char„    Else„      C := Ord (Ch);„End;„„Procedure LZW.Put_Char (C : Integer);„Var„  Ch : Char;„Begin„  Ch := Chr (C);„  PutChar (Ch);„End;„„Procedure LZW.Compress;„  Procedure Put_Code (Hash_Code : Integer);„  Begin„    If (Output_Code = Empty)„      Then„        Begin„          Put_Char ((Hash_Code Shr 4) And $FF);„          Output_Code := Hash_Code And $0F;„        End„      Else„        Begin„          Put_Char (((Output_Code Shl 4) And $FF0) +„                   ((Hash_Code Shr 8) And $00F));„          Put_Char (Hash_Code And $FF);„          Output_Code := Empty;„        End;„  End;„„„  Procedure Do_Compression;„  Var„    C : Integer;„    WC : Integer;„    W : Integer;„  Begin„    Get_Char (C);„    W := Lookup_String (No_Prev, C);„    Get_Char (C);„    While (C <> EOF_Char) Do„      Begin„        WC := Lookup_String (W, C);„        If (WC = End_List)„          Then„            Begin„              Make_Table_Entry (W, C );„              Put_Code (W);„              W := Lookup_String (No_Prev, C);„            End„          Else„            W := WC;„        Get_Char( C );„      End;„    Put_Code (W);„  End;„„Begin„  If_Compressing := True;„  Initialize;„  Do_Compression;„End;„„Procedure LZW.Decompress;„Const„  MaxStack = 4096;„Var„  Stack : Array [1..MaxStack] Of Integer;„  Stack_Pointer : Integer;„„  Procedure Push (C : Integer);„  Begin„    Inc (Stack_Pointer);„    Stack [Stack_Pointer] := C;„    If (Stack_Pointer >= MaxStack)„      Then„        Begin„          LastError := 1;„          Exit;„        End;„  End;„„  Procedure Pop (Var C : Integer);„  Begin;„    If (Stack_Pointer > 0)„      Then„        Begin„          C := Stack [Stack_Pointer];„          Dec (Stack_Pointer);„        End„      Else„        C := Empty;„  End;„„  Procedure Get_Code (Var Hash_Code : Integer);„  Var„    Local_Buf : Integer;„  Begin„    If (Input_Code = Empty)„      Then„        Begin„          Get_Char (Local_Buf);„          If (Local_Buf = EOF_Char)„            Then„              Begin„                Hash_Code := EOF_Char;„                Exit;„              End;„          Get_Char (Input_Code);„          If (Input_Code = EOF_Char)„            Then„              Begin„                Hash_Code := EOF_Char;„                Exit;„              End;„          Hash_Code := ((Local_Buf Shl 4) And $FF0) +„                       ((Input_Code Shr 4) And $00F);„          Input_Code := Input_Code And $0F;„        End„      Else„        Begin„          Get_Char (Local_Buf);„          If (Local_Buf = EOF_Char)„            Then„              Begin„                Hash_Code := EOF_Char;„                Exit;„              End;„          Hash_Code := Local_Buf + ((Input_Code Shl 8) And $F00);„          Input_Code := Empty;„        End;„  End;„„  Procedure Do_Decompression;„  Var„    C : Integer;„    Code : Integer;„    Old_Code : Integer;„    Fin_Char : Integer;„    In_Code : Integer;„    Last_Char : Integer;„    Unknown : Boolean;„    Temp_C : Integer;„  Begin„    Stack_Pointer := 0;„    Unknown := False;„    Get_Code (Old_Code);„    Code := Old_Code;„    C := String_Table[Code].FollChar;„    Put_Char (C);„    Fin_Char := C;„    Get_Code (In_Code);„    While (In_Code <> EOF_Char) Do„      Begin„        Code := In_Code;„        If (Not String_Table [Code].Used)„          Then„            Begin„              Last_Char := Fin_Char;„              Code := Old_Code;„              Unknown := TRUE;„            End;„        While (String_Table [Code].PrevChar <> No_Prev) Do„          With String_Table[Code] Do„            Begin„              Push (FollChar);„              If (LastError <> 0)„                Then„                  Exit;„              Code := PrevChar;„            End;„        Fin_Char := String_Table [Code].FollChar;„        Put_Char (Fin_Char);„        Pop (Temp_C);„        While (Temp_C <> Empty) Do„          Begin„            Put_Char (Temp_C);„            Pop (Temp_C);„          End;„        If Unknown„          Then„            Begin„              Fin_Char := Last_Char;„              Put_Char (Fin_Char);„              Unknown := FALSE;„            End;„        Make_Table_Entry (Old_Code, Fin_Char);„        Old_Code := In_Code;„        Get_Code( In_Code );„      End;„  End;„„Begin„  If_Compressing := False;„  Initialize;„  Do_Decompression;„End;„„End.„„(* *****************************     TEST PROGRAM    ****************** *)„„Program LZWTest;„{ program to demo/test the LZW object }„Uses„  IHLZW;  { Only needs this }„Var„  C : LZW; { The Star of the Show; the Compression Object }„„{$F+} Function GetTheChar (Var Ch : Char) : Boolean; {$F-}„{ Make your GetChar routine's declaration look exactly like this }„„Begin„  If Not Eof (Input) { End of Input? }„    Then„      Begin„        Read (Input, Ch); { Then read one character into Ch and ... }„        GetTheChar := True; { ... Return True }„      End„    Else„      GetTheChar := False; { Otherwise return False }„End;„„{$F+} Procedure PutTheChar (Ch : Char); {$F-}„{ Make your PutChar routine's declaration look exactly like this }„„Begin„  Write (Output, Ch); { Write Ch to Output file }„End;„„Begin„  { Open data files }„  Assign (Input, ''); { Standard Input; requires redirection to be useful }„  Assign (Output, ''); { Standard Output; requires redirection to be useful }„  Reset (Input);„  Rewrite (Output);„  { Can't fail yet -- maybe a descendant could, though... }„  If not C.Init„    Then„      Halt;„  { Assign I/O routines }„  C.GetChar := GetTheChar; { Set LZW's GetChar to routine GetTheChar }„  C.PutChar := PutTheChar; { Set LZW's PutChar to routine PutTheChar }„  { are we compressing or decompressing? }„  If (ParamCount = 0)„    Then„      C.Compress { compress }„    Else„      C.Decompress; { decompress }„  { All Done! }„End.„„                                                                                                      14     11-02-9310:31ALL                      ANTHONY GELAT            Self Modify PKLITE files IMPORT              42     ÆQHL {„ANTHONY GELAT„„>>Is it the size of the EXE File?  You can compress it With PKLite or„>>LZEXE - it'll load into memory With full size, though.  This just„„>Nope, it has self modifying data.  PKLiting it wouldn't work.„„ I have code For a self modifying EXE that claims to be PKLITEable,„ so i believe it can be done...here it is„}„„Unit PCkSelfM;„{ Programmer: Jim Nicholson„„Purpose: Implement a method For creating "self-modifying" .EXE Files from„TP which will survive the encoding techniques used by LZEXE and PKLite(tm).„For discussion and examples, see SelfMod.Pas„This Unit contains code placed into the public domain, With the following„	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^„provision:„Please do not distribute modified versions of this code Without indicating„such modification by commenting the File.„if you have questions, comments, modifications, or suggestions, please„feel free to contact us:„„             PCkS Associates„             138 Frances Place„             Hillside, NJ 07205„„             On CompuServe, EasyPlex to    70152,332„             On Delphi                     CHICKENJN„             On GENie                      J.NICHOLSON1„„}„„Interface„„Var„  ExeFileName : String[128];„„Function  ConfigBlockPresent(Size : Integer)          : Boolean;„Function  NewConfigBlock(Var C_B; Size : Integer)     : Boolean;„Function  ReadConfigBlock(Var C_B; Size : Integer)    : Boolean;„Function  ConfigBlockReWrite(Var C_B; Size : Integer) : Boolean;„„Implementation„„Uses„  Dos;„„Const„  SelfModHeader : String[10] = 'PCkS SMODF';„  CtrlZ         : Char = ^Z;„„Var„  ExeFile : File;„  Buffer  : String[10];„„Function ConfigBlockPresent(Size : Integer) : Boolean;„begin„  assign(ExeFile, ExeFileName);„  reset(ExeFile, 1);„  seek(ExeFile, FileSize(ExeFile) - (SizeOf(SelfModHeader) + Size + 1));„  BlockRead(ExeFile, Buffer, SizeOf(SelfModHeader));„  if Buffer = SelfModHeader then„    ConfigBlockPresent := True„  else„    ConfigBlockPresent := False;„  close(ExeFile);„end;„„Function NewConfigBlock(Var C_B; Size : Integer) : Boolean;„begin„  NewConfigBlock := False;„  if not ConfigBlockPresent(Size) then„  begin„    assign(ExeFile, ExeFileName);„    reset(ExeFile, 1);„    Seek(ExeFile, FileSize(ExeFile));„    BlockWrite(ExeFile, SelfModHeader, SizeOf(SelfModHeader));„    BlockWrite(ExeFile, C_B, Size);„    BlockWrite(ExeFile, CtrlZ, 1);„    close(ExeFile);„    NewConfigBlock := True;„  end;„end;„„Function ReadConfigBlock(Var C_B; Size : Integer) : Boolean;„begin„  ReadConfigBlock := False;„  if ConfigBlockPresent(Size) then„  begin„    assign(ExeFile, ExeFileName);„    reset(ExeFile, 1);„    seek(ExeFile, FileSize(ExeFile) - (Size + 1));„    BlockRead(ExeFile, C_B, Size);„    close(ExeFile);„    ReadConfigBlock := True;„  end;„end;„„Function ConfigBlockReWrite(Var C_B; Size : Integer) : Boolean;„Var„  Temp : String;„begin„  ConfigBlockReWrite := False;„  if ConfigBlockPresent(Size) then„  begin„    assign(ExeFile, ExeFileName);„    reset(ExeFile, 1);„    seek(ExeFile, FileSize(ExeFile) - (SizeOf(SelfModHeader) + Size + 1));„    BlockWrite(ExeFile, SelfModHeader, SizeOf(SelfModHeader));„    BlockWrite(ExeFile, C_B, Size);„    BlockWrite(ExeFile, CtrlZ, 1);„    close(ExeFile);„    ConfigBlockReWrite := True;„  end;„end;„„begin„  ExeFileName := ParamStr(0);„end.„„„{--------------------------And SELFMOD.PAS, referenced above: }„Program SelfMod;„„{„   This demonstrates a technique For creating self-modifying .EXE Files. It„   has an advantage over techniques which use Typed Constants, in that it will„   survive LZEXEC and PkLite(tm).„„   Note that if the Program is run before LZEXEC is used to compress it, the„   compressed Program will not have been initialized. This is because LZEXEC„   strips off the config block (and everything else) at the end of the .EXE„   File. This problem does not occur With PKLite(tm).„„   To run the demo, compile the Program and execute it twice. Whatever„   String you enter is written to the end of the .EXE File.„„   To further demonstrate it's ablities, compress the File With PKLite(tm) or„   LZEXEC after compiling.„„   Address all questions and comments to:„„              PCkS Associates„              138 Frances Place„              Hillside, NJ 07205„„              On CompuServe, EasyPlex to    70152,332„              On Delphi                     CHICKENJN„              On GENie                      J.NICHOLSON1„„„}„„„„Uses„  PCkSelfM;„„Type„  ConfigBlock = String[40];„„Var„  MyConfig : ConfigBlock;„„begin„  if ConfigBlockPresent(SizeOf(ConfigBlock)) then„    if ReadConfigBlock(MyConfig, SizeOf(ConfigBlock)) then„    begin„      Writeln('Old value of MyConfig: ',MyConfig);„      Write('Enter new value: ');„      readln(MyConfig);„      if ConfigBlockReWrite(MyConfig,SizeOf(ConfigBlock)) then„        Writeln('Rewrote the block.')„      else„        Writeln('ConfigBlockReWrite failed.');„    end„    else„      Writeln('ReadConfigBlock failed')„  else„  begin„    Write('Enter inital value For MyConfig: ');„    readln(MyConfig);„    if NewConfigBlock(MyConfig, SizeOf(ConfigBlock)) then„      Writeln('Created new config block')„    else„      Writeln('NewConfigBlock failed.');„  end;„end.„„                                             15     02-03-9416:19ALL                      GAYLE DAVIS              Checking for SFX headers IMPORT              16     ÆQ¿X „{ Detection of ZIP and ARJ SFX files }„„{$S-,V-,D+,I-}„USES DOS;„„„TYPE„  ArchiveTypes = (NONE,ARJ,PKZIP);„  Header = RECORD„           HeadId  : WORD;                                      { 60000 }„           SIG1    : WORD;                          { Basic Header Size }„  END;„„VAR„„   ArchiveName   : PathStr;„   ArchiveSize   : LongInt;  { actual size of archive }„   ArchiveOffset : LongInt;  { bytes to skip in header if SFX }„   ArchiveKind   : ArchiveTypes;„„  FUNCTION CheckSfx(SfxName : PathStr) : BOOLEAN;„„  {-check for self-extracting archive}„  {-if Sfx Exe: set ArchiveName and ArchiveOffset}„  Var ImageInfo : Record„                    ExeId : Array[0..1] Of Char;„                    Remainder,„                    size : Word„                  End;„    SfxExe : File;„    H  : Header;„    rd : Word;„    Err : Boolean;„    AOffset : LongInt;„    ExeId : Array[0..1] Of Char;„„  Begin„„    CheckSFX := FALSE;„    Assign(SfxExe, SfxName); Reset(SfxExe, 1);„    If IoResult > 0 Then Exit;„„    ArchiveName   := SfxName;„    ArchiveOffset := 0;„    ArchiveSize   := Filesize(SfxExe);„    BlockRead(SfxExe, ImageInfo, SizeOf(ImageInfo));„    If ImageInfo.ExeId <> 'MZ' Then Exit;„    AOffset := LongInt(ImageInfo.size-1)*512+ImageInfo.Remainder;„    Seek(SfxExe, AOffset);„    If IoResult > 0 Then Exit;„    BlockRead(SfxExe, H, SizeOf(H), rd);„    Err := (IoResult > 0) Or (rd < SizeOf(Header));„    Close(SfxExe);„    If Err Then Exit;„    ArchiveName   := SfxName;„    ArchiveOffset := AOffset + (ORD(BOOLEAN(H.Sig1 = $EA60)) * 2); { add 2 bytes for ARJ241}„    ArchiveKind   := ArchiveTypes(ORD(ArchiveOffset > 0) + ORD(BOOLEAN(H.Sig1 <> $EA60)));„    CheckSfx      := (ArchiveOffset > 0);„  End;„„                                                „BEGIN„ArchiveName := ParamStr(1);„CheckSfx(archivename);„END.                                                                                            16     05-25-9407:59ALL                      GARETH LEWIN             archive detection        SWAG9405            11     ÆQ   {„„ RS>    Can anyone tell me where to find some source dealing with archive„ RS> detection?  I need to be able to determine what archival method was used„ RS> on a file regardless of the extension..„„Yep.„„BTW: I cut it out of a source I made it for. I should compile as is. you might„have to "USES" dos and/or CRT.„„----------------------------= CUT HERE =-------------------------------------„}„„Type„     ArchiveType = (ARJ,ZIP,UC2,LZH,UNKNOWN);„„Function GetArchiveType (Name : String) : Archivetype;„Var F : File;„    Buf: Word;„    StrBuf : String [3];„Begin„  GetArchiveType := UNKNOWN;„  Assign (F,Name);„  FileMode := 0;„  Reset (F,1);„  If IoResult <> 0 Then„  Begin„    Write ('Unable to access file - ');„    WriteLn (Name);„    Exit;„  End;„  BlockRead (F,Buf,2);„  If Buf = $EA60 Then„  Begin„    GetArchiveType := ARJ;„    Close (f);„    Exit;„  End;„  If Buf = $4b50 Then„  Begin„    GetArchiveType := ZIP;„    Close (f);„    Exit;„  End;„  If Buf = $4355 Then„  Begin„    GetArchiveType := UC2;„    Close (f);„    Exit;„  End;„  BlockRead (F,StrBuf[1],3);„  StrBuf[0] := #3;„  If StrBuf = '-lh' Then„  Begin„    GetArchiveType := LZH;„    Close (f);„    Exit;„  End;„End;„„                                                                                         17     05-25-9407:59ALL                      MIKE COPELAND            arj files                SWAG9405            42     ÆQ   „„const„      BSize    = 4096;                                      { I/O Buffer Size }„      HMax     = 512;                                   { Header Maximum Size }„      DLM      = #32#179;„      HexDigits: array[0..15] of char = '0123456789ABCDEF';„type„      MEDBUF       = array[1..4096] of char;„var„      DISKNUM      : Word;                     { Disk # - offset to Disk Info }„      WVN          : Word;                                 { Working Volume # }„      DIDX         : Word;                              { Files Display Index }„      VIDX         : Word;                            { Volumes Display Index }„      AIDX         : Word;                           { Archives Display Index }„      CIDX         : Word;                   { Compressed Files Display Index }„      ADX          : Word;                            { comPressed file Index }„      RES          : Word;                                   { Buffer Residue }„      N,P,Q        : Longint;„      ASZ,USZ,FSZ  : LongInt;              { Disk Available, Used, Free sizes }„      SEQNUM       : LongInt;                               { File Sequence # }„      C            : LongInt;                                 { Buffer Offset }„      FSize        : LongInt;                                     { File Size }„      CH, CH1      : char;„      DEVICE       : char;                                      { Disk Device }„      BIN,BOUT,„      BWORK        : ^MEDBUF;„      F            : File;„      SNAME        : String;„      DATE         : string[8];                  { formatted date as YY/MM/DD }„      TIME         : string[5];                  {     "     time as HH:MM    }„      X1,X2,X3,X4,„      X5,X6,X7,X8,„      X9,X10,X11,„      X12          : string;„      DISKNAME     : string[15];„      CMD          : string;                             { DOS Command string }„      INDENT       : string;                        { Report Indention string }„      GARB         : string[6];                        { extraneous device id }„      PRIORAN      : STR12;                              { Prior Archive Name }„      DirInfo      : SearchRec;                       { File name search type }„      SR           : SearchRec;„      DT           : DateTime;„      PATH         : PathStr;„      DIR          : DirStr;„      FNAME        : NameStr;„      EXT          : ExtStr;„      Regs         : Registers;„      Temp         : String[1];„      BUFF         : array[1..BSize] of Byte;„      IB           : InfoBuffer;„      S            : string[11];„      SNAME        : string[12];„„Var I,J,K : LongInt;„(**************************** ARJ Files Processing ***************************)„Type  AHMain = record                                           { ARJ Headers }„                 HeadId  : Word;                                      { 60000 }„                 BHdrSz  : Word;                          { Basic Header Size }„                 FHdrSz  : Byte;                           { File Header Size }„                 AVNo    : Byte;„                 MAVX    : Byte;„                 HostOS  : Byte;„                 Flags   : Byte;„                 SVer    : Byte;„                 FType   : Byte;                 { must be 2 for basic header }„                 Res1    : Byte;„                 DOS_DT  : LongInt;„                 CSize   : LongInt;                         { Compressed Size }„                 OSize   : LongInt;                           { Original Size }„                 SEFP    : LongInt;„                 FSFPos  : Word;„                 SEDLgn  : Word;„                 Res2    : Word;„                 NameDat : array[1..120] of char;       { start of Name, etc. }„                 Res3    : array[1..10] of char;„               end;„Var ARJ1     : AHMain;„procedure GET_ARJ_ENTRY;„begin„  FillChar(ARJ1,SizeOf(AHMain),#0); FillChar(BUFF,BSize,#0);„  Seek (F,C-1); BlockRead(F,BUFF,BSIZE,RES);        { read header into buffer }„  Move (BUFF[1],ARJ1,SizeOf(AHMain)); FSize := 0;„  with ARJ1 do„    begin„      if BHdrSz > 0 then„        begin„          I := 1; SNAME := B40;„          while NameDat[I] > #0 do Inc (I);       { scan for end of file name }„          Move (NameDat[1],SNAME[1],I-1); SNAME[0] := Chr(I-1);„          FSize := BHdrSz+CSize;„          if FType = 2 then FSize := BHdrSz;„          if BHdrSz = 0 then FSize := 0;„        end;  { if }„    end;  { with }„end;  { GET_ARJ_ENTRY }„„procedure DO_ARJ (FN : string);„begin„  Assign (F,FN); Reset (F,1); C := 1;„  GET_ARJ_ENTRY;                                        { Process file Header }„  while FSize > 0 do„    begin„      Inc(C,FSize+10); GET_ARJ_ENTRY;                         { get file info }„      if FSize > 0 then„        begin„          with ARJ1 do„            begin„              FSplit (SNAME,DIR,FNAME,EXT);„              if Length(EXT) <= 0 then EXT := '    ';„              while Pos(#00,FNAME) > 0 do FNAME[Pos(#00,FNAME)] := ' ';„              F := Copy(FNAME+B40,1,8); E := Copy(EXT+'    ',1,4);„              SIZE := OSize; RTYPE := 4; D_T := DOS_DT;„              ANUM := ADX; VNUM := VDX;„            end;„        end;  { if }„    end;  { while }„  Close (F);„end;  { DO_ARJ }„„                                                        18     05-25-9408:25ALL                      JOHN SHIPLEY             Zip Viewer               SWAG9405            119    ÆQ   {------8<-------------Snip---------------8<------------Snip------------8<-------}„{$I-}„UNIT zipviewu;„„(*/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\/\/\/\/\/\/\/\*)„(* Unit : Zip View                    Date : March 23, 1994                  *)„(* By   : John Shipley                Ver  : 1.0                             *)„(*                                                                           *)„(* Credits : Steve Wierenga - ZIPV.PAS found in SWAG - Got me started on the *)„(*           zipviewu code since ZIPV.PAS was fairly easy to read unlike     *)„(*           some other code I had seen.                                     *)„(*                                                                           *)„(*           Tom Guinther - ZIPPER.PAS found in ZIPPER.ZIP (1989) available  *)„(*           on my BBS "The Brook Forest Inn 714-951-5282" This code helped  *)„(*           clarify many things. The zipper code is probably better than    *)„(*           this code and well documented.                                  *)„(*                                                                           *)„(*           PkWare's APPNOTE.TXT found in PKZ110.EXE                        *)„(*                                                                           *)„(* This unit is offered to the Public Domain so long as credit is given      *)„(* where credit is due. I accept NO liablity for what this code does to your *)„(* system or your friends or anyone elses. You have the code, so you can fix *)„(* it. If this code formats your hard drive and you loose your lifes work,   *)„(* then all I can say is "Why didn't you back it up?"                        *)„(*                                                                           *)„(* Purpose: To mimic "PKUNZIP -v <filename>" output. (v2.04g)                *)„(*          The code is pretty close to the purpose, but not perfect.        *)„(*                                                                           *)„(* Demo :                                                                    *)„(*                                                                           *)„(* PROGRAM zip_viewit;                                                       *)„(* USES DOS,CRT,zipviewu;                                                    *)„(* BEGIN                                                                     *)„(*   IF PARAMCOUNT<>0 THEN                                                   *)„(*     BEGIN                                                                 *)„(*       zipview(PARAMSTR(1));                                               *)„(*     END;                                                                  *)„(* END.                                                                      *)„(*/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\/\/\/\/\/\/\/\*)„„INTERFACE„„USES DOS,CRT;„„PROCEDURE zipview(zipfile: STRING);„„IMPLEMENTATION„„CONST hexdigit : ARRAY[0..15] OF CHAR = '0123456789abcdef';„„FUNCTION hexbyte(b: byte): STRING;                        (* Byte to Hexbyte *)„  BEGIN„    hexbyte := hexdigit[b SHR 4]+hexdigit[b AND $f];„  END;„„FUNCTION hexlong(l: LONGINT): STRING;                  (* Longint to Hexlong *)„  VAR n : ARRAY[1..4] OF BYTE ABSOLUTE l;„  BEGIN„    hexlong := hexbyte(n[4])+hexbyte(n[3])+hexbyte(n[2])+hexbyte(n[1]);„  END;„„FUNCTION lenn(s: STRING): INTEGER;     (* Like LENGTH, but skips color codes *)„  VAR i,len : INTEGER;„  BEGIN„    len := LENGTH(s);„    i := 1;„    WHILE (i<=LENGTH(s)) DO„      BEGIN„        IF (s[i] IN [#3,'^']) THEN„          IF (i<LENGTH(s)) THEN„            BEGIN„              DEC(len,2);„              INC(i);„            END;„        INC(i);„      END;„    lenn := len;„  END;„„FUNCTION mln(s: STRING; l: INTEGER): STRING;                 (* Left Justify *)„  BEGIN„    WHILE (lenn(s)<l) DO s := s+' ';„    IF (lenn(s)>l) THEN„      REPEAT„        s := COPY(s,1,LENGTH(s)-1)„      UNTIL (lenn(s)=l) OR (LENGTH(s)=0);„    mln := s;„  END;„„FUNCTION mrn(s: STRING; l: INTEGER): STRING;                (* Right Justify *)„  BEGIN„    WHILE lenn(s)<l DO s := ' '+s;„    IF lenn(s)>l THEN s := COPY(s,1,l);„    mrn := s;„  END;„„FUNCTION cstr(i: LONGINT): STRING;         (* convert integer type to string *)„  VAR c : STRING[16];„  BEGIN„    STR(i,c);„    cstr := c;„  END;„„FUNCTION tch(s: STRING): STRING;                          (* Ensure 2 Digits *)„  BEGIN„    IF (LENGTH(s)>2) THEN s := COPY(s,LENGTH(s)-1,2)„    ELSE IF (LENGTH(s)=1) THEN s := '0'+s;„    tch := s;„  END;„„FUNCTION b2attr(a,g: BYTE): STRING;                     (* Byte to Attribute *)„  VAR attr : STRING[5];„  BEGIN„    attr := '--w- ';„    IF (g AND 1)=1 THEN attr[5]:='*';                          (* Encrypted? *)„    IF (a AND 1)=1 THEN attr[3]:='r';                          (* Read Only? *)„    IF (a AND 2)=2 THEN attr[2]:='h';                             (* Hidden? *)„    IF (a AND 4)=4 THEN attr[1]:='s';                             (* System? *)„    IF (a AND 8)=8 THEN attr[4]:='?';                (* Unknown at this time *)„    b2attr := attr;„  END;„„FUNCTION w2date(d: WORD): STRING;                            (* Word to Date *)„  VAR s : STRING;„  BEGIN„    s := tch(cstr((d SHR 5) AND 15 ))+'-'+                          (* Month *)„         tch(cstr((d      ) AND 31 ))+'-'+                            (* Day *)„         tch(cstr(((d SHR 9) AND 127)+80));                          (* Year *)„    w2date := s;„  END;„„FUNCTION w2time(t: WORD): STRING;                            (* Word to Time *)„  VAR s : STRING;„  BEGIN„    s := tch(cstr((t SHR 11) AND 31))+':'+                           (* Hour *)„         tch(cstr((t SHR  5) AND 63));                             (* Minute *)„    w2time := s;„  END;„„PROCEDURE zipview(zipfile: STRING);                     (* View the ZIP File *)„  CONST lsig = $04034B50;                                 (* Local Signature *)„        csig = $02014b50;                               (* Central Signature *)„  TYPE lheader = RECORD                                      (* Local Header *)„                   signature  : LONGINT;      (* local file header signature *)„                   version,                                (* version mad by *)„                   gpflag,                          (* general purpose flags *)„                   compress,                           (* compression method *)„                   time,date  : WORD;         (* last mod file time and date *)„                   crc32,                                          (* crc-32 *)„                   csize,                                 (* compressed size *)„                   usize      : LONGINT;                (* uncompressed size *)„                   fnamelen,                              (* filename length *)„                   extrafield : WORD;                  (* extra field length *)„                 END;„       cheader = RECORD                                    (* Central Header *)„                   signature  : LONGINT;    (* central file header signature *)„                   version    : WORD;                     (* version made by *)„                   vneeded    : WORD;           (* version needed to extract *)„                   gpflag     : ARRAY[1..2] OF BYTE;(* general purpose flags *)„                   compress   : WORD;                  (* compression method *)„                   time       : WORD;                  (* last mod file time *)„                   date       : WORD;                  (* last mod file date *)„                   crc32      : LONGINT;                           (* crc-32 *)„                   csize      : LONGINT;                  (* compressed size *)„                   usize      : LONGINT;                (* uncompressed size *)„                   fnamelen   : WORD;                     (* filename length *)„                   extrafield : WORD;                  (* extra field length *)„                   fcl        : WORD;                 (* file comment length *)„                   dns        : WORD;                   (* disk number start *)„                   ifa        : WORD;            (* internal file attributes *)„                   efa        : ARRAY[1..4] OF BYTE;   (* external file attr *)„                   roolh      : LONGINT;  (* relative offset of local header *)„                 END;„„VAR z          : INTEGER;               (* Number of files processed counter *)„    totalu,                              (* Total bytes that were compressed *)„    totalc     : LONGINT;          (* result of total bytes being compressed *)„    hdr        : ^cheader;            (* temporary cental header file record *)„    f          : FILE;                                           (* file var *)„    s          : STRING;                          (* archive filename string *)„    percent    : BYTE;           (* Temporary var holding percent compressed *)„    numfiles   : WORD;                         (* Number of files in archive *)„„CONST comptypes : ARRAY[0..8] OF STRING[7] =            (* Compression Types *)„                  ('Stored ',                              (* Not Compressed *)„                   'Shrunk ',                                      (* Shrunk *)„                   'Reduce1',                                   (* Reduced 1 *)„                   'Reduce2',                                   (* Reduced 2 *)„                   'Reduce3',                                   (* Reduced 3 *)„                   'Reduce4',                                   (* Reduced 4 *)„                   'Implode',                                    (* Imploded *)„                   'NotSure',                        (* Unknown at this time *)„                   'DeflatN');                                   (* Deflated *)„„FUNCTION seekc(VAR f: FILE): BOOLEAN;„  VAR curpos  : LONGINT;                           (* current file position *)„      buf     : lheader;                   (* Temporary local header record *)„      ioerror : INTEGER;                       (* Temporary IOResult holder *)„      result  : WORD;                                   (* Blockread Result *)„  BEGIN„    seekc := FALSE;                                           (* init seekc *)„    curpos := 0;                              (* init current file position *)„    SEEK(f,0);                                        (* goto start of file *)„    BLOCKREAD(f,buf,SIZEOF(lheader),result);     (* Grab first local header *)„    ioerror := IORESULT;                                  (* Test for error *)„    WHILE (ioerror = 0) AND (buf.signature=lsig) DO (* Test if OK..continue *)„      BEGIN„        INC(numfiles);                         (* Increment number of files *)„        WITH buf DO                             (* Find end of local header *)„          curpos := FILEPOS(f)+fnamelen+extrafield+csize;„        SEEK(f,curpos);                         (* Goto end of local header *)„        BLOCKREAD(f,buf,SIZEOF(lheader),result);  (* Grab next local header *)„        ioerror := IORESULT;                              (* Test for error *)„      END;„      IF ioerror<>0 THEN EXIT;               (* If error then exit function *)„      IF (buf.signature=csig) THEN (* Did we find the first central header? *)„        BEGIN„          seekc := TRUE;                      (* Found first central header *)„          SEEK(f,curpos); (* Ensure we are at central headers file position *)„        END;„  END;„„  VAR curpos : LONGINT;„„  BEGIN„    numfiles := 0;      (* Counter of Number of Files to Determine When Done *)„    z        := 0;                   (* Counter of Number of Files Processed *)„    totalu   := 0;                      (* Total Bytes of Uncompressed Files *)„    totalc   := 0;                      (* Total Size after being Compressed *)„    NEW(hdr);        (* Dynamically Allocate Memory for a Temp Header Record *)„    ASSIGN(f,zipfile);                        (* Assign Filename to File Var *)„    {$I-}„    RESET(f,1);                                         (* Open Untyped File *)„    {$I+}„    IF IORESULT<>0 THEN                  (* If we get an error, exit program *)„      BEGIN„        WRITELN('Error - File not found.');„        HALT(253);„      END;„    IF NOT seekc(f) THEN (* Skip Local Headers and goto first Central Header *)„      BEGIN                       (* If we could not locate a Central Header *)„        CLOSE(f);                                      (* Close Untyped File *)„        WRITELN('Error - Corrupted or Not a ZIP File.');„        HALT(254);                                           (* Exit Program *)„      END;„„    WRITELN(' Length  Method   Size  Ratio   Date    Time    CRC-32 '+„      ' Attr  Name');„    WRITELN(' ------  ------   ----- -----   ----    ----   --------'+„      ' ----  ----');„    REPEAT„      FILLCHAR(s,SIZEOF(s),#0);                         (* Clear Name String *)„      BLOCKREAD(f,hdr^,SIZEOF(cheader));                 (* Read File Header *)„      BLOCKREAD(f,MEM[SEG(s):OFS(s)+1],hdr^.fnamelen);  (* Read Archive Name *)„      s[0] := CHR(hdr^.fnamelen);                 (* Get Archive Name Length *)„      IF (hdr^.signature=csig) THEN                           (* Is a header *)„        BEGIN„          INC(z);                                  (* Increment File Counter *)„          WRITE(mrn(cstr(hdr^.usize),7));       (* Display Uncompressed Size *)„          WRITE(' '+mrn(comptypes[hdr^.compress],7));  (* Compression Method *)„          WRITE(mrn(cstr(hdr^.csize),8));         (* Display Compressed Size *)„          percent := ROUND(100.0-(hdr^.csize/hdr^.usize*100.0));„          WRITE(mrn(cstr(percent),4)+'% ');   (* Display Compression Percent *)„          WRITE(' '+w2date(hdr^.date)+' ');    (* Display Date Last Modified *)„          WRITE(' '+w2time(hdr^.time)+' ');    (* Display Time Last Modified *)„          WRITE(' '+hexlong(hdr^.crc32)+' ');       (* Display CRC-32 in Hex *)„          WRITE(b2attr(hdr^.efa[1],hdr^.gpflag[1]));   (* Display Attributes *)„          WRITELN(' '+mln(s,13));                (* Display Archive Filename *)„          INC(totalu,hdr^.usize);             (* Increment size uncompressed *)„          INC(totalc,hdr^.csize);               (* Increment size compressed *)„        END;„      SEEK(f,FILEPOS(f)+hdr^.extrafield+hdr^.fcl);„    UNTIL (hdr^.signature<>csig) OR EOF(f) OR (z=numfiles); (* No more Files *)„    WRITELN(' ------          ------  ---                                 '+„      ' -------');„    WRITE(mrn(cstr(totalu),7)+'         ');    (* Display Total Uncompressed *)„    WRITE(mrn(cstr(totalc),7)+' ');              (* Display Total Compressed *)„    WRITE((100-TotalC/TotalU*100):3:0,'%'+mrn(' ',34));   (* Display Percent *)„    WRITELN(mrn(cstr(z),7));                      (* Display Number of Files *)„    CLOSE(f);                                          (* Close Untyped File *)„    DISPOSE(hdr);                            (* Deallocate Header Var Memory *)„  END;„„END.„                                            19     05-26-9407:31ALL                      SCOTT BAKER              Zip File Viewer          SWAG9405            42     ÆQ   unit ZipView;„„interface„uses dos;„„type„ barray= array[1..8192] of byte;„ ZipPtr=^ZipRec;„ ZipRec= Record„          version_made: word;„          version_extr: word;„          flags: word;„          comp_method: word;„          last_mod_time: word;„          last_mod_date: word;„          crc_32: longint;„          compressed_size: longint;„          uncompressed_size: longint;„          fname_length: word;„          extra_length: word;„          comment_length: word;„          disk_num_start: word;„          internal_attr: word;„          external_attr: longint;„          rel_ofs: longint;„          name: string[12];„          Next: ZipPtr;„         end;„ bptr = ^barray;„const„ ZipMethod: array[0..9] of string[15] =„           ('stored   ',          'shrunk   ',       'reduced-1',„            'reduced-2',          'reduced-3',       'reduced-4',„            'imploded ',          'unknown  ',       'unknown  ',„            'unknown  ');„„var„ totallength,totalsize,numfiles: longint;„ firstzip: zipptr;„ lineout: string;„ outPtr: pointer;„„procedure LoadZip(filename: string);„procedure DisplayZip;„procedure DisposeZip;„„implementation„„var„ f: file of barray;„ buffer: barray;„ addr: longint;„ bufptr: word;„„{$F+}„Procedure CallProc;„inline($FF/$1E/OutPtr);„{$F-}„„Function NextByte: byte;„var i: integer;„begin;„ inc(addr);„ inc(bufptr);„ if bufptr=8193 then begin;„  {$I-}„  read(f,buffer);„  {$I+}„  i:=ioresult;„  bufptr:=1;„ end;„ nextbyte:=buffer[bufptr];„end;„„procedure LoadZip(filename: string);„var„ b: byte;„ f2: file of byte;„ fs: longint;„ LastZip,Zip: ZipPtr;„ Bytes: Bptr absolute zip;„ a: integer;„ sr: searchrec;„begin;„ firstzip:=nil;„{ assign(f2,filename);„ reset(F2);„ fs:=filesize(f2);„ close(f2);}„ findfirst(filename,anyfile,sr);„ fs:=sr.size;„ assign(f,filename);„ reset(f);„ addr:=0;„ if fs>65535 then begin;„  seek(f,(fs div 8192)-4);„  addr:=addr+((fs div 8192)-4)*8192;„ end;„ {$I-}„ read(f,buffer);„ {$I+}„ a:=ioresult;„ bufptr:=0;„ b:=nextbyte;„ repeat;„  if b=$50 then begin;„   b:=nextbyte;„   if b=$4b then begin;„    b:=nextbyte;„    if b=$01 then begin;„     b:=nextbyte;„     if b=$02 then begin;„      new(zip);„      zip^.next:=nil;„      if firstzip=nil then firstzip:=zip else lastzip^.next:=zip;„      lastzip:=zip;„      for a:=1 to 42 do bytes^[a]:=nextbyte;„      zip^.name:='';„      for a:=1 to zip^.fname_length do zip^.name:=zip^.name+chr(nextbyte);„      b:=nextbyte;„     end;„    end;„   end;„  end else b:=nextbyte;„ until addr>=fs;„end;„„procedure OutLine(s: string);„begin;„ lineout:=s;„ if OutPtr=NIL then writeln(s) else CallProc;„end;„„function format_date(date: word): string;„var„ s,s2: string;„ y,m,d: word;„begin„ m:=(date shr 5) and 15;„ d:=( (date      ) and 31);„ y:=(((date shr 9) and 127)+80);„ str(m,s);„ while length(s)<2 do s:='0'+s;„ s:=s+'-';„ str(d,s2);„ while length(s2)<2 do s2:='0'+s2;„ s:=s+s2+'-';„ str(y,s2);„ while length(s2)<2 do s2:='0'+s2;„ s:=s+s2;„ format_date:=s;„end;„„function format_time(time: word): string;„var„ s,s2: string;„ h,m,se: word;„begin„ h:=(time shr 11) and 31;„ m:=(time shr  5) and 63;„ se:=(time shl  1) and 63;„ str(h,s);„ while length(S)<2 do s:='0'+s;„ s:=s+':';„ str(m,s2);„ while length(s2)<2 do s2:='0'+s2;„ s:=s+s2;„ format_time:=s;„end;„„procedure DisplayHeader;„begin;„ OutLine('Filename      Length   Size     Method     Date      Time   Ratio');„ OutLine('------------  -------  -------  ---------  --------  -----  -----');„end;„„procedure DisplayFooter;„var„ s,s2: string;„ average: real;„begin;„ OutLine('------------  -------  -------                              -----');„ average:=100-totalsize/totallength*100;„ str(numfiles:12,s);„ str(totallength:7,s2);„ s:=s+'  '+s2+'  ';„ str(totalsize:7,s2);„ s:=s+s2+'                              ';„ str(average:4:0,s2);„ s:=s+s2+'%';„ outline(s);„end;„„procedure DisplayZip;„var„ curzip: zipptr;„ s,s2: string;„begin;„ numfiles:=0;„ totallength:=0;„ totalsize:=0;„ DisplayHeader;„ curzip:=firstzip;„ while curzip<>nil do begin;„  s:=curzip^.name;„  while length(s)<14 do s:=s+' ';„  str(curzip^.uncompressed_size,s2);„  while length(s2)<7 do s2:=' '+s2;„  s:=s+s2+'  ';„  str(curzip^.compressed_size,s2);„  while length(s2)<7 do s2:=' '+s2;„  s:=s+s2+'  ';„  s:=s+ZipMethod[curzip^.comp_method]+'  ';„  s:=s+format_date(curzip^.last_mod_date)+'  '+format_time(curzip^.last_mod_time)+'  ';„  str(100-curzip^.compressed_size/curzip^.uncompressed_size*100:1:1,s2);„  s2:=s2+'%';„  while length(s2)<5 do s2:=' '+s2;„  s:=s+s2;„  Outline(s);„  totallength:=totallength+curzip^.uncompressed_size;„  totalsize:=totalsize+curzip^.compressed_size;„  inc(numfiles);„  curzip:=curzip^.next;„ end;„ if (numfiles=0) or (totallength=0) or (totalsize=0) then begin;„  outline('No valid file entries detected.');„ end else begin;„  displayfooter;„ end;„end;„„procedure DisposeZip;„var„ curzip,savezip: zipptr;„begin;„ curzip:=firstzip;„ while curzip<>nil do begin;„  savezip:=curzip^.next;„  dispose(curzip);„  curzip:=savezip;„ end;„end;„„begin;„ OutPtr:=Nil;„end.„„{ --------------------------   CUT HERE -----------------------------}„{ TEST PROGRAM }„„uses zipview;„„var„ s: string;„begin;„ write('File to Zip-View ? ');„ readln(s);„ LoadZip(s);„ DisplayZip;„ DisposeZip;„end.