SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00021         CRT ROUTINES                                                      1      05-28-9313:36ALL                      SWAG SUPPORT TEAM        XY Cursor Position in ASMIMPORT              15     ﬁÆZ‚ {„> If anyone is interested in the BAsm GotoXY/WhereX/WhereY routines„> I'll be happy to post them.   They use standard BIOS routines, and„„I simply followed an Interrupt listing I had to create these Functions.„„Note the DEC commands in GotoXY, and the INC command in Each WHERE* Function.„These are there to make the Procedures/Functions Compatible With the TP Crt„routines, which are 1-based.  (ie: 1,1 in TP.Crt is upper left hand corner).„The BIOS routines need to be given 0,0 For the same coordinates.   If you don't„want to remain Compatible With Turbo's GotoXY and WHERE* Functions, delete them„out and keep your code Zero-based For X/Y screen coords.„}„„Procedure GotoXY(X,Y : Byte); Assembler; Asm„  MOV DH, Y    { DH = Row (Y) }„  MOV DL, X    { DL = Column (X) }„  DEC DH       { Adjust For Zero-based Bios routines }„  DEC DL       { Turbo Crt.GotoXY is 1-based }„  MOV BH,0     { Display page 0 }„  MOV AH,2     { Call For SET CURSOR POSITION }„  INT 10h„end;„„Function  WhereX : Byte;  Assembler;„Asm„  MOV     AH,3      {Ask For current cursor position}„  MOV     BH,0      { On page 0 }„  INT     10h       { Return inFormation in DX }„  INC     DL        { Bios Assumes Zero-based. Crt.WhereX Uses 1 based }„  MOV     AL, DL    { Return X position in AL For use in Byte Result }„end;„„Function WhereY : Byte; Assembler;„Asm„  MOV     AH,3     {Ask For current cursor position}„  MOV     BH,0     { On page 0 }„  INT     10h      { Return inFormation in DX }„  INC     DH       { Bios Assumes Zero-based. Crt.WhereY Uses 1 based }„  MOV     AL, DH   { Return Y position in AL For use in Byte Result }„end;„„{„Note that the WhereX and WhereY Function call the exact same Bios function.„}„                                                                                       2      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Set EGA/VGA Blink Bit    IMPORT              13     ﬁÆ ƒ „  Hi, Rolfi:„„RM>Anybody know and easy way to do DarkGrey for a bkgrnd???„„  ...You have to turn off the "blink-bit", if possible. This is„  only available for CGA and EGA/VGA color text modes.„„  (***** Turn the "blink-bit" on/off to allow 16 different background *)„  (*     colors. (CGA ONLY!)                                          *)„  (*                                                                  *)„  procedure SetBlinkCGA({input } TurnOn : boolean);„  begin„    if TurnOn then„      begin„        mem[$0040:$0065] := (mem[$0040:$0065] AND (NOT $20));„        port[$3D8] := $29„      end„    else„      begin„        mem[$0040:$0065] := (mem[$0040:$0065] OR $20);„        port[$3D8] := $09„      end„  end;        (* SetBlinkCGA.                                         *)„„„  (***** Turn the "blink-bit" on/off to allow 16 different background *)„  (*     colors. (EGA or VGA ONLY!)                                   *)„  (*                                                                  *)„  procedure SetBlinkEGAVGA({input } TurnOn : boolean);„  begin„    asm„      mov ax, 1003h„      mov bl, TurnOn„      int 10h„    end„  end;        (* SetBlinkEGAVGA.                                      *)„„                               - Guy„---„ ˛ DeLuxe˝/386 1.25 #5060 ˛„ * Rose Media, Toronto, Canada : 416-733-2285„ * PostLink(tm) v1.04  ROSE (#1047) : RelayNet(tm)„„                                                                                                                                                       3      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Clear CRT Screen FAST    IMPORT              3      ﬁÆ – {„>Does anyone know how to clear the screen Really fast ?„Well, here is some Asm code but I haven't tested it. It should work:„}„„Procedure FastClrScr; Assembler;„Asm„  MOV AH,0Fh„  INT 10h„  MOV AH,0„  INT 10h„end;„„begin„  FastClrScr;„end.               4      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Clear VGA Screen         IMPORT              6      ﬁÆ»j {„>> Does anyone know how to clear the screen Really fast ?„>> I'm working in VGA-mode With a resolution of 320*200*256„> You could try a block rewriting of the palettes, but that would probably„> take even longer, since it is usually an interrupt instruction.„„Well, use the standard pascal routine called FillChar. ;-)„}„„FillChar(Mem[$A000:$0000],320*200,0);„„{ You can double speed by using 16 bit wide data transfer: }„„Procedure FillChar16(Var X;Count : Word;Value : Byte); Assembler;„Asm„  les   di,X„  mov   cd,Count„  shr   cx,1„  mov   al,Value„  mov   ah,al„  rep   stosw„  test  Count,1„  jz    @end„  stosb„@end:„end;„„        5      05-28-9313:36ALL                      SWAG SUPPORT TEAM        CPU Delay                IMPORT              4      ﬁÆQè {„> does anyone have an accurate BAsm Delay routine that is„> compatible With the one in the Crt Unit? please post it...„}„„Procedure Delay(ms : Word); Assembler;„Asm {machine independent Delay Function}„  mov ax, 1000;„  mul ms;„  mov cx, dx;„  mov dx, ax;„  mov ah, $86;„  int $15;„end;„                                                                                               6      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Reading Keys             IMPORT              5      ﬁÆwM {„> Could someone please post an Asm equivalent of„> Repeat Until KeyPressed;„„Well, here it is using the Dos Unit instead of the Crt....  :)„}„Uses Dos;„Var„  r : Registers;„„Function _ReadKey : Char;„begin„  r.ax := $0700;„  intr($21, r);„  _ReadKey := chr(r.al);„end;„„Function _KeyPressed : Boolean;„begin„  r.ax := $0b00;„  intr($21,r);„  if r.al = 255 then„    _KeyPressed := True„  else„    _KeyPressed := False;„end;„begin„  Repeat Until _keypressed;„end.                                                 7      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Check KEYPRESS           IMPORT              15     ﬁÆiL {„To the person that posted the message about using KeyPressed or anyone„else interested. Below is a Function that I have used to read keyboard input„that is similiar to KeyPressed.  It does a KeyPressed and ReadKey all in one„statement.  If you are familiar With BASIC this InKey Function is similiar„to the one in BASIC in that is doesn't sit and wait For input.  The KeyEnh„Function just returns True/False depending on whether or not it detected„an Enhanced keyboard. SHIFT, CTRL, and ALT are global Boolean Variables„which value reflect the state of these keys involved in the the keypress.„}„„Uses„  Dos;„„Function KeyEnh:  Boolean;„Var„  Enh:  Byte Absolute $0040:$0096;„„begin„  KeyEnh := False;„  if (Enh and $10) = $10 then„    KeyEnh := True;„end;„„Function InKey(Var SCAN, ASCII:  Byte): Boolean;„Var„  i     :  Integer;„  Shift,„  Ctrl,„  Alt   : Boolean;„  Temp,„  Flag1 : Byte;„  HEXCH,„  HEXRD,„  HEXFL : Byte;„  reg   : Registers;„„begin„  if KeyEnh then„  begin„    HEXCH := $11;„    HEXRD := $10;„    HEXFL := $12;„  end„  else„  begin„    HEXCH := $01;„    HEXRD := $00;„    HEXFL := $02;„  end;„„  reg.ah := HEXCH;„  Intr($16, reg);„  i := reg.flags and FZero;„„  reg.ah := HEXFL;„  Intr($16, reg);„  Flag1 := Reg.al;„  Temp  := Flag1 and $03;„„  if Temp = 0 then„    SHIFT := False„  ELSE„    SHIFT := True;„„  Temp  := Flag1 and $04;„  if Temp = 0 then„    CTRL := False„  ELSE„    CTRL := True;„„  Temp  := Flag1 and $08;„  if Temp = 0 Then„    ALT  := False„  ELSE„    ALT  := True;„„  if i = 0 then„  begin„    reg.ah := HEXRD;„    Intr($16, reg);„    scan  := reg.ah;„    ascii := reg.al;„    InKey := True;„  end„  else„    InKey := False;„end;„„„Var„  Hi, Hi2 : Byte;„„begin„  Repeat Until InKey(Hi,Hi2);„  Writeln(Hi);„  Writeln(Hi2);„end.                       8      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Readkey and KEYPRESS     IMPORT              7      ﬁÆH- {„Crt Unit, but I don't want to use the Crt.  Could some one show„me a routine For Pause, or Delay With a Time Factor?„„  ...I can supply you With KeyPressed and ReadKey routines For„  TP6 or TP7, which could be used to create a Pause routine.„  The Delay is a bit harder, I've got a routine I wrote last„  year For this, but I'm still not happy With it's accuracy.„}„„{ Read a key-press. }„Function ReadKeyChar : {output} Char; Assembler;„Asm„  mov ah, 00h„  int 16h„end; { ReadKeyChar. }„„{ Function to indicate if a key is in the keyboard buffer. }„Function KeyPressed : {output} Boolean; Assembler;„Asm„  mov ah, 01h„  int 16h„  mov ax, 00h„  jz #1„  inc ax„  @1:„end; { KeyPressed. }„                                                                               9      05-28-9313:36ALL                      SWAG SUPPORT TEAM        Small CRT Replacement    IMPORT              30     ﬁÆÓÌ Unit sCrt;„„{„„  by Trevor J Carlsen„     PO Box 568„     Port Hedland„     Western Australia 6721„     Phone -„       Voice: 61 91 732026„       Data : 61 91 732569„„   This little Unit is intended to replace the Crt Unit in Programs that do„   not require many of that Units Functions.  As a result the resulting .exe„   code is much smaller.„„   Released into the public domain 1989„„}„„Interface„„Function KeyPressed: Boolean;„  { Returns True if there is a keystroke waiting in the key buffer           }„„Procedure ClrScr;„  { Clears the screen and homes the cursor                                   }„„Procedure ClrKey;„  { Flushes the keystroke buffer                                             }„„Function KeyWord : Word;„    Inline  ($B4/$00/   {mov  ah,0}„             $CD/$16);  {int  16h}„  { Waits For a keypress and returns a Word containing the scancode and      }„  { ascii code For the KeyPressed                                            }„„Function ExtKey(Var k : Char; Var s : Byte): Boolean;„  { Gets next keystroke from the keystroke buffer. if it was an Extended key }„  { (ie. Function key etc.) returns True and k contains the scan code. if a  }„  { normal key then returns False and k contains the Character and s the scan}„  { code                                                                     }„„Function ReadKey: Char;„  { Gets next keystroke from the buffer. if Extended key returns #0          }„„Function NextKey: Char;„  { Flushes the keystroke buffer and then returns the next key as ReadKey    }„„Function PeekKey: Char;„  { Peeks at the next keypress in the buffer without removing it             }„„Procedure Delay(s : Word);„  { Machine independent Delay loop For s seconds                             }„„Procedure GotoXY(x,y : Byte);„  { Moves the cursor to X, y coordinates                                     }„„{ -------------------------------------------------------------------------- }„„Implementation„„Uses Dos;„„Var„  head : Word    Absolute $0040:$001A;„  tail : Word    Absolute $0040:$001C;„  time : LongInt Absolute $0040:$006C;„  regs : Registers;„„Function KeyPressed: Boolean;„  begin„    KeyPressed := (tail <> head);„  end;„„Procedure ClrScr;                                     { 25 line display only }„ begin„   Inline($B4/$06/$B0/$19/$B7/$07/$B5/$00/$B1/$00/$B6/$19/$B2/$4F/„          $CD/$10/$B4/$02/$B7/$00/$B2/$00/$B6/$00/$CD/$10);„ end;„„Procedure ClrKey;„  begin„    head := tail;„  end;„„„Function ExtKey(Var k : Char; Var s : Byte): Boolean;„„  Var„    keycode : Word;„    al      : Byte;„    ah      : Byte;„„  begin„    ExtKey    := False;„    Repeat„      keycode := KeyWord;„      al      := lo(keycode);„      ah      := hi(keycode);„      if al = 0 then begin„        ExtKey := True;„        al     := ah;„      end;„  Until al <> 0;„  k := chr(al);„  s := al;„end;    {ExtKey}„„Function ReadKey : Char;„  Var„    Key : Byte;„  begin„    Key := lo(KeyWord);„    ReadKey := Char(Key);„  end;„„Function NextKey : Char;„  begin„    tail := head;„    NextKey := ReadKey;„  end;„„Function PeekKey : Char;„  begin„    PeekKey := Char(Mem[$40:head]);„  end;„„Procedure Delay(s : Word);„  Var„    start    : LongInt;„    finished : Boolean;„  begin„    start := time;„    Repeat„      if time < start then    { midnight rollover occurred during the period }„        dec(start,$1800B0);„      finished := (time > (start + s * 18.2));„    Until finished;„  end;„„Procedure GotoXY(x,y : Byte);„  begin„    With regs do begin„      ah := $02;„      bh := 0;„      dh := pred(y);„      dl := pred(x);„      intr($10,regs);„    end; { With }„  end;   { GotoXY }„„end.„ „„„                                                                        10     09-26-9309:07ALL                      ROBERT ROTHENBURG        GUI - CRT Replacement    IMPORT              117    ﬁÆÖö (*„===========================================================================„ BBS: Beta Connection„Date: 09-21-93 (09:28)             Number: 2846„From: ROBERT ROTHENBURG            Refer#: 2648„  To: GAYLE DAVIS                   Recvd: YES (PVT)„Subj: SWAG Submission  (Part 1)      Conf: (232) T_Pascal_R„---------------------------------------------------------------------------„->#643„„Gayle,„„        Here's the GUI Unit I mentioned that I would submit for the SWAG„        reader a while back.„„        There's no documentation and a few things could be touched up,„        but it works.„„*)„„Unit GUI; (* Video and GUI Routines *)„„Interface„„Const„  NormalCursor = $0D0E; (* Might be different on some systems *)„  BlankCursor  = $2000;„„Type„  ScrBuffer   = Array [0..1999] Of Word; (* Screen Buffer *)„„Var„  DirectVideoGUI: Boolean; (* define as TRUE if direct-video writing *)„  Screen: Array [0..7] Of ScrBuffer Absolute $B800: 0000;„„Procedure SetActivePage (Page: Byte);„Procedure ScrollWindowUp (NoLines, Attrib, ColUL, RowUL, ColLR, RowLR: Byte);„Procedure ScrollWindowDn (NoLines, Attrib, ColUL, RowUL, ColLR, RowLR: Byte);„Procedure HLineCharAttrib (Page: Byte; CharAttrib: Word; xFrom, xTo, Y: Byte);„Procedure VLineCharAttrib (Page: Byte; CharAttrib: Word; X, yFrom, yTo: Byte);„Function  GetCharAttribXY (Page, X, Y: Byte): Word;„Function  GetCharAttrib (Page: Byte): Word;„Procedure PutCharAttrib (Page: Byte; CharAttrib: Word; NoChar: Word);„Procedure WriteChar (Page: Byte; CharAttrib: Word; NoChar: Word);„Procedure CWriteXY (Page, attrib, X, Y: Byte; n: String);„Procedure WriteXY (Page, attrib, X, Y: Byte; Var n: String);„Procedure WriteXYCh (Page, attrib, X, Y, c: Byte);„Procedure SetCursorPos (Page, Column, Row: Byte);„Procedure GetCursorPos (Var Page, Column, Row: Byte);„Procedure SetCursorType (ctype: Word);„Function  GetCursorType (Page: Byte): Word;„„Procedure InitDirect;„Procedure SavScr (Page: Byte; Var S: ScrBuffer);„Procedure ResScr (Page: Byte; Var S: ScrBuffer);„„Function  GetKeyCode: Word; (* Wait for Key from Buffer *)„Function  GetKeyFlags: Byte;„Function  PollKey (Var Status: Word): Word;„Function  GetKeyStroke: Word;  (* Enhanced Keyboard? *)„Function  CheckKeyBoard: Word; (* Enhanced Keyboard? *)„Procedure WriteKey (KeyCode: Word; Var Status: Byte);„„Procedure WaitOnUser (Var Code, X, Y, Button: Word);„Function  InitMouse: Word;„Procedure ShowMouseCursor;„Procedure HideMouseCursor;„Procedure SetMouseWindow (X1, Y1, X2, Y2: Word);„Procedure GetMousePos (Var X, Y, button: Word);„Procedure SetMousePos (X, Y: Word);„Procedure GetButtonPressInfo (Var X, Y, Button, NumberOfPresses: Word);„Procedure GetButtonRelInfo (Var X, Y, Button, NumberOfReleases: Word);„„Procedure Frame (Page, X1, Y1, X2, Y2, c: Byte; Title: String);„Procedure Shadow (Page, X1, Y1, X2, Y2, cc: Byte);„Procedure FHLine (Page, Attrib, xFrom, xTo, Y: Byte);„Procedure FVLine (Page, Attrib, X, yFrom, yTo: Byte);„Procedure FrameReadLN (Var T: String; Page, X1, Y1, X2, Y2, cc: Byte);„Procedure Dialogue (Var T: String; Page, X1, Y1, X2, Y2, cc: Byte; Title: String);„„IMPLEMENTATION„„uses DOS;„„Const„  NUL    = #00;„  DEL    = #08;„  LF     = #10;„  CR     = #13;„  SP     = #32;„„  VIO    = $10;  (* BIOS Video Interrupt *)„  KBIO   = $16;  (* BIOS Keyboard        *)„  MIO    = $33;  (* Mouse Services       *)„Var X, Y: Word;„    reg: registers;„    DTemp: ScrBuffer;„„function x80(y: word): word;„begin„  asm„    MOV AX,y„    MOV BX,AX„    MOV CL,4„    SHL BX,CL„    MOV CL,6„    SHL AX,CL„    ADD AX,BX„    MOV @Result, AX„  end„end;„„function x80p(y,x: word): word;„begin„  asm„    MOV AX,y„    MOV BX,AX„    MOV CL,4„    SHL BX,CL„    MOV CL,6„    SHL AX,CL„    ADD AX,BX„    ADD AX,x„    MOV @Result, AX„  end„end;„„Procedure WriteChar (Page: Byte; CharAttrib: Word; NoChar: Word);„Begin„  Asm„    MOV AX, CharAttrib„    MOV BL, AH„    MOV AH, $0A„    MOV BH, Page„    MOV CX, NoChar„    Int VIO„  End;„End;„„Procedure PutCharAttrib (Page: Byte; CharAttrib: Word; NoChar: Word);„Begin„  Asm„    MOV AX, CharAttrib„    MOV BL, AH„    MOV AH, $09„    MOV BH, Page„    MOV CX, NoChar„    Int VIO„  End;„End;„„Function GetCharAttrib (Page: Byte): Word;„Begin„  Asm„    MOV AH, $08„    MOV BH, Page„    Int VIO„    MOV @Result, AX„  End;„End;„„Procedure InitDirect; (* CRT uses the variable "DirectVideo"... *)„Begin„  DirectVideoGUI := True„End;„„Function GetCharAttribXY (Page, X, Y: Byte): Word;„Begin„  If DirectVideoGUI„  Then GetCharAttribXY := Screen [Page] [ x80p(Y,X)]„  Else Begin„    Asm„      MOV AH, $02„      MOV BH, Page„      MOV DH, Y„      MOV DL, X„      Int VIO„      MOV AH, $08„      MOV BH, Page„      Int VIO„      MOV @Result, AX„    End„  End;„End;„„Procedure ScrollWindowUp (NoLines, Attrib, ColUL, RowUL, ColLR, RowLR: Byte);„  Assembler;„Asm„  MOV AH, $06„  MOV AL, NoLines„  MOV BH, Attrib„  MOV CH, RowUL„  MOV CL, ColUL„  MOV DH, RowLR„  MOV DL, ColLR„  Int VIO„End;„„Procedure ScrollWindowDn (NoLines, Attrib, ColUL, RowUL, ColLR, RowLR: Byte);„Begin„  Asm„    MOV AH, $07„    MOV AL, NoLines„    MOV BH, Attrib„    MOV CH, RowUL„    MOV CL, ColUL„    MOV DH, RowLR„    MOV DL, ColLR„    Int VIO„  End;„End;„„Procedure SetActivePage (Page: Byte); Assembler;„Asm„  MOV AH, $05„  MOV AL, Page„  Int VIO„End;„„Procedure GetCursorPos (Var Page, Column, Row: Byte);„Var p, X, Y: Byte;„Begin„  p := Page;„  Asm„    MOV AH, $03„    MOV BH, p„    Int VIO„    MOV p, BH„    MOV X, DL„    MOV Y, DH„  End;„  Page := p;„  Column := X;„  Row := Y;„End;„„Function GetCursorType (Page: Byte): Word;„Begin„  Asm„    MOV AH, $03;„    MOV BH, Page„    Int VIO„    MOV @Result, CX„  End;„End;„„Procedure SetCursorPos (Page, Column, Row: Byte);„Begin„  Asm„    MOV AH, $02„    MOV BH, Page„    MOV DH, Row„    MOV DL, Column„    Int VIO„  End;„End;„„Procedure SetCursorType (ctype: Word);„Begin„  Asm„    MOV AH, $01„    MOV CX, ctype„    Int VIO„  End;„End;„„Procedure WriteXYCh (Page, attrib, X, Y, c: Byte);„Begin„  If DirectVideoGUI„  Then Screen [Page] [ x80p(Y,X) ] :=„    (attrib ShL 8) + c„  Else Begin„    Asm„      MOV AH, $02„      MOV BH, Page„      MOV DL, X„      MOV DH, Y„      Int VIO„      MOV AL, c„      MOV BL, Attrib„      MOV AH, $09„      MOV CX, 1„      Int VIO„    End„  End„End;„„Procedure WriteXY (Page, attrib, X, Y: Byte; Var n: String);„Var i: byte;„Begin„  If n [0] <> #0„  Then If DirectVideoGUI„  Then Begin„    For i := 1 To Length (n)„    Do Screen [Page] [ x80p(Y,X+Pred (i)) ] := (attrib ShL 8) + Ord (n [i] );„  End„  Else Begin„   for i:=1 to Length(n)„    do„     WriteXYCh(Page,Attrib,X+pred(i),y,ord(n[i]));„End„End;„„Procedure CWriteXY (Page, attrib, X, Y: Byte; n: String);„Begin„  WriteXY (Page, attrib, X, Y, n);„End;„„Procedure HLineCharAttrib (Page: Byte; CharAttrib: Word; xFrom, xTo, Y: Byte);„Begin„  If DirectVideoGUI„  Then For X := x80p(Y, xFrom) To x80p(Y, xTo)„    Do Screen [Page] [X] := CharAttrib„  Else Begin„    SetCursorPos (Page, xFrom, Y);„    PutCharAttrib (Page, CharAttrib, (xTo - xFrom) + 1)„  End„End;„„Procedure VLineCharAttrib (Page: Byte; CharAttrib: Word; X, yFrom, yTo: Byte);„Var Y: Byte;„Begin„  For Y := yFrom To yTo„  Do If DirectVideoGUI„  Then Screen [Page] [ x80p(Y, X)] := CharAttrib„  Else Begin„    SetCursorPos (Page, X, Y);„    PutCharAttrib (Page, CharAttrib, 1)„  End„End;„„Procedure Frame (Page, X1, Y1, X2, Y2, c: Byte; Title: String);„Begin„  ScrollWindowUP (0, c, X1, Y1, X2, Y2); (* Must be on correct Page! *)„  For X := X1 To X2„  Do Begin„    WriteXYCh (Page, c, X, Y1, 196);„    WriteXYCh (Page, c, X, Y2, 196)„  End;„  For Y := Y1 To Y2„  Do Begin„    WriteXYCh (Page, c, X1, Y, 179);„    WriteXYCh (Page, c, X2, Y, 179)„  End;„  WriteXYCh (Page, c, X1, Y1, 218);„  WriteXYCh (Page, c, X2, Y1, 191);„  WriteXYCh (Page, c, X1, Y2, 192);„  WriteXYCh (Page, c, X2, Y2, 217);„  If title <> ''„  Then CWriteXY (Page, c, ( (X2 - X1) - (Length (title) + 2) ) Div 2, Y1, SP+Title);„End;„„Procedure FHLine (Page, Attrib, xFrom, xTo, Y: Byte);„Begin„  HLineCharAttrib (Page, (Attrib ShL 8) + 196, Succ (xFrom), Pred (xTo), Y);„  WriteXYCh (Page, Attrib, xFrom, Y, 195);„  WriteXYCh (Page, Attrib, xTo, Y, 180);„End;„„Procedure FVLine (Page, Attrib, X, yFrom, yTo: Byte);„Begin„  VLineCharAttrib (Page, (Attrib shl 8) + 179, X, Succ (yFrom), Pred (yTo) );„  WriteXYCh (Page, Attrib, X, yFrom, 194);„  WriteXYCh (Page, Attrib, X, yTo, 193);„End;„„„Procedure SavScr (Page: Byte; Var S: ScrBuffer);„Begin„  If DirectVideoGUI„  Then Move (Screen, S [Page], 4000)„  Else„    asm„      MOV DL, 79„@I1:  MOV DH, 24„@I0:  MOV BH, Page„      MOV AH,02„      INT VIO„      MOV AH,08„      INT VIO„„      XCHG AX, DI„      XOR AX, AX„      MOV AL, DH„      MOV BX, AX„      MOV CL,4„      SHL BX,CL„      MOV CL,6„      SHL AX,CL„      ADD AX,BX„      CLC„      ADD AL,DL„      ADC AH,00„      SHL AX,1„      LDS SI, S„      ADD SI,AX„„      XCHG AX, DI„      MOV WORD PTR [SI],AX„      DEC DH„      CMP DH,-1„      JNE @I0„      DEC DL„      CMP DL,-1„      JNE @I1„    end;„End;„„Procedure ResScr (Page: Byte; var S: ScrBuffer);„Begin„  If DirectVideoGUI„  Then Move (S, Screen [Page], 4000)„  Else„    asm„      MOV DL, 79„@I1:  MOV DH, 24„@I0:  MOV BH, Page„      MOV AH,02„      INT VIO„      XOR AX, AX„      MOV AL, DH„      MOV BX, AX„      MOV CL,4„      SHL BX,CL„      MOV CL,6„      SHL AX,CL„      ADD AX,BX„      CLC„      ADD AL,DL„      ADC AH,00„      SHL AX,1„„      LDS SI, S„      ADD SI,AX„„      MOV AX,WORD PTR [SI]„      MOV BL, AH„      MOV BH, Page„      MOV AH, 09„      MOV CX, 1„      int VIO„      DEC DH„      CMP DH,-1„      JNE @I0„      DEC DL„      CMP DL,-1„      JNE @I1„    end;„End;„„Function GetKeyCode: Word;„Begin„  Asm„    MOV AH, $00„    Int KBIO„    MOV @Result, AX„  End;„End;„„Function PollKey (Var Status: Word): Word;„var s: word;„Begin„  asm„    MOV AH, 01„    INT KBIO„    MOV @Result, AX„    LAHF„    AND AX, 64„    MOV S, AX„  end;„  Status:=s;„End;„„Function GetKeyStroke: Word;„Begin„  Asm„    MOV AH, $10„    Int KBIO„    MOV @Result, AX„  End;„End;„„Function CheckKeyBoard: Word;„Begin„  Asm„    MOV AH, $11„    Int KBIO„    MOV @Result, AX„  End;„End;„„Function GetKeyFlags: Byte;„Begin„  Asm„    MOV AH, $02„    Int KBIO„    MOV @Result, AL„  End;„End;„„Function GetKeyStatus: Word;„Begin„  Asm„    MOV AH, $12„    Int KBIO„    MOV @Result, AX„  End;„End;„„Procedure WriteKey (KeyCode: Word; Var Status: Byte);„Var s: Byte;„Begin„  Asm„    MOV AH, $05„    MOV CX, KeyCode„    Int KBIO„    MOV s, AL„  End;„  Status := s;„End;„„Procedure WaitOnUser (Var Code, X, Y, Button: Word);„ (* wait for key or mouse click *)„Var Status: Word;„Begin„  Repeat„    Code := PollKey (Status);„    GetMousePos (X, Y, Button);„  Until (Button <> 0) Or (Status = 0);„End;„„Function InitMouse: Word;„Begin„  Asm„    MOV AX, $0000„    Int MIO„    MOV @Result, AX„  End;„End;„„Procedure ShowMouseCursor; Assembler;„Asm„  MOV AX, $0001„  Int MIO„End;„„Procedure HideMouseCursor; Assembler;„Asm„  MOV AX, $0002„  Int MIO„End;„„Procedure GetMousePos (Var X, Y, Button: Word);„Var X1, Y1, b: Word;„Begin„  Asm„    MOV AX, $0003„    Int MIO„    MOV b,  BX„    MOV X1, CX„    MOV Y1, DX„  End;„  X := X1;„  Y := Y1;„  Button := b;„End;„„Procedure SetMousePos (X, Y: Word); Assembler;„Asm„  MOV AX, $0004„  MOV CX, X„  MOV DX, Y„  Int MIO„End;„„Procedure GetButtonPressInfo (Var X, Y, Button, NumberOfPresses: Word);„Begin„  reg. AX := $0005;„  reg. BX := Button;„  Intr (MIO, reg);„  Button := reg. AX;„  X := reg. CX;„  Y := reg. DX;„  NumberOfPresses := reg. BX„End;„„Procedure GetButtonRelInfo (Var X, Y, Button, NumberOfReleases: Word);„Begin„  reg. AX := $0006;„  reg. BX := Button;„  Intr (MIO, reg);„  Button := reg. AX;„  X := reg. CX;„  Y := reg. DX;„  NumberOfReleases := reg. BX„End;„„Procedure SetMouseWindow (X1, Y1, X2, Y2: Word);„Begin„  reg. AX := $0007;„  reg. CX := X1;„  reg. DX := X2;„  Intr ($33, reg);„  Inc (reg. AX, 1);„  reg. CX := Y1;„  reg. DX := Y2;„  Intr (MIO, reg)„End;„„„Procedure Shadow (Page, X1, Y1, X2, Y2, cc: Byte);„Begin„  HLineCharAttrib (Page, (cc * $100) + $B1, Succ (X1), Succ (X2), Succ (Y2) );„  VLineCharAttrib (Page, (cc * $100) + $B1, Succ (X2), Succ (Y1), Succ (Y2) );„End;„„Procedure Dialogue (Var T: String; Page, X1, Y1, X2, Y2, cc: Byte; Title: String);„Begin„  SavScr (Page, DTemp);„  Frame (Page, X1, Y1, X2, Y2, cc, ''); Title := SP + Title + SP;„  WriteXY (Page, cc, Succ (X1), Y1, Title);„  FrameReadLN (T, Page, Succ (X1), Succ (Y1), Pred (X2), Pred (Y2), cc);„  ResScr (Page, DTemp)„End;„„Procedure FrameReadLN (Var T: String; Page, X1, Y1, X2, Y2, cc: Byte);„Var i, X, Y, z: Byte;„  Code: Word;„  C: Char;„Begin„  X := X1; Y := Y1;„  If T [0] <> #0„  Then For i := 0 To Pred (Ord (T [0] ) )„    Do WriteXYCh (Page, cc, (i Mod (X2 - X1) ) + X1, (i Div (X2 - X1) ) + Y1, Ord(T[0]));„  SetCursorType (NormalCursor);„  i := 0;„  Repeat„    SetCursorPos (Page, X, Y);„    Code := GetKeyCode;„    C := Chr (Lo (Code) );„    If C = NUL„    Then Begin„      Case Hi (Code) Of„        $4B: If i <> 0 Then Dec (i);„        $4D: If i < Ord (T [0] ) Then Inc (i);„        $47: i := 0;„        $4F: i := Ord (T [0] );„        {   $53:if i<ord(T[0]) then begin„        if i>1„        then T:=Copy(T,1,pred(i))+Copy(T,succ(i),255)„        else if i<>ord(T[0])„        then T:=Copy(T,2,255)„        else T:=Copy(T,1,pred(i));„        for z:=i to ord(T[0])„        do WriteXY(Page,cc,(z mod (x2-x1))+x1,(z div (x2-x1))+y1,T[z]);„        WriteXY(Page,cc,(succ(z) mod (x2-x1))+x1,„        (succ(z) div (x2-x1))+y1,SP);„        end;    }„      End;„      X := (i Mod (X2 - X1) ) + X1;„      Y := (i Div (X2 - X1) ) + Y1„    End„    Else If C <> CR„    Then If (i < 255) And (Y <= Y2)„    Then If C <> DEL„    Then Begin„      Inc (i);„      T [i] := C;„      If i > Ord (T [0] )„      Then Inc (T [0], 1);„      WriteXYCh (Page, cc, X, Y, Ord (C) );„      Inc (X);„      If X = X2„      Then Begin„        Inc (Y);„        X := X1„      End„    End„    Else If (i <> 0) And (i = Ord (T [0] ) )„    Then Begin„      {  if i<ord(T[0])„      then T:=Copy(T,1,pred(i))+Copy(T,succ(i),255);}„      Dec (i);„      Dec (T [0], 1);„      If X = X1„      Then Begin„        X := Pred (X2);„        Dec (Y)„      End„      Else Dec (X);„      If i = Ord (T [0] )„      Then WriteXYCh (Page, cc, X, Y, 32)„        {   else begin„        for z:=i to ord(T[0])„        do WriteXY(Page,cc,(z mod (x2-x1))+x1,(z div (x2-x1))+y1,T[z]);„        WriteXY(Page,cc,(succ(z) mod (x2-x1))+x1,„        (succ(z) div (x2-x1))+y1,SP);„        x:=(i mod (x2-x1))+x1;„        y:=(i div (x2-x1))+y1„        end  }„    End„  Until C = CR;„  SetCursorType (BlankCursor);„End;„„End.„---„ * Your Software Resource * Selden NY * 516-736-6662„ * PostLink(tm) v1.07  YOURSOFTWARE (#5190) : RelayNet(tm)„                                                                               11     09-26-9309:25ALL                      MARTIN RICHARDSON        Scroll Screen UP/DOWN    IMPORT              12     ﬁÆ"; {****************************************************************************„ * Procedure ..... Scroll()„ * Purpose ....... Scroll the screen either up or down„ * Parameters .... nRow       Top row of scroll area„ *                 nCol       Left column of scroll area„ *                 nRows      Number of rows in scroll area„ *                 nCols      Number of cols in scroll area„ *                 nLines     Number of lines to scroll„ *                 nDirect    Direction to scroll in indicator„ *                 nAttr      Color attribute to leave behind„ * Returns ....... Nothing„ * Notes ......... A 0 for nDirect will scroll the screen up, a 1 will„ *                 scroll it down.„ * Author ........ Martin Richardson„ * Date .......... October 2, 1992„ ****************************************************************************}„PROCEDURE Scroll( nRow, nCol, nRows, nCols, nLines, nDirect, nAttr: BYTE ); assembler;„ASM„        MOV     CH, nRow„        DEC     CH„        MOV     CL, nCol„        DEC     CL„        MOV     DH, nRows„        ADD     DH, CH„        DEC     DH„        MOV     DL, nCols„        ADD     DL, CL„        DEC     DL„        MOV     BH, nAttr„        MOV     AL, nLInes„„        MOV     AH, nDirect„        AND     AH, 1„        OR      AH, 6„„        INT     10h„END;„                                                                                     12     09-26-9309:26ALL                      MARTIN RICHARDSON        Enable Blink/NOBLINK     IMPORT              6      ﬁÆ"€ {****************************************************************************„ * Procedure ..... SetBlink;„ * Purpose ....... To enable blinking vice intensity„ * Parameters .... None„ * Returns ....... Nothing„ * Notes ......... Colors with the background attribute high-bit set will„ *                 blink.„ * Author ........ Martin Richardson„ * Date .......... October 28, 1992„ ****************************************************************************}„PROCEDURE SetBlink; ASSEMBLER;„ASM„   MOV  AX, 1003h„   MOV  BL, 01h„   INT  10h„END;„                                                                                           13     09-26-9309:27ALL                      MARTIN RICHARDSON        Enable Brite/NOBRITE     IMPORT              6      ﬁÆ"k {****************************************************************************„ * Procedure ..... SetBright;„ * Purpose ....... To enable intensity vice blinking„ * Parameters .... None„ * Returns ....... Nothing„ * Notes ......... Colors with the background attribute high-bit set will„ *                 show the background in bright colors.„ * Author ........ Martin Richardson„ * Date .......... October 28, 1992„ ****************************************************************************}„PROCEDURE SetBright; ASSEMBLER;„ASM„   MOV  AX, 1003h„   XOR  BL, BL„   INT  10h„END;„„                                                          14     09-26-9310:10ALL                      GREG ESTABROOKS          Blink, Color & Chars     IMPORT              14     ﬁÆP› (*„From: GREG ESTABROOKS„Subj: BLINK, COLOURS AND CHARACTERS„*)„„PROGRAM BlinkBitDemo;           { Aug 31/93, Greg Estabrooks. }„USES CRT;                       { Clrscr,TextAttr.            }„VAR„   Loop1, Loop2, TextA : BYTE;„„PROCEDURE SetBlinkBit( OffOn :BOOLEAN ); ASSEMBLER;„                       { Routine to turn the blink bit on/off.}„ASM„  Push AX                       { Save AX.                    }„  Mov AX,$1003                  { Video routine to toggle bit.}„  Mov BL,OffOn                  { Move OffOn value in BL.     }„  Int $10                       { Call video Interrupt.       }„  Pop AX                        { Restore AX.                 }„END;{SetBlinkBit}„„BEGIN„  ClrScr;                       { Clear up screen clutter.    }„  TextA := 0;                   { Initiate color number.      }„  FOR Loop1 := 0 TO 15 DO       { Now draw color chart.       }„   BEGIN„    FOR Loop2 := 0 TO 15 DO„     BEGIN„       TextAttr := TextA;       { Set new color.              }„       Write(TextA:4);          { Write new color number.     }„       Inc(TextA);              { Move to next color.         }„     END;„     Writeln;                   { Move to the next line.      }„   END;„   Readln;                      { Pause for user.             }„   SetBlinkBit(FALSE);          { Turn off blink bit.         }„   Readln;                      { Pause for user.             }„   SetBlinkBit(TRUE);           { Turn blinkbit back on.      }„END.{BlinkBitDemo}„{*************************************************************}„„                                                                                                                    15     11-02-9305:28ALL                      SWAG SUPPORT TEAM        CRT Clone                IMPORT              52     ﬁÆ©} {„ Well here it is again, its a little rough and some of the Crt.tpu Functions„are left out. This Unit will generate Ansi TextColor and TextBackGrounds.„Becuase of the Ansi screen Writes you can send the Program to the com port„just by using CTTY or GateWay in a bat File before you start your Program.„}„„Unit CrtClone;„„Interface„„Const„  { Foreground and background color Constants }„  Black         = 0;„  Blue          = 1;„  Green         = 2;„  Cyan          = 3;„  Red           = 4;„  Magenta       = 5;„  Brown         = 6;„  LightGray     = 7;„„  { Foreground color Constants }„  DarkGray      = 8;„  LightBlue     = 9;„  LightGreen    = 10;„  LightCyan     = 11;„  LightRed      = 12;„  LightMagenta  = 13;„  Yellow        = 14;„  White         = 15;„„  { Add-in For blinking }„  Blink         = 128;„„Var„  { Interface Variables }„  CheckBreak : Boolean;    { Enable Ctrl-Break }„  CheckEOF   : Boolean;    { Enable Ctrl-Z }„„Procedure TextColor(Color : Byte);„Procedure TextBackground(Color : Byte);„Function  KeyPressed : Boolean;„Function  GetKey : Char;„Function  ReadKey : Char;„Function  WhereX : Byte;„Function  WhereY : Byte;„Procedure NormVideo;„Procedure ClrEol;„Procedure ClrScr;„Procedure GotoXY(X, Y : Byte);„„„Implementation„„Function KeyPressed : Boolean;„{ Replacement For Crt.KeyPressed }„{  ;Detects whether a key is pressed}„{  ;Does nothing With the key}„{  ;Returns True if key is pressed}„{  ;Otherwise, False}„{  ;Key remains in kbd buffer}„Var„  IsThere : Byte;„begin„  Inline(„    $B4/$0B/               {    MOV AH,+$0B         ;Get input status}„    $CD/$21/               {    INT $21             ;Call Dos}„    $88/$86/>ISTHERE);     {    MOV >IsThere[BP],AL ;Move into Variable}„  KeyPressed := (IsThere = $FF);„end;„„Procedure  ClrEol;     { ANSI replacement For Crt.ClrEol }„begin„  Write(#27'[K');„end;„„Procedure ClrScr;     { ANSI replacement For Crt.ClrScr }„begin„  Write(#27'[2J');„end;„„Function GetKey : Char;     { Additional Function.  Not in Crt Unit }„Var„  CH : Char;„begin„  Inline(„  {; Function GetKey : Char}„  {; Clears the keyboard buffer then waits Until}„  {; a key is struck.  if the key is a special, e.g.}„  {; Function key, goes back and reads the next}„  {; Byte in the keyboard buffer.  Thus does}„  {; nothing special With Function keys.}„     $B4/$0C        {       MOV  AH,$0C      ;Set up to clear buffer}„     /$B0/$08       {       MOV  AL,8        ;then to get a Char}„     /$CD/$21       {SPCL:  INT  $21         ;Call Dos}„     /$3C/$00       {       CMP  AL,0        ;if it's a 0 Byte}„     /$75/$04       {       JNZ  CHRDY       ;is spec., get second Byte}„     /$B4/$08       {       MOV  AH,8        ;else set up For another}„     /$EB/$F6       {       JMP  SHORT SPCL  ;and get it}„     /$88/$46/>CH   {CHRDY: MOV  >CH[BP],AL  ;else put into Function return}„   );„  if CheckBreak and (Ch = #3) then„  begin        {if CheckBreak is True and it's a ^C}„    Inline(    {then execute Ctrl_Brk}„    $CD/$23);„  end;„  GetKey := Ch;„end; {Inline Function GetKey}„„„Function ReadKey : Char;  { Replacement For Crt.ReadKey }„Var„  chrout : Char;„begin„  {  ;Just like ReadKey in Crt Unit}„  Inline(„  $B4/$07/               {  MOV AH,$07          ;Char input w/o echo}„  $CD/$21/               {  INT $21             ;Call Dos}„  $88/$86/>CHROUT);      {  MOV >chrout[bp],AL  ;Put into Variable}„  if CheckBreak and (chrout = #3) then  {if it's a ^C and CheckBreak True}„  {then execute Ctrl_Brk}„    Inline($CD/$23);           {     INT $23}„  ReadKey := chrout;                    {else return Character}„end;„„Function WhereX : Byte;       { ANSI replacement For Crt.WhereX }„Var                         { Cursor position report. This is column or }„  ch  : Char;               { X axis report.}„  st  : String;„  st1 : String[2];„  x   : Byte;„  i   : Integer;„begin„  Write(#27'[6n');          { Ansi String to get X-Y position }„  st := '';                 { We will only use X here }„  ch := #0;                 { Make sure Character is not 'R' }„  While ch <> 'R' do        { Return will be }„  begin                   { Esc - [ - Ypos - ; - Xpos - R }„    ch := #0;„    ch := ReadKey;        { Get one }„    st := st + ch;        { Build String }„  end;„  St1 := copy(St,6,2);    { Pick off subString having number in ASCII}„  Val(St1,x,i);           { Make it numeric }„  WhereX := x;            { Return the number }„end;„„Function WhereY : Byte;       { ANSI replacement For Crt.WhereY }„Var                         { Cursor position report.  This is row or }„  ch  : Char;               { Y axis report.}„  st  : String;„  st1 : String[2];„  y   : Byte;„  i   : Integer;„begin„  Write(#27'[6n');          { Ansi String to get X-Y position }„  st := '';                 { We will only use Y here }„  ch := #0;                 { Make sure Character is not 'R' }„  While ch <> 'R' do        { Return will be }„  begin                   { Esc - [ - Ypos - ; - Xpos - R }„    ch := #0;„    ch := ReadKey;        { Get one }„    st := st + ch;        { Build String }„  end;„  St1 := copy(St,3,2);    { Pick off subString having number in ASCII}„  Val(St1,y,i);           { Make it numeric }„  WhereY := y;            { Return the number }„end;„„„Procedure GotoXY(x : Byte ; y : Byte); { ANSI replacement For Crt.GoToXY}„begin„  if (x < 1) or (y < 1) then„    Exit;„  if (x > 80) or (y > 25) then„    Exit;„  Write(#27'[', y, ';', x, 'H');„end;„„Procedure TextBackGround(Color : Byte);„begin„ Case color of„   0 : Write(#27#91#52#48#109);„   1 : Write(#27#91#52#52#109);„   2 : Write(#27#91#52#50#109);„   3 : Write(#27#91#52#54#109);„   4 : Write(#27#91#52#49#109);„   5 : Write(#27#91#52#53#109);„   6 : Write(#27#91#52#51#109);„   6 : Write(#27#91#52#55#109);„  end;„end;„„Procedure TextColor(Color : Byte);„ begin„  Case color of„     0 : Write(#27#91#51#48#109);„     1 : Write(#27#91#51#52#109);„     2 : Write(#27#91#51#50#109);„     3 : Write(#27#91#51#54#109);„     4 : Write(#27#91#51#49#109);„     5 : Write(#27#91#51#53#109);„     6 : Write(#27#91#51#51#109);„     7 : Write(#27#91#51#55#109);„     8 : Write(#27#91#49#59#51#48#109);„     9 : Write(#27#91#49#59#51#52#109);„    10 : Write(#27#91#49#59#51#50#109);„    11 : Write(#27#91#49#59#51#54#109);„    12 : Write(#27#91#49#59#51#49#109);„    13 : Write(#27#91#49#59#51#53#109);„    14 : Write(#27#91#49#59#51#51#109);„    15 : Write(#27#91#49#59#51#55#109);„   128 : Write(#27#91#53#109);„  end;„end;„„Procedure NormVideo;„begin„  Write(#27#91#48#109);„end;„„end.„       16     11-26-9318:16ALL                      SWAG SUPPORT GROUP       Toggle Blink On/Off      IMPORT              2      ﬁÆx† procedure ToggleBlink(OnOff:boolean);„assembler;„asm„  mov ax,1003h„  mov bl,OnOff„  int 10h„end;„                              17     11-26-9318:16ALL                      SWAG SUPPORT GROUP       Set High Background      IMPORT              12     ﬁÆ‰N >Actually James you are in correct.  Here is some code that will change the„>blinking characters to a enhanced back ground...„> „>Procedure HighBackGround;„>VAR„>  R: Registers;  {You must use the Dos Unit.}„>BEGIN„>  WITH R DO„>  BEGIN„>    R.AH:=$10;„>    R.AL:=$03;„>    BL:=0;„>     {0 for intense back ground}„>     {1 for blink}„>  END;„>  Intr($10,R);„>END;„> „>Hope this helps,„>  „„  This solution is correct, but only for EGA or higher monitors.  „„  To get high intensity background colors on a CGA card, you need to„  access the Color Graphics Mode Control Register, port $3d8.„„  The bit meanings are as follows:„„  bit„„  7,6   unused„  5     blink mode 0 = disable blink 1 = enable blink„  4     graphics resolution 0 = 320x200 1 = 640x200„  3     video enable 0 = disable 1 = enable„  2     color mode 0 = color 1 = bw„  1     monitor mode 0 = alphanumeric 1 = graphics„  0     char. size 0 = 40x25 1 = 80x25„„  The simplist answer to your problem is, in TP, „„    port[$3d8] := $9„„  This sets 80x25 color alphanumeric mode with high intensity„  background colors.  If you need other modes, set the bits„  accordingly.  „„  One word of caution:  register $3d8 is write only, so you can't„  use the read-or-write method of bit setting.  You'll need to look„  into the BIOS data area to find out the current video mode if„  necessary.„                                                          18     01-27-9412:21ALL                      SVERRE HJELM             Small CRT Unit           IMPORT              15     ﬁÆ= „Unit sCrt;„„InterFace„„uses„  Crt;„„procedure init;„procedure ws(X, Y, Atr : Byte; Ch : Char);„function  rs(X, Y : byte) : Char;„procedure wst(X, Y, Atr : Byte; S : String);„procedure WstCenter(X, Y, Atr : Byte; Str : string);„procedure WstRight(X, Y, Atr : Byte; Str : string);„„Implementation„„var„  ScreenSeg : longint;„  att       : byte;                (* atributt(se over) *)„„procedure init;„(* Denne prosedyren finner ut skjermadressen i RAM og setter att *)„(* til 15 (hvitt p} sort), dette funker b}de p} farge og monoskjerm *)„begin„  if (Mem[0000:1040] and 48) <> 48 then„    ScreenSeg := $B800„  else„    ScreenSeg := $B000;„  Att := 15;„end;„„procedure ws(X, Y, Atr : Byte; Ch : Char);„(* Skriver ut et tegn(thischar) i posisjon (col,row), der col er *)„(* vanrett (1-80) og row er loddrett (1-25) *)„var„  locationCode : Integer;„begin„  Att := Atr;„  locationCode := (X - 1) * 2 + (Y - 1) * 160;„  Mem[screenseg : locationcode] := Ord(Ch);„  Mem[screenseg : locationcode + 1] := Atr;„end;„„function rs(X, Y : byte) : Char;„(* Leser et tegn p} skjermen i pos. col,row *)„var„  locationcode : Integer;„begin„   LocationCode := (X - 1) * 2 + (Y - 1) * 160;„   rs := chr(Mem[ScreenSeg:LocationCode]);„end;„„procedure wst(X, Y, Atr : Byte; S : String);„(* Skriver ut en streng til skjermen i pos. x,y *)„var„  t : Byte;„begin„   for t := 1 to Length(S) do„     ws(x + t - 1, y, Atr, S(.t.));„end;„„procedure WstCenter(X, Y, Atr : Byte; Str : string);„var„  t : Byte;„begin„  for t := 1 to Length(Str) do„    Ws(t + X - (Length(Str) div 2), Y, Atr, Str[t]);„end;„„procedure WstRight(X, Y, Atr : Byte; Str : string);„var„  t : Byte;„begin„  for t := 1 to Length(Str) do„    Ws(t + X - Length(Str), Y, Atr, Str[t]);„end;„„„begin„  Init;„end.„                                         19     02-05-9407:56ALL                      TOM CARROLL              Writing to Line 25       IMPORT              10     ﬁÆ   {„SB> Hi, i got a LITTLE problem, i want to make a window that takes all 2„SB> lines of my screen.  There is a little piece of code that do this„SB> window, but when it is executed, i lost the first line, could someon„SB> help me?„„Here's something that I have in my tool box that may help you out. }„„PROCEDURE WriteC80_25(S, Fore, Back, Blink : Byte);„{ This procedure will write a single character to the 80th column,„  25th row of the screen without scrolling it on a color monitor }„„BEGIN„   Mem[$B800:3998] := S;„   Mem[$B800:3999] := Blink + (Back SHL 4) + Fore;„END; { WriteC80_25 }„„PROCEDURE WriteM80_25(S, Fore, Back, Blink : Byte);„{ This procedure will write a single character to the 80th column,„  25th row of the screen without scrolling it on a Mono monitor }„„BEGIN„   Mem[$B000:3998] := Ord(S);„   Mem[$B000:3999] := Blink + (Back SHL 4) + Fore;„END; { WriteM80_25 }„„What I would do in your case is I would call the appropriate procedure„for the last character that you write to the screen in your Draw_Window„routine.„„Hope that helps you!„„Tom Carroll„                                                                             20     02-05-9407:56ALL                      IAN HINSON               25/43/50 -no blank!      IMPORT              6      ﬁÆ   „{„ Does anyone have a routine, or more, that will change video mode, 25„ to 43/50 lines, or back WITHOUT clearing the screen as TextMode does?„ I "hate" that <g>, I know OpCrt is supposed to do that, but I cannot„ use OpCrt in this program without doing MAJOR changes to about 20„ other units that use Tp.Crt. I will, but later, fix that, but for now„ could use a routine of this nature.... }„„„PROCEDURE SwitchTo43&50; ASSEMBLER;„ASM„   MOV AX,$1112„   INT $10„END;„„PROCEDURE SwitchTo25; ASSEMBLER;„ASM„   MOV AX,$1114„   INT $10„END;„                                                                                                      21     02-15-9407:48ALL                      TOM DONNELLY             Overwrite CRT Video SEG  IMPORT              14     ﬁÆ   Unit CrtSeg;„{„  CRTSEG.TPU - Written by Tom Donnelly and placed into the public domain.„„               Allow the video segment address in CRT.TPU„               to be overridden with a different address.„               Particularly useful under DesqView, to make„               Turbo Pascal programs more DesqView compliant.„„  Example:     SetCrtSeg(Desqview_video_buffer);„„  This unit has only been tested under Turbo Pascal 6.  It may or may not„  work under different TP versions.  It is distributed "as is" without any„  claims or warranties expressed or implied.  Use at your own risk.„„  If anyone finds a problem with this code, I'd appreciate hearing about it.„  Tom Donnelly - 73200,1323„„  07/23/92 - Version 1.0 - Initial public-domain release.„}„„Interface„„Uses„   CRT;„„Procedure SetCrtSeg(iSeg: Word);„„Implementation„„Const„   CRTSEGOFFSET         = $5D3;  {Offset in CRT.TPU to CRT buff seg value}„   OldCrtSeg            : Word„                        = $B800;„„Procedure SetCrtSeg;„Var„   CrtSegAddr           : ^Word;       {Pointer to CRT buffer segment literal}„   CrtNoOps             : ^Byte;       {Pointer to area to no-op}„Begin„   CrtSegAddr := Ptr(Seg(AssignCrt),CRTSEGOFFSET);„   CrtNoOps   := Ptr(Seg(AssignCrt),CRTSEGOFFSET+2);„   If CrtSegAddr^<>OldCrtSeg Then„   Begin„      Writeln('CRTSEG.TPU: Could not find CRT segment address hook');„      If ReadKey<>#0 Then;„   End„   Else„   Begin„      OldCrtSeg  :=CrtSegAddr^;„      CrtSegAddr^:=iSeg;                   {Plug in new CRT buffer segment}„      FillChar(CrtNoOps^,9,$90);           {No-op the remainder of the code}„   End;„End;„End.„                                