SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00030         HARDWARE DETECTION                                                1      05-28-9313:48ALL                      SWAG SUPPORT TEAM        Write to TWO Monitors    IMPORT              9      ¿◊Ü# {„> Hi I am looking For some help on use 2 monitors at the same time... 1„> is mono and the other is vga.  I would like to just post a certain„> screen on the mono and leave the vga like normal..„„VGA Text mode memory begins at $b800, VGA Graphics memory at $A000, and„MDA/Herc memory begins at $b000.  If you plan on running Text and Text,„try something like this:„}„Type„  WhichMonitor = (MDA, VGA);„„Procedure ChangeCel (Row, Column, Foreground, Background, Character : Byte;„                     Which : WhichMonitor);„Var„  Point : Word;„begin„  If Which = MDA then„    Point := $b000„  else„    Point := $b800;„  MemW[Point : (Row - 1) * 160 + Col * 2] :=„               (Foreground + Background * 16) * 256 + Character;„  end;„{„Of course, there are more optimized ways to do this, but this should„portray the basic concept.  Herc Graphics and VGA Graphics would be„done in much the same manner, but I don't have an Herc With my VGA to„check it.„}                                                                      2      05-28-9313:48ALL                      SWAG SUPPORT TEAM        ALOCSIZE.PAS             IMPORT              21     ¿◊¬y *--*  03-31-93  -  21:47:03  *--*„/. Date: 03-30-93 (23:45)              Number: 24023 of 24035„  To: PEDRO PACHECO                 Refer#: 23957„From: ERIC LU                         Read: NO„Subj: allocation Units              Status: PUBLIC MESSAGE„Conf: R-TP (552)                 Read Type: GENERAL (A) (+)„„PP>> Is there any way to find (in Pascal) what's de size of each allocation uni„PP>> in a Hard drive?„„Pedro,„     See if the following is what you wanted...„„-------------------------------- Cut  ----------------------------------„„Program Int21_36;„Uses Crt,Dos;„Procedure DiskfreeSpace( DriveCode: Byte);„Var„   Regs: Registers;„   SectorsPerCluster,„   AvailableClusters,„   BytesPerSector,„   ClustersPerDrive,„(63 min left), (H)elp, More?    AllocationSize,„   Capacity,„   Free:  LongInt;„begin„   Regs.AH := $36;„   Regs.DL := DriveCode;„   MSDos(Regs);„„   {************* Obtaining Infos ******************}„   SectorsPerCLuster:= Regs.AX;„   AvailableClusters:= Regs.BX;„   BytesPerSEctor   := Regs.CX;„   ClustersPerDrive := Regs.DX;„„   {************* Calculations ********************)„   AllocationSize   := BytesPerSector * SectorsPerCluster;„   Capacity := SectorsPerCluster * BytesPerSector * ClustersPerDrive;„   Free     := SectorsPerCLuster * AvailableClusters * BytesPerSector;„„   {************* Display *************************}„   Writeln(' Sectors Per Cluster   = ',SectorsPerCluster:15,'');„   Writeln(' Available Clusters    = ',AvailableClusters:15,'');„   Writeln(' Bytes Per Sector      = ',BytesPerSector:15,'');„(63 min left), (H)elp, More?    Writeln(' Clusters Per Drive    = ',ClustersPerDrive:15,'');„   Writeln(' Allocation Size       = ',AllocationSize:15,' Bytes');„   Writeln(' Drive Capacity        = ',Capacity:15,' Bytes');„   Writeln(' Free Space            = ',Free:15,' Bytes');„end;„„begin„   ClrScr;„   DiskFreeSpace(0);   {Get Current Drive Info}„   readln;„end.„„„----------------------------- Cut ----------------------------------„„ The above should be ready to run as I have tested on my computer..„ It's got more infos..  I was learning it as I was typing it in so I„ made it more than what you need.„ hope this is what you wanted to know...„„                                                        Eric„„---„(63 min left), (H)elp, More?  ˛ OLX 2.1 TD ˛ It's only a hobby ... only a hobby ... only a„ * Casino Bulletin Board * Hammonton/Atlantic City NJ U.S.A. 1-609-561-3377„ * PostLink(tm) v1.05  CASINO (#18) : RelayNet(tm)„„(63 min left), (H)elp, end of Message Command?                3      05-28-9313:48ALL                      SWAG SUPPORT TEAM        Determine Cluster Size   IMPORT              5      ¿◊8Ô {„> Is there any way to find the size of each allocation Unit in a Hard drive?„}„„Uses Dos;„„Function clustsize (drive : Byte) : Word;„Var„  regs : Registers;„begin„  regs.cx := 0;         {set For error-checking just to be sure}„  regs.ax := $3600;     {get free space}„  regs.dx := drive;     {0=current, 1=a:, 2=b:, etc.}„  msDos (regs);„  clustsize := regs.ax * regs.cx;      {cluster size!}„end;„„begin„  Writeln(ClustSize(0));„end.                                                                           4      05-28-9313:48ALL                      SWAG SUPPORT TEAM        CPU-ID.PAS               IMPORT              12     ¿◊m… {„> How do i get info about witch CPU it is in the current computer??„}„„{$F+}„„Const„  CPU_Type : Array[1..4] of String[5] = ('8086', '80286', '80386', '80486');„  Cpu8086  = 1;„  Cpu80286 = 2;„  Cpu80386 = 3;„  Cpu80486 = 4;„Var„  Result : Byte;„„„Function GetCPU_Type: Byte; Assembler;„„Asm„  MOV   DX,Cpu8086„  PUSH  SP„  POP   AX„  CMP   SP,AX„  JNE   @OUT„  MOV   DX, Cpu80286„  PUSHF„  POP   AX„  or   AX,4000h„  PUSH  AX„  POPF„  PUSHF„  POP   AX„  TEST  AX,4000h„  JE   @OUT„  MOV DX, Cpu80386„  {"DB 66h" indicates '386 extended instruction}„  DB 66h; MOV   BX, SP      {MOV EBX, ESP}„  DB 66h, 83h, 0E4h, 0FCh   {AND ESP, FFFC}„  DB 66h; PUSHF             {PUSHFD}„  DB 66h; POP AX            {POP EAX}„  DB 66h; MOV   CX, AX      {MOV ECX, EAX}„  DB 66h, 35h, 00h„  DB 00h, 04h, 00           {XOR EAX, 00040000}„  DB 66h; PUSH   AX     {PUSH EAX}„  DB 66h; POPF              {POPFD}„  DB 66h; PUSHF             {PUSHFD}„  DB 66h; POP   AX     {POP EAX}„  DB 66h, 25h, 00h„  DB 00h, 04h, 00h          {AND EAX, 00040000}„  DB 66h, 81h, 0E1h, 00h„  DB 00h, 04h, 00h          {AND ECX, 00040000}„  DB 66h; CMP   AX, CX      {CMP EAX, ECX}„  JE @Not486„  MOV DX, Cpu80486„@Not486:„  DB 66h; PUSH   CX         {PUSH EXC}„  DB 66h; POPF              {POPFD}„  DB 66h; MOV   SP, BX      {MOV ESP, EBX}„@Out:„  MOV AX, DX„end;„„begin„  Result := GetCPU_Type;„  Writeln(Result);„end.„                     5      05-28-9313:48ALL                      SWAG SUPPORT TEAM        Determine CPU Speed      IMPORT              13     ¿◊Z {„˙    Subject: How to determine mhz using TP6.0...„„It seems to work pretty well, but on a 486/33DX it gave inacurate results...„}„„Program CpuSpeed;„Uses„  Crt;„Var„  Speed, DelayCalibrate : Word;„Const„  Offset = 9; { For TP 4.0, it should be 16 }„„„Procedure WaitForFloppy;„Var„  tickTil     : LongInt;„  TimerTicks  : LongInt Absolute $40 : $6C;„  motorStatus : Byte Absolute $40 : $3F;„begin„  if MotorStatus and $F > 0 then„  begin„    WriteLn('Loading...');„    TickTil := TimerTicks + 91;„    {There are $17FE80 ticks in a day}„    if TickTil > $17FE80 then„      Dec(TickTil, $17FE80);„    Repeat Until (MotorStatus and $F = 0) or (TimerTicks >= TickTil);„  end;„end;„„begin„  WaitForFloppy;„  DelayCalibrate := MemW[Seg(CheckSnow): Ofs(CheckSnow)+Offset];„  WriteLn('Delay calibration value is ', DelayCalibrate);„  Speed := ((LongInt(1000) * DelayCalibrate) + 110970) div 438;„  Write('Calculated speed: ', Speed div 100,'.');„  WriteLn((speed div 10) MOD 10, speed MOD 10);„  Write('CPU speed is probably ');„  Case Speed OF„    0..499     : WriteLn('4.77MHz or below');„    500..699   : WriteLn('6MHz');„    700..899   : WriteLn('8MHz');„    900..1099  : WriteLn('10MHz');„    1100..1399 : WriteLn('12MHz');„    1400..1799 : WriteLn('16MHz');„    1800..2199 : WriteLn('20MHz');„    2200..2699 : WriteLn('25MHz');„    2700..3599 : WriteLn('30MHz');„    ELSE„      WriteLn('30MHz or MORE!');„  end;„end.„                                                                                                                       6      05-28-9313:48ALL                      SWAG SUPPORT TEAM        FLOPSIZE.PAS             IMPORT              10     ¿◊1 {„>Does anybody know how to determine the size of a disk drive.  I mean„>whether it is a 360 K drive or 720 K, 1.4 M or 1.2 M drive.  I'm„>working on a Program which has the ability to Format diskettes and„>I want it to be able to come up With the size of a disk drive as a„>default.  I have looked at the equipment flag in the BIOS and the„>only thing I can get out of that is the Type of a disk drive not the„>size.„}„Function VarCMOS(i : Byte) : Byte ;„begin„     port[$70]:=i;„     VarCMOS:=port[$71]„end;„„Var  b    : Byte ;„„begin„     b:=VarCMOS($10);„     if b and $f0<>0 then„     begin„          Write('Drive A: = ');„          Case (b and $f0) shr 4 of„               1 : Write('5" 360 Ko');„               2 : Write('5" 1,2 Mo');„               3 : Write('3" 720 Ko');„               4 : Write('3" 1,44 Mo')„          end;„     end;„     if b and $f<>0 then„     begin„          Write(', B: = ');„          Case b and $f of„               1 : Writeln('5" 360 Ko');„               2 : Writeln('5" 1,2 Mo');„               3 : Writeln('3" 720 Ko');„               4 : Writeln('3" 1,44 Mo')„          end;„     end else WriteLn ;„end.„        7      05-28-9313:48ALL                      SWAG SUPPORT TEAM        LPT-ADDR.PAS             IMPORT              5      ¿◊¿' {„Or better yet, the BIOS stores the addresses of the parallel Interfaces„on the system at memory location $0040:$0008.  There are four Words„here, allowing up to 4 parallel devices.„-Brian Pape„}„Var„  i : Byte;„  par : Array[1..4] of Word;„begin„  For i := 1 to 4 do„  begin„    par[i] := Word(ptr($0040, $0008 + (i - 1) * 2)^);„    If Par[i] = 0 then„      Writeln('Not Found')„    else„      Writeln(Par[i]);„  end;„end.„„„                                                                                     8      05-28-9313:48ALL                      SWAG SUPPORT TEAM        SCSICODE.PAS             IMPORT              30     ¿◊Hv {„ > I am trying to issue an SCSI START/StoP Unit via Adaptec's ASPI SCSI„ > manager and an 1542B host adaptor.  This is For an application I am„ > writing in BP.  Adaptec is of no help.  if anyone here has any„ > comments„ > or suggestions please respond in this Forum.„}„„Unit Aspi;„„{ I/O Error reporting:„„  AspiSenseKey is the primary source of error inFormation.„„    0:    I/O Complete.„          Warnings (Filemark, Short block, etc) may be posted in Sense.„„    1-E:  Error occured.„          Examine SRBStat, HostStat, TargStat, Sense For details.„„    F:    Severe error detected, no SCSI info available.„„  -------------------------------------------------------------------- }„„Interface„„Const„  SrbIn = $08;„  SRBOut = $10;„  SRBNone = $18;„  AspiPtr:  Pointer = Nil;„„„Type„  AspiSrb = Record„    SrbCmd:      Byte;„    SrbStat:     Byte;„    SrbHost:     Byte;„    SrbReqFlags: Byte;„    SrbHdrFill:  LongInt;„    Case Integer of„     2: (Srb2TargetID: Byte;„         Srb2LUN:      Byte;„         Srb2DataLen:  LongInt;„         Srb2SenseLen: Byte;„         Srb2DataPtr:  Pointer;„         Srb2LinkPtr:  Pointer;„         Srb2CDBLen:   Byte;„         Srb2HAStat:   Byte;„         Srb2TargStat: Byte;„         Srb2PostAddr: Pointer;„         Srb2Filler:   Array [1..34] of Byte;„         { Sense data follows CDB }„         Srb2CDB:      Array [0..50] of Byte);„     1: (Srb1TargetID: Byte;„         Srb1LUN:      Byte;„         Srb1DevType:  Byte);„     0: (Srb0Cnt:      Byte;„         Srb0TargetID: Byte;„         Srb0MgrID:    Array [1..16] of Char;„         Srb0HostID:   Array [1..16] of Char;„         Srb0HostParm: Array [1..16] of Char);„    end;„„Var„  AspiSRBStat:      Byte;„  AspiHostStat:     Byte;„  AspiTargStat:     Byte;„  AspiSenseKey:     Byte;„  AspiSense:        Array [0..17] of Byte;„  AspiSenseCode:    Word;„„Function AspiOpen: Integer;„„Procedure AspiCall (Var SRB: AspiSrb);„{ Call ASPI Handler With SRB }„Inline ($FF/$1E/>AspiPtr/„        $58/$58);„„Procedure AspiWait (Var SRB: AspiSrb);„„Function AspiClose: Integer;„„Implementation„„Uses Dos;„„Procedure AspiWait (Var SRB: AspiSRB);„{ Call ASPI Handler With SRB and wait For Completion }„begin„  if AspiPtr = Nil„    then begin„      AspiSenseKey := $0F;„      Exit;„      end;„  With Srb do begin„    SrbStat := 0;„    AspiCall (Srb);„    While SrbStat = 0 do ;„    AspiSrbStat   := SrbStat;„    AspiHostStat  := Srb2HAStat;„    AspiTargStat  := Srb2TargStat;„    AspiSenseKey  := 0;„    FillChar (AspiSense, Sizeof (AspiSense), #0);„    Move (Srb2CDB [Srb2CDBLen], AspiSense, Sizeof (AspiSense));„    AspiSenseKey := AspiSense[2] and $0F;„    AspiSenseCode := (AspiSense [12] SHL 8) or AspiSense [13];„    end;„  end;„„Function AspiOpen: Integer;„Const„  AspiName: Array [1..9] of Char = 'SCSIMGR$'#0;„Var„  R:       Registers;„  AspiHan: Word;„begin„  With R do begin„    { Assume failure }„    AspiOpen := -1;„    AspiPtr := Nil;„„    { Open ASPI device driver }„    AX := $3D00;„    DS := Seg (AspiName[1]);„    DX := ofs (AspiName[1]);„    MSDos (R);„    if odd (Flags)„      then Exit;„    AspiHan := AX;„„    { Do IOCtl Read to get Pointer to ASPI handler }„    AX := $4402;„    BX := AspiHan;„    CX := 4;„    DS := Seg (AspiPtr);„    DX := ofs (AspiPtr);„    MSDos (R);„    if Odd (flags)„      then Exit;„„    { Close device driver }„    AX := $3E00;„    BX := AspiHan;„    MsDos (R);„    if Odd (Flags)„      then Exit;„    end;„„  { Indicate success  and Exit }„  AspiOpen := 0;„  end { AspiOpen };„„Function AspiClose: Integer;„begin„  AspiClose := 0;„end { AspiClose };„„end.„                                                                                                                           9      05-28-9313:48ALL                      SWAG SUPPORT TEAM        SECTORIO.PAS             IMPORT              65     ¿◊x {... so there I was, sitting in a bar when a known C Programmer  }„{comes up to me and sniggers "still doing it in Pascal eh?"      }„{"Yup" I replied, and tossed the bartender another hundred.      }„{"Yeah well, when you're ready For a Real language, only C has   }„{all the aces."                                                  }„{I'm a Pascal Programmer.  I don't have to take that.  "Such as?"}„{I hoped he'd bite and he did.                                   }„{"Such as disk sector reading and writing For starters."         }„{"Well I hope you're not bluffin', 'cause here's a trick that    }„{I'll bet you ain't covered."                                    }„{I pulled it out With a swish and laid it on the table.  "Even   }„{provides support For >32M volumes, which the C run-time library }„{manual Forgets to tell you it won't do."                        }„{"Huh?  Where?"                                                  }„{"Right here" I said.  "Just where it says...                    }„„Program AbsReadTest;„„{This Program demonstrates a C-style absread and absWrite For TP.}„{As is, it reads the boot sector off drive A:, and optionally    }„{Writes it out to the very last sector on drive A: (assumes 1.2Meg}„{This Program IS dangerous, and is released to the public domain.}„{I take no responsibility For use or misuse, deliberate or       }„{accidental, of this Program or any Program which Uses the       }„{techniques described herein.                                    }„„{Author: Mitch Davis 3:634/384.6 +61-3-890-2062 v1.0 28-Jun-92.  }„„Var bp:Pointer; {Will point to the buffer For the sector data}„„Function absread (drive:Char; nsects:Word; lsect:Word; buffer:Pointer):Boolean;„„{Works just like the C runtime one- including being restricted to 32M volumes!}„„{drive is a Character, nsects is the number of sectors, and lsect is the first}„{sector.  buffer points to the buffer you'd like filled from disk.  Function  }„{returns True if there was an error, or False if all went well.               }„„Var kludgebuff:Array [0..$1f] of Byte; {Read Ralf Brown's interrupt listing}„    kludgePtr:Pointer;                 {Int 25h - ES:[BP+1E] may change    }„„begin„  kludgePtr := @kludgebuff;„  absread := True;„  if drive < 'A' then Exit;„  if drive > 'Z' then Exit;„  Asm„    push  es„    push  bp„    push  di„    les   di, kludgePtr„    mov   al, drive      { Gets the passed parameter. }„    and   al, 1fh        { Cvt from ASCII to drive num }„    dec   al             { Adjust because A: is drive 0 }„    mov   cx, nsects     { number of sectors to read }„    mov   dx, lsect      { starting at sector.. }„    push  ds„    lds   bx, buffer      { Get the address of the buffer }„    mov   bp, di„    push  si„    int   25h            { Do the drive read. }„    pop   si             { Remove the flags int 25h leaves on stack}„    pop   si„    pop   ds„    pop   di„    pop   bp„    pop   es„    jc    @1„    mov   ah, 0          { No errors, so set Function to False }„    @1:„    mov   @result, ah„  end;„end;„„Function absWrite„            (drive:Char; nsects:Word; lsect:Word; buffer:Pointer):Boolean;„„{Works just like the C one - including being restricted to 32M volumes!}„„{drive is a Character, nsects is the number of sectors, and lsect is the first}„{sector.  buffer points to the buffer you'd like filled from disk.  Function  }„{returns True if there was an error, or False if all went well.               }„„Var kludgebuff:Array [0..$1f] of Byte;„    kludgePtr:Pointer;„„begin„  kludgePtr := @kludgebuff;„  absWrite := True;„  if drive < 'A' then Exit;„  if drive > 'Z' then Exit;„  Asm„    push  es„    push  bp„    push  di„    les   di, kludgePtr„    mov   al, drive      { Gets the passed parameter. }„    and   al, 1fh        { Cvt from ASCII to drive num }„    dec   al             { Adjust because A: is drive 0 }„    mov   cx, nsects     { number of sectors to Write }„    mov   dx, lsect      { starting at sector.. }„    push  ds„    lds   bx, buffer      { Get the address of the buffer }„    mov   bp, di„    push  si„    int   26h            { Do the drive Write. }„    pop   si             { Remove the flags int 26h leaves on stack}„    pop   si„    pop   ds„    pop   di„    pop   bp„    pop   es„    jc    @1„    mov   ah, 0„    @1:„    mov   @result, ah„  end;„end;„„Function absLread (drive:Char; nsects:Word; lsect:LongInt;„buffer:Pointer):Boolean;„„{This Function reads sectors on disks which have the >32M style made popular}„{by Compaq Dos 3.31, MS-Dos 4+ and DR-Dos 5+.                               }„„Var packet:Array [0..9] of Byte; {disk request packet - see Ralf Brown's ints}„„begin„  absLread := True;„  if drive < 'A' then Exit;„  if drive > 'Z' then Exit;„  Asm„    mov   ax, Word ptr lsect     {Get the LSB of the start sector}„    mov   Word ptr packet[0], ax {Store it in the packet         }„    mov   ax, Word ptr lsect + 2 {Get the MSB of the start sector}„    mov   Word ptr packet[2], ax {Store this one too.            }„    mov   ax, nsects             {How many sectors to read       }„    mov   Word ptr packet[4], ax„    {Insert the Pointer to the data buffer into the packet}„    push  bp ; push ds„    lds   dx, buffer      { Get the address of the buffer }„    mov   Word ptr packet[6], dx„    mov   dx, ds„    mov   Word ptr packet[8], dx„    mov   al, drive      { Gets the passed parameter. }„    and   al, 1fh        { Cvt from ASCII to drive num }„    dec   al             { Adjust because A: is drive 0 }„    int   25h            { Do the drive read. }„    pop   si             { Remove the flags int 25h leaves on stack}„    pop   ds„    pop   bp„    jc    @1„    mov   ah, 0„    @1:„    mov   @result, ah„  end;„end;„„Function absLWrite (drive:Char; nsects:Word; lsect:LongInt;„buffer:Pointer):Boolean;„„{This Function Writes sectors on disks which have the >32M style made popular}„{by Compaq Dos 3.31, MS-Dos 4+ and DR-Dos 5+.                                }„„Var packet:Array [0..9] of Byte;„„begin„  absLWrite := True;„  if drive < 'A' then Exit;„  if drive > 'Z' then Exit;„  Asm„    mov   ax, Word ptr lsect„    mov   Word ptr packet[0], ax„    mov   ax, Word ptr lsect + 2„    mov   Word ptr packet[2], ax„    mov   ax, nsects„    mov   Word ptr packet[4], ax„    push  bp ; push ds„    lds   dx, buffer„    mov   Word ptr packet[6], dx„    mov   dx, ds„    mov   Word ptr packet[8], dx„    mov   al, drive      { Gets the passed parameter. }„    and   al, 1fh        { Cvt from ASCII to drive num }„    dec   al             { Adjust because A: is drive 0 }„    int   26h            { Do the drive Write. }„    pop   si             { Remove the flags int 26h leaves on stack}„    pop   ds„    pop   bp„    jc    @1„    mov   ah, 0„    @1:„    mov   @result, ah„  end;„end;„„Function LongNeeded (drive:Char):Boolean;„„{This Function returns True or False depending on whether the long versions}„{of absread/absWrite needed to be invoked; that is, it's a drive Formatted }„{in the Dos 4+ >32M style.                                                 }„{I strongly suggest you see Ralf Brown's interrupt listing For int21h subfs}„{440d and 53 - they'll tell you all you know to understand the guts of this}„{Function.                                                                 }„„Label Escape;„„Var drivestats:Array [0..31] of Byte;„„begin„  LongNeeded := False;„  if drive < 'A' then Exit;„  if drive > 'Z' then Exit;„  Asm„    push ds„    mov  dx, ss„    mov  ds, dx„    lea  dx, drivestats„    mov  bl, drive      { Gets the passed parameter. }„    and  bl, 1fh        { Cvt from ASCII to drive num }„    mov  ax, 440Dh„    mov  cx, 0860h„    int  21h„    jc   Escape„    mov  ax, Word ptr drivestats[0Fh]„    or   ax, ax„    jnz Escape„    mov  @Result, 1„  Escape:„    pop  ds„  end;„end;„„begin„  getmem (bp,2048);„  Writeln (LongNeeded ('A'));„  Writeln (LongNeeded ('C'));„  Writeln (absread  ('A',1,0,bp));„(*  Writeln (absWrite ('A',1,2399,bp)); *) {remove the comments at your own}„                                           {risk!!!}„  freemem (bp,2048);„end.„„{So I bought him a drink.  The poor guy looked like he needed one....}„                                 10     05-28-9313:48ALL                      SWAG SUPPORT TEAM        Activate TURBO Speed     IMPORT              9      ¿◊}v { Does anyone out there know how to set the Software Turbo Speed on Mother„ boards without hitting the Turbo Switch or the <Ctrl> <Alt> <-> key to„ slow the system and or Speed it up again? Thanks...„}„„Program speed;„Uses Dos,Crt;„„Procedure do_speed(mode : String);„Var„ reg : Registers;„ oldmem : Byte;„„begin„ oldmem := mem[$40:$17];„ if UpCase(mode[1]) = 'N' then„ begin„  reg.al := 74;„  Writeln('Speed set to NorMAL MODE');„ end else„ begin„  reg.al := 78;„  Writeln('Speed set to TURBO MODE');„ end;„ mem[$40:$17] := 140;„ reg.ah := $4F;„ intr($15,reg);„ mem[$40:$17] := oldmem;„end;„„begin„ if paramcount < 1 then„ begin„  Writeln(' Speed.exe (c) by Werner Schlagnitweit 2:310/3.0');„  Writeln(' This Program should work on all machines which ');„  Writeln(' use the CTRL-ALT-+ key to toggle the speed     ');„  Writeln;„  Writeln(' Usage : Speed N  For normal NON TURBO mode');„  Writeln('         Speed T  For normal TURBO mode    ');„  halt;„ end else do_speed(paramstr(1));„end.„                                11     08-27-9322:08ALL                      SWAG SUPPORT TEAM        Set the TURBO speed      IMPORT              6      ¿◊(‚ {„ Does anyone out there know how to set the Software Turbo Speed on Mother„ boards without hitting the Turbo Switch or the <Ctrl> <Alt> <-> key to„ slow the system and or Speed it up again? Thanks...„}„„Uses„  Dos;„„Procedure SetSpeed(Turbo : Boolean);„Var„  Regs   : Registers;„  OldMem : Byte;„„begin„  {OldMem := Mem[$40 : $17];}„  If Turbo then„    Regs.AL := 78„  else„    Regs.AL := 74;„„  {Mem[$40 : $17] := 140;}„  Regs.AH := $4F;„  Intr($15, Regs);„  {Mem[$40 : $17] := OldMem;}„end;„„begin„  SetSpeed(False);„end.„                                                                                                                   12     09-26-9308:48ALL                      GAYLE DAVIS              Determine CPU Type       IMPORT              20     ¿◊† Unit CPU;„„INTERFACE„„Type„  CpuType = ( cpu8088,„              cpu8086,„              cpu80286,„              cpu80386,„              cpu80486,„              cpuPentium,„              cpuFuture„             );„  CpuStrType = String[7];„„Function GetCpuType : CpuType;„  { Returns the currently executing CPU type }„„Function GetCpuTypeStr : CpuStrType;„  { Returns the currently executing CPU type as a string }„„IMPLEMENTATION„„Const„  CpuTypeIdentified : Boolean = False;„Var„  ConfirmedCpuType : CpuType;„„{$L CPU.OBJ}„„{$F+}„Function WhichCPU : CpuType;„  { Determines and returns the currently executing CPU type }„EXTERNAL;„{$F-}„„Procedure IdentifyCpuType;„  { Handles initialization of CPU type }„Begin„  If Not CpuTypeIdentified Then„  Begin„    ConfirmedCpuType  := WhichCPU;„    CpuTypeIdentified := True;„  End;„End;   { Procedure IdentifyCpuType }„„Function GetCpuType : CpuType;„  { Returns the currently executing CPU type }„Begin„  IdentifyCpuType;„  GetCpuType := ConfirmedCpuType;„End;   { Function GetCpuType }„„Function GetCpuTypeStr : CpuStrType;„  { Returns the currently executing CPU type as a string }„Begin„  IdentifyCpuType;„  Case ConfirmedCpuType Of„    cpu8088    : GetCpuTypeStr := '8088';„    cpu8086    : GetCpuTypeStr := '8086';„    cpu80286   : GetCpuTypeStr := '80286';„    cpu80386   : GetCpuTypeStr := '80386';„    cpu80486   : GetCpuTypeStr := '80486';„    cpuPentium : GetCpuTypeStr := 'Pentium';„    cpuFuture  : GetCpuTypeStr := 'Future';„  End;   { Case }„End;   { Function GetCpuTypeStr }„„End.„{ eof CPU.PAS }„„„NOTE  :    Cut the following code to a seperate file, and then„           USE XX34 to DECODE the block which contains CPU.OBJ„           needed with this unit.„„*XX3401-000399-290893--68--85-63424---------CPU.OBJ--1-OF--1„U+s+14BkRKZYMLBh9Y3HHE466++++-lIRL7WPm--QrBZPK7gNL6U63NZQbBdPqsUAmsm„aMUI+21dBaTF4UlXQ5JdN43nPGt-Iop0W+A+ECZAZU6++4W6+k-+cNGK-U+2Eox2FIKM„-k-6wk+0+E2WY+w+++26JoV7EoV1I3I+++1xW+E+E86-YO1r++2++-uAm6vMu-k+D+7x„-SUk+CgFu2Y+D+Bw0iVV+1k2T+DcV++TmtmQKs5XzkxHbNlPUSA+w1D+UTg+w5E0g+8R„kkOAm6v+zPc-+9xM+90EiEA+wufwY70EGd0EWw65ktkD+S1Fq5A3i+A+ul0s+5-EbNlM„UCFki+6+R+3+bQC9y6jQNdlab4NMNUo+++E+NZ-abKOQNZVaeE++-+-o+t0EFqORWyC9„lwBab4NMNcjMNXI++0++NZ-abKOQNZVaIqORNWI++0++Nc5X+++U+4MvkrESY7-ai+2+„+++Dch5coSXFuB5coSXFuB5coSUZ1k11i+E+kumQ-E12GJE-zMc0++-o„***** END OF XX-BLOCK *****„„„                                                                                  13     10-28-9311:29ALL                      BRUCE LACKLORE           CPU Info                 IMPORT              46     ¿◊Ù2 Unit CPUInfo;„„{	Version 1.1.0.P„„	Requires Borland Turbo Pascal version 6.0 or later to compile.„	Author:  Bruce J. Lackore.  Created Saturday, October 9, 1993.„}„„{$IFDEF Test}„	{$A+,B-,D+,F-,G-,I+,L+,O-,R+,S+,V-,X+}„{$ELSE}„	{$A+,B-,D-,F-,G-,I-,L-,O-,R-,S-,V-,X+}„{$ENDIF}„„{	This unit contains a handy gadget for determining the CPU speed.  It is NOT„	coded for the Pentium family (if anyone wants to take a shot at it, please„	let me know the results)!„}„„Interface„„Const„	Cpu8086  									= 1;„	Cpu80286 									= 2;„	Cpu80386 									= 3;„	Cpu80486 									= 4;„„Function WhatCPU:  Word;„„{	This function examines the CPU and returns a number corresponding to the„	CPU type;  1 for 8086, 3 for 80386, etc.  This procedure came right out of„	Neil Rubenking's Turbo Pascal 6.0 Techniques and Utilities (thanx Neil!).„}„„Procedure CPUSpd(Var MHz, KHz:  Word);„„{	This procedure is a ROUGH estimation of how fast the CPU is running in„	MegaHertz.  It was adapted from a C program found in the Intel forum of„	CIS written by Glenn Dill.  I had to do some finagling of the original code„	because C allows for a 32-bit UNSIGNED integer, whereas Pascal allows for a„	32-bit SIGNED integer (the LongInt), therefore, I was forced to reduce all„	calculations by 10 in order to get it to fit properly.„}„„{ ************************************************************************** }„„Implementation„„Function WhatCPU;  Assembler;„„	Asm  { Function WhatCPU }„			MOV    	DX,Cpu8086„			PUSH   	SP„			POP    	AX„			CMP    	SP,AX„			JNE 		@OUT„			MOV 		DX,Cpu80286„			PUSHF„			POP    	AX„			OR     	AX,4000h„			PUSH   	AX„			POPF„			PUSHF„			POP    	AX„			TEST   	AX,4000h„			JE     	@OUT„			MOV 		DX,Cpu80386			{	"DB 66h" makes '386 extended instruction }„			DB 66h; MOV BX,SP      	{	MOV EBX,ESP }„			DB 66h, 83h, 0E4h, 0FCh {	AND ESP,FFFC	}„			DB 66h; PUSHF           {	PUSHFD }„			DB 66h; POP AX          {	POP EAX	}„			DB 66h; MOV CX, AX      {	MOV ECX,EAX }„			DB 66h, 35h, 00h„			DB 00h, 04h, 00         {	XOR EAX,00040000	}„			DB 66h; PUSH AX         {	PUSH EAX }„			DB 66h; POPF            {	POPFD }„			DB 66h; PUSHF           {	PUSHFD }„			DB 66h; POP AX          {	POP EAX }„			DB 66h, 25h,00h„			DB 00h, 04h,00h        	{	AND EAX,00040000 }„			DB 66h, 81h,0E1h,00h„			DB 00h, 04h,00h        	{	AND ECX,00040000 }„			DB 66h; CMP AX,CX      	{	CMP EAX,ECX }„			JE @Not486„			MOV DX, Cpu80486„		@Not486:„			DB 66h; PUSH CX         {	PUSH ECX }„			DB 66h; POPF            {	POPFD }„			DB 66h; MOV SP, BX      {	MOV ESP,EBX }„		@Out:„			MOV AX, DX„	End;	{ Function WhatCPU }„„Procedure CPUSpd;„„	Const„		Processor_cycles:				Array[0..4] of Byte = (165, 165, 25, 103, 42);„														{	Cycle times of 8086, 80186, 80286, 80386, 80486}„„		{	Notice that here I have defined the 8086 as a Processor type of 0 vice„			the returned value of 1 from WhatCPU.  Since the original code did not„			distinguish between the 8086 and the 80186, I can get away with this.„		}„„	Var„		Ticks,„		Cycles,„		CPS:										LongInt;„		Which_CPU:							Word;„„	Function i86_to_i286:  Word;  Assembler;„„		Asm  { Function i86_to_i286 }„			CLI„			MOV		CX,1234„			XOR		DX,DX„			XOR		AX,AX„			MOV		AL,$B8„			OUT		$43,AL„			IN		AL,$61„			OR		AL,1„			OUT		$61,AL„			XOR		AL,AL„			OUT		$42,AL„			OUT		$42,AL„			XOR		AX,AX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IDIV	CX„			IN		AL,$42„			MOV		AH,AL„			IN		AL,$42„			XCHG	AL,AH„			NEG		AX„			STI„		End;  { Function i86_to_i286 }„„	Function i386_to_i486:  Word;	Assembler;„„		Asm  { Function i386_to_i486 }„			CLI„			MOV		AL,$B8„			OUT		$43,AL„			IN		AL,$61„			OR		AL,1„			OUT		$61,AL„			XOR		AL,AL„			OUT		$42,AL„			OUT		$42,AL„			DB 66H,$B8,00h,00h,00h,80h;„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			DB 66H,0FH,$BC,$C8;				{	BSF	ECX,EAX }„			IN		AL,42H„			MOV   AH,AL„			IN		AL,42H„			XCHG	AL,AH„			NEG		AX„			STI„		End;  { Function i386_to_486 }„„	Begin  { Procedure CPUSpd }„		Which_CPU := WhatCPU;„		If Which_cpu < 3 Then„			Ticks := i86_to_i286„		Else„			Ticks := i386_to_i486;„		Cycles := 20 * Processor_cycles[Which_CPU];„		CPS := (Cycles * 119318) Div Ticks;„		MHz := CPS Div 100000;„		KHz := (CPS Mod 100000 + 500) Div 1000„	End;  { Procedure CPUSpd }„„End.  { Unit CPUInfo }„„{ ---------------------   TEST PROGRAM --------------------------}„„Program CPUSpeed;„„{	Version 1.0.0.T.„„	Requires Borland Turbo Pascal version 6.0 or later to compile.„„	Author:  Bruce J. Lackore.  Created Saturday, October 9, 1993.„}„„{$IFDEF Test}„	{$A+,B-,D+,E+,F-,G-,I+,L+,N-,R+,S+,V-,X+}„{$ELSE}„	{$A+,B-,D-,E+,F-,G-,I-,L-,N-,R-,S-,V-,X+}„{$ENDIF}„„{$M 1024, 0, 0}„„Uses CPUInfo;„„Var„	MHz,„	KHz:											Word;„„Begin  { Program: Cpuspeed }„	CpuSpd(MHz, KHz);„	Writeln('The CPU speed is ', MHz, '.', KHz, ' MHz.')„End.  { Program:  Cpuspeed }„                                                                  14     11-02-9304:59ALL                      KAI ROHRBACHER           Which BIOS               IMPORT              9      ¿◊˜ô {„KAI ROHRBACHER„„> What bios are you using?„It's  an AMI-BIOS, dated 03-06-1992; but I ran the same code on an old„Tandon-AT (with BIOS from 1987) w/o problems, too!„„> Do you have any other timing code?„Not  at  hand;  one  could reProgram the trigger rate of timer 0 to be„faster  than  1/18.2  sec,  but in my experience, this results in even„more incompatibilities when interfacing the Unit to others.„}„„Function BIOScompatible : Boolean;„Var„  Flag : Byte;„  p    : Pointer;„begin„  Flag := 0;„  p    := @Flag;„  if AT then„  Asm„    STI„    xor CX, CX„    MOV DX, 1„    LES BX, p„    MOV AX, 8300h  {trigger 1 microsecond}„    INT 15h„   @L11:„  end;„  Delay(1); {wait 1 ms:}„  BIOScompatible := Flag = $80; {has flag been set?}„end;„„{„  ...results  in  False  For you, I can't do much! However, I'll add the„  above  routine to disable the timing mechanism in that Case to prevent„  the endless loop, at least.„}„                                                                                                     15     11-02-9305:41ALL                      KAI ROHRBACHER           AT Extended BIOS ??      IMPORT              16     ¿◊Òô {„KAI ROHRBACHER„„  As  promised,  here  is  some  TP-code  to  check whether your machine„  supports  the  extended timing services of the AT's-BIOS: if all works„  fine,  the  Program should give two beeps, the 2nd exactly 5secs after„  the 1st one -and then terminate.„„  (To  all  others  reading  this:  this  timing  scheme  normally works„  _asynchrone_ to whatever you are doing in the "foreground" Program and„  thus  is  great  For  timing  events.  What's  more:  the  clock has a„  resolution of some microseconds!)„}„„Const„  WaitTime = 5000;„Var„  IsAT,„  TimeFlag  : Byte;„  CycleTime : LongInt;„„Function AT : Boolean;„{ in: - }„{out: True/False, if the machine is (at least) an AT}„begin„  AT := MEM[$F000 : $FFFE] = $FC;„end;„„Procedure SetWaitingTime(milliseconds : Word);„{ in: milliseconds = time to wait in ms}„{out: CycleTime := that same value in microseconds}„{     TimeFlag  := $80}„{rem: won't work With PC's}„begin„  TimeFlag  := $80;„  CycleTime := LongInt(milliseconds) * LongInt(1000);„  if (milliseconds <> 0) and AT then„    IsAT := 0      {yes, use timing mechanism}„  else„    IsAT := $80;   {no, don't use that extended service}„end;„„Procedure Wait;„begin„  Asm„    MOV AL, IsAT„    or  AL, AL„    JNE @L11„    MOV TimeFlag,AL„    MOV DX, Word PTR CycleTime„    MOV CX, Word PTR CycleTime+2„    MOV BX, OFFSET TimeFlag„    MOV AX, DS„    MOV ES, AX„    MOV AX, 8300h„    INT 15h„   @L11:„„   @L10:„    MOV AL, TimeFlag {look at bit 7: 1/0 = time over/not over}„    and AL, $80„    JE  @L10„  end;„end;„„begin„  if not AT then„  begin„    WriteLN('Sorry, this Program requires the extended BIOS-' +„            'services, available on AT''s only!');„    Halt(1);„  end;„  WriteLN('The time between the two beeps should be exactly ', WaitTime,„          ' milliseconds!');„  Write(#7);„  SetWaitingTime(5000);„  Wait;„  Write(#7);„end.„                                                 16     11-02-9310:33ALL                      ERIC SCHILKE             PORTS Info               IMPORT              15     ¿◊‹¯ {„ERIC SCHILKE„„>  I need help in obtaining all pertinent information about„>  AuxInPtr and AuxOutPtr, as pertaining to TP 3.0 reserved„>  Words. These Pointers are referencing BIOS entry points.„„This is from memory, since I don't have the references here, and„it has been a While....  AuxInPtr and AuxOutPtr are Pointers„containing the addresses of the respective AuxIn Function and„AuxOut Procedure, which are used (and not available as a standard„Function/Procedure) by the standard TP3 I/O drivers.„„Each of the I/O possibilities has a corresponding Procedure/Function,„address Pointer, and BIOS entry point as follows:„„     Device        proc/funct        address      BIOS entry„„  CON:,TRM:,KBD:   ConIn:Char;       ConInPtr       CONIN„  CON:,TRM:,KBD:   ConOut(Ch:Char);  ConOutPtr      CONOUT„  LST:             LstOut(Ch:Char);  LstOutPtr      LIST„  AUX:             AuxIn:Char;       AuxInPtr       READER„  AUX:             AuxOut(ch:Char);  AuxOutPtr      PUNCH„  USR:             UsrIn:Char;       UsrInPtr       CONIN  ?„  USR:             UsrOut(ch,Char);  UsrOutPtr      CONOUT ?„„I'm not sure about the last two entry points.  Also, if memory„serves correctly, there is another Function, ConSt:Boolean, which„is used by the KeyPressed Function, having a corresponding address„Pointer, ConStPtr, With BIOS entry Const.  if you Write your own I/O„drivers, you should assign the address of the corresponding driver„Function or Procedure to the proper Pointer Variable.  Your question„is a bit vague; what specific problems have you encountered?  I„think that my recollection is accurate; however, my old references„are in an attic in Pennsylvania, While I am here in Huntsville,„Alabama.  Perhaps someone else could confirm and/or amplify on„these observations.„}„         17     11-02-9316:11ALL                      LAURENT M. CHARTINIER    Quick Reset and BOOT     IMPORT              3      ¿◊,< {Laurent M. CHARTINIER}„{computer do a RESET using a small Pascal routine?}„„Procedure Reboot;„Begin„ Asm„  JMP FFFF:0000„ End;„End;„„                                                                                                                          18     01-27-9411:55ALL                      RANDALL WOODMAN          CMOS Data                IMPORT              64     ¿◊y {„Ø Does anyone know how to get the hard drive type(s) from CMOS ?„Ø I can't seem to find this information documented anywhere.„„This is probably a lot more than you are asking for but. . .„NOTE: one function (Long2Str) is not defined in this because it comes from„a commercial unit.  Basically all it does is convert a number to a string„and return the string.„     This code comes from a unit I wrote to get all kinds of niffty„information about your system.  I think I included everything you will need„to get it up and running.  If you get any strange problems or ones you„can't seem to resolve, let me know and I'll see if I can pass you the right„information.„}„„Uses„  KMath,„  Dos;„„type„  String80 = String[80];  { some general purpose string types }„  String40 = String[40];„  String30 = String[30];„  String20 = String[20];„  String12 = String[12];„  String10 = String[10];„  String5  = String[5];„„  CMOSRec = Record„    Found     : Boolean;  { was a CMOS found to exist }„    CmosDate  : String30; { the date found in CMOS }„    CmosTime  : String30; { the time found in CMOS }„    VideoType : String10; { Type of video found in CMOS }„    Coproc    : Boolean;  { does CMOS report a math coprocessor }„    FloppyA   : String12; { type of floppy drive for A }„    FloppyB   : String12; { Type of floppy drive for B }„    Hard0     : Byte;     { Type of hard drive for drive 0 }„    Hard1     : Byte;     { Type of hard drive for Drive 1 }„    ConvenRam : Word;     { amount of conventional ram indicated }„    ExtendRam : Word;     { amount of extended Ram indicated }„    checkSum  : Boolean;  { Did checksum pass }„  end; { CMOS Rec }„„const„  { values of constants for CMOS }„  DayName: array[0..7] of string[9] = ('Sunday', 'Monday', 'Tuesday',„                                       'Wednesday', 'Thursday', 'Friday',„                                       'Saturday', 'Sunday');„  MonthName: array[0..12] of string[9] = ('???', 'January', 'February', 'March',„                                          'April', 'May', 'June', 'July',„                                          'August', 'September', 'October',„                                          'November', 'December');„  ScreenName: array[0..3] of string[10] = ('EGA/VGA', 'CGA 40col',„                                           'CGA 80col', 'Monochrome');„  FloppyName: array[0..5] of string[11] = ('none', '5.25" 360K',„                                           '5.25" 1.2M', '3.5"  720K',„                                           '3.5"  1.44M', '3.5"  2.88M');„  CMOSport : Byte = $70; { port to access the CMOS }„„{===========================================================================}„„„VAR„  Regs : Registers; { General purpose variable to access registers }„  CMOS : CMOSRec;   { variable to hold CMOS data }„„function nocarry : boolean;„{ returns the status of the carry flag }„begin„  nocarry:=regs.flags and fcarry = $0000„end; {nocarry}„„{---------------------------------------------------------------------------}„„Function ByteToWord(ByteA, ByteB : byte) : word;„begin„   ByteToWord := Word(ByteB) shl 8 + ByteA„end; {cbw}„„{---------------------------------------------------------------------------}„„Function BitIsSet(CheckWord : Word; AndValue : Word) : Boolean;„{ returns true if the bit(s) indicated in AndValue are set in CheckByte }„BEGIN„  BitIsSet := CheckWord AND AndValue = AndValue;„end;„„{---------------------------------------------------------------------------}„„Function ReadCMOS(addr: byte): byte;„{ read a value from the CMOS }„Begin„  if CMOSport = $70 then„  begin„    inline($FA);„    Port[CMOSport] := addr;„    readCMOS := Port[CMOSport + 1];„    inline($FB)„  end„end; {readCMOS}„„{---------------------------------------------------------------------------}„„function addzero(b: byte): string5;„var„  c2: string[2];„begin„  Str(b:0, c2);„  if b < 10 then„    c2:='0' + c2;„  addzero:=c2„end; {addzero}„„{---------------------------------------------------------------------------}„„Function ChangeBCD(b: byte): byte;„{ change a BCD into a byte structure }„Begin„  ChangeBCD:=(b and $0F) + ((b shr 4) * 10)„end; {ChangeBCD}„„{---------------------------------------------------------------------------}„„Function GetCMOSDate : String30;„{ gets the date found in the CMOS and returns it in string format }„VAR„  Date,„  Century,„  Year,„  Month : Byte;„  WorkStr : String30;„BEGIN„  WorkStr := '';„  date    := ChangeBCD(readCMOS(7));„  century := ChangeBCD(readCMOS($32));„  year    := ChangeBCD(readCMOS(9));„  month   := ChangeBCD(readCMOS(8));„  WorkStr := DayName[readCMOS(6)]+', ';„  {case country.DateFormat of„    0, 3..255 :}„      WorkStr := WorkStr + Monthname[month]+' '+IntToStr(date)+', '+IntToStr(century)+addzero(year);„ {   1 :„      WorkStr := WorkStr + Long2Str(date)+', '+Monthname[month]+' '+Long2Str(century)+addzero(Year);„    2 :„      WorkStr := WorkStr + Long2Str(century)+addzero(Year)+', '+Monthname[month]+' '+Long2Str(date);„  end; {case}„  GetCMosDate := workStr;„end; { GetCMOSDate }„„{---------------------------------------------------------------------------}„„Function GetCmosTime : String30;„{ returns the time as found in the CMOS }„VAR„  CH : Char;„  Hour,„  Min,„  Sec  : Byte;„  WorkStr : String30;„  IsPM    : Boolean;„BEGIN„  workStr := '';„  hour := ChangeBCD(readCMOS(4));„  min := ChangeBCD(readCMOS(2));„  sec := ChangeBCD(readCMOS(0));„  IsPm := false;„  case hour of„        0: hour := 12;„        1..11: hour := hour;„        12: IsPM := true;„        13..23: begin„                  IsPM := true;„                  hour := hour - 12„                end;„  end; {case}„  WorkStr := WorkStr + AddZero(hour)+':'+addzero(min)+':'+addzero(sec);„  if IsPM then„    workStr := WorkStr + ' PM'„  Else„    WorkStr := WorkStr + ' AM';„  GetCMOSTime := WorkStr;„end; { GetCmosTime }„„{---------------------------------------------------------------------------}„„Function GetCmosCheckSum : Boolean;„{ performs checksum on CMOS and returns true if ok }„VAR„  CheckSum1,„  CheckSum2 : word;„  Count     : Byte;„BEGIN„  checksum1 := 0;„  for count := $10 to $2D do„    Inc(checksum1, readCMOS(count));„  checksum2 := (word(256) * readCMOS($2E)) + readCMOS($2F);„  if checksum1 = checksum2 then„    GetCmosCheckSum := true„  else„    GetCmosCheckSum := false;„end; { GetCmosCheckSum }„„{---------------------------------------------------------------------------}„„Procedure GetCMos;„{ gets the cmos record if it exist }„VAR„  Floppy : Byte;„BEGIN„  FillChar(CMOS, SizeOf(CMos), 0);„  regs.AH:=$C0;„  Intr($15, regs);„  if nocarry or (Mem[$F000:$FFFE] <= $FC) then„  With CMOS DO„  begin„    Found := true;„    CMOSDate := GetCMOSDate;„    CMOSTime := GetCmosTime;„    VideoType := ScreenName[(readCMOS($14) shr 4) and 3];„    CoProc := BitIsSet(readCMOS($14), 2);„    Floppy := readCMOS($10);„    if (Floppy shr 4) < 5 then„      FloppyA := FloppyName[floppy shr 4]„    else„      FloppyA := 'Unknown '+ Byte2Hex(floppy shr 4);„    if (floppy and $0F) < 5 then„      FloppyB := FloppyName[floppy and $0F]„    else„      FloppyB := 'Unknown '+ Byte2Hex(floppy and $0F);„„    Hard0 := readCMOS($12);„    Hard0 := Hard0 shr 4;„    Hard1 := ReadCmos($12);„    Hard1 := Hard1 and $0F;„    if Hard0 = $F then„      Hard0 := readCMOS($19)„    Else Hard0 := $FF; { error }„    if Hard1 = $F then„      Hard1 := readCMOS($1A)„    Else Hard1 := $FF;„    ConvenRam := word(256) * readCMOS($16) + readCMOS($15); { value in K }„    ExtendRam := word(256) * readCMOS($18) + readCMOS($17); { value in K }„    CheckSum := GetCmosCheckSum;„  end„  else„    CMOS.Found := false;„end;„„begin„  GetCmos;„  Writeln(CMOS.Found);„  Writeln(CMOS.CmosDate);„  Writeln(CMOS.CmosTime);„  Writeln(CMOS.VideoType);„  Writeln(CMOS.Coproc);„  Writeln(CMOS.FloppyA);„  Writeln(CMOS.FloppyB);„  Writeln(CMOS.Hard0);„  Writeln(CMOS.Hard1);„  Writeln(CMOS.ConvenRam);„  Writeln(CMOS.ExtendRam);„  Writeln(CMOS.checkSum);„end.„                                                                                                               19     01-27-9411:56ALL                      ANDREW KEY               Color Monitor            IMPORT              7      ¿◊85 {„> I have always addressed $B800 as the screen segment for direct video„> writes in text.... Err, umm, does anyone have the code to detect whether„> it is $B000 or $B800 (for Herc.'s and the like)...„}„„Function ColorAdaptor: Boolean; Assembler; {returns TRUE for color monitor}„asm„  int 11                   {BIOS call - get equipment list}„  and ax, $0030            {mask off all but bits 4 & 5}„  xor ax, $0030            {flip bits 4 & 5 - return val is in ax}„end;„„{„This function uses a BIOS interrupt to get the equipment list(at $0000:$0410)„as determined at time of power-up.  The only problem I can see here is that„a TRUE(non-zero value in al) will also be returned if no video card was„detected at power-up.„}                                           20     01-27-9411:56ALL                      DUSTIN NULF              CPU Speed                IMPORT              14     ¿◊e‚ {„>>> How can i determine the machine's CPU clock speed from a TP„>>> program? An 100% accurate result is not required.„„>> Use a counter and continually increase it. Check the clock and see how„„> There's a big problem : Newer CPUs are faster in executing„> this commands and caching really speed's up the timer.„}„„CONST„  Cpu8086  = 1;„  Cpu80286 = 2;„  Cpu80386 = 3;„  Cpu80486 = 4;„„VAR„  CPU : BYTE;„„„FUNCTION CPUSpeed : BYTE; Assembler;„Asm„ MOV   DX,Cpu8086„ PUSH  SP„ POP   AX„ CMP   SP,AX„ JNE   @OUT„ MOV   DX, Cpu80286„ PUSHF„„ POP   AX„ OR   AX,4000h„ PUSH  AX„ POPF„ PUSHF„ POP   AX„ TEST  AX,4000h„ JE   @OUT„ MOV DX, Cpu80386„ {"DB 66h" indicates '386 extended instruction}„ DB 66h; MOV   BX, SP      {MOV EBX, ESP}„ DB 66h, 83h, 0E4h, 0FCh   {AND ESP, FFFC}„ DB 66h; PUSHF             {PUSHFD}„ DB 66h; POP AX            {POP EAX}„ DB 66h; MOV   CX, AX      {MOV ECX, EAX}„ DB 66h, 35h, 00h„ DB 00h, 04h, 00           {XOR EAX, 00040000}„ DB 66h; PUSH   AX     {PUSH EAX}„„ DB 66h; POPF              {POPFD}„ DB 66h; PUSHF             {PUSHFD}„ DB 66h; POP   AX     {POP EAX}„ DB 66h, 25h, 00h„ DB 00h, 04h, 00h          {AND EAX, 00040000}„ DB 66h, 81h, 0E1h, 00h„ DB 00h, 04h, 00h          {AND ECX, 00040000}„ DB 66h; CMP   AX, CX      {CMP EAX, ECX}„ JE @Not486„ MOV DX, Cpu80486„@Not486:„ DB 66h; PUSH   CX         {PUSH EXC}„ DB 66h; POPF              {POPFD}„ DB 66h; MOV   SP, BX      {MOV ESP, EBX}„@Out:„ MOV AX, DX„end;„„„begin { main }„„„  Writeln(CPUSpeed);  { 1, 2, 3, or 4 is returned; see above consts }„„„end.„„                                                                                                                      21     01-27-9411:57ALL                      WILLIAM PLANKE           device Driver Lists      IMPORT              46     ¿◊9Q {„I've posted a working util that lists the Device Drivers that are resident in„memory.  It uses the header record to point to the next driver in the chain„and "walks" the memory chain until an offset end flag is reached.  Hope you„enjoy it and that it isn't too sloppy.  At the end, I have a question that„needs to be answered if you're interested....„}„„program DevList;„„{ this program walks the device driver memory chain. Each device„  driver points to the next until the ENDFLAG is reached.  I use„  the popular undocumented DOS function $52 to jump to the DOS„  "List of Lists" then $22 bytes beyond that, the first device in„  the chain (NUL) can be found.„„  Thanks to Ralf Brown and his valuable MS DOS Interrupts List,„  to Timo Salmi, and to the person(?) who wrote the cool„  hex-to-string conversion functions that I use all the time.„}„„{$M 8192,0,0}„„uses„  DOS;„„type„  pstrg = string[9];                { pointer conversion format }„„  Array8C = array [1..8] of char; { for device and file names }„„  DevRec = record„    NextDev_ofs  : word; {pointer to next device header, offset value}„    NextDev_seg  : word; {pointer to next device header, segment value}„    Attributes   : word; {Attributes: block or char, IOCTL, etc.}„    Strategy     : word; {pointer to device strategy routine, offset}„    Interrupt    : word; {pointer to device interrupt routine, offset}„    NameDev      : Array8C; {Name if char, or units if block}„  end;„  DevPtr = ^DevRec;„„  DevFileRec = record„    FileName : Array8C;„  end;„  DevFilePtr = ^DevFileRec;„„const„  LOL_HEADDEV_NUL  = $22; { offset from "List of Lists"„                            to NUL device header }„  FNAME            = $8;„  ENDFLAG          = $FFFF;„  STDDEVS : array [1..12] of Array8C =„    ('NUL     ', 'CON     ', 'AUX     ', 'PRN     ',„     'CLOCK$  ', 'COM1    ', 'COM2    ', 'COM3    ',„     'COM4    ', 'LPT1    ', 'LPT2    ', 'LPT3    ');„„var„  r       : registers;„  i,        { index }„  Adjust  : byte;„  Header  : DevPtr;„  DevFile : DevFilePtr;„  Valid,„  Done    : boolean;„„„function BinW(Decimal : word) : string;„const„  BINDIGIT : array [0..1] of char = '01';„var„  i     : byte;„  Binar : string;„begin„  fillchar (binar, sizeof(Binar), ' ');„  Binar [0] := chr(16);„  for i := 0 to 15 do„    Binar[16-i] := BINDIGIT[(Decimal shr i) and 1];„  BinW := Binar;„end;„„„function HexN (b : byte) : char;        { convert nibble to char }„begin„  b := b and 15;                   { forces to only 4 bits }„  if b > 9 then„     inc(b,7);                    { adjust for hex digits };„  HexN := chr(b+48);              { convert to character }„end;„„„function HexB(b : byte) : string;„begin„  HexB := HexN (b shr 4) + HexN (b);  { assemble the nibbles }„end;„„„function HexW(w : word) : string;„begin„{$R-}„  hexw := HexB(w shr 8) + HexB(w);  { assemble the bytes }„{$R+}„end;„„„function HexL(l : longint) : string;„begin„  HexL := HexW(l shr 16) + HexW(l); { assemble the words }„end;„„„function XP(p : pointer) : pstrg;         { display pointer P }„begin„  XP := HexW(seg(p^)) + ':' + HexW(ofs(p^));„end;„„begin„  assign(output, '');„  rewrite(output);     { allow command line redirection }„  writeln('Device':0, 'Address':12, 'Strat':10, 'Intrpt':8,„          'Attrib':10, 'File Name':23);„  for i := 1 to 69 do„    write('-');„  writeln;„„  with r do„  begin„    es := 0;„    bx := 0;„    ah := $52;„    { this is an undocumented DOS function call:„      Get pointer to DOS "List of Lists" }„    msdos (r);„    { es and bx now have values }„    if (es = 0) and (bx = 0) then„      halt(0);„„    Header := ptr(es, bx + LOL_HEADDEV_NUL); { we get NUL dev from this }„  end; {with}„„  Done := FALSE; { dummy variable to keep the repeat loop going,„                    otherwise would have to duplicate the output„                    routines one more time for the final device. }„  repeat„    with Header^ do„    begin„      Adjust := 0;„      { adjust keeps display columns aligned, bit 15 set is a Character„        device, if clear it is a Block device and 1st byte is # of block„        devs supported}„„      if boolean ((Attributes shr 15) and 1) = TRUE then„        write (NameDev)„      else„      begin„        write ('BLKdev=', byte (NameDev[1]));„        Adjust := byte (NameDev[1]) div 10;„      end;„„      write(XP(Header) : 12 - Adjust);„      write(HexW(Strategy) : 7);„      write(HexW(Interrupt) : 7);„      write(HexW(Attributes) : 7, '=');„      write(BinW(Attributes));„„      { this next section I can't find documented anywhere, but I observed it„        and decided to include it anyway, with MSDOS v5.0, others are unknown.„        The file name's extension isn't saved and doesn't matter, either. }„„      if ofs(Header^) < FNAME then„      { "borrow" from the segment and give it to the offset }„        DevFile := ptr(seg(Header^) - $1, ofs(Header^) + $10 - FNAME)„      else„        DevFile := ptr(seg(Header^), ofs(Header^) - FNAME);„„      Valid := TRUE;„      for i := 1 to 12 do„        if DevFile^.FileName = STDDEVS[i] then„          Valid := FALSE;„„      if Valid then„        for i := 1 to 8 do„          if not (DevFile^.Filename[i] in [' '..'z']) then„            Valid := FALSE;„„      if {still} Valid then„        write ('  ', DevFile^.FileName);„„      writeln;„      if NextDev_ofs = ENDFLAG then„        exit; { end of the device chain }„„      Header := ptr(NextDev_seg, NextDev_ofs);„„    end; {with}„  until Done;„end.„{„The question: I have seen utils that do this actually give the size of„the driver in memory.  MSD and PMap both do this.  Does anybody know„how I can determine the size of the driver in memory?„}                                                                                                          22     01-27-9411:58ALL                      HELGE HELGESEN           HD Type                  IMPORT              4      ¿◊‘  {„> Does anyone know how to get the hard drive type(s) from CMOS ?„}„„Function GetFixedDrive(DriveNum : Byte) : Byte; Assembler;„Asm„  mov  al, DriveNum„  and  al, 1„  add  al, $19„  out  $70, al„  in   al, $71„end;„„{„You specify what drive you want (0/1) and you'll get the„disk type as specified in CMOS.„}„„begin„  Writeln(GetFixedDrive(3));„end.                                  23     01-27-9412:12ALL                      THORSTEN BARTH           Port Info                IMPORT              18     ¿◊^ﬂ {„> Can anybody give me any info on how to read signals from pins on say„> COM2: or from LPT1: or even from The joystick port? I think it has„> been done with the PORT command or something, but what are the values„> to use to read them with? Thanks.„„You can read in signals from different pins on LPT ports with the PORT„command ( =OUT/IN command in assembler). Just determine the base adress of„the LPT port using„}„„  LPTadress := MemW[$40 : 6 + LPTNr * 2];„„{„where LPTNr is the number of the LPT port from 1 to 3.„„Should return 03BCh, 0378h or 0278h.„That has to be done once at the beginning of the program.„Now you can start to read/write values on this port.„The LPT port has:„„- 8 data outputs (pin 2 to 9), which can be written using„}„„  Port[LPTAdress] := B;„„{„where B is a byte consisting of the 8 bits. Voltage will be 5V for 1, and 0V„for 0. (but not very high power available (TTL/CMOS)„„- 4 handshake outs which can be written by„}„„  Port[LPTAdress + 2] := B;„„{„where B is a byte with the lowest 4 bits set to the values of the pins and„the higher 4 bits always set to zero.„„        PIN  1: Strobe --> bit 0„        PIN 14: AutoFD --> bit 1„        PIN 16: Init   --> bit 2„        PIN 17: SelIN  --> bit 3„„        Attention! bit 2/pin 16 is 0V when set to zero, all others„        are INVERTED! (0 --> 5V and vice versa)„„- 5 handshake inputs which can be read by„}„„     B := Port[LPTAdress + 1];„„{„     After the command, B contains the signals that are connected to the„     input pins of the LPT port:„        Bit 0-2: no function„        Bit 3 --> PIN 15/Error„        Bit 4 --> PIN 13/Select„        Bit 5 --> PIN 12/PaperEmpty„        Bit 6 --> PIN 10/Acknowledge„        Bit 7 --> PIN 11/Busy     ===> Attention! This input is INVERSE!„„ For information: The pins 18 to 25 are Signal Ground pins.„ To use the inputs, connect TTL level 0V for 0, and 5V for 1 to them.„ (Or just use a resistor 10kOhm against +5V (take it from the keyboard„ connector or so, don't know what pin that is :-( and a switch against GND:„ then you can read in the status of the swith: CLOSED: 0, OPEN: 1...)„}                                                          24     01-27-9412:18ALL                      MARK LEWIS               Port Addresses           IMPORT              18     ¿◊éf {„> does anybody knows the address for serial/parallel ports?„„you can find them by reading the 7 (seven) WORDs starting at address 0040:0000„<smile>...„}„„CONST„  BIOSBASE : word = $0040;„  PORTADDR : word = $0000;„„VAR„  COM1, COM2,„  COM3, COM4,„  LPT1, LPT2, LPT3 : word;„„BEGIN„  COM1 := memw[BIOSBASE:PORTADDR+0];„  COM2 := memw[BIOSBASE:PORTADDR+2];„  COM3 := memw[BIOSBASE:PORTADDR+4];„  COM4 := memw[BIOSBASE:PORTADDR+6];„  LPT1 := memw[BIOSBASE:PORTADDR+8];„  LPT2 := memw[BIOSBASE:PORTADDR+10];„  LPT3 := memw[BIOSBASE:PORTADDR+12];„END.„„{„RICHARD BROWNE„„>I guess I can declare an absolute variable at $40:$0000 and use offset to fi„>the addresses.  Just a guess - haven't tried it yet. Thanks for your help.„„Do this, it works.  When you WRITELN the variables to the„screen, they will be in decimal.  If you convert them to hex,„you'll see that they are the old, familiar addresses.  If any„variable is zero, there is no port present in your computer.„„Another thing you'll notice, if you have com4, for instance, but„no com3.  The normal com4 address will show up in the com3„memory location, and the com4 adderess will be 0.  Which„explains why funny things happen when you are using ports 1, 2„and 4 with no 3, or 1 and 3 with no 2, etc., and why we are told„to always have consecutive com ports, with no "missing" numbers.„}„program testadr;„var„   com1adr : Word Absolute $0040:$0000; { Get COM1 Port address }„   com2adr : Word Absolute $0040:$0002; { Get COM2 Port address }„   com3adr : Word Absolute $0040:$0004; { Get COM3 Port address }„   com4adr : Word Absolute $0040:$0006; { Get COM4 Port address }„   lpt1adr : Word Absolute $0040:$0008; { Get LPT1 Port address }„   lpt2adr : Word Absolute $0040:$000A; { Get LPT2 Port address }„   lpt3adr : Word Absolute $0040:$000C; { Get LPT3 Port address }„„begin„   writeln('com1 address: ',com1adr);„   writeln('com2 address: ',com2adr);„   writeln('com3 address: ',com3adr);„   writeln('com4 address: ',com4adr);„   writeln('lpt1 address: ',lpt1adr);„   writeln('lpt2 address: ',lpt2adr);„   writeln('lpt3 address: ',lpt3adr);„   readln;„end.„                                                             25     01-27-9413:31ALL                      GREG VIGNEAULT           CPU/FPU processor type   IMPORT              20     ¿◊Cj (*-------------------------------------------------------------------*)„ UNIT CPUID; {CPUID.PAS} { determine CPU and FPU processor types }„ Interface               { Copyright 1992 Gregory S. Vigneault }„„ Const	CpuType :Array[0..10] of String[7] = ('8088','8086','NEC V20',„	'NEC V30','80186','80188','80286','386DX','386SX','486DX','486SX');„„	FpuType :Array[0..4] of String[5] = ('None','8087','80287','80387',„	'80487');„„ FUNCTION GetCPU( VAR FPUtype :BYTE ) :BYTE;„ { GetCPU codes:„    0 = 8088      |   6 = 80286„    1 = 8086      |   7 = 386DX   or older/undetected 386SX„    2 = NEC V20   |   8 = 386SX   * not always detected in all modes„    3 = NEC V30   |   9 = 486DX   or (486SX with 487SX)„    4 = 80186     |   10= 486SX„    5 = 80188     |„  FPUtype codes: 0 = none„                 1 = 8087„                 2 = 80287„                 3 = 80387   * 387DX or 387SX„                 4 = 80487   * 487SX or 486DX„                 17= undetermined copro reported by BIOS }„ Implementation  { Mar.9.92 }„ {$L GETCPU.OBJ}„ FUNCTION GetCPU( VAR FPUtype :BYTE ) :BYTE; EXTERNAL;„ END.    { Unit CPUID }„(*-------------------------------------------------------------------*)„(*-------------------------------------------------------------------*)„ PROGRAM ProcessorID; {PID.PAS   determine CPU & FPU (NDP) types }„ USES    CPUID;„ VAR     FPUtype, CPUtype     :BYTE;„ BEGIN„        WriteLn( #10,' PID v0.2, 1992 G.S.Vigneault',#10);„        Write(' CPU type: ');„        CASE GetCPU( FPUtype ) OF„            0   : WriteLn('8088');„            1   : WriteLn('8086');„            2   : WriteLn('NEC V20');„            3   : WriteLn('NEC V30');„            4   : WriteLn('80188');„            5   : WriteLn('80186');„            6   : WriteLn('80286');„            7   : WriteLn('386DX');„            8   : WriteLn('386SX');„            9   : WriteLn('486DX');„            10  : WriteLn('486SX')„            END; {case GetCPU}„        Write(' FPU type: ');„        CASE FPUtype OF„            0   : WriteLn('none');„            1   : WriteLn('8087');„            2   : WriteLn('80287');„            3   : WriteLn('80387');„            4   : WriteLn('80487');„            17  : WriteLn('in equipment byte');„            END; {case FPUtype}„ END.    {ProcessorID}„(*-------------------------------------------------------------------*)„                                                                                          26     02-03-9409:19ALL                      DAVID GWILLIM            Complete BIOS Table      IMPORT              36     ¿◊   {„  This is a complete map of PC, XT, AT, PS/2 and EGA-installed data„  areas between 0400h and 0500h in the low memory segment put into the„  form of a Turbo Pascal 4/5/5.5 compatible unit.„„  I found myself needing one or two of these absolute addresses from time„  to time and got tired of looking them up. Using a record structure„  declared as absolute variable relieves you of specifying the„  individual addresses for each variable, providing that all the Resrved„  areas are included too.„„  I hope this saves all those Turbo Pascal programmers out there some time„  and lets them get on with the creative side of the business. Enjoy!„„  David Gwillim„  159 Woodbury Road„  Hicksville, NY 11801-3030„  (516) 942-8697„„  6 August 1989„„  CREDITS:„„  The absolute addresses for this unit came from "The Programmer's PC„  Sourcebook" by Thom Hogan, published by Microsoft Press.„  ISBN 1-55615-118-7. List price $24.95 USA.„„  This book is very helpful (apart from a few inevitable) typos). I„  consider it an essential purchase for any programmer who has to deal„  with a PC at the hardware level.„„}„„unit Bios;„„interface„„var„   BiosSeg : record„      ComBase : array[1..4] of word;„      LptBase : array[1..4] of word;„      InstalledHardware : array[1..2] of byte;„      POST_Status : byte;      { Convertible only }„      MemorySize : word;„      _RESERVED1 : word;„      KeyboardControl : array[1..2] of byte;„      AlternateKeypadEntry : byte;„      KeyboardBufferHeadPtr : word; { points to first char in type-ahead buffer }„      KeyboardBufferTailPtr : word; { points to last char in type-ahead buffer }„      KeyboardBuffer : array[1..16] of word;„      FloppyRecalStatus : byte;„      FloppyMotorStatus : byte;„      FloppyMotorOffCounter : byte;„      FloppyPrevOpStatus : byte;„      FloppyControllerStatus : array[1..7] of byte;„      DisplayMode : byte;„      NumberOfColumns : word;„      RegenBufferLength : word;„      RegenBufferAddress : word;„      CursorPosition : array[1..8] of word;„      CursorType : word;„      CurrentDisplayPage : byte;„      VideoControllerBaseAddress : word;„      Current3x8Register : byte;„      Current3x9Register : byte;„      PointerToResetCode : pointer;  { PS/2 only - except model 30 }„      _RESERVED2 : byte;„      TimerCounter : longint;„      TimerOverflowFlag : byte;  { non-zero means timer passed 24 hours }„      BreakKeyState : byte;„      ResetFlag : word;  { $1234=bypass mem test; $4321=preserve mem (PS/2) }„                         { $5678=system supended (Convertible) }„                         { $9ABC=manufacturing test (Convertible) }„                         { $ABCD=system POST loop (Convertible only) }„      FixedDiskPrevOpStatus : byte;„      NumberOfFixedDrives : byte;„      FixedDiskDriveControl : byte;   {XT only}„      FixedDiskControllerPort : byte; {XT only}„      LptTimeOut : array[1..4] of byte;  { [4] valid for PC, XT and AT only }„      ComTimeOut : array[1..4] of byte;„      KeyboardBufferStartOffsetPtr :word;„      KeyboardBufferEndOffsetPtr :word;„      VideoRows : byte;„      CharacterHeight : word;  { bytes per character }„      VideoControlStates : array[1..2] of byte;„„      _RESERVED3 : word;„      MediaControl : byte;„      FixedDiskControllerStatus : byte; { AT, XT after 1/10/85, PS/2 only }„      FixedDiskControllerErrorStatus : byte; { AT, XT after 1/10/85, PS/2 only }„      FixedDiskInterruptControl : byte; { AT, XT after 1/10/85, PS/2 only }„      _RESERVED4 : byte;„      DriveMediaState : array[0..1] of byte;„      _RESERVED5 : word;„      DriveCurrentCylinder : array[0..1] of byte;„      KeyboardModeState : byte;„      KeyboardLEDflags : byte;„      UserWaitCompleteFlagAddress : pointer;„      UserWaitCount : longint;   { micro-seconds }„      WaitActiveFlag : byte;„      _RESERVED6 : array[1..7] of byte;„      VideoParameterTable : pointer;          { EGA and PS/2 only }„      DynamicSaveArea : pointer;              { EGA and PS/2 only }„      AlphaModeAuxCharGenerator : pointer;    { EGA and PS/2 only }„      GraphicsModeAuxCharGenerator : pointer; { EGA and PS/2 only }„      SecondarySaveArea : pointer;            { PS/2 only (not Model 30) }„      _RESERVED7 : array[1..4] of byte;„      _RESERVED8 : array[1..64] of byte;„      PrintScreenStatus : byte;„   end absolute $0040:$0000;„„implementation„„end.„„„„                                                                                                                             27     02-03-9416:18ALL                      STEVE ROGERS             Disabling PrtScr         IMPORT              5      ¿◊   „{  Anyone have any idea why this won't disable PrtScr? }„„uses„  crt,dos;„„var„  i : word;„  old_status : byte;„  prt_status : byte absolute $0040:$0100; { PrtScr status byte }„„begin„  old_status:= prt_status;„  prt_status:= 1;„  for i:= 1 to 20 do writeln(' This is line ',i);„  writeln;„  writeln('Press PrtScr to test, any other key to exit');„  readkey;„  prt_status:= old_status;„end.„                                                                                                                        28     05-25-9408:02ALL                      COLEK UMNICKI            Get CPU Type             SWAG9405            9      ¿◊   „{$D-} {$L-}„Program Cpuu;„„Const„    Cpu      : Array[1..4] of String[5] = ('8086','80286','80386','80486');„    Cpu8086  = 1;„    Cpu80286 = 2;„    Cpu80386 = 3;„    Cpu80486 = 4;„„Function GetCPU_Type: Byte; Assembler;„ASM„ MOV    DX, CPU8086„ PUSH   SP„ POP    AX„ CMP    SP,AX„ JNE    @OUT„ MOV    DX, CPU80286„ PUSHF„„ POP    AX„ OR     AX,4000h„ PUSH   AX„ POPF„ PUSHF„ POP    AX„ TEST   AX,4000H„ JE     @OUT„ MOV    DX,CPU80386„ {"DB 66h" INDICATES '386 EXTENDED INSTRUCTION}„ DB 66h„ MOV    BX,SP„ DB 66h, 83h, 0E4h, 0FCh„ DB 66h„ PUSHF„ DB 66h„ POP AX„ DB 66h„ MOV    CX,AX„ DB 66h, 35h, 00h„ DB 00h, 04h, 00„ DB 66h„ PUSH   AX„ DB 66h„ POPF„ DB 66h„ PUSHF„ DB 66h„ POP    AX„ DB 66h,25h, 00h„ DB 00h, 04h, 00h„ DB 66h, 81h, 0E1h, 00h„ DB 00h, 04h, 00h„ DB 66h„ CMP    AX,CX„ JE @NOT486„ MOV DX, CPU80486„@NOT486:„ DB 66h„ PUSH   CX„ DB 66h„ POPF„ DB 66h„ MOV    SP,BX„@OUT:„ MOV    AX,DX„End;„„Begin„    Writeln; Writeln('I detected an ',Cpu[GetCpu_Type],' chip.');„End.„                                         29     05-25-9408:03ALL                      GREG ESTABROOKS          286/8088 code            SWAG9405            16     ¿◊   {„SE>I have Borland Pascal 7.0 and I ran acrost the idea of 286 and 8088 code„SE>specs in a program.  How can you detect for a 286 CPU and if present,„SE>switch $G to $G+ ?„„ There should be a program somewhere in your TP disks that has a routine„ that detects whether or not a 286+ CPU is pressent. Unfortunately you„ can't have it change the status of $G. It's either on or off. You can„ either leave it on , detect CPU type, if its the wrong type leave a„ mesage and abort the program or not use the $G directive at all.„„ Here is a simple CPU detection routine in case you can't find the one I„ mentioned:„}„„CONST„      CPU     :ARRAY[0..3] Of STRING[13] =('8088/V20','80286',„                                          '80386/80486','80486');„FUNCTION CpuType :WORD; ASSEMBLER;„                 {  Returns a value depending on the type of CPU        }„                 {          0 = 8088/V20 or compatible                  }„                 {          1 = 80286    2 = 80386/80486+               }„ASM„  Xor DX,DX                             {  Clear DX                     }„  Push DX„  PopF                                  {  Clear Flags                  }„  PushF„  Pop AX                                {  Load Cleared Flags           }„  And AX,$0F000                         {  Check hi bits for F0h        }„  Cmp AX,$0F000„  Je @Quit                              {  Quit if 8088                 }„  Inc DX„  Mov AX,$0F000                         {  Now Check For 80286          }„  Push AX„  PopF„  PushF„  Pop AX„  And AX,$0F000                         {  If The top 4 bits aren't set }„  Jz @Quit                              {  Its a 80286+                 }„  Inc DX                                {  Else its a 80386 or better   }„@Quit:„  Mov AX,DX                             {  Return Result in AX          }„END;{CpuType}„„BEGIN„  Writeln('Your CPU is a ',CPU[CpuType]);„END.„                   30     05-26-9406:14ALL                      ANDRES CVITKOVICH        Another Which CPU        SWAG9405            26     ¿◊   >     Hi!  I was wondering.. does anyone have any TP codes to find„ > out what type„ > of machine (ie. XT, 286, 386, 486, Pentium, etc) that the user„ > is running?„ > The type of coding (Inline Assembly or BASM).. I don't care..„ > just make sure„ > that it is usable by Turbo Pascal 6.0 =8)  Thanks!„„{„  GetCPU                             Byte„  ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„  Ermittelt den arbeitenden CPU-Typ.  Der„  zurÅckgelieferte Code entspricht:„„     0 - Intel 8088„     1 - Intel 8086„     2 - NEC V20„     3 - NEC V30„     4 - Intel 80188„     5 - Intel 80186„     6 - Intel 80286 (or Harris or... whatever)„     7 - Intel 80386 (or AMD or Cyrix (?) or... whatever)„     8 - Intel 80486 (or AMD or Cyrix (?) or... ;))„     9 - Intel Pentium (still looking forward for clones... ;))„}„Function GetCPU: Byte; Assembler;„Const processor: Byte= $FF;„Asm„    mov  al, processor„    cmp  al, 0FFh„    jne  @get_out„    pushf„    xor  bx,bx„    push bx„    popf„    pushf„    pop  bx„    and  bx,0F000h„    cmp  bx,0F000h„    je   @no286„    mov  bx,07000h„    push bx„    popf„    pushf„    pop  bx„    and  bx,07000h„    jne  @test486„    mov  dl,6„    jmp  @end„@test486:„    mov  dl,7„    xor  si,si„    mov  ax,cs„{$IFDEF DPMI}„    add  ax,SelectorInc„{$ENDIF}„    mov  es,ax„    mov  byte ptr es:[@queue486+11], 46h     { 46h == "INC SI" }„@queue486:„    nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop„    or   si,si„    jnz  @end„    inc  dl„    db   66h ; pushf      { pushfd }„    db   66h ; pushf      { pushfd }„    db   66h ; pop  ax    { pop eax }„    db   66h ; mov  cx,ax { mov ecx,eax }„    db   66h,35h„    db   00h,00h,20h,00h  { xor eax,(1 shl 21) (Pentium ID flag) }„    db   66h ; push ax    { push eax }„    db   66h ; popf       { popfd }„    db   66h ; pushf      { pushfd }„    db   66h ; pop  ax    { pop eax }„    db   66h,25h„    db   00h,00h,20h,00h  { and eax,(1 shl 21) }„    db   66h,81h,0E1h„    db   00h,00h,20h,00h  { and ecx,(1 shl 21) }„    db   66h ; cmp ax,cx  { cmp eax,ecx }„    je   @is486„    inc  dl„@is486:„    db   66h ; popf       { popfd }„    jmp  @end„@no286:„    mov  dl,5„    mov  al,0FFh„    mov  cl,21h„    shr  al,cl„    jnz  @testdatabus„    mov  dl,2„    sti„    xor  si,si„    mov  cx,0FFFFh„{$IFDEF DPMI}„    push es„    push ds„    pop  es„{$ENDIF}„    rep  seges lodsb      { == rep lods byte ptr es:[si] }„{$IFDEF DPMI}„    pop  es„{$ENDIF}„    or   cx,cx„    jz   @testdatabus„    mov  dl,1„@testdatabus:„    push cs„{$IFDEF DPMI}„    pop  ax„    add  ax,SelectorInc„    mov  es,ax„{$ELSE}„    pop  es„{$ENDIF}„    xor  bx,bx„    std„    mov  al,90h„    mov  cx,3„    call @ip2di„    cli„    rep  stosb„    cld„    nop; nop; nop„    inc  bx„    nop„    sti„    or   bx,bx„    jz   @end      { v20 or 8086 or 80186 }„    cmp  dl,1„    je   @its8088„    cmp  dl,2„    je   @itsV30„    cmp  dl,5„    jne  @end„    mov  dl,4„    jmp  @end„@its8088:„    xor  dl,dl„    jmp  @end„@itsV30:„    mov  dl,3„    jmp  @end„@ip2di:„    pop  di„    push di„    add  di,9„    retn„@end:„    popf„    mov  al,dl„    mov  processor,al„@get_out:„End;„                                                                          