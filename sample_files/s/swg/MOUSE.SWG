SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00020         RODENT MANAGMENT ROUTINES                                         1      05-28-9313:52ALL                      SWAG SUPPORT TEAM        MOUSPIC1.PAS             IMPORT              23     l»\ {„>    I'm interested in how to change the default mouse cursor to„> another user defined shape.  if you know how to do that, can you„> please post the source For it?  Thanks in advance.„}„„„Uses„  Dos, Graph;„„Var„   Regs : Registers;„„Type„   CursorType = Array[0..31] of Word;   { to store the cursor shape }„„„{ define a cursor shape }„Const HourGlass : CursorType =„„  { this specific Constant, when used in the Procedure to change the cursor„    shape will change it to an hourglass shaped cursor.  of course you can„    define your own cursor shape to suit your needs.„    the comments beside the hex numbers are what it will look like (binary),„    they help TREMendOUSLY in designing a cursor shape. }„„„  { Screen mask : the 0's will show up as the background colour, the 1's„    will show whatever is on the screen at that location }„„   ($0001,  { 0000000000000001 }„    $0001,  { 0000000000000001 }„    $8003,  { 1000000000000011 }„    $C7C7,  { 1100011111000111 }„    $E38F,  { 1110001110001111 }„    $F11F,  { 1111000100011111 }„    $F83F,  { 1111100000111111 }„    $FC7F,  { 1111110001111111 }„    $F83F,  { 1111100000111111 }„    $F11F,  { 1111000100011111 }„    $E38F,  { 1110001110001111 }„    $C7C7,  { 1100011111000111 }„    $8003,  { 1000000000000011 }„    $0001,  { 0000000000000001 }„    $0001,  { 0000000000000001 }„    $0000,  { 0000000000000000 }„„  { Cursor mask : the 1's will show up as white (or whatever color you have„    reassigned it to if you have done a SetPalette or SetRGBPalette) }„„    $0000,  { 0000000000000000 }„    $7FFC,  { 0111111111111100 }„    $2008,  { 0010000000001000 }„    $1010,  { 0001000000010000 }„    $0820,  { 0000100000100000 }„    $0440,  { 0000010001000000 }„    $0280,  { 0000001010000000 }„    $0100,  { 0000000100000000 }„    $0280,  { 0000001010000000 }„    $0440,  { 0000010001000000 }„    $0820,  { 0000100000100000 }„    $1010,  { 0001000000010000 }„    $2008,  { 0010000000001000 }„    $7FFC,  { 0111111111111100 }„    $0000,  { 0000000000000000 }„    $0000); { 0000000000000000 }„„Procedure SetMouseCursor(HotX, HotY: Integer; Var Pattern : CursorType);„begin„  Regs.AX := 9;    { Function 9 }„  Regs.BX := HotX; { X-ordinate of hot spot }„  Regs.CX := HotY; { Y-ordinate of hot spot }„  { the hot spots are the co-ordinates that will show up as being where„    the mouse is when reading the co-ordinates of the mouse }„  Regs.DX := ofs(Pattern);„  Regs.ES := Seg(Pattern);„  Intr($33, Regs);„end;„„begin„   { [...initialize the Graphics screen etc...] }„„   SetMouseCursor(7, 7, HourGlass);„   { this will set the mouse cursor to an hourglass shape With the hot spot„     right in the centre at position 7,7 from the top left of the shape }„„   { [...continue Program...] }„end.„                                                                 2      05-28-9313:52ALL                      SWAG SUPPORT TEAM        MOUSPIC2.PAS             IMPORT              11     l»F {„>Hey Programmers,„>	I'm trying to change the way my mouse cursor looks in one of my„>Programs from the standard block to an arrow.  I looked up the inFormation„>in my interrupt list and found that I need to use Interrupt 33h (Big„>surprise) With AX = 0009h.  I'm ok up to this point, but the inFormation„>lost me when is says that ES:DX->bitmap With 16 Words screen mask and 16„>Words cursor mask.  Now I know what it means and have already defined the„>code For my curse, but how do I assign ES:DX to its value? (Source example„>below).  Any help would be great and please E-MAIL it to me.  Thanks„}„„Const„   ArrowCursor: Array [0..31] of Word = („   	 $3fff,$1fff,$fff,$7ff,$3ff,$1ff,$ff,$7f,„	   $3f,$1f,$f,$7,$1847,$387f,$fc3f,$fe7f,„	   $0,$4000,$6000,$7000,$7800,$7c00,$7e00,$7f00,„	   $7f80,$7fc0,$7fe0,$6730,$4300,$300,$180,$0);„   HotSpotX : Word = 1;„   HotSpotY : Word = 0;„„„Procedure ArrowMouse;„Var regs : Registers;„begin„   Regs.AX := $000A;„   Regs.BX := HotSpotX;„   Regs.CX := HotSpotY;„„   { ES:DX -> bitmap  16 Words screen mask  16 Words cusor mask }„   Regs.ES := Seg(ArrowCursor); { Answer :) }„   Regs.DX := ofs(ArrorCursor); { Answer :) }„„   intr($33,Regs);„end;„„                                                                                      3      05-28-9313:52ALL                      SWAG SUPPORT TEAM        RODENT.PAS               IMPORT              51     l»† Unit Rodent;„Interface„Uses Dos;„„const MDD = $33;   { mouse interupt }„                   { Interupt driven        Polled       = AX  }„      bit_0 = $01; { mouse movement         left button down   }„      bit_1 = $02; { left button pressed    right button down  }„      bit_2 = $04; { left button released   center button down }„      bit_3 = $08; { right button pressed }„      bit_4 = $10; { right button released }„      bit_5 = $20; { center pressed }„      bit_6 = $40; { center released }„      bit_7 = $80;„„type„  resetRec = record„    exists   : Boolean;„    nButtons : Integer;„  end;„  LocRec = record„    buttonStatus,„    opCount,„    column,„    row       : Integer;„  end;„  moveRec = record„    hCount,„    vCount    : Integer;„  end;„{$F+}„  eventRec = record„               flag, button, col, row: Word;„             end;„{$F-}„„var mReg     : Registers;„    theMouse : resetRec;     { Does mouse exist }„    mrecord  : locRec;       { polled record    }„    mEvent   : eventRec;     { interupt record  }„„procedure mFixXY (x1,y1,x2,y2:integer);„function mouseX (n:integer) : integer;„function mouseY (n:integer) : integer;„procedure mReset (VAR Mouse: resetRec);                                {  0 }„procedure mShow;                                                       {  1 }„procedure mHide;                                                       {  2 }„procedure mPos (VAR Mouse: LocRec);                                    {  3 }„procedure mMoveto (col, row: Integer);                                 {  4 }„procedure mPressed (button: Integer; VAR Mouse: LocRec);               {  5 }„procedure mReleased (button: Integer; VAR Mouse: LocRec);              {  6 }„procedure mColRange (min, max : Integer);                              {  7 }„procedure mRowRange (min, max : Integer);                              {  8 }„procedure mGraphCursor (hHot, vHot: Integer; maskSeg, maskOfs: Word);  {  9 }„procedure mTextCursor (ctype, p1, p2: Word);                           { 10 }„procedure mMotion (VAR moved: moveRec);                                { 11 }„procedure mInstTask (mask: Word);                                      { 12 }„procedure mLpenOn;                                                     { 13 }„procedure mLpenOff;                                                    { 14 }„procedure mRatio (horiz, vert: Integer);                               { 15 }„„implementation„var„  maxcol   : word absolute $0040:$004A;   { x }„„procedure EventHandler(Flags,CS,AX,BX,CX,DX,SI,DI,DS,ES,BP: Word);„interrupt;„begin„  mEvent.flag   := AX;„  mEvent.button := BX;„  mEvent.col    := CX;„  mEvent.row    := DX;„  inLine($8B/$E5/$5D/$07/$1F/$5F/$5E/$5A/$59/$5B/$58/$CB);„end;„„function Lower (n1, n2: Integer): Integer;„  begin„    if n1 < n2 then Lower := n1 else Lower := n2;„  end;„„function Upper (n1, n2: Integer): Integer;„  begin„    if n1 > n2 then Upper := n1 else Upper := n2;„  end;„„procedure mFixXY;„  var i : integer;„  begin„    if maxcol = 80„    then i := 3„    else i := 4;„    mColRange(pred(x1) shl i,pred(x2) shl i);„    mRowRange(pred(y1) shl 3,pred(y2) shl 3);„  end;„„function mouseX;„  var i : integer;„  begin„    if maxcol = 80„    then i := 3„    else i := 4;„    mouseX := succ(n shr i);„  end;„„function mouseY;„  begin„    mouseY := succ(n shr 3);„  end;„„procedure mReset (VAR Mouse: resetRec);„  begin„    mreg.ax := 0;„    intr(MDD, mreg);„    Mouse.exists := boolean(mreg.ax <> 0);„    Mouse.nButtons := mreg.bx;„  end;„„procedure mShow;„  begin„    inline($B8/$01/$00/$CD/MDD);„{    mreg.ax := 1;    }„{    intr(MDD, mreg); }„  end;„„procedure mHide;„  begin„    inline($B8/$02/$00/$CD/MDD);„{    mreg.ax := 2;    }„{    intr(MDD, mreg); }„  end;„„procedure mPos (VAR Mouse: LocRec);„  begin„    mreg.ax := 3;„    intr(MDD, mreg);„    Mouse.buttonStatus := mreg.bx;„    Mouse.column := mreg.cx;„    Mouse.row := mreg.dx;„  end;„„procedure mMoveto (col, row: Integer);„  var i : word;„  begin„    if maxcol = 80„    then i := 3„    else i := 4;„    mreg.ax := 4;„    mreg.cx := col shl i;„    mreg.dx := row shl i;;„    intr(MDD, mreg);„  end;„„procedure mPressed (button: Integer; VAR Mouse: LocRec);„  begin„    mreg.ax := 5;„    mreg.bx := button;„    intr(MDD, mreg);„    Mouse.buttonStatus := mreg.ax;„    Mouse.opCount := mreg.bx;„    Mouse.column := mreg.cx;„    Mouse.row := mreg.dx;„  end;„„procedure mReleased (button: Integer; VAR Mouse: LocRec);„  begin„    mreg.ax := 6;„    mreg.bx := button;„    intr(MDD, mreg);„    Mouse.buttonStatus := mreg.ax;„    Mouse.opCount := mreg.bx;„    Mouse.column := mreg.cx;„    Mouse.row := mreg.dx;„  end;„„procedure mColRange (min, max : Integer);„  begin„    mreg.ax := 7;„    mreg.cx := Lower(min, max);„    mreg.dx := Upper(min, max);„    intr(MDD, mreg);„  end;„„procedure mRowRange (min, max : Integer);„  begin„    mreg.ax := 8;„    mreg.cx := Lower (min, max);„    mreg.dx := Upper (min, max);„    intr(MDD, mreg);„  end;„„procedure mGraphCursor (hHot, vHot: Integer; maskSeg, maskOfs: Word);„  begin„    mreg.ax := 9;„    mreg.bx := hHot;„    mreg.cx := vHot;„    mreg.dx := maskOfs;„    mreg.es := maskSeg;„    intr(MDD, mreg);„  end;„„procedure mTextCursor (ctype, p1, p2: Word);„  begin„    mreg.ax := 10;„    mreg.bx := ctype;       { 0=software, 1=hardware          }„    mreg.cx := p1;          { 0=and mask else start line      }„    mreg.dx := p2;          { 0=xor mask else Cursor end line }„    intr(MDD, mreg);„  end;„„{ Returns mouse displacement in mickeys since last call }„procedure mMotion (VAR moved: moveRec);„  begin„    mreg.ax := 11;„    intr(MDD, mreg);„    moved.hCount := mreg.cx;„    moved.vCount := mreg.dx;„  end;„„procedure mInstTask;„  begin„    mreg.ax := 12;„    mreg.cx := mask;         { see bit constants above }„    mreg.dx := Ofs(EventHandler);„    mreg.es := Seg(EventHandler);„    intr(MDD, mreg);„  end;„„procedure mLpenOn;„  begin„    mreg.ax := 13;„    intr(MDD, mreg);„  end;„„procedure mLpenOff;„  begin„    mreg.ax := 14;„    intr(MDD, mreg);„  end;„„procedure mRatio (horiz, vert: Integer);„  begin„    mreg.ax := 15;„    mreg.cx := horiz;„    mreg.dx := vert;„    intr(MDD, mreg);„  end;„„{ Sample base line program...„  mReset(theMouse);„  if theMouse.exists„  then minstTask(15);      (* for 80x25 *)„  mFixXY(1,1,succ(lo(windmax)),succ(hi(windmax)));„  mEvent.Flag := 0;„<< do the program >>„  mReset(theMouse);„}„END.„„            4      08-17-9308:46ALL                      SWAG SUPPORT TEAM        A Compelte Mouse Unit    IMPORT              27     l»H) UNIT Mouse;„„{Program:   Master Mouse Routine Library}„„INTERFACE„„USES DOS;„„CONST„„  {Button press definitions}„„   PrL = 1;„   PrR = 2;„   PrLr = 3;„   PrM = 4;„   PrLM = 5;„   PrMR = 6;„   PrAll = 7;„   PrNone = 0;„„  {Button definitions}„„   ButtonLeft = 0;„   ButtonRight = 1;„   ButtonMiddle = 2;„„„FUNCTION ThereIsAMouse: Boolean;„FUNCTION MouseReset: Boolean;„FUNCTION GetMouseStatus„         (VAR MPosX, MPosY: Byte): Byte;„„PROCEDURE ClearButton (Button: Byte);„PROCEDURE MouseOn;„PROCEDURE MouseOff;„PROCEDURE SetMouseSoftCursor„   (MouseChar, MouseFGColor, MouseBGColor: Byte);„„IMPLEMENTATION„„CONST„   MouseIntr = $33;„„VAR„   MouseVisible			 : Boolean;„   MHMax, MVMax, MHCell, MVCell	 : Word;„   Regs : Registers;„„PROCEDURE MouseHandler (A, B, C, D: Byte);„   BEGIN„      WITH Regs DO„			BEGIN„				ax := A;„				bx := B;„				cx := C;„				dx := D;„				Intr(MouseIntr, Regs)„			END„   END;„„FUNCTION GetButtonUpStatus„  (Button: Byte;VAR MPosX, MPosY: Word): Boolean;„„   BEGIN„      WITH Regs DO„			BEGIN„				ax := 6;„				bx := Button;„				MouseHandler(ax, bx, 0, 0);„				MPosX := cx DIV MHCell + 1;„				MPosY := dx DIV MVCell + 1;„				IF ax = 0 THEN„					GetButtonUpStatus := TRUE„				ELSE„					GetButtonUpStatus := FALSE„			END„   END;„„PROCEDURE ClearButton (Button: Byte);„VAR„   MPosX,MPosY: Word;„„   BEGIN„      REPEAT UNTIL„          GetButtonUpStatus(Button, MPosX,MPosY)„   END;„„FUNCTION GetMouseStatus„         (VAR MPosX, MPosY: Byte): Byte;„   BEGIN„      WITH Regs DO„			BEGIN„				ax := 3;„				MouseHandler(ax, 0, 0, 0);„				GetMouseStatus := bx;„				MPosX := cx DIV MHCell + 1;„				MPosY := dx DIV MVCell + 1„			END„   END;„„PROCEDURE MouseOff;„   BEGIN„      IF MouseVisible THEN„			BEGIN„				MouseHandler(2, 0, 0, 0);„				MouseVisible := FALSE„			END„   END;„„PROCEDURE MouseOn;„   BEGIN„      IF NOT MouseVisible THEN„			BEGIN„				MouseHandler(1, 0, 0, 0);„				MouseVisible := TRUE„			END„   END;„„FUNCTION MouseReset: Boolean;„   BEGIN„      MHMax := 639; {Max virtual horizontal pos}„      MVMax := 199; {Max virtual vertical pos}„      MHCell := 8;  {Mouse horizontal cell width}„      MVCell := 8;  {Mouse vertical cell height}„      MouseHandler(0, 0, 0, 0);„      IF Regs.ax = 0 THEN„         MouseReset := FALSE„      ELSE„         MouseReset := TRUE;„			MouseVisible := FALSE„   END;„„PROCEDURE SetMouseSoftCursor„   (MouseChar, MouseFGColor, MouseBGColor: Byte);„   BEGIN„      MouseOn;„      Regs.ax := 10;„      Regs.bx := 0; {Select software cursor}„   {Screen Mask Value (don't change character)}„      Regs.cx := $8800;„      Regs.dx := $8800 + MouseBGColor * 4096 +„                  MouseFGColor * 256 + MouseChar;„      Intr($33,Regs);„      MouseOff„   END;„„FUNCTION ThereIsAMouse: Boolean;„CONST„   IRET = 207;„VAR„   MouseSegment : Word ABSOLUTE $0000:$00CE;„   MouseOffset : Word ABSOLUTE $0000:$00CC;„   MouseInstruction: Byte;„   BEGIN„      IF (MouseSegment = 0) AND„           (MouseOffset = 0) THEN„         ThereIsAMouse := FALSE„      ELSE„			BEGIN„				MouseInstruction :=„                   MEM[MouseSegment:MouseOffset];„				IF MouseInstruction = IRET THEN„					ThereIsAMouse := FALSE„				ELSE„					ThereIsAMouse := TRUE„			END„   END;„„{No initialization section}„„END.„                                                                                           5      08-27-9321:38ALL                      RAPHAEL VANNEY           Set Mouse Cursor         IMPORT              7      l»ç {„RAPHAEL VANNEY„„> Can anybody help me out on the Function INT 33 - 9/8. It's the set mouse„> cursor Function. I see that you can draw your own mouse cursor, but I don't„> understand how to move a bitmap into Es:Dx. I don't know the size for„> the bit map to be, or the dimensions. Could anybody help me out?„}„„Const Disque : Array [0..31] of Word =„      (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,„       0,32766,32766,32760,32760,32766,32382,31806,„       31806,32382,32766,32382,32382,32382,32766,0);„„Procedure CurseurSouris(Var Motif; x, y : Word); Assembler;„Asm„  Mov  AX, 9     { set cursor shape }„  Mov  BX, x„  Mov  CX, y„  LES  DX, Motif„  Int  $33„end ;„„begin„  { ... }„  CurseurSouris(Disque, 8, 8);„  { ... }„end.„                                             6      08-27-9321:38ALL                      MIKE BURNS               The easy Mouse unit      IMPORT              7      l»'â {„MIKE BURNS„„> How did you get a mouse Pointer into your Program?„}„„„Procedure Clear_Regs;„begin„  FillChar(Regs, SizeOf(Regs), 0);„end;„„„Function InitMouse : Boolean;„begin„  Clear_Regs;„„  Regs.AX := 00;„  Intr ($33, Regs);„  if Regs.AX <> 0 then            { if not 0 then YES THERE IS A MOUSE }„  begin„    InitMouse := True;„    MbutS     := BX;              { Number of buttons on the mouse }„  end„  else„  begin„    InitMouse := False;„    Mbuts     := 0;„  end;„end;„„„Procedure ShowMouse;„ begin„  Clear_Regs;„  Regs.AX := 01;„  Intr ($33, Regs);„end;„„Procedure HideMouse;„ begin„  Clear_Regs;„  Regs.AX := 02;„  Intr ($33, Regs);„end;„                                                                                                                      7      09-26-9309:18ALL                      RICHARD SADOWSKY         The "Classic" mouse unit IMPORT              38     l»˝® Unit Mouse4;„„{*******************************************************************}„{*                   Mouse4 - Text Mouse Unit                      *}„{*                     version .9, 11/20/87                        *}„{*                by Richard Sadowsky 74017,1670                   *}„{*                 released to the public domain                   *}„{*******************************************************************}„„Interface„„Uses DOS;„„const„  CURPOS           = 1; { not used yet in this version }„  LEFTPRESS        = 2;„  LEFTREL          = 4;„  RIGHTPRESS       = 8;„  RIGHTREL         = 16;„„var„  Mouse_Reg        : Registers;„  Mouse_Installed  : Boolean;„  Mouse_Error      : Word;„„function InitMouse : Word;„{ Function 0 - Initialize mouse software and hardware }„„procedure ShowMouse;„{ function 1 - show mouse cursor }„„procedure HideMouse;„{ function 2 - hide mouse cursor }„„function MousePosition(var MouseX,MouseY : Word) : Word;„{ function 3 - return mouse position and button status }„{ X and Y values scaled for 80 col text mode }„„procedure setmouseposition(mousex, mousey: Word);„{ function 4 - sets mouse position  }„{ X and Y values scaled for 80 col text mode }„„function mousepress(button: Word;„                     var count, lastx, lasty: Word): Word;„{ function 5 - gets button press information  }„{ X and Y values scaled for 80 col text mode }„„function mouserelease(button: Word;„                       var count, lastx, lasty: Word): Word;„{ function 6 - gets button release information  }„{ X and Y values scaled for 80 col text mode }„„procedure setmousexy(x1,y1,x2,y2: Word);„{ functions 7 and 8 - sets min/max values for horizontal/vertical  }„{ X and Y values scaled for 80 col text mode }„„procedure restoremousexy;„{ functions 7 and 8 - restores min/max values for CGA screen }„„procedure SetPixeltoMickey(Horiz,Verti : Word);„{ function 15 - sets the mickey to pixel ratio }„„implementation„„function InitMouse : Word;„{ Function 0 - Initialize mouse software and hardware }„begin„  with Mouse_Reg do„    Ax := 0;„  Intr($33,Mouse_Reg);„  InitMouse := Mouse_Reg.Ax;„end;„„procedure ShowMouse;„{ function 1 - show mouse cursor }„begin„  Mouse_Reg.Ax := 1;„  Intr($33,Mouse_Reg);„end;„„procedure HideMouse;„{ function 2 - hide mouse cursor }„„begin„  Mouse_Reg.AX := 2;„  Intr($33,Mouse_Reg);„end;„„function MousePosition(var MouseX,MouseY : Word) : Word;„{ function 3 - return mouse position and button status }„{ X and Y values scaled for 80 col text mode }„begin„  Mouse_Reg.Ax := 3;„  Intr($33,Mouse_Reg);„  with Mouse_Reg do begin„    MouseX := Succ(Cx DIV 8);„    MouseY := Succ(Dx DIV 8);„    MousePosition := Bx;„  end;„end;„„procedure setmouseposition(mousex, mousey: Word);„{ function 4 - sets mouse position  }„{ X and Y values scaled for 80 col text mode }„begin„  Mouse_Reg.ax:=4;„  Mouse_Reg.cx:=Pred(mousex*8);„  Mouse_Reg.dx:=Pred(mousey*8);„  intr($33,Mouse_Reg);„end;„„function mousepress(button: Word;„                     var count, lastx, lasty: Word): Word;„{ function 5 - gets button press information  }„{ X and Y values scaled for 80 col text mode }„begin„  Mouse_Reg.ax:=5;„  Mouse_Reg.bx:=button;„  intr($33,Mouse_Reg);;„  mousepress:=Mouse_Reg.ax;„  count:=Mouse_Reg.bx;„  lastx:=Succ(Mouse_Reg.cx div 8);„  lasty:=Succ(Mouse_Reg.dx div 8);„end;„„function mouserelease(button: Word;„                       var count, lastx, lasty: Word): Word;„{ function 6 - gets button release information  }„{ X and Y values scaled for 80 col text mode }„begin„  Mouse_Reg.ax:=6;„  Mouse_Reg.bx:=button;„  intr($33,Mouse_Reg);;„  mouserelease:=Mouse_Reg.ax;„  count:=Mouse_Reg.bx;„  lastx := Succ(Mouse_Reg.cx div 8);„  lasty := Succ(Mouse_Reg.dx div 8);„end;„„procedure setmousexy(x1,y1,x2,y2: Word);„{ functions 7 and 8 - sets min/max values for horizontal/vertical  }„{ X and Y values scaled for 80 col text mode }„begin„  Mouse_Reg.ax:=7;„  Mouse_Reg.cx:=Pred(x1*8);„  Mouse_Reg.dx:=Pred(x2*8);„  intr($33,Mouse_Reg);„  Mouse_Reg.ax:=8;„  Mouse_Reg.cx:=Pred(y1*8);„  Mouse_Reg.dx:=Pred(y2*8);„  intr($33,Mouse_Reg);„end;„„procedure restoremousexy;„{ functions 7 and 8 - restores min/max values for CGA screen }„begin„  Mouse_Reg.ax:=7;„  Mouse_Reg.cx:=0;„  Mouse_Reg.dx:=639;„  intr($33,Mouse_Reg);„  Mouse_Reg.ax:=8;„  Mouse_Reg.cx:=0;„  Mouse_Reg.dx:=199;„  intr($33,Mouse_Reg);„end;„„procedure SetPixeltoMickey(Horiz,Verti : Word);„{ function 15 - sets the mickey to pixel ratio }„„begin„  with Mouse_Reg do begin„    Ax := 15;„    Cx := Horiz;„    Dx := Verti;„  end;„  Intr($33,Mouse_Reg)„end;„„begin„  Mouse_Error := InitMouse;„  Mouse_Installed := Mouse_Error = 65535;„end.„                                                                             8      10-28-9311:25ALL                      GAYLE DAIVS              A GOOD Mouse Unit        IMPORT              26     l»,{ „UNIT AMOUSE; (* mouse/keyboard Routines *)„„INTERFACE„„CONST„          MouseInstalled : Boolean = FALSE;„„FUNCTION  InitMouse : WORD;„PROCEDURE ShowMouseCursor;„PROCEDURE HideMouseCursor;„PROCEDURE SetMouseWindow (X1, Y1, X2, Y2 : WORD);„PROCEDURE GetMousePos (VAR X, Y, button : WORD);„PROCEDURE SetMousePos (X, Y : WORD);„PROCEDURE GetButtonPressInfo (VAR X, Y, Button, NumberOfPresses : WORD);„PROCEDURE GetButtonRelInfo (VAR X, Y, Button, NumberOfReleases : WORD);„PROCEDURE KeyOrButton (VAR Code, X, Y, Button : WORD; VAR Ch : CHAR);„FUNCTION  KEYPRESSED : BOOLEAN;„FUNCTION  MousePRESSED : BOOLEAN;„FUNCTION  MouseORKeyPRESSED : BOOLEAN;„„IMPLEMENTATION„„USES DOS;„„CONST„„  MIO    = $33;  (* Mouse Services       *)„  KBIO   = $16;  (* BIOS Keyboard        *)„„VAR„   X, Y : WORD;„   reg  : REGISTERS;„„„FUNCTION KEYPRESSED : BOOLEAN; Assembler;„ASM„  PUSH DS„  MOV AX, 40h„  MOV DS, AX„  CLI„  MOV AX, [1Ah]„  CMP AX, [1Ch]„  STI„  MOV AX, 0„  JZ @NoPress„  INC AX„  @NoPress :„  POP DS„END;„„„FUNCTION PollKey (VAR Status : WORD) : WORD;„VAR s : WORD;„BEGIN„  asm„    MOV AH, 01„    INT KBIO„    MOV @Result, AX„    LAHF„    AND AX, 64„    MOV S, AX„  END;„  Status := s;„END;„„FUNCTION MousePressed : BOOLEAN;„VAR B : WORD;„  BEGIN„  Asm„    MOV AX, $0003„    INT $33„    MOV B,  BX„  END;„  MousePressed := (B <> 0);„  END;„„FUNCTION MouseORKeyPressed : BOOLEAN;„VAR B : WORD;„  BEGIN„  Asm„    MOV AX, $0003„    INT $33„    MOV B,  BX„  END;„  MouseORKeyPressed := (B <> 0) OR KeyPressed;„  END;„„PROCEDURE KeyOrButton (VAR Code, X, Y, Button : WORD; VAR Ch : CHAR);„ (* wait for key or mouse click and returns data *)„VAR Status : WORD;„BEGIN„  REPEAT„    Code := PollKey (Status);„    GetMousePos (X, Y, Button);„  UNTIL (Button <> 0) OR (Status = 0);„„  IF (LO (Status) = 0) AND (HI (Status) <> 0) THEN„        Ch := CHR ( HI (Status) + 128 )„      ELSE„        Ch := CHR (LO (Status) );„END;„„FUNCTION InitMouse : WORD;„BEGIN„  Asm„    MOV AX, $0000„    INT MIO„    MOV @Result, AX„  END;„END;„„PROCEDURE ShowMouseCursor; Assembler;„Asm„  MOV AX, $0001„  INT MIO„END;„„PROCEDURE HideMouseCursor; Assembler;„Asm„  MOV AX, $0002„  INT MIO„END;„„PROCEDURE GetMousePos (VAR X, Y, Button : WORD);„VAR X1, Y1, b : WORD;„BEGIN„  Asm„    MOV AX, $0003„    INT MIO„    MOV b,  BX„    MOV X1, CX„    MOV Y1, DX„  END;„  X := X1;„  Y := Y1;„  Button := b;„END;„„PROCEDURE SetMousePos (X, Y : WORD); Assembler;„Asm„  MOV AX, $0004„  MOV CX, X„  MOV DX, Y„  INT MIO„END;„„PROCEDURE GetButtonPressInfo (VAR X, Y, Button, NumberOfPresses : WORD);„BEGIN„  reg. AX := $0005;„  reg. BX := Button;„  INTR (MIO, reg);„  Button := reg. AX;„  X := reg. CX;„  Y := reg. DX;„  NumberOfPresses := reg. BX„END;„„PROCEDURE GetButtonRelInfo (VAR X, Y, Button, NumberOfReleases : WORD);„BEGIN„  reg. AX := $0006;„  reg. BX := Button;„  INTR (MIO, reg);„  Button := reg. AX;„  X := reg. CX;„  Y := reg. DX;„  NumberOfReleases := reg. BX„END;„„PROCEDURE SetMouseWindow (X1, Y1, X2, Y2 : WORD);„BEGIN„  reg. AX := $0007;„  reg. CX := X1;„  reg. DX := X2;„  INTR ($33, reg);„  INC (reg. AX, 1);„  reg. CX := Y1;„  reg. DX := Y2;„  INTR (MIO, reg)„END;„„BEGIN„  MouseInstalled := (InitMouse <> 0);„END.               9      11-02-9317:39ALL                      LOU DUCHEZ               Mouse Library            IMPORT              49     l»Œ {„From: LOU DUCHEZ„Subj: mouse Library„}„„unit mouse;„interface                                 { "Global" declarations }„var mouseexist, mousecursoron: boolean;   { Is a mouse hooked up? / Is the    }„procedure mouseinit;                      {   mouse cursor "on"?              }„procedure mouseon;„procedure mouseoff;„function mousex: word;                    { Note about coordinates: these     }„function mousey: word;                    {  routines return values starting  }„function mouseleft: boolean;              {  at 0, not 1 (even in text mode). }„function mousemiddle: boolean;            {  So for text mode, you may want   }„function mouseright: boolean;             {  to modify a bit ...              }„procedure setmousexy(newx, newy: word);„procedure limitmouse(lox, loy, hix, hiy: word);„„„implementation                            { internal workings }„uses dos;„var regs: registers;                      { Used for the "mouse" interrupts }„    xshift, yshift: byte;                 { Depending on your video mode, you }„                                          {  may need to convert "mouse"      }„                                          {  coordinates to / from "video"    }„procedure calcshifts;                     {  coordinates.  It's a matter of   }„var tempregs: registers;                  {  shifting left/right; xshift      }„begin                                     {  records how to shift the "X",    }„  tempregs.ah := $0f;                     {  and yshift records for the "Y".  }„  intr($10, tempregs);                    { Procedure CalcShifts figures out  }„  case tempregs.al of                     {  what text mode you're in and how }„    0, 1, 2, 3, 7: begin                  {  much to shift by.  It gets the   }„      xshift := 3;                        {  video mode w/interrupt $10/$0f;  }„      yshift := 3;                        {  modes 0, 1, 2, 3 and 7 are text  }„      end;                                {  modes.  4, 5, $0d and $13 are    }„    4, 5, $0d, $13: begin                 {  320 x 200 graphics modes.  All   }„      xshift := 1;                        {  other graphics modes are okay    }„      yshift := 0;                        {  "as is", although come to think  }„      end;                                {  of it I had a CGA system when I  }„    else begin                            {  wrote this library and thus      }„      xshift := 0;                        {  couldn't text VGA modes ...      }„      yshift := 0;„      end;„    end;„  end;„„„procedure mouseinit;                  { Initializes mouse -- determines if   }„begin                                 { one is present, then figures out the }„  regs.ax := $0000;                   { shifts, and initializes the "cursor" }„  intr($33, regs);                    { variable to "false". }„  mouseexist := (regs.ax = $FFFF);„  if mouseexist then calcshifts;      { Called automatically on startup; you }„  mousecursoron := false;             { should call it if you change video   }„  end;                                { modes in the program. }„„„procedure mouseon;                    { Turns cursor ON. }„begin„  if mouseexist then begin            { Note: you really should "pair" each }„    regs.ax := $0001;                 {  "on" with an "off"; if you don't,  }„    intr($33, regs);                  {  the PC can get confused. }„    mousecursoron := true;„    end;„  end;„„„procedure mouseoff;                   { Turns cursor OFF.  Note: when writing }„begin                                 {  to the screen, you typically want to }„  if mouseexist then begin            {  turn the cursor OFF: the PC isn't    }„    regs.ax := $0002;                 {  smart enough to say, "I'm writing a  }„    intr($33, regs);                  {  character right where the mouse      }„    mousecursoron := false;           {  cursor is: better make it inverse    }„    end;                              {  video".  So you need to shut it off. }„  end;„„„function mousex: word;                { Gets the current mouse column. }„var tempword: word;„begin„  if mouseexist then begin„    regs.ax := $0003;„    intr($33, regs);„    tempword := regs.cx;„    end„   else„    tempword := 0;„  mousex := tempword shr xshift;      { one of those funky "shift" things }„  end;„„function mousey: word;                { Gets the current mouse row. }„var tempword: word;„begin„  if mouseexist then begin„    regs.ax := $0003;„    intr($33, regs);„    tempword := regs.dx;„    end„   else„    tempword := 0;„  mousey := tempword shr yshift;„  end;„„„function mouseleft: boolean;      { Is the left button down? }„var tempword: word;„begin„  if mouseexist then begin„    regs.ax := $0003;„    intr($33, regs);„    tempword := regs.bx;„    end„   else„    tempword := 0;„  mouseleft := mouseexist and (1 and tempword = 1);„  end;„„„function mousemiddle: boolean;    { Is the middle button down? }„var tempword: word;„begin„  if mouseexist then begin„    regs.ax := $0003;„    intr($33, regs);„    tempword := regs.bx;„    end„   else„    tempword := 0;„  mousemiddle := mouseexist and (4 and tempword = 4);„  end;„„„function mouseright: boolean;     { Is the right button down? }„var tempword: word;„begin„  if mouseexist then begin„    regs.ax := $0003;„    intr($33, regs);„    tempword := regs.bx;„    end„   else„    tempword := 0;„  mouseright := mouseexist and (2 and tempword = 2);„  end;„„„procedure setmousexy(newx, newy: word);   { Position mouse cursor. }„begin„  regs.ax := $0004;„  regs.cx := newx shl xshift;             { Shifts to get it into "mouse" }„  regs.dx := newy shl yshift;             {  coordinates. }„  intr($33, regs);„  end;„„„procedure limitmouse(lox, loy, hix, hiy: word);   { Restrict mouse movements. }„begin„  regs.ah := $0f;„  intr($10, regs);„  regs.ax := $0007;„  regs.cx := lox shl xshift;„  regs.dx := hix shl xshift;„  intr($33, regs);„  regs.ax := $0008;„  regs.cx := loy shl yshift;„  regs.dx := hiy shl yshift;„  intr($33, regs);„  end;„„„begin                 { Startup code: initializes mouse and gets video mode. }„  mouseinit;„  end.„                                        10     11-21-9309:42ALL                      FRED JOHNSON             Mouse Tutor              IMPORT              38     l»Ù {„From: FRED JOHNSON„Subj: Mousey Control..„Can someone out there please explain how to read from the mouse?„}„„{Explanation below in reference table}„USES dos,crt;„„VAR„ M1,M2,M3,M4 : word;„ Regs        : Registers;  { MS DOS Registers }„ satisfied   : boolean;    { if mouse pos and button are together }„„PROCEDURE mouse( var M1,M2,M3,M4 : word );„  begin„    With Regs DO„      begin„        AX := M1; BX := M2; CX := M3; DX := M4;„      end;„    intr($33,Regs); { Interrupt $33, the mouse interrupt }„    With Regs DO„      begin„        M1 := AX; M2 := BX; M3 := CX; M4 := DX;„      end;„  end;„„PROCEDURE initmouse;„  begin„    M1 := 1 ; Mouse( M1,M2,M3,M4 ) { Set mouse cursor ON }„  end;„„BEGIN„  satisfied := false;„  textcolor(7); { Grey }„  clrscr;„  initmouse;„ while not keypressed do { until  KEYBOARD key is pressed }„    begin„     M1 := 3;„      MOUSE(m1,M2,M3,M4);„      IF (M2 and 1) <> 0 then„        begin                { if left button pressed }„          writeln(' Left Button');„          write(' M3 =',M3 div 8); write(' M4 =',M4 div 8);„        end;„      if (M2 and 2) <> 0 then„        begin                { if rght button pressed }„          writeln(' Right Button');„          write(' M3 =',M3 div 8); write(' M4 =',M4 div 8);„        end;„      if (M2 and 4) <> 0 then                      {if midlbutton pressed}„        begin„          M1 := 4; M2 := 0; M3 := 30*8; M4 := 11*8; {Sets MCursor out of }„          mouse( M1,M2,M3,M4 );                     {the way }„          gotoxy(25,10); write('***************');„          gotoxy(25,11); write('* ');textcolor(14);„          write('C'); textcolor(07); write('learscreen *');„          gotoxy(25,12); write('* '); textcolor(14);„          write('Q'); textcolor(07); write('uit        *');„          gotoxy(25,13); write('***************');„          repeat„            M1 := 3;„            mouse(M1,M2,M3,M4);„            if (M3 div 8) = 26 then                 { Tests X position }„              if (M4 div 8) = 10 then               { Tests Y position }„                if (M2 and 1) <> 0 then             { Tests lft button }„                  begin„                    satisfied := true;„                    M1 := 4; M2  := 0; M3 :=0; M4 :=0;{MCursor out of way}„                    mouse( M1,M2,M3,M4 );„                    clrscr;„                  end;„„            if (M3 div 8) = 26 then                { Tests X position }„              if (M4 div 8) = 11 then              { Tests Y position }„                if (M2 and 1) <> 0 then            { Tests lft button }„                  begin„                    satisfied := true;„                    M1 := 0; M2 :=0; M3 :=0; M4 := 0;  { Turn Mouse Off }„                    mouse( M1,M2,M3,M4 );„                    clrscr;„                    halt;„                  end;„„          until satisfied = true;„          clrscr;„          end;„          satisfied := false;„   end;„   M1 := 0;                                            { Turn Mouse Off }„   mouse(M1,M2,M3,M4);„END.„„Reference Table„  M1 M2 M3 M4„  1  0  0  0   = Turn Mouse on with cursor.„  2  0  0  0   = Turn Mouse Off.„  3  ?  ?  ?   = To see if buttons are pressed.„                  Test registers with logical AND   (M2 is BX register)„                  M2 and 1 = Left Button„                  M2 and 2 = Right Button„                  M2 and 3 = Left and Right Buttons„                  M2 and 4 = Middle Button„                  M2 and 5 = Left and Middle Buttons„                  M2 and 6 = Right and Middle Buttons„                  M2 and 7 = Left, Middle and Right Buttons„„  3  0  X  Y  = Get Mouse Cursor position.„                 M3 (CX) will return Mouse X coordinates. (0  =left wall)„                 M4 (DX) will return Mouse Y coordinates. (632= rght wall)„                 Divide by 8 and add 1 for Turbo Pascal XY position.„„  4  0  X  Y  = Set Mouse Cursor position.„                 M3 (CX) set for Mouse X coordinate.      (0  = left wall)„                 M4 (DX) set for Mouse Y coordinate.      (632= rght wall)„„  6  ?  0  0  = Mouse Button Release Status.             M2(BX)set if True„„                          Assembly Language Example„mov ax,0001   ; (M1 := 1)„int 33h       ; Set Mouse cursor ON„here:         ;„mov ax,0003   ; (M1 := 3)„int 33h       ; Test for mouse Keypress„and bx,1      ; left button?„jne lft       ;„mov ax,0003   ;„int 33h       ;„and bx,2      ; right button?„jne rht       ;„mov ax,0003   ;„int 33h       ;„and bx,4      ; middle button?„jne mid       ;„jmp here      ; if not keep looping„lft:          ;„mov dx,lft_st ; address of string if left button„jmp prnt      ;„rht:          ;„mov dx,rht_st ; address of string if right button„                     11     11-26-9317:15ALL                      SWAG SUPPORT TEAM        Rodent Control           IMPORT              129    l»k UNIT Mouse;„{*****************************************************************************}„                               INTERFACE„{*****************************************************************************}„USES DOS;„„TYPE mouse_cursor_mask = RECORD„                         screen_mask : ARRAY[0..7] OF BYTE;„                         cursor_mask : ARRAY[8..15] OF BYTE;„                         END;„„CONST on = TRUE;„CONST off = FALSE;„CONST left = $00;„CONST right = $01;„„CONST change_in_cursor_position = $0001;         {call masks for user defined}„CONST left_button_pressed = $0002;               {input mask and swap vectors}„CONST left_button_released = $0004;„CONST right_button_pressed = $0008;„CONST right_button_released = $0010;„„CONST alternate_key_pressed = $0001;   {call masks for alternate user handlers}„CONST control_key_pressed = $0002;„CONST shift_button_pressed = $0004;„CONST right_button_up = $0008;„CONST right_button_down = $0010;„CONST left_button_up = $0020;„CONST left_button_down = $0040;„CONST cursor_moved = $0080;„„VAR mouse_driver_disabled : BOOLEAN;„VAR number_of_presses, number_of_releases : INTEGER;„VAR number_buttons, x, y : INTEGER;„VAR button_status, horizontal_counts, vertical_counts : INTEGER;„VAR left_mouse_button_pressed, right_mouse_button_pressed,„    left_mouse_button_released, right_mouse_button_released : BOOLEAN;„VAR register : REGISTERS;„„PROCEDURE check_button_status;„PROCEDURE disable_mouse_driver (VAR int33h_vector_address : POINTER);„PROCEDURE enable_mouse_driver; INLINE($B8/$20/$00/$CD/$33);„FUNCTION  get_alternate_user_interrupt_vector (call_mask : WORD) : POINTER;„PROCEDURE get_left_button_press_information;„PROCEDURE get_left_button_release_information;„PROCEDURE get_mouse_position;„PROCEDURE get_mouse_sensitivity (VAR horizontal_coordinates_per_pixel,„                                     vertical_coordinates_per_pixel,„                                     double_speed_threshold : WORD);„PROCEDURE get_right_button_press_information;„PROCEDURE get_right_button_release_information;„PROCEDURE light_pen_emulation; INLINE($B8/$0D/$00/$CD/$33);„FUNCTION  mouse_button_pressed : BOOLEAN;„PROCEDURE mouse_cursor_off; INLINE($B8/$02/$00/$CD/$33);„PROCEDURE mouse_cursor_off_area (x1,y1,x2,y2 : INTEGER);„PROCEDURE mouse_cursor_on; INLINE($B8/$01/$00/$CD/$33);„FUNCTION  mouse_exists : BOOLEAN;„FUNCTION  mouse_state_buffer_size : INTEGER;„FUNCTION  mouse_video_page : WORD;„FUNCTION  number_of_buttons : INTEGER;„PROCEDURE relative_number_of_screen_positions_moved (VAR x, y : INTEGER);„          {reported in units of 0.02 inches - approximately 0.5 millimeters}„PROCEDURE reset_mouse_software; INLINE($B8/$21/$00/$CD/$33);„PROCEDURE restore_mouse_driver_state (mouse_state_buffer_segment,„                                      mouse_state_buffer_offset : WORD);„          {use when returning from another program to your program}„PROCEDURE save_mouse_driver_state (mouse_state_buffer_segment,„                                   mouse_state_buffer_offset : WORD);„          {use mouse_state_buffer_size to set up buffer first;„           use when EXEC another program from your program}„PROCEDURE set_alternate_mouse_user_handler (call_mask,„                                            function_offset : INTEGER);„PROCEDURE set_double_speed_threshold (threshold_speed : INTEGER);„PROCEDURE set_graphics_mouse_cursor (hot_spot_x, hot_spot_y : INTEGER;„                                   screen_and_cursor_mask : mouse_cursor_mask);„PROCEDURE set_mouse_physical_movement_ratio (x8_positions_to_move,„                                             y8_positions_to_move : INTEGER);„          {each position corresponds to 1/200th of an inch}„PROCEDURE set_mouse_position (x,y : INTEGER);„PROCEDURE set_mouse_sensitivity (horizontal_coordinates_per_pixel,„                                 vertical_coordinates_per_pixel,„                                 double_speed_threshold : WORD);„PROCEDURE set_mouse_video_page (page_number : WORD);„PROCEDURE set_mouse_x_bounds (minimum_x, maximum_x : WORD);„PROCEDURE set_mouse_y_bounds (minimum_y, maximum_y : WORD);„PROCEDURE set_text_mouse_attribute_cursor (screen_cursor_mask_offset : WORD);„PROCEDURE set_text_mouse_hardware_cursor (top_scan_line,„                                          bottom_scan_line : INTEGER);„PROCEDURE stop_light_pen_emulation; INLINE($B8/$0E/$00/$CD/$33);„PROCEDURE swap_mouse_interrupt_vector (VAR call_mask, mouse_vector_segment,„                                           mouse_vector_offset : WORD);„{*****************************************************************************}„                             IMPLEMENTATION„{*****************************************************************************}„PROCEDURE check_button_status;„   VAR check_left, check_right : WORD;„   BEGIN„      IF button_status AND $0001 = $0001 THEN„         left_mouse_button_pressed := TRUE ELSE„         left_mouse_button_pressed := FALSE;„„      IF button_status AND $0002 = $0002 THEN„         right_mouse_button_pressed := TRUE ELSE„         right_mouse_button_pressed := FALSE;„   END;„{*****************************************************************************}„PROCEDURE disable_mouse_driver (VAR int33h_vector_address : POINTER);„   BEGIN„      register.AX := $001F;„      INTR($33,register);„      IF register.AX = $001F THEN„         BEGIN„            mouse_driver_disabled := TRUE;„            int33h_vector_address := PTR(register.ES,register.BX);„         END ELSE mouse_driver_disabled := FALSE;„   END;„{*****************************************************************************}„FUNCTION  get_alternate_user_interrupt_vector (call_mask : WORD) : POINTER;„   BEGIN„      register.AX := $0019;„      register.CX := call_mask;„      INTR($33,register);„      get_alternate_user_interrupt_vector := PTR(register.BX,register.DX);„   END;„{*****************************************************************************}„PROCEDURE get_left_button_press_information;„   BEGIN„      register.BX := $0000;„      register.AX := $0005;„      INTR($33,register);„      number_of_presses := register.BX;„      x := register.CX;„      y := register.DX;„      button_status := register.AX;„      check_button_status;„   END;„{*****************************************************************************}„PROCEDURE get_left_button_release_information;„   BEGIN„      register.BX := $0000;„      register.AX := $0006;„      INTR($33,register);„      number_of_releases := register.BX;„      x := register.CX;„      y := register.DX;„      button_status := register.AX;„      check_button_status;„   END;„{*****************************************************************************}„PROCEDURE get_mouse_position;„   BEGIN„      register.AX := $0003;„      INTR($33,register);„      x := register.CX;„      y := register.DX;„      button_status := register.BX;„      check_button_status;„   END;„{*****************************************************************************}„PROCEDURE get_mouse_sensitivity (VAR horizontal_coordinates_per_pixel,„                                     vertical_coordinates_per_pixel,„                                     double_speed_threshold : WORD);„   BEGIN„      register.AX := $001B;„      register.BX := horizontal_coordinates_per_pixel;„      register.CX := vertical_coordinates_per_pixel;„      register.DX := double_speed_threshold;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE get_right_button_press_information;„   BEGIN„      register.BX := $0001;„      register.AX := $0005;„      INTR($33,register);„      number_of_presses := register.BX;„      x := register.CX;„      y := register.DX;„      button_status := register.AX;„      check_button_status;„   END;„{*****************************************************************************}„PROCEDURE get_right_button_release_information;„   BEGIN„      register.BX := $0001;„      register.AX := $0006;„      INTR($33,register);„      number_of_releases := register.BX;„      x := register.CX;„      y := register.DX;„      button_status := register.AX;„      check_button_status;„   END;„{*****************************************************************************}„FUNCTION mouse_button_pressed : BOOLEAN;„   BEGIN„      register.AX := $0003;„      INTR($33,register);„      button_status := register.BX;„      check_button_status;„   END;„{*****************************************************************************}„PROCEDURE mouse_cursor_off_area (x1,y1,x2,y2 : INTEGER);„   BEGIN„      register.AX := $0010;„      register.CX := x1;„      register.DX := y1;„      register.SI := x2;„      register.DI := y2;„      INTR($33,register);„      mouse_cursor_on;   {may need to remove this statement}„   END;„{*****************************************************************************}„FUNCTION  mouse_exists : BOOLEAN;„   BEGIN„      register.AX := $0021;„      INTR($33,register);„      IF (register.AX = $FFFF) AND (register.BX = $02) THEN„         mouse_exists := TRUE ELSE„         mouse_exists := FALSE;„   END;„{*****************************************************************************}„FUNCTION  mouse_state_buffer_size : INTEGER;„   BEGIN„      register.AX := $15;„      INTR($33,register);„      mouse_state_buffer_size := register.BX;„   END;„{*****************************************************************************}„FUNCTION mouse_video_page : WORD;„   BEGIN„      INLINE($B8/$1E/$00/$CD/$33);„      mouse_video_page := register.BX;„   END;„{*****************************************************************************}„FUNCTION number_of_buttons : INTEGER;„   BEGIN„      register.AX := $0000;„      INTR($33,register);„      number_of_buttons := register.BX;„   END;„{*****************************************************************************}„PROCEDURE relative_number_of_screen_positions_moved (VAR x, y : INTEGER);„   BEGIN„      register.AX := $000B;„      INTR($33,register);„      register.CX := x;„      register.DX := y;„   END;„{*****************************************************************************}„PROCEDURE restore_mouse_driver_state (mouse_state_buffer_segment,„                                      mouse_state_buffer_offset : WORD);„   BEGIN„      register.AX := $17;„      register.ES := mouse_state_buffer_segment;„      register.DX := mouse_state_buffer_offset;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE save_mouse_driver_state (mouse_state_buffer_segment,„                                   mouse_state_buffer_offset : WORD);„   BEGIN„      register.AX := $16;„      register.ES := mouse_state_buffer_segment;„      register.DX := mouse_state_buffer_offset;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_alternate_mouse_user_handler (call_mask,„                                            function_offset : INTEGER);„   BEGIN„      register.AX := $0018;„      register.CX := call_mask;„      register.DX := function_offset;„      INTR($33,register);„      x := register.CX;„      y := register.DX;„      horizontal_counts := register.DI;„      vertical_counts := register.SI;„      button_status := register.BX;„      check_button_status;„   END;„{*****************************************************************************}„PROCEDURE set_mouse_video_page (page_number : WORD);„   BEGIN„      register.AX := $001D;„      register.BX := page_number;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_double_speed_threshold (threshold_speed : INTEGER);„   BEGIN„      register.AX := $0013;„      register.DX := threshold_speed;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_graphics_mouse_cursor (hot_spot_x, hot_spot_y : INTEGER;„                                   screen_and_cursor_mask : mouse_cursor_mask);„   BEGIN„      register.AX := $0009;„      register.BX := hot_spot_x;„      register.CX := hot_spot_y;„      register.ES := SEG(screen_and_cursor_mask);„      register.DX := OFS(screen_and_cursor_mask);„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_mouse_physical_movement_ratio (x8_positions_to_move,„                                             y8_positions_to_move : INTEGER);„   BEGIN„      register.AX := $000F;„      register.CX := x8_positions_to_move;„      register.DX := y8_positions_to_move;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_mouse_position (x,y : INTEGER);„   BEGIN„      register.AX := $0004;„      register.CX := x;„      register.DX := y;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_mouse_sensitivity (horizontal_coordinates_per_pixel,„                                 vertical_coordinates_per_pixel,„                                 double_speed_threshold : WORD);„   BEGIN„      register.AX := $001A;„      register.BX := horizontal_coordinates_per_pixel;„      register.CX := vertical_coordinates_per_pixel;„      register.DX := double_speed_threshold;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_mouse_x_bounds (minimum_x, maximum_x : WORD);„   BEGIN„      register.AX := $0008;„      register.CX := minimum_x;„      register.DX := maximum_x;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_mouse_y_bounds (minimum_y, maximum_y : WORD);„   BEGIN„      register.AX := $0007;„      register.CX := minimum_y;„      register.DX := maximum_y;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_text_mouse_attribute_cursor (screen_cursor_mask_offset : WORD);„   BEGIN„      register.AX := $000A;„      register.BX := $0000;„      register.CX := screen_cursor_mask_offset;„      register.DX := screen_cursor_mask_offset + 8;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_text_mouse_hardware_cursor (top_scan_line,„                                          bottom_scan_line : INTEGER);„   BEGIN„      register.AX := $000A;„      register.BX := $0001;„      register.CX := top_scan_line;„      register.DX := bottom_scan_line;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE set_user_defined_input_mask (call_mask, function_offset : INTEGER);„   BEGIN„      register.AX := $000C;„      register.CX := call_mask;„      register.DX := function_offset;„      INTR($33,register);„   END;„{*****************************************************************************}„PROCEDURE swap_mouse_interrupt_vector (VAR call_mask, mouse_vector_segment,„                                           mouse_vector_offset : WORD);„   VAR register_DS : INTEGER;„   BEGIN„      register_DS := register.DS;  {save the data segment}„      register.AX := $0014;„      register.CX := call_mask;„      register.ES := mouse_vector_offset;„      register.DX := mouse_vector_offset;„      INTR($33,register);„      call_mask := register.CX;„      mouse_vector_segment := register.ES;„      mouse_vector_offset := register.DX;„      register.DS := register_DS;   {resets the data segment}„      button_status := register.BX;„      check_button_status;„      horizontal_counts := register.DI;„      vertical_counts := register.SI;„      x := register.CX;„      y := register.DX;„   END;„{*****************************************************************************}„BEGIN„   x := 0;„   y := 0;„   number_buttons := number_of_buttons;„   number_of_presses := 0;„   number_of_releases := 0;„   left_mouse_button_released := FALSE;„   right_mouse_button_released := FALSE;„   left_mouse_button_released := FALSE;„   right_mouse_button_released := FALSE;„END.„                                                                                  12     01-27-9411:56ALL                      MICHAEL NICOLAI          Mouse Cursors            IMPORT              25     l»H? {„> I whant to draw a new mouse cursor, and the routines that I'm using will„> allow me to do this by passing an array [0..31] of integer; I don't know„> how to draw a cursor thought using this array. Some other routins have„> predifined cursors, but that nubers are out of range.„„Here's some explanation:„„At the memory location where ES:DX points to, there have to be first 16„words (the screen mask) followed by 16 words (the cursor mask).„„The screen mask defines an AND with the background beneath the cursor, and„the cursor mask defines a XOR with the background pixels.„„- For each pixel use the following Equations:„„ 1. expand each mask-bit to the width needed to display one colored-pixel„    in the used video-mode, e.g. if you are using mode $13 (320x200x256)„    each mask-bit is expanded to 8 bits (one byte). If you are using„    640x480x16, each mask-bit is expanded to 4 bits.„„ 2. Backgrd._pixel AND screen-mask_pixel XOR cursor-mask_pixel => new„    pixel.„„Example: (standard arrow-cursor)„„            screen-mask       cursor-mask    |   cursor-form„                                             |„          1001111111111111  0000000000000000 | +00+++++++++++++„          1000111111111111  0010000000000000 | +010++++++++++++„          1000011111111111  0011000000000000 | +0110+++++++++++„          1000001111111111  0011100000000000 | +01110++++++++++„          1000000111111111  0011110000000000 | +011110+++++++++„          1000000011111111  0011111000000000 | +0111110++++++++„          1000000001111111  0011111100000000 | +01111110+++++++„          1000000000111111  0011111110000000 | +011111110++++++„          1000000000011111  0011111111000000 | +0111111110+++++„          1000000000001111  0011111000000000 | +01111100000++++„          1000000011111111  0011011000000000 | +0110110++++++++„          1000100001111111  0010001100000000 | +01000110+++++++„          1001100001111111  0000001100000000 | +00++0110+++++++„          1111110000111111  0000000110000000 | ++++++0110++++++„          1111110000111111  0000000110000000 | ++++++0110++++++„          1111111000111111  0000000000000000 | +++++++000++++++„                                             |„„As you can easily see:„„„    screen-mask | cursor-mask | new pixel„   -------------+-------------+-----------„        0       |      0      |  black„        0       |      1      |  white„        1       |      0      |  background visible„        1       |      1      |  background inverted„„„A quick example for the inverted background:„„Lets say we have a 01101101 as a backgroundpixel, ok?„„     1.       01101101„          AND 11111111 (expanded) screen-mask-bit„         -----------------------------------------„              01101101 leaving the background-pixel untouched.„„„     2.       01101101„          XOR 11111111 (expanded) cursor-mask-bit„         -----------------------------------------„              10010010 inverted background pixel„„}„                                                                                                                       13     01-27-9412:15ALL                      TORSTEN PINKERT          Mouse Cursor Editor      IMPORT              27     l»À˙ {„Now here's the source for the Mouse-Cursor-Editor„„}„PROGRAM Mouse_Edit;„uses Crt;„type„ Masktype = array[1..16] of word;„var„ Cursor :  Array[1..2] of Masktype;„ screenmask,Cursormask : Array [1..16,1..16] of Char;„ x,y,oldx,oldy : Byte;„ Fenster : Boolean; {False=Links,True=Rechts}„ i,j : Byte;„ c : Char;„ wert : word;„  dest : text;„  s : string;„„procedure Init;„begin„  TextMode (co40);„ ClrScr;„ for i:=1 to 16 do„  for j:=1 to 16 do„  begin„   Screenmask[i,j]:='*';„   GoToXY(i+2,j);„   Write (Screenmask[i,j]);„   CursorMask[i,j]:='.';„   GoToXY (i+22,j);„   Write (CursorMask[i,j]);„  end;„ x:=8; oldx:=8; y:=8; oldy:=8;„ Fenster := false;„ GotoXY(20,20); write('X=',x:3,'  Y=',y:3);„ GotoXY (x+2,y);„end;„procedure Changemask;„var„ t : byte;„begin„ t:=x; x:=oldx; oldx:=t;„ t:=y; y:=oldy; oldy:=t;„ fenster := fenster xor true;„ GotoXY(20,20); write('X=',x:3,'  Y=',y:3);„end;„begin„ init;„ repeat„  c:=readkey;„  if c=#9 then„   ChangeMask„  else if c=#32 then„   if fenster then begin„    if cursormask[x,y]='.' then„     cursormask[x,y]:='*'„    else„     cursormask[x,y]:='.';„    write(cursormask[x,y]);„    GotoXY(wherex-1,wherey);„   end else begin„    if screenmask[x,y]='.' then„     screenmask[x,y]:='*'„    else„     screenmask[x,y]:='.';„    write(screenmask[x,y]);„    GotoXY(wherex-1,wherey)„  end else if c=#0 then begin„   c:=readkey;„   case c of„    #72 : if y > 1 then„        dec(y);„    #80 : if y < 16 then„        inc(y);„    #77 : if x<16 then„        inc(x);„    #75 : if x > 1 then„        dec(x);„   end;„   GotoXY(20,20); write('X=',x:3,'  Y=',y:3);„  end;„  if fenster then„   GotoXY(x+22,y)„  else„   GotoXY(x+2,y);„ until c=#27;„ for i:=1 to 16 do begin„  wert:=0;„  for j:=1 to 16 do„   if screenmask[j,i]='*' then„    inc(wert,1 shl (16-j));„  Cursor[1,i]:=wert;„ end;„ for i:=1 to 16 do begin„  wert:=0;„  for j:=1 to 16 do„   if cursormask[j,i]='*' then„    inc(wert,1 shl (16-j));„  Cursor[2,i]:=wert;„ end;„  assign(dest,'pfeil.dat');„  rewrite(dest);„  writeln (dest,'const');„  write (dest,#7,'screenmask : masktype = (');„  for i:=1 to 16 do begin„   str(cursor[1,i],s);„   write(dest,s);„    if i<16 then„     write(dest,',');„  end;„  writeln(dest,');');„  write (dest,#7,'cursormask : masktype = (');„  for i:=1 to 16 do begin„   str(cursor[2,i],s);„   write(dest,s);„    if i<16 then„     write(dest,',');„  end;„  writeln(dest,');');„ close(dest);„end.„„{„TORSTEN PINKERT„„And now here's the program to test how Mouse-Edit works...„}„PROGRAM Mouse_Edit_Test;„uses graph;„type„ masktype = array[1..16] of word;„„{$I Pfeil.dat}„„var„ cursor : array[1..2] of masktype;„  gd,gm : integer;„„procedure ShowMouse; assembler;„ asm„  mov ax,1„  int 33h„end; {ShowMouse}„procedure HideMouse; assembler;„ asm„  mov ax,2„  int 33h„end; {HideMouse}„procedure ChangeMousePointer (x,y:integer; zeiger:word); assembler;„asm„ mov ax,9„ mov bx,x„ mov bx,y„ mov dx,zeiger„ int 33h„end; {ChangeMousePointer}„„begin„ gd:=VGA; gm := VGAHi;„ initgraph(gd,gm,'c:\bp\bgi');„  setfillstyle(solidfill,white);„  bar (200,200,400,400);„ cursor[1]:=screenmask; cursor[2]:=cursormask;„ SetBKColor(black);„ ShowMouse;„ ChangeMousePointer(8,8,ofs(cursor));„  readln;„  HideMouse;„  closegraph;„end.„                                                                                                       14     01-27-9413:32ALL                      GREG ESTABROOKS          What PORT is Mouse on    IMPORT              17     l»c {************************************************************}„PROGRAM WhatPortIsTheMouseOn;   { Sept 18/93, Greg Estabrooks}„TYPE„    MouseParamTable = RECORD„                        BaudRate   :WORD; { Baud Rate Div 100}„                        Emulation  :WORD;„                        ReportRate :WORD; { Report Rate.     }„                        FirmRev    :WORD;„                        ZeroWord   :WORD; { Should be zero.  }„                        PortLoc    :WORD; { Com Port Used.   }„                        PhysButtons:WORD; { Physical Buttons.}„                        LogButtons :WORD; { Logical Buttons. }„                      END;„VAR„   MouseInf :MouseParamTable;„„PROCEDURE GetMouseInf( VAR MouseTable ); ASSEMBLER;„                       { Routine to Get info about mouse.   }„                       { NOTE Doesn't check to see if a     }„                       {  a mouse is installed.             }„ASM„  Push AX                      { Save Registers Used.       }„  Push ES„  Push DX„  Mov AX,$246C                 { Get Mouse Parameters.      }„  LES DX,MouseTable            { Point ES:DX to Param Table.}„  Int $33                      { Call Mouse Interrupt.      }„  Pop DX                       { Restore Registers used.    }„  Pop ES„  Pop AX„END;{GetMouseInf}„„BEGIN„  GetMouseInf(MouseInf);        { Get mouse info.            }„  Writeln('     ___Mouse Info___'); { Show a title.          }„  Writeln;„  WITH MouseInf DO              { Display Mouse Info.        }„    BEGIN„      Writeln('Baud Rate     : ',BaudRate * 100);„      Writeln('Emulation     : ',Emulation);„      Writeln('Report Rate   : ',ReportRate);„      Writeln('FirmWare Rev  : ',FirmRev);„      Writeln('Com Port      : ',PortLoc);„      Writeln('Physical Butns: ',PhysButtons);„      Writeln('Logical Buttns: ',LogButtons);„    END;„  Readln;                       { Wait for user to have a look.}„END.{WhatPortIsTheMouseOn}„{************************************************************}„                                                       15     01-27-9417:32ALL                      BERNIE PALLEK            Basic Mouse Routines     IMPORT              31     l»ÈI {„From: BERNIE PALLEK„Subj: Mouse routines„---------------------------------------------------------------------------„>I'm after a good mouse unit for Turbo Pascal 7.„„OK, here it is:„}„{$R-,S-}„„UNIT BMouse;  { basic mouse routines }„„„INTERFACE„„„TYPE„  CustomMouseCursor = ARRAY[0..31] OF Word;„„CONST„  { button masks }„  Left_B    = $0001;„  Right_B   = $0002;„  Center_B  = $0004;„  { text pointer selectors }„  Software_Pointer = 0;„  Hardware_Pointer = 1;„„FUNCTION  Ms_Init(VAR numOfButtons : Word) : Boolean;„PROCEDURE Ms_SetHLimits(xmin, xmax : Word);„PROCEDURE Ms_SetVLimits(ymin, ymax : Word);„PROCEDURE Ms_Show;„PROCEDURE Ms_Hide;„PROCEDURE Ms_Read(VAR x, y, b_mask : Word);„PROCEDURE Ms_SetPos(x, y : Word);„PROCEDURE Ms_SetGraphPointer(newShape : CustomMouseCursor; hot_x, hot_y :„Word);„PROCEDURE Ms_SetTextPointer(select : Word; scr_char : Char; scr_attr : Byte;„                            ptr_char : Char; ptr_attr : Byte);„PROCEDURE Ms_SetMPP(hMPP, vMPP : Word);„PROCEDURE Ms_ReadPosFromLast(VAR hCount, vCount : Word);„„„IMPLEMENTATION„„„USES Dos;„„VAR„  mouse_detected : Boolean;„  r              : Registers; { scratch Registers variable }„  mi             : Pointer;   { mouse interrupt vector for initial test }„„„FUNCTION Ms_Init(VAR numOfButtons : Word) : Boolean;„BEGIN„  IF mouse_detected THEN BEGIN„    r.AX := 0;„    Intr($33, r);„    IF (r.AX = 0) THEN BEGIN„      numOfButtons := 0;„      Ms_Init := False;„    END ELSE BEGIN„       numOfButtons := r.BX;„       Ms_Init := True;„    END;„  END ELSE BEGIN„    numOfButtons := 0;„    Ms_Init := False;„  END;„END;„„PROCEDURE Ms_SetHLimits(xmin, xmax : Word);„BEGIN„  r.AX := 7;  { set horizontal limits }„  r.CX := xmin;„  r.DX := xmax;„  Intr($33, r);„END;„„PROCEDURE Ms_SetVLimits(ymin, ymax : Word);„BEGIN„  r.AX := 8;  { set vertical limits }„  r.CX := ymin;„  r.DX := ymax;„  Intr($33, r);„END;„„PROCEDURE Ms_Show;„BEGIN„  r.AX := 1;„  Intr($33, r);„END;„„PROCEDURE Ms_Hide;„BEGIN„  r.AX := 2;„  Intr($33, r);„END;„„PROCEDURE Ms_Read(VAR x, y, b_mask : Word);„BEGIN„  r.AX := 3;„  Intr($33, r);„  x := r.CX;„  y := r.DX;„  b_mask := r.BX;„END;„„PROCEDURE Ms_SetPos(x, y : Word);„BEGIN„  r.AX := 4;„  r.CX := x;„  r.DX := y;„  Intr($33, r);„END;„„PROCEDURE Ms_SetGraphPointer(newShape : CustomMouseCursor; hot_x, hot_y :„Word);„BEGIN„  r.AX := 9;„  r.BX := hot_x;„  r.CX := hot_y;„  r.DX := Ofs(newShape);„  r.ES := Seg(newShape);„  Intr($33, r);„END;„„PROCEDURE Ms_SetTextPointer(select : Word; scr_char : Char; scr_attr : Byte;„                            ptr_char : Char; ptr_attr : Byte);„BEGIN„  r.AX := 10;„  r.BX := select;  { determines which pointer: software or hardware }„  r.CL := Byte(scr_char);„  r.CH := scr_attr;„  r.DL := Byte(ptr_char);„  r.DH := ptr_attr;„  Intr($33, r);„END;„„PROCEDURE Ms_SetMPP(hMPP, vMPP : Word);  { Set [M]ickeys [P]er [P]ixel }„{  set horizontal and vertical mouse motion rates }„{  MPP (1 <= MPP <= 32767) = Mickeys / 8 pixels   }„{  default hMPP is 8:8                            }„{  default vMPP is 16:8                           }„BEGIN„  IF (hMPP >= 1) AND (hMPP <= 32767) AND (vMPP >= 1) AND (vMPP <= 32767) THEN„BEGIN„    r.AX := 15;„    r.CX := hMPP;„    r.DX := vMPP;„    Intr($33, r);„  END;„END;„„PROCEDURE Ms_ReadPosFromLast(VAR hCount, vCount : Word);„{ Return the number of Mickeys the mouse has moved since the }„{ last call to this function.                                }„{ A positive number is right/down.                           }„BEGIN„  r.AX := 11;„  Intr($33, r);„  hCount := r.CX;„  vCount := r.DX;„END;„„„{=== UNIT INITIALIZATION ========================================}„BEGIN„  GetIntVec($33, mi);„  IF (mi = NIL) THEN„    mouse_detected := False„  ELSE„    IF (Byte(mi^) = $CF) THEN mouse_detected := False„  ELSE„    mouse_detected := True;„END.„„                               16     02-03-9416:12ALL                      RICHARD JORDAN           Change Graphic Mouse CursIMPORT              15     l»   {„ DR> Hello I was wondering how I might be able to load a batch„ DR> file under Turbo Pascal. I was also wondering how to„ DR> change how the mouse symbol looks like when you install„ DR> the mouse in your programs. Thank you.„}„Type„        CursorData  = Array [1..32] of Word;„„        ArrowMask : CursorData = ($7fff,$3fff,$1fff,$0fff,„                                  $07ff,$03ff,$01ff,$00ff,„                                  $007f,$03ff,$03ff,$29ff,„                                  $71ff,$f0ff,$faff,$f8ff,„„                                  $8000,$C000,$A000,$9000,„                                  $8800,$8400,$8200,$8100,„                                  $8f80,$9400,$b400,$d200,„                                  $8a00,$0900,$0500,$0700);„„        HourGlassMask : CursorData = ($0000,$0000,$0000,$c003,„                                      $e007,$f00f,$F81F,$fc3f,„                                      $fc3F,$F81F,$F00F,$e007,„                                      $c003,$0000,$0000,$0000,„„                                      $0000,$7ffe,$0000,$1ff8,„                                      $0ff0,$0000,$0000,$0000,„                                      $0180,$0340,$07e0,$0e78,„                                      $1818,$0000,$7ffe,$0000);„„„„„„„„„Var„        Regs    : Registers;„„„„Procedure SetMouseCursor(CursorMask : CursorData);„„Begin„        Regs.AX := $0009;„        Regs.BX := $0004;„        Regs.CX := $0004;„        Regs.ES := Seg(CursorMask);„        Regs.DX := Ofs(CursorMask);„        Intr($33,Regs);„End;„„„„Here's a little routine I used to change my cursor from an arrow to an„hour-glass and back.... You can design your own cursors by following my„examples. The First 16 Words of the array are the cursor the next 16 are„the mask.„                    17     02-03-9416:16ALL                      SWAG SUPPORT TEAM        Full Featured Mouse Unit IMPORT              112    l»   „                    {MOUSE.PAS creates MOUSE.TPU Unit}„     {From the book "OBJECT ORIENTED PROGRAMMING IN TURBO PASCAL 5.5"}„„Unit Mouse;„„Interface„„Type„    GCursor = record„            ScreenMask,„            CursorMask : array[0..15] of word;„            hotX,hotY  : integer;„            end; {record}„„„                  {================================}„                  {Graphics Cursors are predefined }„                  {for use with GraphicMouse       }„                  {================================}„„„Const           {The graphics cursors are defined as constants       }„„     HAMMER : GCursor =       {As in the hammer of THOR, my favorite}„            (ScreenMask : ($8003,$0001,$0001,$1831,„                           $1011,$0001,$0001,$8003,„                           $F83F,$F83F,$F83F,$F83F,„                           $F83F,$F83F,$F83F,$F83F);„             CursorMask : ($0000,$3FF8,$4284,$4104,„                           $4284,$4444,$3FF8,$0380,„                           $0380,$0380,$0380,$0380,„                           $0380,$0380,$0380,$0000);„             HotX : $0007;„             HotY : $0003);„„     ARROW : GCursor =       {Your run-of-the-mill Graphics Arrow cursor}„           (ScreenMask : ($1FFF,$0FFF,$07FF,$03FF,„                          $01FF,$00FF,$007F,$003F,„                          $001F,$003F,$01FF,$01FF,„                          $E0FF,$F0FF,$F8FF,$F8FF);„            CursorMask : ($0000,$4000,$6000,$7000,„                          $7800,$7C00,$7E00,$7F00,„                          $7F80,$7C00,$4C00,$0600,„                          $0600,$0300,$0400,$0000);„            HotX : $0001;„            HotY : $0001);„„     CHECK : GCursor =       {A check-mark cursor}„           (ScreenMask : ($FFF0,$FFE0,$FFC0,$FF81,„                          $FF03,$0607,$000F,$001F,„                          $803F,$C07F,$E0FF,$F1FF,„                          $FFFF,$FFFF,$FFFF,$FFFF);„            CursorMask : ($0000,$0006,$000C,$0018,„                          $0030,$0060,$70C0,$3980,„                          $1F00,$0E00,$0400,$0000,„                          $0000,$0000,$0000,$0000);„            HotX : $0005;„            HotY : $0010);„„     CROSS : GCursor =       {A circle with center cross cursor}„           (ScreenMask : ($F01F,$E00F,$C007,$8003,„                          $0441,$0C61,$0381,$0381,„                          $0381,$0C61,$0441,$8003,„                          $C007,$E00F,$F01F,$FFFF);„            CursorMask : ($0000,$07C0,$0920,$1110,„                          $2108,$4004,$4004,$783C,„                          $4004,$4004,$2108,$1110,„                          $0920,$07C0,$0000,$0000);„            HotX : $0007;„            HotY : $0007);„„     GLOVE : GCursor =       {The hand with pointing finger cursor}„           (ScreenMask : ($F3FF,$E1FF,$E1FF,$E1FF,„                          $E1FF,$E049,$E000,$8000,„                          $0000,$0000,$07FC,$07F8,„                          $9FF9,$8FF1,$C003,$E007);„            CursorMask : ($0C00,$1200,$1200,$1200,„                          $1200,$13B6,$1249,$7249,„                          $9249,$9001,$9001,$8001,„                          $4002,$4002,$2004,$1FF8);„            HotX : $0004;„            HotY : $0000);„„     IBEAM : GCursor =       {Your normal text entering I shaped cursor}„           (ScreenMask : ($F3FF,$E1FF,$E1FF,$E1FF,„                          $E1FF,$E049,$E000,$8000,„                          $0000,$0000,$07FC,$07F8,„                          $9FF9,$8FF1,$C003,$E007);„            CursorMask : ($0C30,$0240,$0180,$0180,„                          $0180,$0180,$0180,$0180,„                          $0180,$0180,$0180,$0180,„                          $0180,$0180,$0240,$0C30);„            HotX : $0007;„            HotY : $0007);„„      KKG : GCursor =     {KKG symbol, a little sorority stuff}„        (ScreenMask : ($FFFF,$1040,$1040,$0000,„                       $0000,$0000,$0411,$0411,„                       $0001,$0001,$0001,$1041,„                       $1041,$1041,$FFFF,$FFFF );„         CursorMask : ($0000,$0000,$4517,$4515,„                       $4925,$5144,$6184,$6184,„                       $5144,$4924,$4514,$4514,„                       $4514,$0000,$0000,$0000 );„         HotX : $0007;„         HotY : $0005);„„      SMILEY : GCursor =  {a Smiley face for you!}„        (ScreenMask : ($C003,$8001,$07E0,$0000,„                       $0000,$0000,$0000,$0000,„                       $0000,$0000,$0000,$8001,„                       $C003,$C003,$E007,$F81F );„         CursorMask : ($0FF0,$1008,$2004,$4002,„                       $4E72,$4A52,$4E72,$4002,„                       $4992,$581A,$2424,$13C8,„                       $1008,$0C30,$03C0,$0000 );„         HotX : $0007;„         HotY : $0005);„„      XOUT : GCursor =    {a BIG X marks the spot}„        (ScreenMask : ($1FF8,$0FF0,$07E0,$03C0,„                       $8181,$C003,$E007,$F00F,„                       $F81F,$F00F,$E007,$C003,„                       $8181,$03C0,$07E0,$0FF0 );„         CursorMask : ($8001,$C003,$6006,$300C,„                       $1818,$0C30,$0660,$03C0,„                       $0180,$03C0,$0660,$0C30,„                       $1818,$300C,$6006,$C003 );„         HotX : $0007;„         HotY : $0008);„„      SWORD : GCursor =   {For the D&D buffs...}„        (ScreenMask : ($F83F,$F83F,$F83F,$F83F,„                       $F83F,$F83F,$F83F,$F83F,„                       $8003,$8003,$8003,$8003,„                       $8003,$F83F,$F01F,$F01F );„         CursorMask : ($0100,$0380,$0380,$0380,„                       $0380,$0380,$0380,$0380,„                       $0380,$3398,$3398,$3FF8,„                       $0380,$0380,$0380,$07C0 );„         HotX : $0007;„         HotY : $0000);„„„Type„    Position = record„             btnStat,„             opCount,„             Xpos,Ypos : integer;„             end; {record}„„Const„     ButtonL = 0;„     ButtonR = 1;„     ButtonM = 2;„     Software = 0;„     Hardware = 1;„„     „Type„    GenMouse = object„             X,Y : integer;„             Visible : boolean;„             Function TestMouse : boolean;„             Procedure SetAccel(Threshold : integer);„             Procedure Show(Option : boolean);„             Procedure GetPosition(var BtnStatus,Xpos,Ypos : integer);„             Procedure QueryBtnDn(Button : integer;var mouse : position);„             Procedure QueryBtnUp(Button : integer;var mouse : position);„             Procedure ReadMove(var XMove,YMove : integer);„             Procedure Reset(var Status : boolean;var BtnCount : integer);„             Procedure SetRatio(HorPix,VerPix : integer);„             Procedure SetLimits(XPosMin,YPosMin,XPosMax,YPosMax : integer);„             Procedure SetPosition(XPos,YPos : integer);„             end; {object}„„    GraphicMouse = object(GenMouse)„                 Procedure Initialize;„                 Procedure ConditionalHide(Left,Top,Right,Bottom : integer);„                 Procedure SetCursor(Cursor : GCursor);„                 end; {object}„„    TextMouse = object(GenMouse)„              Procedure Initialize;„              Procedure SetCursor(Ctype,C1,C2 : word);„              end; {object}„„    GraphicLightPen = object(GraphicMouse)„                    Procedure LightPen(Option : boolean);„                    end; {object}„„    TextLightPen = object(TextMouse)„                 Procedure LightPen(Option : boolean);„                 end; {object}„„{=========================================================================}„„Implementation„„Uses„    Crt,Graph,Dos;„Var„   Regs : registers;„„{*************************************************************************}„„Function Lower(N1,N2 : integer) : integer;„Begin„     if N1 < N2 then„        Lower := N1„     else„         Lower := N2;„End;„„{*************************************************************************}„„Function Upper(N1,N2 : integer) : integer;„Begin„     if N1 > N2 then„        Upper := N1„     else„         Upper := N2;„End;„„{*************************************************************************}„„Function GenMouse.TestMouse : boolean;„Const„     Iret = 207;„Var„   dOff,dSeg : integer;„Begin„     dOff := MemW[0000:0204];„     dSeg := MemW[0000:0206];„     if ((dSeg = 0) or (dOff = 0)) then„        TestMouse := False„     else„         TestMouse := Mem[dSeg:dOff] <> Iret;„End;„„{*************************************************************************}„„Procedure GenMouse.Reset(var Status : boolean; var BtnCount : integer);„Begin„     Regs.AX := $00;            {Reset to default conditions}„     intr($33,Regs);„     Status := Regs.AX <> 0;    {Mouse Present}„     BtnCount := Regs.BX;       {Button Count}„End;„„{*************************************************************************}„„Procedure GenMouse.SetAccel(Threshold : integer);„Begin„     Regs.AX := $13;„     Regs.DX := Threshold;„     Intr($33,Regs);„End;„„{*************************************************************************}„„Procedure GenMouse.Show(Option : boolean);„Begin„     if Option and not Visible then„     begin„          Regs.AX := $01;         {Show mouse cursor}„          Visible := True;„          Intr($33,Regs);„     end„     else„     if Visible and not Option then„     begin„          Regs.AX := $02;           {Hide mouse cursor}„          Visible := False;„          Intr($33,Regs);„     end;„End;„„{*************************************************************************}„„Procedure GenMouse.GetPosition(var BtnStatus,Xpos,Ypos : integer);„Begin„     Regs.AX := $03;„     Intr($33,Regs);„     BtnStatus := Regs.BX;„     Xpos      := Regs.CX;„     Ypos      := Regs.DX;„End;„„{*************************************************************************}„„Procedure GenMouse.SetPosition(Xpos,Ypos : integer);„Begin„     Regs.AX := $04;„     Regs.CX := Xpos;„     Regs.DX := Ypos;„     Intr($33,Regs);„End;„„{*************************************************************************}„„Procedure GenMouse.SetRatio(HorPix,VerPix : integer);„Begin„     Regs.AX := $0F;„     Regs.CX := HorPix;         {horizonal mickeys/pixel}„     Regs.DX := VerPix;         {vertical mickeys/pixel}„     Intr($33,Regs);„End;„„{*************************************************************************}„„Procedure GenMouse.QueryBtnDn(Button : integer;var Mouse : position);„Begin„     Regs.AX := $05;„     Regs.BX := Button;„     Intr($33,Regs);„     Mouse.BtnStat := Regs.AX;„     Mouse.OpCount := Regs.BX;„     Mouse.Xpos    := Regs.CX;„     Mouse.Ypos    := Regs.DX;„End;„„{*************************************************************************}„„Procedure GenMouse.QueryBtnUp(Button : integer;var Mouse : position);„Begin„     Regs.AX := $06;„     Regs.BX := Button;„     Intr($33,Regs);„     Mouse.BtnStat := Regs.AX;„     Mouse.OpCount := Regs.BX;„     Mouse.Xpos    := Regs.CX;„     Mouse.Ypos    := Regs.DX;„End;„„{*************************************************************************}„„Procedure GenMouse.SetLimits(XPosMin,YPosMin,XPosMax,YPosMax : integer);„Begin„     Regs.AX := $07;    {horizonal limits}„     Regs.CX := Lower(XPosMin,XPosMax);„     Regs.DX := Upper(XPosMin,XPosMax);„     Intr($33,Regs);„     Regs.AX := $08;    {vertical limits}„     Regs.CX := Lower(YPosMin,YPosMax);„     Regs.DX := Upper(YPosMin,YPosMax);„     Intr($33,Regs);„End;„„{*************************************************************************}„„Procedure GenMouse.ReadMove(var XMove,YMove : integer);„Begin„     Regs.AX := $0B;„     Intr($33,Regs);„     XMove := Regs.CX;„     YMove := Regs.DX;„End;„„{*************************************************************************}„„             {=======================================}„             {Implementation methods for GraphicMouse}„             {=======================================}„„Procedure GraphicMouse.SetCursor(Cursor : GCursor);„Begin„     Regs.AX := $09;„     Regs.BX := Cursor.HotX;„     Regs.CX := Cursor.HotY;„     Regs.DX := Ofs(Cursor.ScreenMask);„     Regs.ES := Seg(Cursor.ScreenMask);„     Intr($33,Regs);„End;„„{*************************************************************************}„„Procedure GraphicMouse.ConditionalHide(Left,Top,Right,Bottom : integer);„Begin„     Regs.AX := $0A;„     Regs.CX := Left;„     Regs.DX := Top;„     Regs.SI := Right;„     Regs.DI := Bottom;„     Intr($33,Regs);„End;„„{*************************************************************************}„„Procedure GraphicMouse.Initialize;„Begin„     Visible := False;„     SetLimits(0,0,GetMaxX,GetMaxY);„     SetCursor(Arrow);„     SetPosition(GetMaxX div 2,GetMaxY div 2);„     Show(True);„End;„„{*************************************************************************}„„                    {====================================}„                    {Implementation methods for TextMouse}„                    {====================================}„„Procedure TextMouse.Initialize;„Begin„     Visible := False;„     SetLimits(Lo(WindMin)*8,Hi(WindMin)*8,Lo(WindMax)*8,Hi(WindMax)*8);„     SetCursor(Hardware,6,7);„     SetPosition(0,0);„     Show(True);„End;„„{*************************************************************************}„„Procedure TextMouse.SetCursor(CType,C1,C2 : word);„Begin„     Regs.AX := $0A;            {function 10h}„     Regs.BX := CType;          {0=software,1=hardware}„     Regs.CX := C1;             {screen mask or scan start line}„     Regs.DX := C2;             {screen mask or scan stop line}„     Intr($33,Regs);„End;„„{*************************************************************************}„„             {===================================}„             {Implementation methods for LightPen}„             {===================================}„„Procedure TextLightPen.LightPen(Option : boolean);„Begin„     if Option then„        Regs.AX := $0D„     else„         Regs.AX := $0E;„     Intr($33,Regs);„End;„„{*************************************************************************}„„Procedure GraphicLightPen.LightPen(Option : boolean);„Begin„     if Option then„        Regs.AX := $0D„     else„         Regs.AX := $0E;„     Intr($33,Regs);„End;„„{*************************************************************************}„„BEGIN„END.„„     18     02-05-9407:57ALL                      MARK MILBRATH            TP7 Mouse Unit           IMPORT              32     l»   Program MouseDemo;   { I just learned this little piece of wizardry }„Uses                 { so I thought I would pass it on -- have fun! }„  Crt,Dos,Drivers;„Type„  CharType=Set Of Char;„Var„  Key:Char; ValidKeys:CharType;„  Button_Status,Mouse_X,Mouse_Y,ButtonPressed,X,Y:Word;„Procedure GetMouse (Var Button_Status,Mouse_X,Mouse_Y:Word;„                                              Monitor:Word);„Var                       { --------------------------------------- }„  Regs:Registers;         { Button_Status     0 = no button pressed }„Begin                     { Mouse_X           X coordinate          }„  Regs.AX:=3;             { Mouse_Y           Y coordinate          }„  Intr($33,Regs);         { Monitor           0 = off  1 = on       }„  Button_Status:=Regs.BX; { Monitor can be set to 1 While coding to }„  Mouse_X      :=Regs.CX; { display Button_Status,   Mouse_X,   and }„  Mouse_Y      :=Regs.DX; { Mouse_Y in the upper-left corner of the }„  If (Monitor=1) Then     { screen                                  }„    Begin                 { --------------------------------------- }„      TextBackGround(7); TextColor(8); GotoXY(1,1);„      Write('             '); GotoXY(1,1);„      Write(Button_Status:2,Mouse_X:5,Mouse_Y:5); Delay(100)„    End„End;„Procedure GetEvent;„Label„  ExitLoop;„Begin„  TextBackGround(0); ClrScr; TextColor(7);„  GotoXY(26,12); Write('Continue? [Y] or [N]? ');„  ValidKeys:=[#89,#78];          { accept only Y or N as valid keys }„  Key:=#255;                     { initialize Key to a nonvalid key }„  Repeat„    While (Not KeyPressed) Do„      Begin„        GetMouse(Button_Status,Mouse_X,Mouse_Y,0);„        Repeat                               { ^  turns monitor off }„          GetMouse(ButtonPressed,X,Y,0) { X & Y are dummy variables }„        Until (KeyPressed) Or (ButtonPressed<>Button_Status);„    { Repeat ^ Until "waits" until a change in Button_Status occurs }„    { this eliminates a "slow" click from being processed as two or }„    { more clicks                                                   }„        If (Button_Status>0) THEN { a mouse button has been pressed }„          Begin { convert mouse clicks into corresponding key codes }„            If      (Mouse_X=288) And (Mouse_Y=88) Then Key:=#89„            Else If (Mouse_X=344) And (Mouse_Y=88) Then Key:=#78;„            If      (Key In ValidKeys)             Then Goto ExitLoop„          End                              { exit the loop if valid }„      End;                                 { key codes are received }„    Key:=Upcase(ReadKey) { get keyboard event if KeyPressed is true }„  Until (Key In ValidKeys);„  ExitLoop: TextBackGround(0); ClrScr; TextColor(7);„  If Key=#89 Then„    Begin„      Randomize;„      X:=Random(61)+10;      { pick a random X column from 10 to 60 }„      Y:=Random(21)+ 3;      { pick a random Y row    from  3 to 23 }„      GotoXY(X,Y);     Write(#177);„      GotoXY(X-5,Y+1); Write('Click here!');„              { the X column and Y row numbers must be converted to }„              { X and Y coordinates by multiplying the column & row }„              { numbers by 8 and then subtracting 8 from that value }„      Repeat  { for example:  column 40, row 10 converts to 312, 72 }„        GetMouse(Button_Status,Mouse_X,Mouse_Y,1)„                                             { ^   turns monitor on }„      Until(Button_Status>0) And (Mouse_X=X*8-8) And (Mouse_Y=Y*8-8);„      GetEvent                   {        ^^^^^               ^^^^^ }„    End;                         { X coordinate        Y coordinate }„  HideMouse; ClrScr„End;„Begin„  InitEvents;„        { sets the "hide counter" to zero and displays mouse cursor }„        { use ShowMouse to decrement the hide counter               }„        { use HideMouse to increment the hide counter               }„        { when hide counter equals zero the mouse cursor is visible }„  GetEvent„End.„                                                          19     02-09-9411:49ALL                      SEAN PALMER              GREAT Mouse Routines     IMPORT              49     l»   „{ Rodent unit  v1.3      OooO }  { << isn't he cute? } {   09/01/93              \/  }„{ Interrupt-style interface for Microsoft mouse, Turbo Pascal 6.0+}„„{ by Sean L. Palmer }„{ Released to the Public Domain }„„{ Please credit me if your program uses these routines! }„„„unit Rodent;„{$A-,B-,D-,E-,F-,G+,I-,L-,N-,O-,R-,S-,V-,X+}„{make sure you alloc enough stack space in main program!} {as written, requires a 286+ and that the mouse exists}„„interface„„const„ x :integer=0; y :integer=0; {current mouse pos}„ xs:integer=0; ys:integer=0; {mickey counts}„ left=1; center=2; right=4;  {button masks- (btn and left)<>0 if left button„                              down}„ b:boolean=false;            {button status, true if any button down} var„ btn:byte absolute b;        {button status, mask with (btn and mask)<>0 to„                              get a specific button}„ hidden:boolean;„type„ pMouseHook=^tMouseHook;„ tMouseHook=procedure;„„{avoid calling dos, bios, and mouse routines from these if possible}„function erasHook(h:tMouseHook):pMouseHook;„function moveHook(h:tMouseHook):pMouseHook;„function drawHook(h:tMouseHook):pMouseHook; {change out handlers}„function clikHook(h:tMouseHook):pMouseHook;„function liftHook(h:tMouseHook):pMouseHook;„„procedure show(f:boolean);          {true=show}„procedure confine(l,t,r,b:integer); {set min,max bounds}„procedure moveTo(h,v:integer);„procedure setSpeed(xs,ys,thr:word); {set x,y pix per 16 mickeys, double speed threshold}„„implementation„„{This unit should work in any mode, but you need to provide the routines„ to draw and erase the cursor.}„{note: reason coords are scaled *8 throughout is because mouse driver}„ {stupidly messes with the values differently in different modes.}„ {This is just a work-around so it won't be limited to every eighth column„  or row in text modes.}„{PS: be very careful using mickey counts in DI & SI in event handler.}„„var„ hideCount:byte absolute hidden;„„„{this procedure does nothing, used to disable an event} procedure defaultMouseHook;far;assembler;asm end;„„{must save previous setting of I-flag}„procedure clearInts;inline($9C/$FA); {pushF;cli} procedure restoreInts;inline($9D);   {popF}„„const„ vDrawHook:tMouseHook=defaultMouseHook; {pre-set all hooks to do nothing}„ vErasHook:tMouseHook=defaultMouseHook;„ vMoveHook:tMouseHook=defaultMouseHook;„ vClikHook:tMouseHook=defaultMouseHook;„ vLiftHook:tMouseHook=defaultMouseHook;„„{these all both set a hook to a procedure you provide, and also return„ the old hook so you can later restore it} {Use something like:}„„{var savedClikHook:tMouseHook;}„{...}„{@savedClikHook:=clikHook(myClikHook);}„{...}„{clikHook(savedClikHook)}„„function drawHook(h:tMouseHook):pMouseHook;begin„ drawHook:=@vDrawHook; clearInts; vDrawHook:=h; restoreInts;„ end;„function erasHook(h:tMouseHook):pMouseHook;begin„ erasHook:=@vErasHook; clearInts; vErasHook:=h; restoreInts;„ end;„function moveHook(h:tMouseHook):pMouseHook;begin„ moveHook:=@vMoveHook; clearInts; vMoveHook:=h; restoreInts;„ end;„function clikHook(h:tMouseHook):pMouseHook;begin„ clikHook:=@vclikHook; clearInts; vClikHook:=h; restoreInts;„ end;„function liftHook(h:tMouseHook):pMouseHook;begin„ liftHook:=@vLiftHook; clearInts; vLiftHook:=h; restoreInts;„ end;„„{here is the callback function for the mouse driver}„„{calling regs:}„ {ax:triggering event bit mask}„ {bx:button status bit mask (bit 0=left,1=center,2=right)}„ {cx:mouse X/bit 7 is sign for di,bit 0 always=0}„ {dx:mouse Y/bit 7 is sign for si}„ {di:abs mouse Delta X}„ {si:abs mouse Delta Y}„„{bits in event mask:}„ {0:move}„ {1:left btn down}„ {2:left btn up}„ {3,4:center btn}„ {5,6:right btn}„„{This code is real easy to break, be careful!} procedure doMouseHook;far;assembler;asm„ push ax; mov ax,seg @DATA; mov ds,ax; pop ax;„ mov xs,si; mov ys,di; {disregard di,si mickey counts}„ mov btn,bl;„ and cx,$3FFF; shr cx,3; and dx,$3FFF; shr dx,3; {strip hi bits}„ push ax; push cx; push dx;  {save event status}„ test hidden,$FF; jnz @NOERAS; call vErasHook; @NOERAS:„ pop dx; mov y,dx; pop cx; mov x,cx;„ call vMoveHook;  {always assume mouse has moved, disregard bit 0 of ax}„ test hidden,$FF; jnz @NODRAW; call vDrawHook; @NODRAW:„ pop ax; {restore event status}„@CLIK: test al,00101010b; jz @LIFT; {check any button clik flag}„ push ax; call vClikHook; pop ax;„@LIFT: test al,01010100b; jz @EXIT; {check any button lift flag}„ call vLiftHook;„@EXIT:„ end;„„procedure show(f:boolean);begin„ clearInts;„ if f then begin„  if hidden then begin dec(hideCount); if not hidden then vDrawHook; end;„  end„ else begin if not hidden then vErasHook; inc(hideCount); end;„ restoreInts;„ end;„„Procedure confine(l,t,r,b:integer);assembler;asm„ mov ax,7; mov cx,l; shl cx,3; mov dx,r; shl dx,3; int $33;„ mov ax,8; mov cx,t; shl cx,3; mov dx,b; shl dx,3; int $33;„ end;„„procedure moveTo(h,v:integer);begin„ if not hidden then vErasHook;„ asm mov cx,h; mov x,cx; shl cx,3;„     mov dx,v; mov y,dx; shl dx,3;„     mov ax,4; int $33; end;„ if not hidden then vDrawHook;„ end;„„procedure setSpeed(xs,ys,thr:word);assembler;asm„ mov ax,$1A; mov bx,xs; shl bx,3; mov cx,ys; shl cx,3; mov dx,thr; int $33;„ end;„„var„ oldMouseHook:pointer;„ oldEventMask:word;„„procedure removeMouse;begin„ if not hidden then show(false);„ asm les dx,oldMouseHook; mov cx,oldEventMask; mov ax,$C; int $33;end;„ end;„„var„ mouseHook:pointer absolute 0:$33*4;„const„ eventMask=$7F;  {all events}„„function exists:boolean;assembler;asm„ xor ax,ax; mov es,ax; {get ready to check interrupt vector for nil}„ mov bx,es:[$33*4]; or bx,es:[$33*4+2]; jz @X; {no}„ {ax still 0} int $33; @X:  {result in al}„ end;„„begin„ if exists then begin„  setSpeed(32,64,4);    {set up a natural-feeling speed for 640x480}„  moveTo(0,0); confine(0,0,0,0); {trap the little sucker}„  hideCount:=1;„  asm„   push cs; pop es; mov dx,offset doMouseHook; {loc of callback function}„   mov cx,eventMask; mov ax,$14; int $33;      {enable event callbacks}„   mov oldEventMask,cx;„   mov word ptr oldMouseHook,dx; mov word ptr oldMouseHook+2,es;„   end;„  end„ else begin writeln('Need mouse.'); halt(1);end;„ end.„                         20     05-26-9406:17ALL                      FLORIAN ANSORGE          Mouse Detection          SWAG9405            16     l»   {„(The Procedure Mouse_Check can be done shorter, but this one "remembers" a„mouseclick, so you can click the mouse, and at a later time call this„procedure and it will tell you the mouse-information!)„„>-----------------------------            }„„PROGRAM Mouse_on_the_screen;„„USES DOS,Graph;„„TYPE„     MouseType = RECORD„                   x, y, Button     : Word;„                   RButton, LButton : Boolean;„                 END;„VAR„     Reg                              : Registers;„     Mouse                            : Mousetype;„„PROCEDURE Show_Mouse;„BEGIN„  Reg.AX := 1;„  Intr($33,Reg);„END;„„PROCEDURE Hide_Mouse;„BEGIN„  Reg.AX := 2;„  Intr($33,Reg);„END;„„PROCEDURE SetMouseArea(XMin,YMin,XMax,YMax :Word);„BEGIN„  Reg.AX := 7;„  Reg.CX := XMin;„  Reg.DX := XMax;„  Intr($33,Reg);„  Reg.AX := 8;„  Reg.CX := YMin;„  Reg.DX := YMax;„  Intr($33,Reg);„END;„„PROCEDURE Init_Mouse;„BEGIN„  Reg.AX := 0;„  Intr($33,Reg);„  SetMouseArea(0,0,GetMaxX,GetMaxY);„  Reg.AX := 4;„  Reg.CX := 100;„  Reg.DX := 100;„  Intr($33,Reg);„END;„„PROCEDURE Mouse_Check;„BEGIN„  Reg.AX := 5;„  Reg.BX := 1;„  Intr($33,Reg);„  Mouse.RButton := Reg.BX > 0;„  Mouse.Button := Reg.AX;„  IF Mouse.RButton THEN Mouse.Button := 2;„  Mouse.X := Reg.CX;„  Mouse.Y := Reg.DX;„„  IF NOT Mouse.RButton„    THEN Begin„           Reg.AX := 5;„           Reg.BX := 0;„           Intr($33,Reg);„           Mouse.LButton := Reg.BX > 0;„           Mouse.Button := Reg.AX;„           IF Mouse.LButton THEN Mouse.Button := 1;„           Mouse.X := Reg.CX;„           Mouse.Y := Reg.DX;„         End;„END;„„BEGIN„  {Init graphics screen here!}„„  Init_Mouse;„  Show_Mouse;„  .                     {You have to finish this part yourself}„  .                     { ___     }„  .                     { |-lorian}„  Hide_Mouse;„ {CloseGraph};„END.„                                                                                                     