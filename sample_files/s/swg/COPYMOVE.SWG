SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00020         FILE COPY/MOVE ROUTINES                                           1      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Copy File #1             IMPORT              6      ﬁS®ù Program Copy;„„Var InFile, OutFile : File;„    Buffer          : Array[ 1..512 ] Of Char;„    NumberRead,„    NumberWritten   : Word;„„begin„   If ParamCount <> 2 Then Halt( 1 );„   Assign( InFile, ParamStr( 1 ) );„   Reset ( InFile, 1 );     {This is Reset For unTyped Files}„   Assign  ( OutFile, ParamStr( 2 ) );„   ReWrite ( OutFile, 1 );  {This is ReWrite For unTyped Files}„   Repeat„      BlockRead ( InFile, Buffer, Sizeof( Buffer ), NumberRead );„      BlockWrite( OutFile, Buffer, NumberRead, NumberWritten );„   Until (NumberRead = 0) or (NumberRead <> NumberWritten);„   Close( InFile );„   Close( OutFile );„end.„              2      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Copy File #2             IMPORT              30     ﬁS‘Ñ {I've been trying to figure out how to do a fairly fast copy„ in pascal.  It doesn't have to be faster then Dos copy, but„ I definatly DON'T want to shell out to Dos to do it!„ I've got the following working... in the IDE of Turbo 6.0!„ If I compile it, it wont work at all.  ALSO... If you COMP„ the Files to check For errors, They are there.  (UGH!)„ (ie, it isn't a perfect copy!)„ The thing is I want to get as much as I can in each pass!„ (But turbo has limits!)„ Heres my code... Just rough, so no Real comments.„}„„Program Copy (InFile, OutFile);„„Uses Dos;„„Var„   I, Count, BytesGot : Integer;„   BP : Pointer;„   InFile,OutFile:File;„„   FI,FO : Word;„„   Path,„   FileName : String[80];„„   DirInfo : SearchRec;„   BaseRec, RecSize : longInt;„„begin„   FileName := ParamStr(1);             {Set the SOURCE as the first ParamSTR}„   Path := ParamStr(2);                 {Set the Dest.  as the 2nd paramSTR}„„   If paramCount = 0 Then„      begin„           Writeln('FastCopy (C) 1993 - Steven Shimatzki');„           Writeln('Version : 3.0   Usage: FastCopy <Source> <Destination>');„           Halt(1);„      end;„„   FindFirst(FileName,Archive,DirInfo);„„   If DirInfo.Name <> '' Then„   begin„„       RecSize := MaxAvail - 1024;  {Get the most memory but leave some}„       BaseRec := RecSize;„„       If RecSize > DirInfo.Size Then      {If a "SMALL" File, gobble it up}„           RecSize := DirInfo.Size;        {In one pass!  Size = Recordsize}„„       Count := DirInfo.Size Div RecSize;  {Find out how many Passes!}„„       GetMem (Bp, RecSize);   {Allocate memory to the dynamic Variable}„„       Assign (InFile,FileName);       {Assign the File}„       Assign (OutFile,Path);          {Assign the File}„„       Filemode := 0;     {Open the INFile as READONLY}„„       Reset(InFile,RecSize);      {open the input}„       ReWrite(OutFile,RecSize);   {make the output}„„„       For I := 1 to Count do    {Do it For COUNT passes!}„       begin„„            {$I-}„            Blockread(InFile,BP^,1,BytesGot);   {Read 1 BLOCK}„            {$I+}„„            BlockWrite(outFile,BP^,1,BytesGot);   {Write 1 BLOCK}„„            If BytesGot <> 1 Then„               Writeln('Error!  Disk Full!');„„       end;„„{If not all read in, then I have to get the rest seperatly!  partial Record!}„„       If Not ((Count * RecSize) = DirInfo.Size) Then„       begin„            RecSize := (DirInfo.Size - (Count * RecSize)) ;„                       {^^^ How much is left to read? get it in one pass!}„„„            FreeMem(Bp, BaseRec);      {Dump the mem back}„            GetMem(Bp, RecSize);       {Get the new memory}„„            FileMode := 0;         {Set input For readonly}„„            Reset (InFile,1);„„            Filemode := 2;         {Set output For Read/Write}„„            Reset (OutFile,1);„„            Seek(InFile, (Count * BaseRec));   {Move to old location}„            Seek(OutFile, (Count * BaseRec));{ same }„„            FI := FilePos(InFile);    {Just used to see where I am in the File}„            FO := FilePos(OutFile);   {Under the Watch Window... Remove later}„„            {$I-}„            BlockRead(InFile,Bp^,RecSize,BytesGot);    {REad the File}„            {$I+}„„            BlockWrite(OutFile,Bp^,RecSize,BytesGot);  {Write the File}„„       end;„„       Close(OutFile);„       Close(InFile);„„       FreeMem (Bp,RecSize);„„   end;„„end.„„{„You don't close the input- and output File when your finished With the„first count passes. Maybe your last block will not be written to disk,„when you reopen the outputFile For writing. I can't see another problem„right now.                                                                                                       3      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Copy File #3             IMPORT              10     ﬁS˝¥ {„> Or can someone put up some Procedure that will copy Files.„}„„{$O+}„„Uses„  Dos;„„Function CopyFile(SourceFile, TargetFile : String): Byte;„{ Return codes:  0 successful„                 1 source and target the same„                 2 cannot open source„                 3 unable to create target„                 4 error during copy„}„Var„  Source,„  Target  : File;„  BRead,„  BWrite  : Word;„  FileBuf : Array[1..2048] of Char;„begin„  If SourceFile = TargetFile then„  begin„    CopyFile := 1;„    Exit;„  end;„  Assign(Source,SourceFile);„  {$I-}„  Reset(Source,1);„  {$I+}„  If IOResult <> 0 then„  begin„    CopyFile := 2;„    Exit;„  end;„  Assign(Target,TargetFile);„  {$I-}„  ReWrite(Target,1);„  {$I+}„  If IOResult <> 0 then„  begin„    CopyFile := 3;„    Exit;„  end;„  Repeat„    BlockRead(Source,FileBuf,SizeOf(FileBuf),BRead);„    BlockWrite(Target,FileBuf,Bread,BWrite);„  Until (Bread = 0) or (Bread <> BWrite);„  Close(Source);„  Close(Target);„  If Bread <> BWrite then„    CopyFile := 4„  else„    CopyFile := 0;„end; {of func CopyFile}„„                                                                                         4      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Copy File #4             IMPORT              20     ﬁSEo {I am having a bit of a problem in Pascal.  I am writing a routine to„copy Files.  The Program is to be used in an area where anything at„all can happen, so it has to be totally bullet-proof.  All is well,„except one little thing.  Should the Program encounter a major disk„error (for example, the user removes the disk While the copy is taking„place), the Program breaks into Dos after an 'Abort, Retry, Fail'„prompt.  Now comes the weird part.  This crash to Dos only occurs only„once the Program terminates.  It processes the error perfectly, and only„gives the error once my entire Program is at an end!  Following is the„source code in question:„}„Program FileTest;„„Uses„  Dos;„„Procedure FileCopy(SrcPath, DstPath, FSpec : String; Var ExStat : Integer);„Var„  DirInfo : SearchRec;„  Done    : Boolean;„„Procedure Process(X : String);„Var„  Source,„  Dest     : File;„  Buffer   : Array[1..4096] of Byte;„  ReadCnt,„  WriteCnt : Word;„„begin„  {$I-}„  ExStat:=0;„  Assign(Source,SrcPath+X);„  Reset(Source,1);„  If IOResult <> 0 then„    ExStat := 1;„  If ExStat = 0 then„  begin„    Assign(Dest,DstPath+X);„    ReWrite(Dest,1);„    If IOResult <> 0 then„      ExStat := 2;„    If ExStat = 0 then„    begin„      Repeat„        BlockRead(Source,Buffer,Sizeof(Buffer),ReadCnt);„        BlockWrite(Dest,Buffer,ReadCnt,WriteCnt);„        If IOResult <> 0 then„          ExStat := 3;„      Until (ReadCnt = 0) or (WriteCnt <> ReadCnt) or (ExStat <> 0);„      Close(Dest);„    end;„    Close(Source);„  end;„  {$I+}„end;„„begin„  {$I-}„    ExStat := 0;„    FindFirst(SrcPath + FSpec, Archive, DirInfo);„    Done := False;„    While Not Done do„    begin„      Write('Copying ',DirInfo.Name,' ');„      Process(DirInfo.Name);„      If (ExStat = 0) then„      begin„        FindNext(DirInfo);„        If (DosError<>0) then„          Done := True;„      end„      else„        Done := True;„    end;„  {$I+}„end;„„Procedure Main;„Var„  ExC : Integer;„begin„  FileCopy('C:\Dos\','A:\','*.BAS',ExC);„  Writeln('Exit Code:',ExC);„end;„„begin„  Main;„  Writeln('Program is Complete');„end.„{„That's it.  All errors get logged normally, and right after 'Program is„Complete', I get an 'Abort, Retry, Fail'.  It must be a File left open,„and TP tries to close it once the Program terminates, but I can't„imagine which File it might be!„}                                                                                                       5      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Copy File #5             IMPORT              16     ﬁSPQ { copy Files With certain extentions to a specific directory (Both„ parameters specified at the command line or in a Text File).. I cannot„ seem to find a command withing TP 6.0 to copy Files.. I have looked„ several times through the manuals but still no luck.. I even asked the„ teacher in Charge and he did not even know! Ok all you Programmers out„ there.. Show your stuff.. If you Really want to be kind, help me out„ on this..I am just starting in TP and this is all new to me!„}„„{$R-,I+} {Set range checking off, IOChecking on}„{$M $400, $2000, $10000} {Make sure enough heap space}„{    1k Stack, 8k MinHeap, 64k MaxHeap }„Type„        Buf = Array[0..65527] of Byte;„Var„        FileFrom, FileTo : File;„        Buffer : ^Buf;„        BytesToRead, BytesRead : Word;„        MoreToCopy, IoStatus : Boolean;„„begin„        {Determine largest possible buffer useable}„        If MaxAvail < 65528 then„                BytesToRead := MaxAvail„        else„                BytesToRead := 65528;„        Writeln('Program is using ', BytesToRead , ' Bytes of buffer');„        GetMem(Buffer, BytesToRead);    {Grab heap memory For buffer}„        Assign(FileFrom, 'File_1');„        Assign(FileTo, 'File_2');„        Reset(FileFrom, 1);     {Open File With 1Byte Record size}„        ReWrite(FileTo, 1);„        IoStatus := (IoResult = 0);„        MoreToCopy := True;„        While IoStatus and MoreToCopy do begin„        {$I-}„                blockread(FileFrom, Buffer^, BytesToRead, BytesRead);„                blockWrite(FileTo, Buffer^, BytesRead);„        {$I+}„                MoreToCopy := (BytesRead = BytesToRead);„                IoStatus := (IoResult=0);„        end;„        Close(FileTO);„        Close(FileFrom);„        FreeMem(Buffer, BytesToRead); {Release Heap memory}„        If (not IoStatus) then„            Writeln('Error copying File!!!');„end.„                                                6      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Copy File #6             IMPORT              33     ﬁSØ
 {$A+,B-,D-,E+,F-,I+,L-,N-,O-,R+,S+,V-}„{$M 16384,65536,655360}„„Program scopy;„„Uses„  Dos,„  tpDos,„  sundry,„  Strings;„„Type„  buffer_Type = Array[0..65519] of Byte;„  buffptr     = ^buffer_Type;„„Var„  f1,f2       : File;„  fname1,„  fname2,„  NewFName,„  OldDir      : PathStr;„  SRec        : SearchRec;„  errorcode   : Integer;„  buffer      : buffptr;„Const„  MakeNewName : Boolean = False;„  FilesCopied : Word = 0;„  MaxHeapSize = 65520;„„Function IOCheck(stop : Boolean; msg : String): Boolean;„  Var„    error : Integer;„  begin„    error := Ioresult;„    IOCheck := (error = 0);„    if error <> 0 then begin„      Writeln(msg);„      if stop then begin„        ChDir(OldDir);„        halt(error);„      end;„    end;„  end;„„Procedure Initialise;„  Var„    temp  : String;„    dir   : DirStr;„    name  : NameStr;„    ext   : ExtStr;„  begin„    if MaxAvail < MaxHeapSize then begin„      Writeln('Insufficient memory');„      halt;„    end„    else„      new(buffer);„    {I-} GetDir(0,OldDir); {$I+} if IOCheck(True,'') then;„    Case ParamCount of„      0: begin„           Writeln('No parameters provided');„           halt;„         end;„      1: begin„           TempStr := ParamStr(1);„           if not ParsePath(TempStr,fname1,fname2) then begin„             Writeln('Invalid parameter');„             halt;„           end;„           {$I-} ChDir(fname2); {$I+} if IOCheck(True,'') then;„         end;„      2: begin„           TempStr := ParamStr(1);„           if not ParsePath(TempStr,fname1,fname2) then begin„             Writeln('Invalid parameter');„             halt;„           end„           else„             {$I-} ChDir(fname2); {$I+} if IOCheck(True,'') then;„„           TempStr := ParamStr(2);„           if not ParsePath(TempStr,fname2,temp) then begin„             Writeln('Invalid parameter');„             halt;„           end;„           FSplit(fname2,dir,name,ext);„           if length(name) <> 0 then„             MakeNewName := True;„         end;„    else begin„           Writeln('too many parameters');„           halt;„         end;„    end; { Case }„  end; { Initialise }„„Procedure CopyFiles;„  Var„    result : Word;„„  Function MakeNewFileName(fn : String): String;„    Var„      temp  : String;„      dir   : DirStr;„      name  : NameStr;„      ext   : ExtStr;„      numb  : Word;„    begin„      numb := 0;„      FSplit(fn,dir,name,ext);„      Repeat„        inc(numb);„        if numb > 255 then begin„          Writeln('Invalid File name');„          halt(255);„        end;„        ext := copy(Numb2Hex(numb),2,3);„        temp := dir + name + ext;„        Writeln(temp);„      Until not ExistFile(temp);„      MakeNewFileName := temp;„    end; { MakeNewFileName }„„„  begin„    FindFirst(fname1,AnyFile,Srec);„    While Doserror = 0 do begin„      if (SRec.attr and $19) = 0 then begin„        if MakeNewName then„          NewFName := fname2„        else„          NewFName := SRec.name;„        if ExistFile(NewFName) then„          NewFName := MakeNewFileName(NewFName);„        {$I-}„        Writeln('Copying ',SRec.name,' > ',NewFName);„        assign(f1,SRec.name);„        reset(f1,1);„        if { =1= } IOCheck(False,'1. Cannot copy '+fname1) then begin„          assign(f2,fname2);„          reWrite(f2,1);„          if IOCheck(False,'2. Cannot copy '+SRec.name) then„            Repeat„              BlockRead(f1,buffer^,MaxHeapSize);„              if IOCheck(False,'3. Cannot copy '+SRec.name) then„                result := 0„              else begin„                BlockWrite(f2,buffer^,result);„                if IOCheck(False,'4. Cannot copy '+NewFName) then„                  result := 0;„              end;„            Until result < MaxHeapSize;„          close(f1); close(f2);„          if IOCheck(False,'Error While copying '+SRec.name) then;„        end; { =1= }„      end;  { if SRec.attr }„      FindNext(Srec);„    end; { While Doserror = 0 }„  end; { CopyFiles }„„begin„  Initialise;„  CopyFiles;„  ChDir(OldDir);„end.„„                                                                                       7      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Copy File with Display   IMPORT              15     ﬁS!¡ Hello Matthew!„„Answering a msg of <Monday April 12 1993>, from Matthew Staikos to All:„„The Norton-like bar along with the copying won't compile,„but you get the idea, no?„„  {$I-}„  function __copyfil(„    show: boolean; x1,x2,y,f,b: byte; fs: longint; src, targ: string„  ): byte;„  {„   return codes:„     0 successful„     1 source and target the same„     2 cannot open source„     3 unable to create target„     4 error during copy„     5 cannot allocate buffer„  }„  const„    bufsize = 16384;„„  type„    fbuf = array[1..bufsize] of char;„    fbf  = ^fbuf;„„  var„    source,„    target   :    file;„    bread,„    bwrite   :    word;„    filebuf  :    ^fbf;„    tr       : longint;„    nr       :    real;„„  begin„    if memavail > bufsize then new(filebuf) else begin„      __copyfil := 5; exit„    end;„    if src = targ then begin __copyfil := 1; exit end;„    assign(source, src); reset(source,1);„    if ioresult <> 0 then begin __copyfil := 2; exit end;„    assign(target, targ); rewrite(target,1);„    if ioresult <> 0 then begin __copyfil := 3; exit end;„    if show then __write(x1+2,y,f,b,__rep(x2-x1-3,'∞')); tr := 0;„    repeat„      blockread(source,filebuf^,bufsize,bread);„      tr := tr + bread; nr := tr/fs;„      nr := nr * (x2-x1-3);„      if show then __write(x1+2,y,f,b,__rep(trunc(nr), '€'));„      blockwrite(target,filebuf^,bread,bwrite);„    until (bread = 0) or (bread <> bwrite);„    if show then __write(x1+2,y,f,b,__rep((x2-x1-3),'€'));„    close(source); close(target);„    if bread <> bwrite then __copyfil := 4 else __copyfil := 0;„  end;„  {$I-}„„„„„Floor„„--- GoldED 2.40„ * Origin: UltiHouse/2 5 Years! V32b/HST/16k8: x31,13,638709 (2:512/195)„                                                                                                      8      05-28-9313:35ALL                      SWAG SUPPORT TEAM        Copy File from ECO-LIB   IMPORT              14     ﬁS.u {„Note : Functions beginning with "__" come from the ECO Library - Kerry.„„FLOOR A.C. NAAIJKENS„„The Norton-like bar along with the copying won't compile„„{$I-}„function __copyfil(show : boolean; x1, x2, y, f, b : byte;„                   fs : longint; src, targ : string) : byte;„{„ return codes:„  0 successful„  1 source and target the same„  2 cannot open source„  3 unable to create target„  4 error during copy„  5 cannot allocate buffer„}„const„  bufsize = 16384;„„type„  fbuf = array[1..bufsize] of char;„  fbf  = ^fbuf;„„var„  source,„  target   :    file;„  bread,„  bwrite   :    word;„  filebuf  :    ^fbf;„  tr       : longint;„  nr       :    real;„„begin„  if memavail > bufsize then„    new(filebuf)„  else„  begin„    __copyfil := 5;„    exit„  end;„  if src = targ then„  begin„    __copyfil := 1;„    exit„  end;„  assign(source, src);„  reset(source,1);„  if ioresult <> 0 then„  begin„    __copyfil := 2;„    exit„  end;„  assign(target, targ);„  rewrite(target,1);„  if ioresult <> 0 then„  begin„    __copyfil := 3;„    exit„  end;„  if show then„    __write(x1 + 2 , y, f, b, __rep(x2 - x1 - 3, '∞'));„  tr := 0;„  repeat„    blockread(source, filebuf^, bufsize, bread);„    tr := tr + bread;„    nr := tr / fs;„    nr := nr * (x2 - x1 - 3);„    if show then„      __write(x1 + 2, y, f, b, __rep(trunc(nr), '€'));„    blockwrite(target, filebuf^, bread, bwrite);„  until (bread = 0) or (bread <> bwrite);„  if show then„    __write(x1 + 2, y, f, b, __rep((x2 - x1 - 3), '€'));„  close(source);„  close(target);„  if bread <> bwrite then„    __copyfil := 4„  else„    __copyfil := 0;„end;„{$I-}„„                                             9      05-28-9313:35ALL                      SWAG SUPPORT TEAM        FAST Copy File           IMPORT              5      ﬁSá {≥o≥ I want to make my buffer For the BlockRead command as       ≥o∫„≥o≥ large as possible. When I make it above 11k, I get an       ≥o∫„≥o≥ error telling me "too many Variables."                      ≥o∫„Use dynamic memory, as in thanks a heap.„}„„„if memavail > maxint  { up to 65520 }„then bufsize := maxint„else bufsize := memavail;„if i<128„then Exitmsg('No memory')„else getmem(buf,bufsize);„„„                                                                                                                10     05-28-9313:35ALL                      SWAG SUPPORT TEAM        Move File #1             IMPORT              49     ﬁSƒÏ {„I found a source * COPY.PAS * (don't know where anymore or who posted it) and„tried to Write my own move_Files Program based on it.„„The simple idea is to move the Files specified in paramstr(1) to a destination„directory specified in paramstr(2) and create the directories that do not yet„exist.„„On a first look it seems just to work out ok. But yet it does not.„„to help me find the failure set paramstr(1) to any path you want (For example„D:\test\*.txt or whatever) and set paramstr(2) to a non existing path which is„C:\A\B\C\D\E\F\G\H\..\Z\A\B\C\D\E\F\„„The directories C:\A through C:\A\B\C\D\F\..\Q\R\S will be created and than the„Program hangs.„„Who can help me find what the mistake is?„„I Really will be grateful For any kind of help.„„The code is:„}„„{$A+,B-,D+,E+,F-,G-,I-,L+,N-,O-,R+,S-,V+,X-}„Program aMOVE;„„Uses„  Crt, Dos;„Const„  BufSize = 32768;„Var„  ioCode               : Byte;„  SrcFile, DstFile     : File;„  FileNameA,„  FileNameB            : String;„  Buffer               : Array[1..BufSize] of Byte;„  RecsRead             : Integer;„  DiskFull             : Boolean;„  CurrDir              : DirStr;        {Aktuelles Verzeichnis speichern}„  HelpList             : Boolean;       {Hilfe uber mogliche Parameter?}„  i,„  n                    : Integer;„  str                  : String[1];„„  SDStr                : DirStr;        {Quellverzeichnis}„  SNStr                : NameStr;       {Quelldateiname}„  SEStr                : ExtStr;        {Quelldateierweiterung}„„  DDStr                : DirStr;        {Zielverzeichnis}„  DNStr                : NameStr;       {Zieldateiname}„  DEStr                : ExtStr;        {Zieldateierweiterung}„„  SrcInfo              : SearchRec;     {Liste der Quelldateien}„  SubDirStr            : Array [0..32] of DirStr;„  key                  : Char;„„„  Procedure SrcFileError(ioCode : Byte);„  begin„    Write(#7, 'I/O result of ', ioCode, ' (decimal) ', #26);„    Case ioCode of„      $01 : WriteLn(' Source File not found.');„      $F3 : WriteLn(' too many Files open.');„    else WriteLn(' "Reset" unknown I/O error.');„    end;„  end;„„  Procedure DstFileError(ioCode : Byte);„  begin„    Write(#7, 'I/O result of ', ioCode, ' (decimal) ', #26);„    Case ioCode of„      $F0 : WriteLn(' Disk data area full.');„      $F1 : WriteLn(' Disk directory full.');„      $F3 : WriteLn(' too many Files open.');„    else WriteLn(' "ReWrite" unknown I/O error.');„    end;„  end;„„„„Procedure EXPAR;                      {externe Parameter abfragen} begin„  GetDir(0,CurrDir);                  {Aktuelles Verzeichnis speichern}„  if DDStr='' then DDStr:= CurrDir;   {Wenn keine Zialangabe, dann ins„                                       aktuelle Verzeichnis verschieben}„  FSplit(paramstr(1), SDStr, SNStr, SEStr);„end;„„Procedure Copy2Dest;„begin„  if FileNameB <> FileNameA then„    begin„      Assign(SrcFile, FileNameA);„      Assign(DstFile, FileNameB);„      {* note second parameter in "reset" and "reWrite" of UNTyped Files. *}„      {$I-} Reset(SrcFile, 1); {$I+}„      ioCode := Ioresult;„      if (ioCode <> 0) then SrcFileError(ioCode)„      else„        begin„          {$I-} ReWrite(DstFile, 1); {$I+}„          ioCode := Ioresult;„          if (ioCode <> 0) then DstFileError(ioCode)„          else„            begin„              DiskFull := False;„              While (not EoF(SrcFile)) and (not DiskFull) do„                begin„                  {* note fourth parameter in "blockread". *}„                  {$I-}„                  BlockRead(SrcFile, Buffer, BufSize, RecsRead);„                  {$I+}„                  ioCode := Ioresult;„                  if ioCode <> 0 then„                    begin„                      SrcFileError(ioCode);„                      DiskFull := True„                    end„                  else„                    begin„                      {$I-}„                      BlockWrite(DstFile, Buffer, RecsRead);„                      {$I+}„                      ioCode := Ioresult;„                      if ioCode <> 0 then„                        begin„                          DstFileError(ioCode);„                          DiskFull := True„                        end„                    end„                end;„              if not DiskFull then WriteLn(FileNameB)„            end;„          Close(DstFile)„        end;„      Close(SrcFile)„    end„  else WriteLn(#7, 'File can not be copied onto itself.')„end;„„Procedure ProofDest;„begin„  if length(paramstr(2)) > 67 then begin„    Writeln;„    Writeln(#7,'Invalid destination directory specified.');„    Writeln('Program aborted.');„    Halt(1);„  end;„  FSplit(paramstr(2), DDStr, DNStr, DEStr);„  if copy(DNStr,length(DNStr),1)<>'.' then begin„    insert(DNStr,DDStr,length(DDStr)+1);„    DNStr:='';„  end;„  if copy(DDStr,length(DDStr),1)<>'\' then„    insert('\',DDSTR,length(DDStr)+1);„  SubDirStr[0]:= DDStr;„  For i:= 1 to 20 do begin„    SubDirStr[i]:=copy(DDStr,1,pos('\',DDStr));„    Delete(DDStr,1,pos('\',DDStr));„  end;„  For i:= 32 doWNto 1 do begin„    if SubDirStr[i]= '' then n:= i-1;„  end;„„  DDStr:= SubDirStr[0];„  SubDirStr[0]:='';„„  For i:= 1 to n do begin„    SubDirStr[0]:= SubDirStr[0]+SubDirStr[i];„„    if copy(SubDirStr[0],length(SubDirStr[0]),1)='\' then„      delete(SubDirStr[0],length(SubDirStr[0]),1);„„ begin„      {$I-}„      MkDir(SubDirStr[0]);„      {$I+}„      if Ioresult = 0 then„      WriteLn('New directory created: ', SubDirStr[0]);„    end;„„    if copy(SubDirStr[0],length(SubDirStr[0]),1)<>'\' then„      insert('\',SubDirStr[0],length(SubDirStr[0])+1);„  end;„end;„„Procedure HandleMove;„begin„  FileNameA:= SDStr+SrcInfo.Name;„  FileNameB:= DDStr+SrcInfo.Name;„  Copy2Dest;„  Erase(SrcFile);„end;„„Procedure ExeMove;„begin„  ProofDest;„  FindFirst(paramstr(1), AnyFile, SrcInfo);„  While DosError = 0 do begin„    HandleMove;„    FindNext(SrcInfo);„  end;„end;„„„„begin„  SDStr:= '';„  SNStr:= '';„  SEStr:= '';„  DDStr:= '';„  DNStr:= '';„  DEStr:= '';„  For i:=0 to 32 do SubDirStr[i]:='';„  ExPar;„  ExeMove;„end.„                                                                                 11     05-28-9313:35ALL                      SWAG SUPPORT TEAM        Move File #2             IMPORT              7      ﬁSÜ{ {„> How would I move a File from within my Program.„„if the File is to moved from & to the same partition,„all you have to do is:„„  Assign(F,OldPath);„  Rename(F,NewPath);„„On the other hand, if the File is to be moved to a different„partition, you will have to copy / erase the File.„Example:„}„Program MoveFile;„„Var„  fin,fout  : File;„  p         : Pointer;„  w         : Word;„„begin„  GetMem(p,64000);„  Assign(fin,ParamStr(1));               { Assumes command line parameter. }„  Assign(fout,ParamStr(2));„  Reset(fin);„  ReWrite(fout);„  While not Eof(fin) do„  begin„    BlockRead(fin,p^,64000,w);„    BlockWrite(fout,p^,w);„  end;„  Close(fin);„  Close(fout);„  Erase(fin);„  FreeMem(p,64000);„end.„„{„This Program has NO error control.„}                   12     05-28-9313:35ALL                      SWAG SUPPORT TEAM        Move File FAST           IMPORT              13     ﬁSÄ {$S-,R-,V-,I-,N-,B-,F-}„„{$IFNDEF Ver40}„  {Allow overlays}„  {$F+,O-,X+,A-}„{$ENDIF}„„UNIT MoveFile;„„INTERFACE„„USES Dos;„„FUNCTION MoveFiles ( VAR OldFullPath : PathStr;„                     VAR NewFullPath : PathStr) : BOOLEAN;„„IMPLEMENTATION„„„FUNCTION MoveFiles ( VAR OldFullPath : PathStr;„                     VAR NewFullPath : PathStr) : BOOLEAN;„„VAR„  regs : REGISTERS;„  Error_Return,„  N      : BYTE;„„  PROCEDURE MoveToNewPath;„  { On same disk drive }„  BEGIN„  OldFullPath [LENGTH (OldFullPath) + 1] := CHR (0);„  NewFullPath [LENGTH (NewFullPath) + 1] := CHR (0);„  WITH regs DO„    BEGIN„      DS := SEG (OldFullPath);„      DX := OFS (OldFullPath) + 1;  {the very first byte is the length}„      ES := SEG (NewFullPath);„      DI := OFS (NewFullPath) + 1;„      AX := $56 SHL 8;               { ERRORS are             }„      INTR ($21, regs);                {   2 : file not found   }„      IF Flags AND 1 = 1 THEN        {   3 : path not found   }„        error_return := AX           {   5 : access denied    }„      ELSE                           {  17 : not same device  }„        error_return := 0;„    END;  {with}„  END;„„BEGIN„  Error_Return := 0;„  IF OldFullPath [1] = '\' THEN OldFullPath := FExpand (OldFullPath);„  IF NewFullPath [1] = '\' THEN NewFullPath := FExpand (NewFullPath);„  IF UPCASE (OldFullPath [1]) = UPCASE (NewFullPath [1]) THEN MoveToNewPath„     ELSE Error_Return := 17;„„MoveFiles := (Error_Return = 0);„END;„„END.                                                                     13     05-28-9313:35ALL                      SWAG SUPPORT TEAM        Rename File #1           IMPORT              6      ﬁSµÿ {„> Does anybody know how to do a "fast" move of a File?„> ie: not copying it but just moving the FAT Record„„  Yup.  In Pascal you can do it With the Rename command.  The Format is:„„   Rename (Var F; NewName : String)„„where F is a File Variable of any Type.„„to move a File Really fast, and to avoid having to copy it somewhere first and„then deleting the original, do this:„}„„Procedure MoveIt;  {No error checking done}„Var„   F : File;„   FName : String;„   NName : String;„begin„   Assign (F, FName);„   NName:= {new directory / File name}„   Rename (F, NName);„End.                                                                   14     05-28-9313:35ALL                      SWAG SUPPORT TEAM        Rename File #2           IMPORT              14     ﬁS>ï {„>I am interested in the source in Assembler or TP to move a File from one„>directory to another by means of the FAT table.  I have seen several„>small utilities to do this but I was unable to understand them after„>reverse engineering/disassembly.  (Don't worry, they were PD).  <G>„>Anyway, any help would be appreciated.  Thanks.„„You don't Really need to do much. Dos Interrupt (21h), Function 56h, will„rename a File, and in essence move it if the source and destination„directories are not the same. That's all there is to it. I know Function„56h is available in Dos 3.3 and above. I am not sure about prior„versions.„„On entry: AH      56H„          DS:DX   Pointer to an ASCIIZ String containing the drive, path,„                  and Filename of the File to be renamed.„          ES:DI   Pointer to an ASCIIZ String containing the new path and„                  Filename„On return AX      Error codes if carry flag set, NONE if carry flag not set„„Below is some crude TP code I Typed on the fly. It may not be exactly right„but you get the idea.„}„„Uses„  Dos;„Var„  Regs        : Registers;„  Source,„  Destination : PathStr;„„begin„  { Add an ASCII 0 at the end of the Strings to male them ASCIIZ„    Strings, without actually affecting their actual lengths }„  Source[ord(Source[0])] := #0;„  Destination[ord(Destination[0])] := #0;„„  { Set the Registers }„  Regs.AH := $56;„  Regs.DS := Seg(Source[1]);„  Regs.DX := ofs(Source[1]);„  Regs.ES := Seg(Destination[1]);„  Regs.DI := ofs(Destination[1]);„„  { Do the Interrupt }„  Intr($21,Regs);„end.„                                                                                                      15     05-28-9313:35ALL                      SWAG SUPPORT TEAM        Move File with Rename    IMPORT              8      ﬁS'Ã {„≥ I am interested in the source in Asm or TP to move a File from one„≥ directory to another by means of the FAT table.„„All you have to do is use the Rename Procedure.  It isn't done via the„FAT table, but via Dos Function 56h.  The only restrictions are (1)„you must be running on Dos 2.0 or greater, and (2) the original and„target directories must be on the same drive.  The code might look„something like this:„}„„Function MoveFile( FileName, NewDir: Dos.PathStr ): Boolean;„Var„  f:      File;„  OldDir: Dos.DirStr;„  Nam:    Dos.NameStr;„  Ext:    Dos.ExtStr;„begin„  Dos.FSplit( FileName, OldDir, Nam, Ext );„  if NewDir[ Length(NewDir) ] <> '\' then„    NewDir := NewDir + '\';„  {$I-}„  Assign( f, FileName );„  FileName := NewDir + Nam + Ext;„  Rename( f, FileName );„  MoveFile := (Ioresult=0);„  {$I+}„end; { MoveFile }„                                                              16     06-22-9307:50ALL                      SWAG SUPPORT TEAM        Copy/Move Files Anywhere IMPORT              49     ﬁSî› {$A+,B-,D+,E+,F-,G+,I+,L+,N-,O-,P-,Q-,R-,S-,T-,V-,X+,Y+}„{$M 16384,0,655360}„„USES DOS,Crt;„„   TYPE„„   { Define action type MOVE or COPY }„   cTYPE = (cMOVE,cCOPY);„„   { Define the special structure of a DOS Disk Transfer Area (DTA) }„   DTARec      =  RECORD„                     Filler   :  ARRAY [1..21] OF BYTE;„                     Attr     :  BYTE;„                     Time     :  WORD;„                     Date     :  WORD;„                     Size     :  LONGINT;„                     Name     :  STRING [12];„                  END {DtaRec};„„VAR„    OK : Integer;„    IP,OP : PathStr;  { input,output file names }„„   FUNCTION Copier (cWhat : cTYPE; VAR orig: STRING;VAR nName: STRING) : Integer;„„   { Copy or Move file through DOS if not on same disk. Retain original date,„     time and size and delete the original on Move.  The beauty here is that„     we can move files across different drives.  Also, we can rename file if„     we choose.     If error, function returns error number }„„„      CONST bufsize = $C000;            { About 48 KB - 49152 }„„      TYPE„       fileBuffer = ARRAY [1..bufsize] OF BYTE;„„      VAR   Regs: registers;„            src,dst: INTEGER;„            bsize,osize: LONGINT;„            buffer : ^fileBuffer;„            DTABlk : DTARec;„            fError : BOOLEAN;„„      FUNCTION CheckError(err : Integer) : BOOLEAN;„      BEGIN„      CheckError := (Err <> 0);„      fError     := (Err <> 0);„      Copier     := err;„      END;„„      PROCEDURE delfile (VAR fName: STRING);„„         VAR   Regs: registers;„„         BEGIN„            WITH Regs do BEGIN„               ah := $43;             { Make file R/W for delete }„               al := 1;„               cx := 0;               { Normal file }„               ds := Seg(fName[1]);   { fName is the fully qualified }„               dx := Ofs(fName[1]);   { pathname of file, 0 terminated }„               MsDos (Regs);„               IF CheckError(Flags AND 1) THEN EXIT„               ELSE BEGIN„                  ah := $41;            { Delete file through fName }„                  { ds:dx stil valid from set-attributes }„                  MsDos (Regs);„                  IF CheckError(Flags AND 1) THEN EXIT;„                  END„               END„         END;„„      BEGIN„„         Copier := 0;  { Assume Success }„         FindFirst(Orig,Anyfile,SearchRec(DTABlk));„         IF CheckError(DosError) THEN EXIT;„„         WITH Regs DO BEGIN„            ah := $3D;                  { Open existing file }„            al := 0;                    { Read-only }„            ds := Seg(orig[1]);         { Original filename (from) }„            dx := Ofs(orig[1]);„            MsDos (Regs);„            IF CheckError(Flags AND 1) THEN Exit„            ELSE BEGIN„               src := ax;               { Handle of the file }„„               ah := $3C;               { Create a new file }„               cx := 0;                 { Start as normal file }„               ds := Seg(nName[1]);     { Pathname to move TO }„               dx := Ofs(nName[1]);„               MsDos (Regs);„               IF CheckError(Flags AND 1) THEN Exit„               ELSE„                  dst := ax„               END„            END;„„         osize := DTABlk.size;       { Size of file, from "findfirst" }„         WHILE (osize > 0) AND NOT ferror DO BEGIN„„            IF osize > bufsize THEN„               bsize := bufsize        { Too big for buffer, use buffer size }„            ELSE„               bsize := osize;„„            IF BSize > MAXAVAIL THEN BSize := MAXAVAIL;„„            GETMEM (buffer, BSize);    { Grap some HEAP memory }„„            WITH Regs DO BEGIN„               ah := $3F;               { Read block from file }„               bx := src;„               cx := bsize;„               ds := Seg(buffer^);„               dx := Ofs(buffer^);„               MsDos (Regs);„               IF CheckError(Flags AND 1) THEN {}„               ELSE BEGIN„                  ah := $40;            { Write block to file }„                  bx := dst;„                  { cx and ds:dx still valid from Read }„                  MsDos (Regs);„                  IF CheckError(Flags AND 1) THEN {}„                  ELSE IF ax < bsize THEN„                     BEGIN„                     CheckError(98); { disk full }„                     END„                  ELSE„                     osize := osize - bsize„                  END;„               END;„„            FREEMEM (buffer, BSize);   { Give back the memory }„            END;„„         IF NOT ferror AND (cWHAT = cMOVE) THEN„         WITH Regs DO„            BEGIN„            ah := $57;                  { Adjust date and time of file }„            al := 1;                    { Set date }„            bx := dst;„            cx := DTABlk.time;          { Out of the "find" }„            dx := DTABlk.date;„            MsDos (Regs);„            CheckError(Flags AND 1);„            END;„„         WITH Regs DO„            BEGIN„            ah := $3E;                  { Close all files, even with errors! }„            bx := src;„            MsDos (Regs);„            ferror := ferror OR ((flags AND 1) <> 0);„            ah := $3E;„            bx := dst;„            MsDos (Regs);„            ferror := ferror OR ((flags AND 1) <> 0)„            END;„„         IF ferror THEN EXIT            { we had an error somewhere }„         ELSE WITH Regs DO„            BEGIN„            ah := $43;                  { Set correct attributes to new file }„            al := 1;                    { Change attributes }„            cx := DTABlk.attr;          { Attribute out of "find" }„            ds := Seg(nName[1]);„            dx := Ofs(nName[1]);„            MsDos (Regs);„            IF CheckError(Flags AND 1) THEN EXIT„            ELSE„               If (cWHAT = cMOVE) THEN DelFile (orig) { Now delete the original }„            END                                       { if we are moving file }„      END;„„BEGIN„clrscr;„IP := 'queen1.PAS';„OP := 'd:\temp\queen1.pas';„OK := Copier(cCOPY,IP,OP);„WriteLn(OK);„END.                                                                17     08-17-9308:42ALL                      SWAG SUPPORT TEAM        An OOP FILECOPY          IMPORT              13     ﬁSÄ( PROGRAM FileCopyDemo;	 { FILECOPY.PAS }„„USES Crt;„„TYPE„   Action  = (Input, Output);„   DataBlk = array[1..512] of byte;„   FileObj = OBJECT„     fp : FILE;„     CONSTRUCTOR OpenFile(FileName: string;„			   FileAction: Action);„     PROCEDURE ReadBlock(VAR fb: DataBlk;„			    VAR Size: integer);„     PROCEDURE WriteBlock(fb: DataBlk;„				size: integer);„     DESTRUCTOR CloseFile;„   END;„„CONSTRUCTOR FileObj.OpenFile;„BEGIN„  Assign(fp, FileName);„  CASE FileAction of„    Input: BEGIN„      Reset(fp, 1);„      IF IOResult <> 0 THEN„	BEGIN„	  WriteLn(FileName, ' not found!');„	  Halt(1);„	END;„	WriteLn(FileName,' opened for read ... ');„      END;„    Output: BEGIN„      Rewrite(fp, 1);„      WriteLn(FileName,' opened for write ... ');„      END;„   END; {CASE}„END;„„DESTRUCTOR FileObj.CloseFile;„BEGIN„   Close(fp);„   WriteLn('File closed ...');„END;„„PROCEDURE FileObj.ReadBlock;„BEGIN„   BlockRead(fp, fb, SizeOf(fb), Size);„   WriteLn('Reading ', Size, ' bytes ... ');„END;„„PROCEDURE FileObj.WriteBlock;„BEGIN„   BlockWrite(fp, fb, Size);„   WriteLn('Writing ', Size, ' bytes ... ');„END;„„VAR„   InFile, OutFile : FileObj;„   Data: DataBlk;„   Size: integer;„„BEGIN„   ClrScr;„   InFile.OpenFile('FILECOPY.PAS', Input);„   OutFile.OpenFile('FILECOPY.CPY', Output);„   REPEAT„      InFile.ReadBlock(Data, Size);„      OutFile.WriteBlock(Data, Size);„   UNTIL Size <> SizeOf(DataBlk);„   InFile.CloseFile;„   OutFile.CloseFile;„   Write('Press Enter to quit ... ');„   ReadLn;„END.„                                     18     08-27-9320:52ALL                      MARK LEWIS               Copy file in EMS         IMPORT              21     ﬁSB| { MARK LEWIS }„„PROGRAM EMSCopy;„„USES„  Objects;  {The Object unit is need to access TStream}„„VAR„  InFile,„  OutFile   : PStream;       {Pointer to InPut/OutPut Files}„  EmsStream : PStream;       {Pointer to EMS Memory Block}„  InPos     : LongInt;       {Where are we in the Stream}„„BEGIN„  Writeln;„  Writeln('                  EMSCopy v1.00');„  Writeln;„  Writeln('{ Mangled together from code in the FIDO PASCAL Echo }');„  Writeln('{ Assembled by Mark Lewis                            }');„  Writeln('{ Some ideas and code taken from examples by         }');„  Writeln('{ DJ Murdoch and Todd Holmes                         }');„  Writeln('{ Released in the Public Domain                      }');„  Writeln;„  If ParamCount < 2 Then„  Begin„    Writeln('Usage: EMSCopy <Source_File> <Destination_File>');„    Halt(1);„  End;„„  Infile := New(PBufStream, init(paramstr(1), stOpenRead, 4096));„  If (InFile^.Status <> stOK) Then„  Begin„    Writeln(#7, 'Error! Source File Not Found!');„    InFile^.Reset;„    Dispose(InFile, Done);„    Halt(2);„  End;„„  Outfile := New(PBufStream, init(paramstr(2), stCreate, 4096));„  If (OutFile^.Status <> stOK) Then„  Begin„    Writeln(#7,'Error! Destination File Creation Error!');„    OutFile^.Reset;„    Dispose(OutFile, Done);„    Halt(3);„  End;„„  EmsStream := New(PEmsStream, Init (16000, InFile^.GetSize));„  If (EmsStream^.Status <> stOK) Then„  Begin„    Writeln(#7, 'Error! EMS Allocation Error!');„    Writeln('At Least One Page of EMS Required :(');„    EmsStream^.Reset;„    Dispose(EmsStream, Done);„    Halt(4);„  End;„„  Writeln('InPut File Size : ', InFile^.Getsize : 10, ' Bytes');„  InPos := EmsStream^.GetSize;„  Repeat„    Write('Filling EMS Buffer...     ');„    EmsStream^.CopyFrom(InFile^, InFile^.GetSize - InPos);„    if (EmsStream^.Status <> stOK) then„      EmsStream^.Reset;„„    InPos := InPos + EmsStream^.GetSize;„    Write(EmsStream^.GetSize : 10, ' Bytes   ');„    EmsStream^.Seek(0);„    Write('Writing DOS File... ');„    OutFile^.CopyFrom(EmsStream^, EmsStream^.GetSize);„    Writeln(OutFile^.Getsize : 10, ' Bytes');„    If (InFile^.Status <> stOK) Then„      InFile^.Reset;„    If (OutFile^.GetSize < InFile^.GetSize) Then„    Begin„      EmsStream^.Seek(0);„      EmsStream^.Truncate;„      InFile^.Seek(InPos);„    End;„  Until (OutFile^.GetSize = InFile^.GetSize);„  Writeln('Done!');„  DISPOSE(InFile, Done);„  DISPOSE(OutFile, Done);„  DISPOSE(EmsStream, Done);„END.„                                                                                                    19     10-28-9311:33ALL                      GUY MCLOUGHLIN           File Copy Routine        IMPORT              114    ﬁSËê „              (* Compiler directives.                               *)„ {$A+,B-,D-,E-,F-,I+,N-,O-,R-,S-,V+}„„              (* STACK, HEAP memory directives.                     *)„ {$M 1024, 0, 0}„„              (* Public domain file-copy program.                   *)„              (* Guy McLoughlin - August 23, 1992.                  *)„program MCopy;„„uses          (* We need this unit for the paramcount, paramstr,    *)„  Dos;        (* fsearch, fexpand, fsplit routines.                 *)„„const„              (* Carridge-return + Line-feed constant.              *)„  coCrLf = #13#10;„„              (* Size of the buffer we're going to use.             *)„  coBuffSize = 61440;„„type„              (* User defined file read/write buffer.               *)„  arBuffSize = array[1..coBuffSize] of byte;„„var„              (* Path display width.                                *)„  byDispWidth : byte;„„              (* Variable to record the number of files copied.     *)„  woCopyCount,„              (* Variable to record the number of bytes read.       *)„  woBytesRead,„              (* Variable to record the number of bytes written.    *)„  woBytesWritten : word;„„              (* Variable to record the size in bytes of IN-file.   *)„  loInSize,„              (* Variable to record the number of bytes copied.     *)„  loByteProc : longint;„„              (* Variables for TP "Fsplit" routine.                 *)„  stName : namestr;„  stExt  : extstr;„„              (* Directory-string variables.                        *)„  stDirTo,„  stDirFrom : dirstr;„„              (* Path-string variables.                             *)„  stPathTo,„  stPathFrom,„  stPathTemp : pathstr;„„              (* Array used to buffer file reads/writes.            *)„  arBuffer : arBuffSize;„„              (* Directory search-record.                           *)„  rcSearchTemp : searchrec;„„              (* IN file-variable.                                  *)„  fiIN,„              (* OUT file-variable.                                 *)„  fiOUT : file;„„„   (***** Handle file errors.                                       *)„   procedure ErrorHandler( byErrorNum : byte);„   begin„     case byErrorNum of„„       1 : begin„             writeln(coCrLf, ' (SYNTAX) MCOPY <path1><filespec1>' +„                             ' <path2><filename2>');„             writeln(coCrLf, ' (USAGE)  MCOPY c:\utils\*.doc' +„                             ' c:\temp\master.doc');„             writeln('          MCOPY   \utils\*.doc    ' +„                     '\temp\master.doc');„             writeln(coCrLf, ' (Copies all files with the ''.doc''' +„                             ' extension from ''c:\utils'')');„             writeln(' (directory, to ''master.doc'' in the ' +„                     '''c:\temp'' directory.    )');„             writeln(coCrLf, ' ( Public-domain utility by Guy ' +„                     'McLoughlin  \  August 1992  )')„           end;„„       2 : writeln(coCrLf,„                  ' Error : <path1><filespec1> = <path2><filename2>');„„       3 : writeln(coCrLf, ' Directory not found ---> ', stDirFrom);„„       4 : writeln(coCrLf, ' Directory not found ---> ', stDirTo);„„       5 : writeln(coCrLf, ' Error opening ---> ', stPathTo);„„       6 : writeln(coCrLf, ' File copy aborted');„„       7 : writeln(coCrLf, ' Error creating ---> ', stPathTo);„„       8 : writeln(coCrLf, ' Error opening ---> ', stPathTemp);„„       9 : writeln(coCrLf, ' Error with disk I/O ')„„     end;     (* case byErrorNum.                                   *)„„     halt„   end;       (* ErrorHandler.                                      *)„„„   (***** Determine if a file exists.                               *)„   function FileExist(FileName : pathstr) : boolean;„   begin„     FileExist := (FSearch(FileName, '') <> '')„   end;       (* FileExist.                                         *)„„„   (***** Determine if a directory exists.                          *)„   function DirExist(stDir : dirstr) : boolean;„   var„     woFattr : word;„     fiTemp  : file;„   begin„     assign(fiTemp, (stDir + '.'));„     getfattr(fiTemp, woFattr);„     if (doserror <> 0) then„       DirExist := false„     else„       DirExist := ((woFattr and directory) <> 0)„   end;       (* DirExist.                                          *)„„„   (***** Clear the keyboard-buffer.                                *)„   procedure ClearKeyBuff; assembler;„   asm„     @1: mov ah, 01h„         int 16h„         jz  @2„         mov ah, 00h„         int 16h„         jmp @1„     @2:„   end;       (* ClearKeyBuff                                       *)„„„   (***** Read a key-press.                                         *)„   function ReadKeyChar : char; assembler;„   asm„     mov ah, 00h„     int 16h„   end;        (* ReadKeyChar.                                      *)„„„   (***** Obtain user's choice.                                     *)„   function UserChoice : char;„   var„     Key : char;„   begin„     ClearKeyBuff;„     repeat„       Key := upcase(ReadKeyChar)„     until (Key in ['A', 'O', 'Q']);„     writeln(Key);„     UserChoice := Key„   end;       (* UserChoice.                                        *)„„„   (***** Returns all valid wildcard names for a specific directory.*)„   (*     When the last file is found, the next call will return an *)„   (*     empty string.                                             *)„   (*                                                               *)„   (* NOTE: Standard TP DOS unit must be listed in your program's   *)„   (*       "uses" directive, for this routine to compile.          *)„„   function WildCardNames({ input}     stPath   : pathstr;„                                       woAttr   : word;„                          {update} var stDir    : dirstr;„                                   var rcSearch : searchrec)„                          {output}              : pathstr;„   var„              (* Fsplit variables.                                  *)„     stName : namestr;„     stExt  : extstr;„   begin„              (* If the search-record "name" field is empty, then   *)„              (* initialize it with the first matching file found.  *)„     if (rcSearch.name = '') then„       begin„              (* Obtain directory-string from passed path-string.   *)„         fsplit(stPath, stDir, stName, stExt);„„              (* Find first match of path-string.                   *)„         findfirst(stPath, woAttr, rcSearch);„„              (* If a matching file was found, then return full     *)„              (* path-name.                                         *)„         if (doserror = 0) and (rcSearch.name <> '') then„           WildCardNames := (stDir + rcSearch.name)„         else„              (* No match found, return empty string.               *)„           WildCardNames := ''„       end„     else„              (* Search-record "name" field is not empty, so        *)„              (* continue searching for matches.                    *)„       begin„         findnext(rcSearch);„„              (* If no error occurred, then match was found...      *)„         if (doserror = 0) then„           WildCardNames := (stDir + rcSearch.name)„         else„              (* No match found. Re-set search-record "name" field, *)„              (* and return empty path-string.                      *)„           begin„             rcSearch.name := '';„             WildCardNames := ''„           end„       end„   end;„„„   (***** Pad a string with extras spaces on the right.             *)„   function PadR(stIn : string; bySize : byte) : string;„   begin„     fillchar(stIn[succ(length(stIn))], (bySize - length(stIn)) ,' ');„     inc(stIn[0], (bySize - length(stIn)));„     PadR := stIn„   end;       (* PadR.                                              *)„„„              (* Main program execution block.                      *)„BEGIN„              (* If too many or too few parameters, display syntax. *)„  if (paramcount <> 2) then„    ErrorHandler(1);„„              (* Assign program parameters to string variables.     *)„  stPathFrom := paramstr(1);„  stPathTo   := paramstr(2);„„              (* Make sure full path-string is used.                *)„  stPathFrom := fexpand(stPathFrom);„  stPathTo   := fexpand(stPathTo);„  stPathTemp := stPathFrom;„„              (* Check if IN-Filename is the same as OUT-Filename.  *)„  if (stPathFrom = stPathTo) then„    ErrorHandler(2);„„              (* Seperate directory-strings from path-strings.      *)„  fsplit(stPathFrom, stDirFrom, stName, stExt);„  fsplit(stPathTo, stDirTo, stName, stExt);„„              (* Make sure that "From" directory exists.            *)„  if NOT DirExist(stDirFrom) then„    ErrorHandler(3);„„              (* Make sure that "To" directory exists.              *)„  if NOT DirExist(stDirTo) then„    ErrorHandler(4);„„              (* Determine the full path display width.             *)„  if (stDirFrom[0] > stDirTo[0]) then„    byDispWidth := length(stDirFrom) + 12„  else„    byDispWidth := length(stDirTo) + 12;„„              (* Check if the OUT-File does exist, then...          *)„  if FileExist(stPathTo) then„    begin„              (* Ask if user wants to append/overwrite file or quit.*)„      writeln(coCrLf, ' File exists ---> ', stPathTo);„      write(coCrLf, ' Append / Overwrite / Quit  [A,O,Q]? ');„„              (* Obtain user's response.                            *)„      case UserChoice of„        'A' : begin„              (* Open the OUT-file to write to it.                  *)„                assign(fiOUT, stPathTo);„                {$I-}„                reset(fiOUT, 1);„                {$I+}„„              (* If there is an error opening the OUT-file, inform  *)„              (* the user of it, and halt the program.              *)„                if (ioresult <> 0) then„                  ErrorHandler(5);„„              (* Seek to end of file, so that data can be appended. *)„                seek(fiOUT, filesize(fiOUT))„              end;„„        'O' : begin„              (* Open the OUT-file to write to it.                  *)„                assign(fiOUT, stPathTo);„                {$I-}„                rewrite(fiOUT, 1);„                {$I+}„„              (* If there is an error opening the OUT-file, inform  *)„              (* the user of it, and halt the program.              *)„                if (ioresult <> 0) then„                  ErrorHandler(5)„              end;„„        'Q' : ErrorHandler(6)„„      end     (* case UserChoice.                                   *)„„    end„„  else        (* OUT-file does not exist.                           *)„„    begin„              (* Create the OUT-file to write to.                   *)„      assign(fiOUT, stPathTo);„      {$I-}„      rewrite(fiOUT, 1);„      {$I+}„„              (* If there is an error creating the OUT-file, inform *)„              (* the user of it, and halt the program.              *)„      if (ioresult <> 0) then„        ErrorHandler(7)„    end;„„              (* Clear the search-record, before begining.          *)„  fillchar(rcSearchTemp, sizeof(rcSearchTemp), 0);„„              (* Initialize copy-counter.                           *)„  woCopyCount := 0;„„              (* Set current file-mode to "read-only".              *)„  filemode := 0;„„  writeln;„„              (* Repeat... ...Until (stPathTemp = '').              *)„  repeat„              (* Search for vaild filenames.                        *)„    stPathTemp := WildCardNames(stPathTemp, archive, stDirFrom,„                                rcSearchTemp);„„              (* If file search was successful, then...             *)„    if (stPathTemp <> '') then„      begin„              (* Open the IN-file to read it.                       *)„        assign(fiIN, stPathTemp);„        {$I-}„        reset(fiIN, 1);„        {$I+}„„              (* If there is an error opening the IN-file, inform   *)„              (* the user of it, and halt the program.              *)„        if (ioresult <> 0) then„          begin„            close(fiOUT);„            erase(fiOUT);„            ErrorHandler(8)„          end;„„              (* Determine the size of the IN-file.                 *)„        loInSize := filesize(fiIN);„„              (* Set the number of bytes processed to 0.            *)„        loByteProc := 0;„„              (* Repeat... ...Until the IN-file has been completely *)„              (* copied.                                            *)„        repeat„„              (* Read the IN-file into the file-buffer.             *)„          blockread(fiIN, arBuffer, coBuffSize, woBytesRead);„„              (* Write the file-buffer to the OUT-file.             *)„          blockwrite(fiOUT, arBuffer, woBytesRead, woBytesWritten);„„              (* If there is a problem writing the bytes to the     *)„              (* OUT-file, let the user know, and halt the program. *)„          if (woBytesWritten <> woBytesRead) then„            begin„              close(fiIN);„              close(fiOUT);„              erase(fiOut);„              ErrorHandler(9)„            end„          else„              (* Advance the bytes-processed variable by the        *)„              (* number of bytes written to the OUT-file.           *)„            inc(loByteProc, woBytesWritten)„„              (* Repeat... ...Until the complete IN-file has been   *)„              (* processed.                                         *)„        until (loByteProc = loInSize);„„              (* Close the IN-file that has been copied.            *)„        close(fiIN);„„              (* Increment copy-counter by 1.                       *)„        inc(woCopyCount);„„              (* Let the user know that we've finished copying file.*)„        writeln(' ', PadR(stPathTemp, byDispWidth),' COPIED TO ---> ',„                stPathTo);„„      end     (* If (stPathTemp <> '') then...                      *)„„              (* Repeat... ...Until no more files are found.        *)„  until (stPathTemp = '');„„              (* Close the OUT-file.                                *)„  close(fiOUT);„„              (* Display the number of files copied.                *)„  if (woCopyCount = 0) then„    begin„      erase(fiOut);„      writeln(coCrLf, ' No matching files found ---> ', stPathFrom)„    end„  else„    writeln(coCrLf, ' ', woCopyCount, ' Files copied')„END.„„„                              20     11-02-9317:51ALL                      IAN LIN                  Simple File Copy         IMPORT              10     ﬁSë {„From: IAN LIN„To just copy files, use buffers on the heap. Just make an array type that's„almost 64k in size. Use as many of these as needed that can fit in RAM and„blockread the data in. After you blockread all you can, close the file if„it's been fully read in. If it hasn't then don't close the input file yet.„Next you open the output file and dump everything in each buffer with„blockwrite. If you're done now, close both files, otherwise keep reading„all you can at once from the input file and blockwriting it to the output„file. }„„type„ pbuf=^buf;„ buf=record„  n:pbuf;„  b:array [1..65530] of byte;„ end;„var„ buffer,bufp:pbuf;„ bufc:byte;„ outf,f:file;„begin„ bufp:=new(buffer);„ assign(f,'IT');„ reset(f,1);„ blockread(f,bufp^,sizeof(bufp^);„ assign(outf,'OTHER');„ rewrite(outf,1);„ blockwrite(outf,bufp^,sizeof(bufp^);„ close(f);„ close(outf);„end.„„This is just an example so don't expect it to be very useful. :)„„For text files, if you want to modify them, you may want to use linked„lists which point to a line at a time. Remove unwanted lines from the list,„and then write it to the output file.„                                  