SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00009         CHARACTER HANDLING                                                1      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Manipulating the VGA FontIMPORT              18     ﬁN/ {„DAVID DRZYZGA„„> Is there any way to create or use your own fonts in„> regular Text mode With Pascal?„„Here's a demo of a routine originally posted by Bernie P and revised by me:„}„„Program UpsideDown;„{-upsidedown and backwards Text aka redefining the Text mode font}„Var„  newCharset,„  oldCharset : Array[0..255,1..16] of Byte;„„Procedure getoldCharset;„Var„  b : Byte;„  w : Word;„begin„  For b := 0 to 255 do„  begin„    w := b * 32;„    Inline($FA);„    PortW[$3C4] := $0402;„    PortW[$3C4] := $0704;„    PortW[$3CE] := $0204;„    PortW[$3CE] := $0005;„    PortW[$3CE] := $0006;„    Move(Ptr($A000, w)^, oldCharset[b, 1], 16);„    PortW[$3C4] := $0302;„    PortW[$3C4] := $0304;„    PortW[$3CE] := $0004;„    PortW[$3CE] := $1005;„    PortW[$3CE] := $0E06;„    Inline($FB);„  end;„end;„„Procedure restoreoldCharset;„Var„  b : Byte;„  w : Word;„begin„  For b := 0 to 255 do„  begin„    w := b * 32;„    Inline($FA);„    PortW[$3C4] := $0402;„    PortW[$3C4] := $0704;„    PortW[$3CE] := $0204;„    PortW[$3CE] := $0005;„    PortW[$3CE] := $0006;„    Move(oldCharset[b, 1], Ptr($A000, w)^, 16);„    PortW[$3C4] := $0302;„    PortW[$3C4] := $0304;„    PortW[$3CE] := $0004;„    PortW[$3CE] := $1005;„    PortW[$3CE] := $0E06;„    Inline($FB);„  end;„end;„„Procedure setasciiChar(Charnum : Byte; Var data);„Var„  offset : Word;„begin„  offset := CharNum * 32;„  Inline($FA);„  PortW[$3C4] := $0402;„  PortW[$3C4] := $0704;„  PortW[$3CE] := $0204;„  PortW[$3CE] := $0005;„  PortW[$3CE] := $0006;„  Move(data, Ptr($A000, offset)^, 16);„  PortW[$3C4] := $0302;„  PortW[$3C4] := $0304;„  PortW[$3CE] := $0004;„  PortW[$3CE] := $1005;„  PortW[$3CE] := $0E06;„  Inline($FB);„end;„„Procedure newWriteln(s : String);„ {- Reverses order of Characters written}„Var„  b : Byte;„begin„  For b := length(s) downto 1 do„    Write(s[b]);„  Writeln;„end;„„Var„  b, c : Byte;„„begin„  getoldCharset;„  For b := 0 to 255 do„    For c := 1 to 16 do„      newCharset[b, c] := oldCharset[b, (17 - c)];„  For b := 0 to 255 do„    setasciiChar(b, newCharset[b, 1]);„  newWriteln('Hello World!');„  readln;„  restoreoldCharset;„end.„                                                              2      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Character Case           IMPORT              23     ﬁN]ù {„BO BendTSEN„„  Upper/lower changing of Strings are always a difficult problem,„  but as a person living in Denmark i must normally care about„  danish Characters, i know a lot of developers does not care about„  international Character and just use the normal UPCASE routines.„  I advise you to use these routines or make some that has the„  same effect, so we will not have any problems when searching for„  uppercased Strings.„„  Made available to everyone 1993 by Bo Bendtsen 2:231/111 +4542643827„„     Lowcase   Upper/high/capital letters„              í„     õ         ù„     Ü         è„     Ñ         é„     á         Ä„     Ç         ê„     î         ô„     §         •„     Å         ö„„}„„Function UpChar(Ch : Char) : Char;„{ Uppercase a Char }„begin„  If Ord(Ch) In [97..122] Then Ch := Chr(Ord(Ch) - 32)„  Else If Ord(Ch) > 90 Then„    If Ch='' Then Ch:='í'„    Else If Ch='õ' Then Ch:='ù' Else If Ch='Ü' Then Ch:='è'„    Else If Ch='Ñ' Then Ch:='é' Else If Ch='á' Then Ch:='Ä'„    Else If Ch='Ç' Then Ch:='ê' Else If Ch='î' Then Ch:='ô'„    Else If Ch='§' Then Ch:='•' Else If Ch='Å' Then Ch:='ö';„  UpChar:=Ch;„end;„„Function StUpCase(S : String) : String;„{ Uppercase a String }„Var„  SLen : Byte Absolute S;„  x    : Integer;„begin„  For x := 1 To SLen Do S[x]:=UpChar(S[x]);„  StUpCase := S;„end;„„Function LowChar(Ch : Char) : Char;„{ lowercase a Char }„begin„  If Ord(Ch) In [65..90] Then Ch := Chr(Ord(Ch) + 32)„  Else If Ord(Ch) > 122 Then„    If Ch='í' Then Ch := ' '„    Else If Ch='ù' Then Ch:='õ' Else If Ch='è' Then Ch:='Ü'„    Else If Ch='é' Then Ch:='Ñ' Else If Ch='Ä' Then Ch:='á'„    Else If Ch='ê' Then Ch:='Ç' Else If Ch='ô' Then Ch:='î'„    Else If Ch='•' Then Ch:='§' Else If Ch='ö' Then Ch:='Å';„  LowChar := Ch;„end;„„Function StLowCase(S : String) : String;„{ Lowercase a String }„Var„  SLen : Byte Absolute S;„  i    : Integer;„begin„  For i := 1 To SLen Do S[i]:=LowChar(S[i]);„  StLowCase := S;„end;„„Function StToggleCase(S : String) : String;„{ lower = upper and upper = lower }„Var„  SLen : Byte Absolute S;„  i    : Integer;„begin„  For i := 1 To SLen Do„  begin„    If Ord(S[i]) In [65..90] Then S[i] := Chr(Ord(S[i]) + 32)„    Else If Ord(S[i]) In [97..122] Then S[i] := Chr(Ord(S[i]) - 32)„    Else If Pos(S[i],'õÜÑáÇî§Å') <> 0 Then S[i]:=UpChar(S[i])„    Else If Pos(S[i],'íèùÄéôêö•')<> 0 Then S[i]:=LowChar(S[i]);„  end;„  StToggleCase := S;„end;„„Function StSmartCase(S : String) : String;„{ bO bEnDTSen will be converted into : Bo Bendtsen }„Var„  SLen : Byte Absolute S;„  i    : Integer;„begin„  s:=StLowCase(s);„  For i := 1 To SLen Do„  begin„    If i=1 Then S[1]:=UpChar(S[1])„    Else if S[i-1]=' ' Then S[i]:=UpChar(S[i])„    Else if (Ord(S[i-1]) In [32..64]) And (S[i-1]<>'''') Then„S[i]:=UpChar(S[i]);„  end;„  StSmartCase := S;„end;„                   3      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Switch Font Characters   IMPORT              27     ﬁNxÃ {„> How can I redefine the ASCII Chars. For example how can„> I make the ASCII code 65 become a "weird form" instead„> of an "A".„„You want it, you got it.  Here are the two Procedures you need, plus some„info. First, you need to make a data Type With an Array of [1..16] of Byte,„so the best idea would be this:  Make a Record as follows:„}„„Type„  CharRec = Record„    data : Array[1..16] of Byte;„  end;„„{ Now, make a Variable to contain the entire Character set. }„„Var„  CharSet : Array[0..255] of CharRec;„„{ Next, you'll need the two Procedures: }„„Procedure GetImageChar(chrVal : Byte; Var CharInfo);„Var„  offset : Word;„begin„  offset := chrVal * 32;„  Inline($FA);„  PortW[$3C4] := $0402;„  PortW[$3C4] := $0704;„  PortW[$3CE] := $0204;„  PortW[$3CE] := $0005;„  PortW[$3CE] := $0006;„  (* refer to following notes For info about the next line *)„  Move(Ptr($A000, offset)^, CharInfo, 16);„  PortW[$3C4] := $0302;„  PortW[$3C4] := $0304;„  PortW[$3CE] := $0004;„  PortW[$3CE] := $1005;„  PortW[$3CE] := $0E06;„  Inline($FB);„end;„„{„OK.  That's the Procedure to GET a Character bitmap, and store it in a„Variable.  So, if you use the Type and Var I defined at the top, do this:„„GetImageChar(65, CharSet[65]);„„This example will copy the bitmap from Character 65 (A) into the Record of 65,„so you'll have copied the bitmap For 'A'.  Now, you can edit the bitmap (I„wrote my own font editor) and Write it to memory With a second Procedure.„„Here's the tricky part.  I didn't Write the 2nd Procedure because it is„identical to the first *EXCEPT* For ONE line.  Copy the Procedure and change„it's name to SetImageChar, and change this line:„„Move(Ptr($A000, offset)^, CharInfo, 16);„„and make it read:„„Move(CharInfo, Ptr($A000, offset)^, 16);„„That's it!  Have fun!  TTYL.„}„„{„OK, 'data' is an Array [1..16] of Byte.  So, you just draw your Character on„Graph paper in binary, convert to decimal Bytes, put them in the Array, and„feed it into this Procedure.  'CharNum' is the ASCII value of the Character you„want to remap.  To make a Procedure that READS the bitmap instead of writing,„just change the line With 'Move(data, Ptr($A000, offset)^, 16)' and make it say„'Move(Ptr($A000, offset)^, data, 16);' and you will now be able to read bitmaps„from the Character set.  I'm running out of time, so I can't explain it very„well, but I hope this helps.  TTYL.„}„{„„  I ran that in a loop and after a While it screwed up the whole„  font - might just be my EGA card, but my opinion is that this„  method stinks...there are Registers For getting/setting the„  font; I found code from a Program called Display Font Editor„  (DFE).  DFE edits font Files, and it came With source to„   load these font Files. Following is a bit from setting„  the Registers to load a font (don't have getting a font)„„  r.ax := $1110;„  r.bh := 14;                   (* Bytes per Character *)„  r.bl := 0;                    (* load to block 0 *)„  r.cx := 256;                  (* 256 Characters *)„  r.dx := 0;                    (* start With Character 0 *)„  r.es := Seg(P^);              (* segment of table *)„  r.bp := Ofs(P^);              (* offset of the table *)„  intr($10, r);„„  With this, you can see, you can even do one Character at a„  time ( cx = 1, dx = ascii, P^ = Array[1..14] of Byte)„}                             4      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Read Screen CHARS        IMPORT              5      ﬁNúv {„Author: A A Olowofoyeku„„As For reading the ASCII stuff from the screen, I have a routine that„allows you to read a Character from any location on the screen.„}„„Uses„  Dos;„„{-- read the Character at the cursor and return it as a Char --}„Function ScreenChar : Char;„Var„  R : Registers;„begin„  FillChar(R, SizeOf(R), 0);„  R.AH := 8;„  R.BH := 0;„  Intr($10, R);„  ScreenChar := Chr(R.AL);„end;„                                                                                                                5      05-28-9313:33ALL                      SWAG SUPPORT TEAM        Redefine FONT Chars      IMPORT              22     ﬁN0 {„>> I know this can be done - in fact I've seen posts on it before, but it„>> didn't strike me as something to save at the time. . .„>  Does anyone know how to redefine the Characters used in Text mode?  I„>> don't want to use a whole new set; rather I'd like to change just about a„>> dozen or so Characters to my own.„„This is a little routine I developed sometime ago to redefine some of the„ascii Chars as 'smileys'. The Arrays of hex values are Character„bitmaps. There is a rather good article about doing this sort of thing in PC„Magazine,Volume 9 number 2 (Jan 30, 1990)„}„„Program Redefine;„„Uses„  Dos,Crt;„„Procedure loadChar;„Const„  numnewChars = 6;„Type„  ByteArray = Array[0..15] of Byte;„  CharArray = Array[1..numnewChars] of Record„    CharNum : Byte;„    CharData : ByteArray;„  end;„„Const newChars : CharArray = („   (CharNum : 21;„    CharData : ($00,$00,$E7,$A5,$E7,$00,$00,$08,$18,$38,$00,$00,$C3,$C3,$7E,$00)),„   (Charnum : 4;„    CharData : ($00,$00,$E7,$A5,$E7,$00,$00,$08,$18,$38,$00,$00,$7E,$C3,$C3,$00)),„   (Charnum : 19;„    CharData : ($AA,$AA,$FE,$00,$EE,$AA,$EE,$00,$08,$18,$38,$00,$C6,$C6,$7C,$00)),„   (Charnum : 17;„    CharData : ($03,$07,$FF,$00,$0E,$0A,$0E,$00,$00,$01,$03,$00,$08,$07,$00,$00)),„   (Charnum : 23;„    CharData : ($C0,$E0,$FF,$00,$E0,$A0,$E0,$00,$80,$80,$80,$10,$10,$E0,$00,$00)),„   (Charnum : 24;„    CharData : ($E7,$42,$00,$C3,$A5,$E7,$00,$08,$18,$38,$00,$00,$7E,$FF,$81,$00))„    );„„Var„  r : Registers;„  i : Byte;„„begin„for i := 1 to numnewChars do„  With r do„  begin„    ah := $11;             { video sub-Function $11 }„    al := $0;              { Load Chars to table }„    bh := $10;             { number of Bytes per Char }„    bl := 0;               { Character table to edit }„    cx := 1;               { number of Chars we're definig }„    dx := NewChars[i].CharNum;          { ascii value of the Char }„    es := seg(NewChars[i].CharData);    { es:bp --> table we're loading }„    bp := ofs(NewChars[i].CharData);„    intr($10,r);„  end;„end;„„begin„  loadChar;„  Writeln('Char(21) is now ',chr(21));Writeln;„  Writeln('Char(04) is now ',chr(04));Writeln;„  Writeln('Char(19) is now ',chr(19));Writeln;„  Writeln('Char(17) is now ',chr(17));Writeln;„  Writeln('Char(23) is now ',chr(23));Writeln;„  Writeln('Char(24) is now ',chr(24));Writeln;„  readln;„  Textmode(co80);„  Writeln('Char(21) is now ',chr(21));Writeln;„  Writeln('Char(04) is now ',chr(04));Writeln;„  Writeln('Char(19) is now ',chr(19));Writeln;„  Writeln('Char(17) is now ',chr(17));Writeln;„  Writeln('Char(23) is now ',chr(23));Writeln;„  Writeln('Char(24) is now ',chr(24));Writeln;„end.„                                                  6      11-26-9318:05ALL                      MICHAEL HOENIE           Change VGA/EGA/CGA Fonts IMPORT              27     ﬁN¿c {„From: MICHAEL HOENIE„Subj: CHARACTER UNIT.„----------------------------------------------------------------------„here is some revised code to allow users to change the standard ASCII„font in EGA or VGA. I don't know if it will work in standard CGA, but„it works well on VGA. }„„   unit graphics;„„   interface uses dos, crt;„„   const„     numnewchars=9; { # of chars available }„„     {1 2 4 8 1 3 6 1„      ≥ ≥ ≥ ≥ 6 2 4 2„      ≥ ≥ ≥ ≥ ≥ ≥ ≥ 8„      ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥     Character.„      1 2 3 4 5 6 7 8       8x16„     ⁄ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒø„    1≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=„    2≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       This is a BYTE mapper.„    3≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       Fill in the blanks, then add„    4≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       the numbers together on a calculator.„    5≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       The # should never be greater than 255.„    6≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=„    7≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       The #'s are as follows:„    8≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=„    9≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       1,2,4,8,16,32,64,128„   10≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=„   11≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       So if you had:„   12≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=„   13≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       X X X    X  X      X„   14≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=       1 2 4   16 32    128   = 183„   15≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=„   16≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥ ≥=„     ¿ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒŸ}„„     procedure loadchar; { this is the procedure to change the characters }„„   implementation„„     procedure loadchar;„     type„       bytearray=array[0..15] of byte;„       chararray=array[1..numnewchars] of record„         charnum:byte;„         chardata:bytearray;„       end;„     const { these are the characters outlined 9 = chr(9), 176 = chr(176) }„       newchars:chararray=(„         (charnum:9; chardata: (24,0,66,0,0,024,165,24,60,102,66,66,66,„                               102,60,0)),„         (charnum:10; chardata: (24,126,255,231,231,255,255,255,255,255,„                                191,255,255,255,255,255)),„         (charnum:24; chardata: (24,24,24,24,24,24,24,24,24,24,126,24,24,„                                24,60,24)),„         (charnum:231; chardata: (8,42,28,127,27,42,8,8,8,8,8,8,8,8,8,0)),„         (charnum:235; chardata: (0,0,102,60,24,24,24,60,60,126,126,126,„                                 60,24,0,0)),„         (charnum:239; chardata: (255,171,213,171,213,171,213,171,213,171,„                                 213,171,213,171,213,171)),„         (charnum:225; chardata: (24,60,102,102,102,60,24,24,24,24,120,120,„                                 24,120,120,0)),„         (charnum:176; chardata: (9,64,4,33,0,136,2,32,1,136,0,66,0,8,64,18)),„         (charnum:177; chardata: (119,119,119,0,238,238,238,0,119,119,119,0,„                                 238,238,238,0)));„„     var„       regs:registers;„       i:byte;„     begin„       for i:=1 to numnewchars do„         begin„           with regs do„             begin„               ah:=$11;  { video sub-Function $11 }„               al:=$0;   { Load Chars to table $1 }„               bh:=$10;  { number of Bytes per Char $10 }„               bl:=0;    { Character table to edit }„               cx:=1;    { number of Chars we're definig }„               dx:=newchars[i].charnum;„               es:=seg(newchars[i].chardata);„               bp:=ofs(newchars[i].chardata);„               intr($10,regs);„             end;„         end;„     end;„„   begin„   end.„                     7      11-26-9318:05ALL                      SEAN PALMER              Text Fonts in ASM        IMPORT              9      ﬁNè {„From: SEAN PALMER„Subj: Text Fonts in ASM„}„„Procedure SetAsciiChar(Charnum : Word; Var Data); Assembler;„ASM„   mov ah,11h„   mov al,10h„   mov bh,10h„   mov bl,0„   mov cx,1      {set 1 character only}„   mov dx,charnum     {what charnum to modify }„   mov bp,seg data   {seg of the char}„   mov es,bp„   mov bp,offset data  {ofs of the char}„   int 10h„End;„„{„This has been reputed to work. Although I didn't write it (Salim Samhara„I think is who did) and if I did I would have changed it to load ax and„bx as one unit instead of ah and al, then bh and bl. With this though„you have to have the buffer in the data segment, not on the stack.„„So here's how I would do it:„}„„Procedure LoadFont (FileName : String);„Type„ FontType=Array [char] of Array [0..15] of Byte;„Var„ F    : File of FontType;„ Font : FontType;„Begin„ Assign (F, FileName);„ Reset (F);„ Read (F,Font);„ Close (F);„ Asm„  mov ax,$1100„  mov bx,$1000„  mov cx,$0100„  xor dx,dx„  mov es,seg Font„  mov bp,offset Font„  Int $10„  end;„ End;„        8      11-26-9318:05ALL                      SWAG SUPPORT TEAM        Font Library for Text    IMPORT              38     ﬁNhÏ {„User font library for text mode.„}„„„{$IFDEF DPMI}„{$X+,S-}„{$ELSE}„{$X+,F+,O+}„{$ENDIF}„unit BBFont;„„interface„„const„  FontHeight = 16;   { 14 for EGA mode }„„type„  PCharShape = ^TCharShape;„  TCharShape = array[0..FontHeight-1] of byte;„„var„  points : word;„„„procedure ReplaceChar(c : char; NewChar : PCharShape);„„„implementation„„„{*******************************************************************}„{ Wen 03-mrt-1993 - wvl                                             }„{                                                                   }„{ Get font block index of current (resident) and alternate          }„{ character set. Up to two fonts can be active at the same time     }„{                                                                   }„{*******************************************************************}„„Type„  FontBlock    = 0..7;„„„Procedure GetFontBlock(Var primary, secondary : FontBlock); Assembler;„„ASM„  { Get character map select register:„    (VGA sequencer port 3C4h/3C5h index 3)„„    7  6  5  4  3  2  1  0„          3  3  3  3  3  3„          3  3  3  3  @DDADD   Primary font   (lower 2 bits)„          3  3  @DDADDDDDDDD   Secondary font (lower 2 bits)„          3  @DDDDDDDDDDDDDD   Primary font   (high bit)„          @DDDDDDDDDDDDDDDDD   Secondary font (high bit)     }„„        MOV     AL, 3„        MOV     DX, 3C4h„        OUT     DX, AL„        INC     DX„        IN      AL, DX„        MOV     BL, AL„        PUSH    AX„„  { Get secondary font number: add up bits 5, 3 and 2 }„„        SHR     AL, 1„        SHR     AL, 1„        AND     AL, 3„        TEST    BL, 00100000b„        JZ      @1„        ADD     AL, 4„@1:     LES     DI, secondary„        STOSB„„  { Get primary font number: add up bits 4, 1 and 0 }„„        POP     AX„        AND     AL, 3„        TEST    BL, 00010000b„        JZ      @2„        ADD     AL, 4„@2:     LES     DI, primary„        STOSB„end;  { GetFontBlock }„„„„function postinc(var w : word) : word;  assembler;„asm„  les  di,w„  mov  ax,word ptr es:[di]„  inc  word ptr es:[di]„end;„{* pascal code„begin„  postinc := w;„  inc(w);„end;„*}„„„procedure ReplaceChar(c : char; NewChar : PCharShape);„var„  i : integer;„  off : word;„  CharPos : word;„  primfont, secfont : FontBlock;„  base : word;„begin„„{* program the VGA controller *}„  asm„    pushf               { Disable interrupts }„    cli„    mov  dx, 03c4h      { Sequencer port address }„    mov  ax, 0704h      { Sequential addressing }„    out  dx, ax„    mov  dx, 03ceh      { Graphics Controller port address }„    mov  ax, 0204h      { Select map 2 for CPU reads }„    out  dx, ax„    mov  ax, 0005h      { Disable odd-even addressing }„    out  dx, ax„    mov  ax, 0406h      { Map starts at A000:0000 (64K mode) }„    out  dx, ax„    mov  dx, 03c4h      { Sequencer port address }„    mov  ax, 0402h      { CPU writes only to map 2 }„    out  dx, ax„  end;„„{ first get the current font *}„  GetFontBlock(primfont, secfont);„  base := 8192*primfont;„„  off := 16 - points;„„  CharPos := Ord(c) * 32;„„  for i := 0 to points-1 do  begin„    mem[SegA000:base+postinc(CharPos)] := NewChar^[postinc(off)];„  end;„„{ Ok, put the Sequencer and Graphics Controller back to normal }„„  asm„„  { Program the Sequencer }„    pushf               { Disable interrupts }„    cli„    mov dx, 3c4h        { Sequencer port address }„    mov ax, 0302h       { CPU writes to maps 0 and 1 }„    out dx, ax„    mov ax, 0304h       { Odd-even addressing }„    out dx, ax„„  { Program the Graphics Controller }„    mov dx, 3ceh        { Graphics Controller port address }„    mov ax, 0004h       { Select map 0 for CPU reads }„    out dx, ax„    mov ax, 1005h       { Enable odd-even addressing }„    out dx, ax;„    mov ax,Seg0040„    mov es,ax„    mov ax, 0e06h       { Map starts at B800:0000 }„    mov bl, 7„    cmp es:[49h], bl    { Get current video mode }„    jne @@notmono„    mov ax, 0806h       { Map starts at B000:0000 }„@@notmono:„    out dx, ax;„    popf;„  end;„end;„„„begin„  if (Mem[Seg0040:$0084] = 0)„   then  points := 8„   else  begin„     if Mem[Seg0040:$0084] in [42,49]„      then  points := 13„      else  points := Mem[Seg0040:$0085];„   end;„end.  { of unit BBFont }„„„„program Test;„„uses BBFont,...;„„procedure TestFont;„const„  NewA:TCharShape = („    $FF,  {11111111}„    $00,  {00000000}„    $FF,  {11111111}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00,  {00000000}„    $00   {00000000}„  );„begin„  ReplaceChar('A', @NewA);„end;„„„begin„  TestFont;„end.„„„                     9      11-26-9318:06ALL                      RICHARD WILTON           Reverse EGA/VGA Fonts    IMPORT              26     ﬁN program Reverse;„„{„  Sample program demonstrating manipulation of the VGA (EGA?)„  alphanumeric character set using the 80x25 character mode.„„  The only thing this program does is to copy the current character„  set from the video adapter, and restore it in such a way that all„  the characters appear upside-down.  To restore the characters,„  simply run the program again.  Not that this is a terribly useful„  thing to do, mind you...„„  NOTE: This has not been tested on monochrome monitors or in„        other video modes.„„  Written using Borland Pascal 7.0.„„  For more information on character sets for other video modes and„  a whole bunch of good stuff on the EGA & VGA in general, you will„  want the following book:„„   Title     - "Programmer's Guide to PC & PS/2 Video Systems"„   Author    - Richard Wilton, 1987„   Publisher - Microsoft Press„               16011 NE 36th Way„               Box 97017„               Redmond, Washington  98073-9717„}„„  var„    I, J: integer;„    CBuf: array [0..8191] of byte; { Buffer for original character map }„„„  procedure CharGenModeOn;„„  { I'm sorry that there is no explanation here, but I did this a while„    ago and I don't have the reference with me right now.   }„„    begin„      asm„        cli„        mov       dx,03C4h„        mov       ax,0100h„        out       dx,ax„        mov       ax,0402h„        out       dx,ax„        mov       ax,0704h„        out       dx,ax„        mov       ax,0300h„        out       dx,ax„        sti„        mov       dl,0CEh„        mov       ax,0204h„        out       dx,ax„        mov       ax,0005h„        out       dx,ax„        mov       ax,0006h„        out       dx,ax„     end;„   end;„„„  procedure CharGenModeOff;„„    begin„      asm„        cli„        mov       dx,03C4h„        mov       ax,0100h„        out       dx,ax„        mov       ax,0302h„        out       dx,ax„        mov       ax,0304h„        out       dx,ax„        mov       ax,0300h„        out       dx,ax„        sti„        mov       dl,0CEh„        mov       ax,0004h„        out       dx,ax„        mov       ax,1005h„        out       dx,ax„        mov       ax,0E06h„        out       dx,ax„        mov       ah,0Fh„        int       10h„        cmp       al,7„        jne       @skip„        mov       ax,0806h„        out       dx,ax„      @skip:„      end;„    end;„„„  begin„    CharGenModeOn;  { Get access to character map }„„    { Copy the current character map into the buffer }„    move( mem[$A000: 0], CBuf, 8192 );„„    { Restore the map, inverting the top 16 scan lines.„„      Characters are stored in a 8x32 pixel matrix, allowing„      for characters that are 32 scan lines high.  Each byte„      in the buffer represents one scan line of a single„      character.  In the 80x25 character mode only the first„      16 scan lines are displayed, so we need to be a little„      careful about what bytes are swapped. }„„    for I := 0 to 255 do                { Each of the 256 characters }„      for J := 0 to 15 do               { Top 16 scan lines of each }„        mem[$a000:((I*32) + J)] := CBuf[(I*32) + (15 - J)];„„    CharGenModeOff; { Restore normal video operations }„  end.„    