SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00006         PARSING/TOKENIZING ROUTINES                                       1      05-28-9313:54ALL                      SWAG SUPPORT TEAM        PARSENUM.PAS             IMPORT              55     Dõ} Type„   RW_toKEN = Record„      token_str :String[9];„      token_cod :toKEN_CODE;„   end;„„   RW_Type = Array[0..9] of RW_toKEN;„   RWT_PTR = ^RW_Type;„„Const„   NULL = '';„„   Rw_2  :RW_Type = ((token_str : 'do'; token_cod : tdo),„                     (token_str : 'if'; token_cod : tif),„                     (token_str : 'in'; token_cod : tin),„                     (token_str : 'of'; token_cod : tof),„                     (token_str : 'or'; token_cod : tor),„                     (token_str : 'to'; token_cod : tto),„                     (token_str : NULL; token_cod : NO_toKEN),„                     (token_str : NULL; token_cod : NO_toKEN),„                     (token_str : NULL; token_cod : NO_toKEN),„                     (token_str : NULL; token_cod : NO_toKEN)„                    );„„    ...the difference being the explicit declaration of the Constant„    Record fields. (I'm used to Array Constants, not Record„    Constants - I was unaware of the requirement)„„    PARSinG NUMBERS„„    Now we'll concentrate on parsing Integer and Real numbers.„„    The Pascal definition of a number begins With an UNSIGNED„    Integer. An unsigned Integer consists of one or more consecutive„    DIGITS. The simplest Form of a number token is an unsigned„    Integer:„„    1 9 120 12654„„    A number token can also be an unsigned Integer (the whole part)„    followed by a fraction part. A fraction part consists of a„    decimal point followed by an unsigned Integer, such as:„„    123.45 0.9987564„„    These numbers have whole parts 123 and 0 respectively, and„    fraction parts .45 and .9987564 respectively.„„    A number token can also be a whole part followed by an EXPONENT„    part. An exponent part consists of an "E" (or "e") followed by„    an unsigned Integer. An optional exponent sign, + or -, can„    appear between the letter and the first exponent digit.„    Examples:„„    134e2  2E99 123e-45 73623E+4„„    Finally, a number token can be a whole part followed by a„    fraction part and an exponent part, in that order:„„    2.3498E7 0.00034e-66„„    I arbitrarily limit the number of digits to 20, and the exponent„    value from -37 to +37 - the exact value necessary to limit this„    value is dependant on how Real values are represented on the„    Computer.„„    The "get_number" Function is likely to be the biggest Function„    in your scanner, but it should be relatively straighForward to„    code...in light of what has already been done With the scanner/„    tokenizer module, and the definition of a number.„„    EXERCISE #1„„    Write the get_number Function to parse Integers and Real„    numbers.„„    You will need to add the following Types and Variables to your„    global data segment:„„    Type  { add "Real"s to list... }„„    LITERAL_Type = (Integer_LIT, Real_LIT, String_LIT);„„    LITERAL_REC = Record„       Case lType:LITERAL_Type of„          Integer_LIT: (ivalue :Integer);„          Real_LIT   : (rvalue :Real   );„          String_LIT : (svalue :String );„    end;„„    Var„„    digit_count :Word;„    count_error :Boolean;„„--------------     PART 2     ---------------------------------------„„    The rest of this post will cover two simple topics - parsing„    Strings inside quotes, and parsing comments.„„    PARSinG COMMENTS {}„„    The Compiler should ignore the input between two curly braces„    ({}), and the curly braces themselves. My scanner is written so„    the entire comment is replace by a Single blank (" "), although„    you could possibly Write the scanner so that comments are„    _totally_ ignored.„„    EXERCISE #2:„„    Integrate COMMENT detection into the get_Char routine, so that„    when your Character fetching routine will ignore comments and„    pass a blank when a comment is encountered, skipping the comment„    entirely For the next fetch.„„    Make sure that the routine keeps reading Until the right curly„    brace is detected, even past the end-of-line. if the end-of-File„    is encountered beFore the right curly brace is found, an„    "unexpected end" error should be generated.„„    PARSinG StringS (QUOTES) ''„„    The quote Character delimits Strings, any Character between the„    Strings is ignored by the Compiler, except to stored as a String„    LITERAL. if you wish a ' (quote) to be included in the literal,„    and extra ' must precede it.„„    One possible tricky area is the {} (comment) Character. You must„    be careful not to inadvertently trigger the comment routine within„    the quote routine While reading a String, otherwise you will„    have a BUG.„„    EXERCISE #3:„„    Add a quote routine to the get_token routine within your module,„    to fetch Strings, as a LITERAL IDENTifIER when the QUOTE„    Character is detected.„„    The following mods to your Types are required:„„    Eof_Char = #$7F;„„Type„  Char_CODE  = (LETTER, DIGIT, QUOTE, SPECIAL, Eof_CODE);„„ {  The following code init's the Character maping table:  }„„Var„   ch :Byte;„begin„   For ch := 0 to 255 do„      Char_table[ch] := SPECIAL;„   For ch := ord('0') to ord('9') do„      Char_table[ch] := DIGIT;„„   For ch := ord('A') to ord('Z') do„      Char_table[ch] := LETTER;„   For ch := ord('a') to ord('z') do„      Char_table[ch] := LETTER;„„   Char_table[ord(Eof_Char)] := Eof_CODE;„„   Char_table[39] := QUOTE;„end;„„    ----------------------------------------------------------------„„    PLEASE, please let me know what you think about these posts,„    even if they're negative - I want to have some feedback on the„    difficulties, and whether or not people are having trouble„    following the material - I _can_ be more concise at the cost of„    being more verbose - if it's needed!„„    if you are having problems With your source code, and want me to„    do a detailed examination of your code, expecially if it's„    written in a language other than Pascal, send me email via the„    Internet - to avoid "carpet bombing" the conference with„    undesired material.„„„    NEXT POST:„„    Error codes, and putting your code to the test - our first„    utility (other than the lister) : a source Program Compactor„    (not cruncher).„„    FUTURE POSTS:„„    - Review and (hopefully) a status report from "students"„    - Symbol table„    - YA utility (cross - referencer)„    - YA utility (source Program CRUNCHer)„    - YA utility (source Program UNcruncher)„    - Parsing simple expressions„    - Utility : CALC, using infix-to-postfix conversions and stack„      ops.„    - Parsing statements„    - Utility: Pascal syntax checker part I„    - Parsing declarations (Var, Type, etc)„      incl's: much improved (and much more Complex) symbol table„    - Utility: Declarations analyzer.„    - Syntax Checker part II„    - Parsing Program, Procedure, and Function declarations„      (routines).„    - Syntax checker Part III„„    - Review and discussion?„                                                      2      05-28-9313:54ALL                      SWAG SUPPORT TEAM        PARSEWRD.PAS             IMPORT              33     Dñ/ Program PARSER;„„{The Object of this Program is to accept a sentence from the user then to break the„ sentence into its Component Words and to display each Word on a separate line.„}„„Uses Crt; {Required by Turbo Pascal}„„Const„  maxWord     = 15;„  maxsentence = 15;„  space       = CHR(32);„  first       = 1;„„Type„  Strng = Array[1..maxWord] of Char;„  Word  = Record„    body   : Strng;„    length : Integer„  end;„„Var„  sentence                 : Array[1..maxsentence] of Word;„  row, col, nextcol, count : Integer;„  demarker                 : Boolean;„  ans                      : Char;„„Procedure SpaceTrap;„{ Insures that there is ony 1 space between Words     }„begin„  Repeat„    READ(sentence[row].body[first])„  Until sentence[row].body[first] <> space„end;„„Procedure StringWrite(Var phrase : Word);„{Writes only the required length of each Character String.„This is required when using 32 col. mode.}„Var„  letter : Integer;„begin„         For letter := first to phrase.length do„           Write(phrase.body[letter])„       end; {Procedure StringWrite}„„     Procedure StringRead;„      Var I : Integer;„      begin„      {„       Intitialize the Variables„      }„        count    := 1;„        row      := first;„        col      := first;„        nextcol  := col + 1;„        demarker := False;„        For I := first to maxsentence do„            sentence[I].length := 1;„        Write('Type a sentence >  ');„        {READLN;} {Clears the buffer of EOLN}„                  {Required by HiSoft Pascal}„            While (not EOLN) and (row < maxsentence) do„                begin„                   READ(sentence[row].body[col]);„                   if sentence[row].body[first] = space then SpaceTrap;„                   if sentence[row].body[col] = space then„                      demarker := True;„                   if (not demarker) and (nextcol < maxWord) then„                       begin„                         col     := col + 1;„                         nextcol := nextcol + 1„                       end„                    else„                      begin„                        sentence[row].length := col;„                        count                := count + 1;„                        row                  := row + 1;„                        col                  := first;„                        nextcol              := col + 1;„                        demarker             := False„                      end; {if...then...else}„        if EOLN then sentence[row].length := col - 1„        {Accounts For the last Word entered less the EOLN marker.}„                end {While loop}„      end; {Procedure StringRead}„„     Procedure PrintItOut;„      Var„          subsequent : Integer;„      begin„          subsequent := first + 1;„          Write('Parsing > ');„          StringWrite(sentence[first]);„          WriteLN;„          if count >= subsequent then„              begin„                  For row := subsequent to count do„                      begin„                          Write('          ');„                          StringWrite(sentence[row]);„                          WriteLN„                      end„              end„       end; {Procedure PrintItOut}„„     Procedure SongandDance;„      begin„          {PAGE;} {HiSoft Pascal = Turbo Pascal ClrScr}„          ClrScr;„          WriteLN('           Parser');„          WriteLN;„          WriteLN('    Program By David Solly');„          WriteLN;„          WriteLN('   The Object of this Program');„          WriteLN('is to accept a sentence from');„          WriteLN('the user then to break the');„          WriteLN('sentence down into its');„          WriteLN('Component Words and to display');„          WriteLN('each Word on a seperate line.');„          WriteLN;„          WriteLN;„      end; {Procedure SongandDance}„„     begin {Main Program}„     SongandDance;„     StringRead;„     WriteLN;„     PrintItOut;„     WriteLN;„     WriteLN('end of Demonstration.');„     READLN(ans);„     end. {Main Program}„                                                                     3      08-17-9308:50ALL                      RYAN THOMPSON            Command Line Parsing     IMPORT              37     DQc ===========================================================================„ BBS: Canada Remote Systems„Date: 08-10-93 (01:00)             Number: 33744„From: RYAN THOMPSON                Refer#: NONE„  To: TERRY GRANT @ 912/701         Recvd: NO  „Subj: RE: COMMAND LINE PARSING       Conf: (1221) F-PASCAL„---------------------------------------------------------------------------„>>> Quoting message from Terry Grant @ 912/701 to All„>>> Original sent 07 Aug 93  20:36:00 about Command Line Parsing„„TG> Hello All!„TG>„TG>  After working on this for awhile, I thought mabe someone else could help„TG> me out a little here. All I need this to do is Parse the command line for„TG> seven parameters,„TG>„TG> The BaudRate     (/B),„TG> :„TG> and Overlay Size (/O).„TG>„TG>  My Main problem here is, it will SEE the command line, But WILL NOT allow„TG> me to use anything AFTER the Switch ? Like /B2400 !„„  Sure thing!  I once wrote a unit which among other things has some neat„parsing for the command line.  Here's a snippet:„„{- Top -}„„  Function SwitchNum(S : String) : Integer;„           { If a switch character specified exists, return which position }„           { it is in on the command line.  Used internally. }„    Var„      Temp : String;„      X,„      Y : Integer;„    Begin„      Temp:= '';„      X:= ParamCount;„      Y:= 0;„      while (X > 0) and (Y = 0) do begin„        Temp:= ParamStr(X);„        if (Temp[1] = '/') or (Temp[1] = '-') then„          if UpCase(Temp[2]) = UpString(S) then Y:= X;„        Dec(X);„      end;„      SwitchNum:= Y;„    End;„„„  Function SwitchThere(S : String) : Boolean;„           { Returns TRUE if a switch of the character specified exists. }„    Begin„      If SwitchNum(S) = 0 then SwitchThere:= False„      else SwitchThere:= True;„    End;„„„  Function SwitchData(S : String) : String;„           { Return the data following a switch: /B2400 returns 2400. }„    Var„      Temp : String;„    Begin„      If SwitchNum(S) > 0 then begin„        Temp:= ParamStr(SwitchNum(S));„        Delete(Temp, 1, 2);„      end„      else Temp:= '';„      SwitchData:= Temp;„    End;„„„  Function Parameter(N : Byte) : String;„           { Returns the Nth command line parameter.  Parameters in quotes }„           { are returned with the spaces in between:  /D Test "One Two" }„           { Returns >Test< for Parameter(1) and >"One Two< for Parameter(2) }„           { This allows you to, if you like, see what type of quote was }„           { used, for perhaps literal vs. translate to ALL CAPS. }„    Var„      X,„      Count : Byte;„      Parm,„      Temp : String;„    Begin„      X:= 0;„      Count:= 0;„      Parm:= '';„      If ParamCount > 0 then repeat„        Inc(X);„        Temp:= ParamStr(X);„        If (Temp[1] = '"') or (Temp[1] = '''') then begin„          Parm:= Temp;„          If X < ParamCount then repeat„            Inc(X);„            Parm:= Parm + ' ' + ParamStr(X);„          until (Parm[Length(Parm)] = '"') or„                (Parm[Length(Parm)] = '''') or (X = ParamCount);„          Inc(Count);„        end„        else if (Temp[1] <> '/') and (Temp[1] <> '-')„        then begin„          Inc(Count);„          Parm:= Temp;„        end;„      until (X = ParamCount) or (Count = N);„      If Count = N then Parameter:= Parm„      else Parameter:= '';„    End;„„„  Function Parameters : Byte;„           { Return the number of non-switch parameters on the command line. }„    Var„      X : Byte;„    Begin„      X:= 0;„      If ParamCount > 0 then begin„        Repeat„          Inc(X)„        Until Parameter(X) = '';„        Parameters:= X - 1;„      end„      else Parameters:= 0;„    End;„„{- Fin -}„„  A few examples:„„  If SwitchThere('?') then DisplayHelp;„  If SwitchThere('B') then BaudString:= SwitchData('B');„  If Parameters < 1 then begin WriteLn('Too few parms'); Halt; end;„  For X:= 1 to Parameters do„  begin„    Param[X]:= Parameter(X);„  end;„„  Sample command lines:„„  TESTPROG /D /F TEST /B2400 "This is a test" /M-„„  Parameters returns 2,„  Parameter(1) returns TEST„  Parameter(2) returns "This is a test„  SwitchThere('L') returns False„  SwitchData('M') returns -„  SwitchData('G') returns null.„„  I hope this helps you out!  It could be optimized a lot by simply reading„all of the parameters into an array in your initialization code, to eliminate„all of the redundant parsing, but I don't think that parsing time for a few„hundred characters at most is a limiting factor of any sort.  ;-)„„bye„Ryan„„--- Renegade v07-17 Beta„                                                                               4      09-26-9309:12ALL                      MARTIN RICHARDSON        Check for CmdLine switch IMPORT              7      D"s {*****************************************************************************„ * Function ...... IsSwitch()„ * Purpose ....... To test for the presence of a switch on the command line„ * Parameters .... sSwitch     Switch to scan the command line for„ * Returns ....... .T. if the switch was found„ * Notes ......... Uses functions Command and UpperCase„ * Author ........ Martin Richardson„ * Date .......... September 28, 1992„ *****************************************************************************}„FUNCTION IsSwitch( sSwitch: STRING ): BOOLEAN;„BEGIN„     IsSwitch := (POS( '/'+sSwitch, UpperCase(Command) ) <> 0) OR„                 (POS( '-'+sSwitch, UpperCase(Command) ) <> 0);„END;„                                                                      5      09-26-9309:22ALL                      MARTIN RICHARDSON        Parse out tokens         IMPORT              16     DY› {*****************************************************************************„ * Function ...... ParseCount()„ * Purpose ....... To count the number of tokens in a string„ * Parameters .... cString      String to count tokens in„ *                 cChar        Token separator„ * Returns ....... Number of tokens in <cString>„ * Notes ......... Uses function StripChar„ * Author ........ Martin Richardson„ * Date .......... September 30, 1992„ *****************************************************************************}„FUNCTION ParseCount( cString: STRING; cChar: CHAR ): INTEGER;„BEGIN„     ParseCount := LENGTH(cString) - LENGTH(StripChar(cString, cChar)) + 1;„END;„„{*****************************************************************************„ * Function ...... Parse()„ * Purpose ....... To parse out tokens from a string„ * Parameters .... cString      String to parse„ *                 nIndex       Token number to return„ *                 cChar        Token separator„ * Returns ....... Token <nIndex> extracted from <cString>„ * Notes ......... If <nIndex> is greater than the number of tokens in„ *                 <cString> then a null string is returned.„ *               . Uses function Left, Right, and ParseCount„ * Author ........ Martin Richardson„ * Date .......... September 30, 1992„ *****************************************************************************}„FUNCTION Parse( cString: STRING; nIndex: INTEGER; cChar: CHAR ): STRING;„VAR „   i: INTEGER;„   cResult: STRING;„BEGIN„     IF nIndex > ParseCount( cString, cChar ) THEN„        cResult := ''„     ELSE BEGIN„          cString := cString + cChar;„          FOR i := 1 TO nIndex DO BEGIN„              cResult := Left( cString, POS( cChar, cString ) - 1 );„              cString := Right(cString, LENGTH(cString) - POS(cChar, cString));„          END { Next I };„     END { IF };„     Parse := cResult;„END;„„                     6      10-28-9311:35ALL                      RYAN THOMPSON            Command Line Parsing     IMPORT              31     DåÎ {===========================================================================„ BBS: Canada Remote Systems„From: RYAN THOMPSON„Subj: RE: COMMAND LINE PARSING„„>>> Quoting from Chet Kress to Frans Van Duinen about Command Line Parsing„„CK>  FVD>I want to pass to my BP 7 program a few parameters, one of which„CK>  FVD>has embedded (or even trailing) blanks.  The naive approach of„CK>  FVD>PROCFAX  PROCFAX.CFG \PCB\MAIN\MSGS58  "FAX MAIL" does not work.„CK>  FVD>Currently  I pick up FAX and MAIL as two parameters and„CK>  FVD>string, but I want to allow multiple embedded/trailing blanks.„„  Here's a set of routines to do just what you want.„„  Parameters      Returns the number of parameters on the command line.  Does„                   not include switches.„  Parameter(n)    Returns the nth parameter, ignoring switches and passing„                   strings in quotes as " or ' followed by the entire string„                   including any imbedded spaces.„  SwitchThere(x)  Returns True if the switch specified by the character„                   passed is present on the command line.„  SwitchData(x)   Returns the data following the switch character if the„                   switch character specified is present on the command line.„  SwitchNum(x)    Returns the position on the command line of the switch„                   specified.  Skips parameters. }„„„  Function SwitchNum(S : String) : Integer;„    Var„      Temp : String;„      X,„      Y : Integer;„    Begin„      Temp:= '';„      X:= ParamCount;„      Y:= 0;„      while (X > 0) and (Y = 0) do begin„        Temp:= ParamStr(X);„        if (Temp[1] = '/') or (Temp[1] = '-') then„          if UpCase(Temp[2]) = UpString(S) then Y:= X;„        Dec(X);„      end;„      SwitchNum:= Y;„    End;„„„  Function SwitchThere(S : String) : Boolean;„    Begin„      SwitchThere:= not (SwitchNum(S) = 0);„    End;„„„  Function SwitchData(S : String) : String;„    Var„      Temp : String;„    Begin„      If SwitchNum(S) > 0 then begin„        Temp:= ParamStr(SwitchNum(S));„        Delete(Temp, 1, 2);„      end„      else Temp:= '';„      SwitchData:= Temp;„    End;„„„  Function Parameter(N : Byte) : String;„    Var„      X,„      Count : Byte;„      Parm,„      Temp : String;„    Begin„      X:= 0;„      Count:= 0;„      Parm:= '';„      If ParamCount > 0 then repeat„        Inc(X);„        Temp:= ParamStr(X);„        If (Temp[1] = '"') or (Temp[1] = '''') then begin„          Parm:= Temp;„          If X < ParamCount then repeat„            Inc(X);„            Parm:= Parm + ' ' + ParamStr(X);„          until (Parm[Length(Parm)] = '"') or„                (Parm[Length(Parm)] = '''') or (X = ParamCount);„          Inc(Count);„        end„        else if (Temp[1] <> '/') and (Temp[1] <> '-')„        then begin„          Inc(Count);„          Parm:= Temp;„        end;„      until (X = ParamCount) or (Count = N);„      If Count = N then Parameter:= Parm„      else Parameter:= '';„    End;„„„  Function Parameters : Byte;„    Var„      X : Byte;„    Begin„      X:= 0;„      If ParamCount > 0 then begin„        Repeat„          Inc(X)„        Until Parameter(X) = '';„        Parameters:= X - 1;„      end„      else Parameters:= 0;„    End;„„{„  For example, the command line:„„TESTPRG /C INPUT.DAT /X67 "first one"„„        Parameters  returns  2„      Parameter(1)  returns  INPUT.DAT„      Parameter(2)  returns  "first one„  SwitchThere('F')  returns  false„   SwitchData('X')  returns  67„„  Notice that in quoted parameters, the first quote is returned- this allows„you to check for " vs. ', which you could use as the difference between case„sensitive and non-case-sensitive.  A simple Delete(S,1,1) can remove it from„the string for use. }„                                                                                                               