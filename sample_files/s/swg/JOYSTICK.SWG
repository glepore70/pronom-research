SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00012         JOYSTICK ROUTINES                                                 1      05-28-9313:49ALL                      SWAG SUPPORT TEAM        JOYSTCK1.PAS             IMPORT              22     …†¶ Unit Joystick;„Interface„ Uses Crt;„„ { Joystick Interface For Turbo Pascal V. 4.0 and above„   Public Domain, November 1989 by„   JonSoft Technologies Inc.„   (C) 1989 JonSoft Technologies Inc. }„„Const„ centX : Byte=80;„ centY : Byte=40;„ Joyst : Boolean=True;„„Procedure FastInitJS;„Procedure BetterInitJS( range : Byte );„Function joy_X : Byte;„Function joy_Y : Byte;„Function button_1 : Byte;„Function button_2 : Byte;„Function Horiz : shortint;„Function Vert : shortint;„„„Implementation„„Const„ rangexm : Byte=25;„ rangeym : Byte=20;„ rangexp : Byte=25;„ rangeyp : Byte=25;„„Function joy_X : Byte;„  Var„    x : Word;„  begin„    x := 0;„    Port[$201] := $ff;„    While Port[$201] and $1=1 do Inc(x);„    joy_X := x;„  end;„„Function joy_Y : Byte;„  Var„    y : Word;„  begin„    y := 0;„    Port[$201] := $0;„    While Port[$201] and $2=2 do Inc(y);„    joy_Y := y;„  end;„„Procedure FastInitJs;„  begin„    centX := joy_X;„    centY := joy_Y;„  end;„„Function button_1 : Byte;„  begin„    button_1 := ((Port[$201] and $10) Xor $10) ShR 4;„  end;„„Function button_2 : Byte;„  begin„    button_2 := ((Port[$201] and $20) Xor $20) ShR 5;„  end;„„Procedure BetterInitJs(range : Byte);„  Var„(*    Ch : Char; *)„    uprjoyX, uprjoyY, centrjoyX, centrjoyY, lowrjoyX, lowrjoyY : Byte;„„begin„ WriteLN('Are you using a joystick? (Button = yes, RETURN = no)');„ Repeat„  if button_1+button_2 > 0 then Joyst := True;„  if KeyPressed then Joyst := False;„ Until (button_1+button_2 > 0) or KeyPressed;„ if Joyst = True then begin„  Repeat Until button_1+button_2 = 0;„  WriteLN('Move joystick to UPPER RIGHT corner and press a button.');„  Repeat Until button_1+button_2 > 0;„  uprjoyX := joy_X;„  uprjoyY := joy_Y;„  Repeat Until button_1+button_2 = 0;„  WriteLN('Move joystick to CENTER and press a button.');„  Repeat Until button_1+button_2 > 0;„  centrjoyX := joy_X;„  centrjoyY := joy_Y;„  centX := centrjoyX;„  centY := centrjoyY;„  Repeat Until button_1+button_2 = 0;„  WriteLN('Move joystick to LOWER LEFT CorNER and press a button.');„  Repeat Until button_1+button_2 > 0;„  lowrjoyX := joy_X;„  lowrjoyY := joy_Y;„  rangexm := (centrjoyX-uprjoyX) div range;„  rangexp := (lowrjoyX-centrjoyX) div range;„  rangeym := (centrjoyY-uprjoyY) div range;„  rangeyp := (lowrjoyY-centrjoyY) div range;„ end;„end;„„Function Horiz : shortint;„  begin„    if joy_X<centX-rangexm then Horiz := -1„    else if joy_X > centX+rangexp then Horiz := 1„    else Horiz := 0;„  end;„„Function Vert : shortint;„  begin„    if joy_Y<centY-rangeym then Vert := -1„    else if joy_Y > centY+rangeyp then Vert := 1„    else Vert := 0;„  end;„„end.„                                                          2      05-28-9313:49ALL                      SWAG SUPPORT TEAM        JOYSTCK2.PAS             IMPORT              30     …._ {„Anyone know how to read the Joystick.... I only need Joy(1) read....„I have used 1 Procedure i d/led, but all it did was tell me if the buttons„were down (it didnt work in telling me which direction (it should of))„}„Program JOYSTICK;„„Uses Crt, Dos;„„(*„WRITTEN BY JAMES P. MCADAMS - 25 DECEMBER 1984„„Program DEMONSTRATinG THE USE of TURBO PASCAL to ACCESS THE„IBM-PC GAME CONTROL ADAPTER. THE TWO Function CALLS ARE EACH„CompLETE in ITSELF. EITHER ONE or BOTH CAN BE MOVED to ANY„Program THAT NEEDS THE USE of JOYSTICKS or PADDLES.„*)„„„„Var„I: Integer;„TEMP: Byte;„„„   Function BUTtoN_PRESSED (WHICH_ONE: Char): Boolean;„   (* RETURN True if THE BUTtoN IS PRESSED *)„   Const„      JOYPorT = $201; (* LOCATION of THE GAME PorT *)„   Var„      MASK: Byte;„   begin„   if not (WHICH_ONE in ['A'..'D']) then WHICH_ONE := 'A';„   Case WHICH_ONE of„      'A': MASK := 16;„      'B': MASK := 32;„      'C': MASK := 64;„      'D': MASK := 128;„      end;„   BUTtoN_PRESSED := (PorT [JOYPorT] and MASK) = 0;„   end; (* BUTtoN_PRESSED *)„„„   Function JOYSTICK_POS (WHICH_ONE: Char): Integer;„   (*„   With A KRAFT JOYSTICK, VALUES RETURNED ARE in THE RANGE 4 to ABOUT„   140. if YOUR MACHinE RUNS FASTER THAN A STandARD IBM-PC or if YOU„   MODifY YOUR GAME ADAPTER CARD With BIGGER CAPACItoRS, YOU WILL„   GET LARGER COUNTS and YOU MUST MODifY "MAXCOUNT".„„   CALLinG A JOYSTICK THAT IS not in USE or ONE THAT HAS GONE„   OVER-RANGE (COUNT REACHED MAXCOUNT) YIELDS A VALUE of 0.„   *)„   Const„      MAXCOUNT =  2000; (* MODifY THIS if YOU CAN GET LONGER COUNTS     *)„      JOYPorT  = $201; (* For inForMATION ONLY: LOC of GAME inPUT PorT *)„   Var„      COUNTER: Integer;„      MASK: Byte;„   begin„   if not (WHICH_ONE in ['A'..'D']) then WHICH_ONE := 'A';„   Case WHICH_ONE of„      'A': MASK := 1;„      'B': MASK := 2;„      'C': MASK := 4;„      'D': MASK := 8;„      end;„   (*„   THIS ASSEMBLY CODE CAUses THE CX REGISTER to COUNT doWN FROM "MAXCOUNT"„   toWARD ZERO. WHEN CX REACHES ZERO or WHEN THE ONE-SHOT ON THE GAME„   ADAPTER TIMES OUT, THE LOOPinG StoPS and "COUNTER" IS ASSIGNED THE NUMBER„   of COUNTS THAT toOK PLACE. MAXCOUNT SHOULD BE CHOSEN SO THAT CX NEVER„   REACHES 0 SO THAT THE USABLE RANGE of THE JOYSTICK WILL not BE LIMITED.„   *)„   Inline („      $B9/MAXCOUNT/       (*       MOV CX,MAXCOUNT inITIALIZE doWN-COUNTER *)„      $BA/JOYPorT/        (*       MOV DX,JOYPorT  PorT ADDR of JOYSTICKS  *)„      $8A/$A6/MASK/       (*       MOV AH,MASK[BP] MASK For DESIRED 1-SHOT *)„      $EE/                (*       OUT DX,AL       START THE ONE-SHOTS     *)„      $EC/                (* READ: in  AL,DX       READ THE ONESHOTS       *)„      $84/$C4/            (*      TEST AL,AH       CHECK DESIRED ONE-SHOT  *)„      $E0/$FB/            (*    LOOPNZ READ        Repeat Until TIMED OUT  *)„      $89/$8E/COUNTER);   (*       MOV COUNTER[BP],CX  THIS MAKES CX AVAIL-*)„                          (*                           ABLE to TURBO       *)„   if COUNTER = 0„      then JOYSTICK_POS := 0 (* OVER-RANGE or not in USE *)„      else JOYSTICK_POS := MAXCOUNT - COUNTER;„   end; (* JOYSTICK_POS *)„„„begin    (***** DEMO Program - MAin CODE *****)„ClrScr;„GotoXY (1, 2);„WriteLN ('JOYSTICKS':10, 'BUTtoNS':10);„Write   ('A':5, 'B':5, 'A':5, 'B':5);„„While True do (* PRESS CTRL C to StoP THE Program *)„   begin„   GotoXY (1, 5);„   Write (JOYSTICK_POS ('A'):5, JOYSTICK_POS ('B'):5);„   if BUTtoN_PRESSED ('A')„      then Write ('PRES':5)„      else Write ('UP':5);„   if BUTtoN_PRESSED ('B')„      then Write ('PRES':5)„      else Write ('UP':5);„   end;„end.„                                                                                                                         3      05-28-9313:49ALL                      SWAG SUPPORT TEAM        JOYSTCK3.PAS             IMPORT              42     …8æ {„to whomever sent me a message concerning joystick support, I apologize that I„cannot send this message to you directly (message Pointers were screwed up on m„end, and I lost your message), but here is both my source For a Unit and a„sample Program.  First I'd like to say that my Unit may be somewhat inComplete.„have only a Single joystick port, so reading of two ports is impossible.  For„this reason, I'd like to ask any and all to make suggestions, and modifications„so that I, and all Programmers, may have a Complete Unit.  Also, remarks have„not been added to the Program, if an explanation is needed, please feel free to„ask...I'd be more than happy to give explanations For my work.  Anyhows, here i„is...„}„Unit Joystick;„„Interface„„Function JoystickExists : Boolean;„Function JoystickPosX : Integer;„Function JoystickPosY : Integer;„Function JoystickButtonA : Boolean;„Function JoystickButtonB : Boolean;„„Implementation„„Uses Crt, Dos;„„Const GamePortAddr = $200;„     MaxCount = 500;„„Function JoystickStatus (Mask : Byte) : Integer;„Var Counter : Integer;„Label Read;„begin„  Asm„  mov cx,MaxCount„  mov dx,GamePortAddr„  mov ah,Mask„  out dx,al„  read:„     in al,dx„     test al,ah„     loopnz read„  mov counter,cx„  end;„  JoystickStatus := MaxCount - Counter;„  Delay (2);„end;„„Function JoystickPosX : Integer;„begin„  JoystickPosX := JoystickStatus (1);„end;„„Function JoystickPosY : Integer;„begin„  JoystickPosY := JoystickStatus (2);„end;„„Function JoystickButtonA : Boolean;„begin„  JoystickButtonA := (Port [GamePortAddr] and 16) = 0;„end;„„Function JoystickButtonB : Boolean;„begin„  JoystickButtonB := (Port [GamePortAddr] and 32) = 0;„end;„„Function JoystickExists : Boolean;„Var Regs : Registers;„begin„  JoystickExists := not ((JoystickPosX = 0) and (JoystickPosY = 0));„end;„„end.„„„Program JoyTest;„„Uses Crt, Dos, AniVGA, Joystick;„„Var XMin, XMax, YMin, YMax,„   XRange, YRange,„   X, Y,„   PosX, PosY,„   Bullet1X, Bullet1Y,„   Bullet2X, Bullet2Y : Integer;„   Shooting1, Shooting2 : Boolean;„   ShootNext : Boolean;„„Procedure CalibrateJoystick (Var XMin, XMax, YMin, YMax : Integer);„begin„  Write ('Press joystick to upper left corner and press button one...');„  Repeat Until JoystickButtonA;„  XMin := JoystickPosX;„  YMin := JoystickPosY;„  Writeln ('OK.');„  Repeat Until not JoystickButtonA;„  Write ('Press joystick to lower right corner and press button two...');„  Repeat Until JoystickButtonB;„  XMax := JoystickPosX;„  YMax := JoystickPosY;„  Writeln ('OK.');„  Repeat Until not JoystickButtonB;„end;„„Procedure AnimateShip;„begin„  X := JoystickPosX - XMin;„  if (X <= XRange div 3) then„     Dec (PosX, 3)„  else if (X > XRange * 2 div 3) then„     Inc (PosX, 3);„  Y := JoystickPosY - YMin;„  if (Y <= YRange div 3) then„     Dec (PosY, 3)„  else if (Y > YRange * 2 div 3) then„     Inc (PosY, 3);„  SpriteX [0] := PosX;„  SpriteY [0] := PosY;„end;„„Procedure AnimateBullets;„begin„  if Shooting1 then„     if (Bullet1Y < 0) then„        Shooting1 := False„     else„        Dec (Bullet1Y, 8)„  else„     begin„        Bullet1X := PosX + 3;„        Bullet1Y := PosY + 14;„     end;„  if Shooting2 then„     if (Bullet2Y < 0) then„        Shooting2 := False„    else„        Dec (Bullet2Y, 8)„  else„     begin„        Bullet2X := PosX + 30;„        Bullet2Y := PosY + 14;„     end;„  SpriteX [1] := Bullet1X;„  SpriteY [1] := Bullet1Y;„  SpriteX [2] := Bullet2X;„  SpriteY [2] := Bullet2Y;„end;„„begin„  if JoystickExists and (LoadSprite ('SHIP1.COD', 1) = 1) and„     (LoadSprite ('BULLET.COD', 2) = 1) then„     begin„        ClrScr;„        CalibrateJoystick (XMin, XMax, YMin, YMax);„        ClrScr;„        InitGraph;„        SpriteN [0] := 1;„        SpriteN [1] := 2;„        SpriteN [2] := 2;„        PosX := 160;„        PosY := 160;„        Shooting1 := False;„        XRange := XMax - XMin;„        YRange := YMax - YMin;„        ShootNext := Boolean (0);„        While not (JoystickButtonA and JoystickButtonB) do„           begin„              if JoystickButtonA and not JoystickButtonB then„                 if not Shooting1 and ShootNext then„                    begin„                       Bullet1X := PosX + 3;„                       Bullet1Y := PosY + 14;„                       Shooting1 := True;„                       ShootNext := False;„                    end„                 else if not Shooting2 and not ShootNext then„                    begin„                       Bullet2X := PosX + 30;„                       Bullet2Y := PosY + 14;„                       Shooting2 := True;„                       ShootNext := True;„                    end;„              While JoystickButtonA do„                 begin„                    AnimateShip;„                    AnimateBullets;„                    Animate;„                 end;„              AnimateShip;„              AnimateBullets;„              Animate;„           end;„        CloseRoutines;„     end„  else„     Writeln ('Game card not installed.');„end.„{„I apologize For giving you an example that Uses another Unit.  if need be, this„Program can be easily modified to provide a successful example.  Hope this„helps, and I hope my Programming is not toO bad.„}                                                4      05-28-9313:49ALL                      SWAG SUPPORT TEAM        JOYSTCK4.PAS             IMPORT              5      …$ „Anyone know how to read the Joystick....„„if you are using an AT (286 or later), here's the easy way.„Use Intr ($15, Regs), and load AH With the $84, then load„DX With 1 to get the joystick status' and 0 to get the„button status.  if you use DX=1, it returns:„„AX x of joystick A„BX y of joystick A„CX x of joystick B„DX y of joystick B„„if you use DX=0:„„AL button status, bit #„   4 joystick A,button 1„   5 joystick A,button 2„   6 joystick B,button 1„   7 joystick B,button 2„                               5      05-28-9313:49ALL                      SWAG SUPPORT TEAM        JOYSTCK5.PAS             IMPORT              42     …8æ {„to whomever sent me a message concerning joystick support, I apologize that I„cannot send this message to you directly (message Pointers were screwed up on m„end, and I lost your message), but here is both my source For a Unit and a„sample Program.  First I'd like to say that my Unit may be somewhat inComplete.„have only a Single joystick port, so reading of two ports is impossible.  For„this reason, I'd like to ask any and all to make suggestions, and modifications„so that I, and all Programmers, may have a Complete Unit.  Also, remarks have„not been added to the Program, if an explanation is needed, please feel free to„ask...I'd be more than happy to give explanations For my work.  Anyhows, here i„is...„}„„Unit Joystick;„„Interface„„Function JoystickExists : Boolean;„Function JoystickPosX : Integer;„Function JoystickPosY : Integer;„Function JoystickButtonA : Boolean;„Function JoystickButtonB : Boolean;„„Implementation„„Uses Crt, Dos;„„Const GamePortAddr = $200;„     MaxCount = 500;„„Function JoystickStatus (Mask : Byte) : Integer;„Var Counter : Integer;„Label Read;„begin„  Asm„  mov cx,MaxCount„  mov dx,GamePortAddr„  mov ah,Mask„  out dx,al„  read:„     in al,dx„     test al,ah„     loopnz read„  mov counter,cx„  end;„  JoystickStatus := MaxCount - Counter;„  Delay (2);„end;„„Function JoystickPosX : Integer;„begin„  JoystickPosX := JoystickStatus (1);„end;„„Function JoystickPosY : Integer;„begin„  JoystickPosY := JoystickStatus (2);„end;„„Function JoystickButtonA : Boolean;„begin„  JoystickButtonA := (Port [GamePortAddr] and 16) = 0;„end;„„Function JoystickButtonB : Boolean;„begin„  JoystickButtonB := (Port [GamePortAddr] and 32) = 0;„end;„„Function JoystickExists : Boolean;„Var Regs : Registers;„begin„  JoystickExists := not ((JoystickPosX = 0) and (JoystickPosY = 0));„end;„„end.„„„{„„Program JoyTest;„„Uses Crt, Dos, AniVGA, Joystick;„„Var XMin, XMax, YMin, YMax,„   XRange, YRange,„   X, Y,„   PosX, PosY,„   Bullet1X, Bullet1Y,„   Bullet2X, Bullet2Y : Integer;„   Shooting1, Shooting2 : Boolean;„   ShootNext : Boolean;„„Procedure CalibrateJoystick (Var XMin, XMax, YMin, YMax : Integer);„begin„  Write ('Press joystick to upper left corner and press button one...');„  Repeat Until JoystickButtonA;„  XMin := JoystickPosX;„  YMin := JoystickPosY;„  Writeln ('OK.');„  Repeat Until not JoystickButtonA;„  Write ('Press joystick to lower right corner and press button two...');„  Repeat Until JoystickButtonB;„  XMax := JoystickPosX;„  YMax := JoystickPosY;„  Writeln ('OK.');„  Repeat Until not JoystickButtonB;„end;„„Procedure AnimateShip;„begin„  X := JoystickPosX - XMin;„  if (X <= XRange div 3) then„     Dec (PosX, 3)„  else if (X > XRange * 2 div 3) then„     Inc (PosX, 3);„  Y := JoystickPosY - YMin;„  if (Y <= YRange div 3) then„     Dec (PosY, 3)„  else if (Y > YRange * 2 div 3) then„     Inc (PosY, 3);„  SpriteX [0] := PosX;„  SpriteY [0] := PosY;„end;„„Procedure AnimateBullets;„begin„  if Shooting1 then„     if (Bullet1Y < 0) then„        Shooting1 := False„     else„        Dec (Bullet1Y, 8)„  else„     begin„        Bullet1X := PosX + 3;„        Bullet1Y := PosY + 14;„     end;„  if Shooting2 then„     if (Bullet2Y < 0) then„        Shooting2 := False„     else„        Dec (Bullet2Y, 8)„  else„     begin„        Bullet2X := PosX + 30;„        Bullet2Y := PosY + 14;„     end;„  SpriteX [1] := Bullet1X;„  SpriteY [1] := Bullet1Y;„  SpriteX [2] := Bullet2X;„  SpriteY [2] := Bullet2Y;„end;„„begin„  if JoystickExists and (LoadSprite ('SHIP1.COD', 1) = 1) and„     (LoadSprite ('BULLET.COD', 2) = 1) then„     begin„        ClrScr;„        CalibrateJoystick (XMin, XMax, YMin, YMax);„        ClrScr;„        InitGraph;„        SpriteN [0] := 1;„        SpriteN [1] := 2;„        SpriteN [2] := 2;„        PosX := 160;„        PosY := 160;„        Shooting1 := False;„        XRange := XMax - XMin;„        YRange := YMax - YMin;„        ShootNext := Boolean (0);„        While not (JoystickButtonA and JoystickButtonB) do„           begin„              if JoystickButtonA and not JoystickButtonB then„                 if not Shooting1 and ShootNext then„                    begin„                       Bullet1X := PosX + 3;„                       Bullet1Y := PosY + 14;„                       Shooting1 := True;„                       ShootNext := False;„                    end„                 else if not Shooting2 and not ShootNext then„                    begin„                       Bullet2X := PosX + 30;„                       Bullet2Y := PosY + 14;„                       Shooting2 := True;„                       ShootNext := True;„                    end;„              While JoystickButtonA do„                 begin„                    AnimateShip;„                    AnimateBullets;„                    Animate;„                 end;„              AnimateShip;„              AnimateBullets;„              Animate;„           end;„        CloseRoutines;„     end„  else„     Writeln ('Game card not installed.');„end.„„I apologize For giving you an example that Uses another Unit.  if need be, this„Program can be easily modified to provide a successful example.  Hope this„helps, and I hope my Programming is not toO bad.„}                                            6      05-31-9308:11ALL                      SWAG SUPPORT TEAM        Two Joysticks            IMPORT              95     …Qc ==============================================================================„ BBS: ÆÆ The Information and Technology Exchan„  To: MATT CRILL                   Date: 01-05ƒ92 (23:03)„From: DANIEL CHURCHMAN           Number: 4144   [101] PASCAL„Subj: JOYSTICK 1                 Status: Public„------------------------------------------------------------------------------„Program Joy;  { Read Joystick positions and button states }„„Uses DOS, Crt;„„Const„  Buttons          : Byte = 0;„  Joystick         : Byte = 1;„„  JoyIntr          : Byte = $15;„  JoyFunc          : Byte = $84;„„  CStart           : Byte = 0; { To hold cursor start line }„  CEnd             : Byte = 0; { To hold cursor end line }„„  kX               : Real = 6.25; { constant for horizontal conversion }„  kY               : Real = 20.0; { constant for vertical conversion }„„  LastKey          : Char = ' ';„„Var„  { Variables for Joystick 1 }„  Joy1Vert         : Word; { Vertical Position }„  Joy1Hori         : Word; { Horizontal Position }„  Joy1But1         : Boolean; { Button 1 }„  Joy1But2         : Boolean; { Button 2 }„„  { Variables for Joystick 2 }„  Joy2Vert         : Word; { Vertical Position }„  Joy2Hori         : Word; { Horizontal Position }„  Joy2But1         : Boolean; { Button 1 }„  Joy2But2         : Boolean; { Button 2 }„„  Error            : Boolean; { We'll set this if the joystick isn't found }„„  Regs             : Registers;„  NewX, NewY       : Byte;„  OldX, OldY       : Byte;„  MinX, MinY,„  MaxX, MaxY       : Word;„„{ Checkjoy and CheckBut are really the only two procedures of real }„{ interest to you; the rest is just support code to do something   }„{ with the samples.                                                }„„„Procedure CheckJoy;„    begin   { Prepare and make Int 15h, subfunction 84h call }„      With Regs do„      begin„        AH := JoyFunc;„        DX := Joystick;  { Subfunction 1 = joystick }„        Intr(JoyIntr, Regs);„        Joy1Hori := AX;„        Joy1Vert := BX;„        Joy2Hori := CX;„        Joy2Vert := DX;„        Error := ((Flags AND FCarry) <> 0)„      end;„    end;„„Procedure CheckBut;„    Const„      MaskJ1B1     = $10;„      MaskJ1B2     = $20;„      MaskJ2B1     = $40;„      MaskJ2B2     = $80;„    begin   { Prepare and make Int 15h, subfunction 84h call }„      With Regs do„      begin„        AH := JoyFunc;„        DX := Buttons;  { Subfunction 0 = buttons }„        Intr(JoyIntr, Regs);„        Joy1But1 := (AL AND MaskJ1B1) <> MaskJ1B1;„        Joy1But2 := (AL AND MaskJ1B2) <> MaskJ1B2;„        Joy2But1 := (AL AND MaskJ2B1) <> MaskJ2B1;„        Joy2But2 := (AL AND MaskJ2B2) <> MaskJ2B2;„        Error := ((Flags AND FCarry) <> 0)„      end;„    end;„„Procedure Calibrate;„    Var„      n            : Byte;„    begin„      { Calibrate joystick 1 }„      CheckJoy;„      If Error then„      begin„        Write('No Joystick(s) found - terminating program');„        Halt(1)„      end;„„      If (Joy1Vert + Joy1Hori) = 0 then„        Writeln('Joystick 1 Absent')„      else„        Writeln('Joystick 1 Present');„      If (Joy2Vert + Joy2Hori) = 0 then„        Writeln('Joystick 2 Absent')„      else„        Writeln('Joystick 2 Present');„„(*      { Get centre joystick values for X and Y }„      Write('Hold joystick in centre position and press a button');„      Repeat„        CheckBut„      Until (Joy1But1 OR Joy1But2);„      CentreX := 0;„      CentreY := 0;„      For n := 1 to 10 do„      begin„        CheckJoy;„        CentreX := CentreX + Joy1Hori;„        CentreY := CentreY + Joy1Vert;„      end;„      CentreX := CentreX DIV 10;„      CentreY := CentreY DIV 10;„      While (Joy1But1 OR Joy1But2) do  { Wait till button released }„      begin„        CheckBut„      end;„      Writeln('  -  ',CentreX,':',CentreY);„*)„„      { Get minimum joystick values for X and Y }„      Write('Hold joystick in upper-left position and press a button');„      Repeat„        CheckBut„      Until (Joy1But1 OR Joy1But2);„      MinX := 0;„      MinY := 0;„      For n := 1 to 10 do  { Sample over time for accuracy }„      begin„        CheckJoy;„        { Bias the reading slightly to ensure }„        { we can always reach coord 1,1 }„        MinX := MinX + Word(Round(Joy1Hori * 1.1));„        MinY := MinY + Word(Round(Joy1Vert * 1.1))„      end;„      MinX := MinX DIV 10;„      MinY := MinY DIV 10;„      While (Joy1But1 OR Joy1But2) do  { Wait till button released }„      begin„        CheckBut„      end;„      Writeln('  -  ',MinX,':',MinY);„„      { Get maximum joystick values for X and Y }„      Write('Hold joystick in bottom-right position and press a button');„      Repeat„        CheckBut„      Until (Joy1But1 OR Joy1But2);„      MaxX := 0;„      MaxY := 0;„      For n := 1 to 10 do   { Sample over time for accuracy }„      begin„        CheckJoy;„        { Bias the reading slightly to ensure }„        { we can always reach coord 80,25 }„        MaxX := MaxX + Word(Round(Joy1Hori * 0.95));„        MaxY := MaxY + Word(Round(Joy1Vert * 0.95))„      end;„      MaxX := MaxX DIV 10;„      MaxY := MaxY DIV 10;„      While (Joy1But1 OR Joy1But2) do  { Wait till button released }„      begin„        CheckBut„      end;„      Writeln('  -  ',MaxX,':',MaxY);„„      { Important to note that the following calculations of kX and   }„      { kY is done linearly.  This is not really correct, as you'll   }„      { see by the fact that when centred, your screen coords are     }„      { NOT 40,13.  The reason is that the resistors in joysticks     }„      { work on a logarithmic scale.  My knowledge of logs is too     }„      { rusty to build this in properly, so I've skipped it.  What    }„      { you should do is derive the log that correctly passes through }„      { minimum, maximum AND centre.  This way, the joystick, centred }„      { will correctly position your screen coord dead centre, and    }„      { you can still reach the extremes as well.                     }„„      kX := (MaxX - MinX) / 80;„      kY := (MaxY - MinY) / 25;„      Writeln('kX = ', kX:0:2,'     kY = ',kY:0:2);„„    end;„„[Continued]„„„--- Msged/sq„ * Origin: C&O Systems, Brisbane, AUSTRALIA (3:640/777)„==============================================================================„ BBS: ÆÆ The Information and Technology Exchan„  To: MATT CRILL                   Date: 01-05ƒ92 (23:04)„From: DANIEL CHURCHMAN           Number: 4145   [101] PASCAL„Subj: JOYSTICK 2                 Status: Public„------------------------------------------------------------------------------„Procedure SetCoord;„    begin„      If Joy1Hori < MinX then NewX := 1 else„        NewX := Byte(Round((Joy1Hori - MinX) / kX));„      If Joy1Vert < MinY then NewY := 1 else„        NewY := Byte(Round((Joy1Vert - MinY) / kY));„„      If NewX = 0 then NewX := 1;„      If NewX > 80 then NewX := 80;„      If NewY = 0 then NewY := 1;„      If NewY > 25 then NewY := 25;„„    end;„„Procedure MoveIndicator;„    begin„„      { If the position has changed, clean up old indicator }„      If NOT ((OldX = NewX) AND (OldY = NewY)) then„      begin„„        { Turn off indicator at old position }„        With Regs do„        begin„          { First, move cursor to old position }„          AH := 2;   { Set cursor position                }„          BH := 0;   { Assume page 0                      }„          DH := OldY - 1; { This value must be zero-based }„          DL := OldX - 1; { This one too                  }„          Intr($10,Regs);„„          { Now change the attribute }„          AH := 8;   { Read what character is there now                  }„          BH := 0;   { I'm assuming page 0                               }„          Intr($10,Regs);  {AH now holds the attribute, AL the character }„          AH := 9;   { Write Character and Attribute, AL is ok, so...    }„          BL := 31;  { ...only change the attribute                      }„          BH := 0;   { Again, assume page 0                              }„          CX := 1;   { Number of characters to write                     }„          Intr($10,Regs)„        end„      end;„      { Always refresh the current position }„„      With Regs do„      begin„        { Next, move cursor to new position }„        AH := 2;   { Set cursor position                }„        BH := 0;   { Assume page 0                      }„        DH := NewY - 1; { This value must be zero-based }„        DL := NewX - 1; { This one too                  }„        Intr($10,Regs);„„        { Then, turn on indicator at NEW position }„        AH := 8;   { Read what character is there now                  }„        BH := 0;   { I'm assuming page 0                               }„        Intr($10,Regs);  {AH now holds the attribute, AL the character }„        AH := 9;   { Write Character and Attribute, AL is ok, so...    }„        BL := 112; { ...change the attribute to black on grey          }„        BH := 0;   { Again, assume page 0                              }„        CX := 1;   { Number of characters to write                     }„        Intr($10,Regs)„„      end;„„    end;„„Procedure InitScreen;„    begin„      GotoXY(26,10);„      Write('Joystick 1        Joystick 2');„      GotoXY(20,12);„      Write('X :');„      GotoXY(20,13);„      Write('Y :');„      GotoXY(14,14);„      Write('Buttons :');„      GotoXY(16,16);„      Write('Error =');„      GotoXY(20,23);„      Write('Press "C" to reCalibrate your joystick');„„      With Regs do„      begin      { First, save present cursor configuration }„„        AH := 3; { Read cursor pos and config }„        BH := 0; { Assuming we are using page 0 }„        Intr($10,Regs);„        CStart := CH; { Starting line of cursor }„        CEnd   := CL; { Ending line of cursor }„        { DH holds cursor row }„        { DL holds cursor column }„„        { Now turn the cursor off - we hope! }„„        AH := 1;  { Set cursor type }„        CH := $20; { Should cause the cursor to disappear }„        Intr($10,Regs);„„      end„    end;„„Procedure GetKey;„    begin„      If KeyPressed then„      begin„        LastKey := ReadKey;  { Read the key in the buffer       }„        If LastKey = #0 then { The key is an extended character }„          LastKey := ReadKey { Read the extended value          }„      end else„        LastKey := #0„    end;„„[Continued]„„--- Msged/sq„ * Origin: C&O Systems, Brisbane, AUSTRALIA (3:640/777)„==============================================================================„ BBS: ÆÆ The Information and Technology Exchan„  To: MATT CRILL                   Date: 01-05ƒ92 (23:05)„From: DANIEL CHURCHMAN           Number: 4146   [101] PASCAL„Subj: JOYSTICK 3                 Status: Public„------------------------------------------------------------------------------„begin„  TextAttr := 31;  { White on Blue - my favourite :-) }„  ClrScr;„„  Calibrate;„  SetCoord;„„  InitScreen;„„  Repeat„    GetKey;  { Simply load the variable LastKey with }„             { a keystroke if one is available       }„    CheckJoy;„    CheckBut;„    OldX := NewX;„    OldY := NewY;„    SetCoord;„    GotoXY(24,12);„    Write(Joy1Hori:10);„    GotoXY(24,13);„    Write(Joy1Vert:10);„    GotoXY(31,14);„    Write((Joy1But1):5,':',(Joy1But2):5);„„    GotoXY(44,12);„    Write(Joy2Hori:10);„    GotoXY(44,13);„    Write(Joy2Vert:10);„    GotoXY(51,14);„    Write(Byte(Joy2But1),':',Byte(Joy2But2));„„    GotoXY(37,15);„    Write(NewX:2,':',NewY:2);„„    GotoXY(24,16);„    Write(Error:5);„„    Writeln;„    MoveIndicator;„„    If UpCase(LastKey) = 'C' then„    begin„      ClrScr;„      Calibrate;„      InitScreen„    end;„„  Until LastKey = #27;„„  With Regs do„  begin      { Restore original cursor configuration }„„    AH := 1;  { Set cursor type }„    CH := CStart; { Original cursor start line }„    CL := CEnd;   { Original cursor end line }„    Intr($10,Regs);„    GotoXY(1,24)„  end;„„end.„„„„[End of code]„--- Msged/sq„ * Origin: C&O Systems, Brisbane, AUSTRALIA (3:640/777)„                                                                      7      01-27-9412:10ALL                      RICHARD GODBEE           Joystick Manipulation    IMPORT              13     …ÜŒ {„> I'd like to use a joystick in a program but I'm not familiar„> with any algorithm to do that, suggestions?„„Here's one I found lying around (public domain...<G>) on a local BBS... I„changed it around a little so it would fit in one message...  It compiled into„a .TPU okay, so it *probably* works.  Let me know if it doesn't... :)„„--Ricky Godbee, Jr.„}„„unit Joystick;„interface„uses Dos, Crt;„procedure JPos(Joystick_Number: byte; var Joystick_X, Joystick_Y: word);„procedure JBut(Joystick_Number: byte; var Button_1, Button_2: boolean);„implementation„var Register: Registers;„procedure InitRegisters;„begin„ FillChar(Register, Sizeof(Register), 0);„end;„procedure JPos(Joystick_Number: byte; var Joystick_X, Joystick_Y: word);„begin„ InitRegisters;„ Register.AH := $84;„ Register.DX := $01;„ Intr($15, Register);„ if Joystick_Number = 1 then„  begin„   Joystick_X := Register.AX;„   Joystick_Y := Register.BX;„  end„ else if Joystick_Number = 2 then„  begin„   Joystick_X := Register.CX;„   Joystick_Y := Register.DX;„  end;„end;„procedure JBut(Joystick_Number: byte; var Button_1, Button_2: boolean);„begin„ InitRegisters;„ Register.AH := $84;„ Register.DX := $00;„ Intr($15, Register);„ case Joystick_Number of„  1: begin„      Button_1 := (Register.AL and $20) <> $20;„      Button_2 := (Register.AL and $10) <> $10;„     end;„  2: begin„      Button_1 := (Register.AL and $40) <> $40;„      Button_2 := (Register.AL and $80) <> $80;„     end;„ end;„end;„end.„                                                                 8      01-27-9412:10ALL                      WESLEY R. ELSBERRY       Joystick Routines        IMPORT              20     …^ﬂ {„> Can anybody give me any info on how to read signals from pins on say„> COM2: or from LPT1: or even from The joystick port? I think it has„> been done with the PORT command or something, but what are the values„> to use to read them with?„„As mentioned in the Neural_Net Echo:„}„„UNIT joys;„„{Joystick interface for Turbo Pascal.}„{Copyright 1993 by Wesley R. Elsberry.  Released for noncommercial use.}„{NO WARRANTY.}„„INTERFACE„„VAR„  xcor, ycor,„  fire1, fire2 : WORD;„„PROCEDURE joy;     { basic info for first joystick }„PROCEDURE testjoy; { minimal test routine }„„IMPLEMENTATION„„{ Significant aid was had from the example given in:„  programm to read joystick : turbo c 2.0 - Jean-Yves Vinet }„„CONST„  JOYPORT = $201;„  STROUT  = $FF;„  STRCMP  = $FFFF;„„VAR„  inread,„  temp   : BYTE;„„PROCEDURE joy;„VAR„  done : BOOLEAN;„BEGIN„  done := FALSE;„  xcor := 0;„  ycor := 0;„  port[JOYPORT] := STROUT;„„  while (NOT done) DO„  BEGIN„    if ((port[JOYPORT] AND 1) = 0) then„      done := TRUE;„    INC(xcor);„    if (xcor = STRCMP) then„      done := true;„  END;„„  while ((port[JOYPORT] AND 2) <> 0) DO ;„„  done := FALSE;„  port[JOYPORT] := STROUT;„„  while (NOT done) DO„  BEGIN„    if ((port[JOYPORT] AND 2) = 0) then„      done := TRUE;„    INC(ycor);„    if (ycor = STRCMP) then„      done := TRUE;„  END;„„  inread := port[JOYPORT];„„  { Button A at $10, B at $20, C at $40, D at $80. }„  if ((inread AND $10) <> $10) then„    fire1 := 1;„  if ((inread AND $20) <> $20) then„    fire2 := 1;„END;„„{If you want to grab the second joystick values, the X coordinate„should be gotten from comparing port[JOYPORT] to 4, the Y coordinate„from comparing port[JOYPORT] to 8.}„„PROCEDURE testjoy;„BEGIN„  while TRUE do„  BEGIN„    joy;„    WRITELN(xcor : 5, '  ', ycor, '  ', fire1, '  ', fire2);„    xcor  := 0;„    ycor  := 0;„    fire1 := 0;„    fire2 := 0;„  END;„END;„„BEGIN„  {No initialization required.}„END.„„{„The above was a pretty quick and dirty approach to grabbing values„off the game card.  I'm sure that there are better means of doing it,„but I haven't put in the time to find them.  Interestingly enough,„the Turbo C version mentioned in the comments of the unit above does„not give as large a value for the maximum displacement of a joystick,„which is an indicator that the Turbo Pascal code is faster than its„equivalent Turbo C counterpart.„}„                                                           9      02-09-9411:50ALL                      LOU DUCHEZ               Joystick Reading         IMPORT              61     …â« {„The basic approach to reading a joystick is to monitor port 201h.  The eight„bits at that port correspond to:„„01h - Joystick A, "X" position„02h - Joystick A, "Y" position„04h - Joystick B, "X" position„08h - Joystick B, "Y" position„10h - Joystick A, button 1„20h - Joystick A, button 2„40h - Joystick B, button 1„80h - Joystick B, button 2„„The buttons are easy: a bit of "0" means "pressed" and "1" means "not„pressed".  But a single bit to read a joystick position?!?  Here's what„you do:„„1)  Write a value -- any value -- to port 201h.  The four lowest bits„    will then all assume a value of "1".„„2)  Start a counter, and see how many iterations it takes for your„    desired bit to go to zero.  The number of iterations = the joystick„    position, with lower values corresponding to "left" or "up" and„    higher values corresponding to "right" or "down".„„Like any joystick code, thess routines return the button statuses and the„joystick positions.  They also return boolean indicators of whether the„stick is left or right, up or down, based on a sensitivity you define.„„The routines you call are:„„procedure calibrate(r: real) -- Call this at the beginning of your program.„                                Determines presence of joysticks and how„                                far the stick has to be moved to constitute„                                L/R/U/D.  "r" is a real value from 0 to 1;„                                a value of 0.25 means that the stick has to„                                move 25% from center to count as L/R/U/D.„procedure readsticks         -- Reads sticks and buttons.  Call this once„                                every round of play or whatever.„„THE CODE:„{--------------------------------------------------------------------------}„unit joystick;„„interface„„var jax, jay, jbx, jby: word;                 { Joystick positions }„    ja1, ja2, jaleft, jaright, jaup, jadown,  { JA1, JA2, JB1, JB2 = buttons }„    jb1, jb2, jbleft, jbright, jbup, jbdown,  { GotJoystickA/B record which }„    gotjoysticka, gotjoystickb: boolean;      {   joysticks are present }„„   { lefts, rights, ups, downs are determined when the joysticks are read:„       if the stick is sufficiently off-center, L, R, U, and/or D will be„       flagged appropriately }„„procedure readsticks;                         { reads joysticks }„procedure calibrate(offcenterthresh: real);   { determines what stick values„                                                  constitute L/R/U/D }„{--------------------------------------------------------------------------}„implementation„„var jal, jar, jau, jad, jbl, jbr, jbu, jbd: word;   { thresholds for L/R/U/D }„{--------------------------------------------------------------------------}„procedure calibrate(offcenterthresh: real);   { get base figures for sticks }„begin„  gotjoysticka := true;                       { initially assume both sticks }„  gotjoystickb := true;                       {   are present }„  readsticks;                                 { get stick positions }„  gotjoysticka := (jax > 0) or (jay > 0);     { if joystick reads as position }„  gotjoystickb := (jbx > 0) or (jby > 0);     {   (0,0), it doesn't exist }„  jal := round(jax*(1 - offcenterthresh));    { OFFCENTERTHRESH is a real }„  jar := round(jax*(1 + offcenterthresh));    {   from 0 to 1 that tells the }„  jau := round(jay*(1 - offcenterthresh));    {   system how far off-center }„  jad := round(jay*(1 + offcenterthresh));    {   the stick has to be to get }„  jbl := round(jbx*(1 - offcenterthresh));    {   counted as L/R/U/D.  For }„  jbr := round(jbx*(1 + offcenterthresh));    {   example, a value of "0.25" }„  jbu := round(jby*(1 - offcenterthresh));    {   means the stick has to be }„  jbd := round(jby*(1 + offcenterthresh));    {   25% below base to be L / U, }„  end;                                        {   or 25% above to be R / D. }„„procedure readsticks;                       { Reads sticks & buttons. }„var gotax, gotay, gotbx, gotby: boolean;    { whether we have a stick value }„    cnter: word;                            { just a counter }„begin„  if gotjoysticka or gotjoystickb then begin  { if no sticks, skip reading them }„    ja1 := (port[$201] and $10) = 0;          { read the buttons }„    ja2 := (port[$201] and $20) = 0;„    jb1 := (port[$201] and $40) = 0;„    jb2 := (port[$201] and $80) = 0;„    gotax := not gotjoysticka;              { Flags: do we have values yet? }„    gotay := not gotjoysticka;              { Set to "true" for nonexistent }„    gotbx := not gotjoystickb;              {   stick -- no need to give    }„    gotby := not gotjoystickb;              {   them a second thought }„    jax := 0;                               { set actual stick positions to }„    jay := 0;                               {   zero -- on "existing" sticks }„    jbx := 0;                               {   the number will increase }„    jby := 0;„    asm„      mov  cx, 0000h   { set counter to zero }„      mov  al, 0fh     { AL contains "new" port value (initialized to 0fh) }„      mov  ah, al      { AH contains "old" port value (initialized to 0fh) }„      mov  dx, 0201h   { load up joystick port }„      out  dx, al      { "prime" joystick port by writing 0fh to it }„      @beginloop:      { the stick-reading loop }„„      in   al, dx      { read joystick port }„      and  al, 0fh     { "and" it with 0fh to "eliminate" the button bits }„      cmp  al, ah      { compare to the "old" port value }„      je   @endloop    { if no change, skip past position checking }„„      @chkax:          { checking "X" value on joystick "A" }„      cmp  gotax, 01h  { see if "gotax" equals 1: if so, we've already got }„      je   @chkay      {   a reading on it, and skip to "ay" readings }„      test al, 01h     { if first bit of BL is a 1: if so, we don't have a }„      jnz  @chkay      {   value for "ax", so jump over to "ay" }„      mov  gotax, 01h  { set boolean "gotax" to "true" }„      mov  jax, cx     { record counter value }„„      @chkay:          { checking "Y" value on joystick "A" }„      cmp  gotay, 01h„      je   @chkbx„      test al, 02h„      jnz  @chkbx„      mov  gotay, 01h„      mov  jay, cx„„      @chkbx:          { checking "X" value on joystick "B" }„      cmp  gotbx, 01h„      je   @chkby„      test al, 04h„      jnz  @chkby„      mov  gotbx, 01h„      mov  jbx, cx„„      @chkby:          { checking "Y" value on joystick "B" }„      cmp  gotby, 01h„      je   @endloop„      test al, 08h„      jnz  @endloop„      mov  gotby, 01h„      mov  jby, cx„„      @endloop:        { counter increments and data-evaluating }„      mov  ah, al      { store "new" port value as "old" value for next pass }„      inc  cx          { increment counter }„      cmp  cx, 65535   { compare counter to 65535 }„      je   @ending     { if counter = 65535, get out of loop }„      cmp  gotax, 01h  { see if we have a value for "ax"; }„      jne  @beginloop  {   if not, jump to top of loop for another pass }„      cmp  gotay, 01h  { check "ay" }„      jne  @beginloop„      cmp  gotbx, 01h  { check "bx" }„      jne  @beginloop„      cmp  gotby, 01h  { check "by" }„      jne  @beginloop„      @ending:         { we're past the end of the loop }„      mov  cnter,cx    { store counter value into "Pascal" variable }„      end;„    end;„  jaleft := (jax < jal);  jaright := (jax > jar);  { determine L/R/U/D }„  jaup   := (jay < jau);  jadown  := (jay > jad);„  jbleft := (jbx < jbl);  jbright := (jbx > jbr);„  jbup   := (jby < jbu);  jbdown  := (jby > jbd);„  end;„{--------------------------------------------------------------------------}„  end.„       10     05-25-9408:17ALL                      IAN HINSON               Joystick interface       SWAG9405            13     …   „UNIT JoyStick;„(* Public Domain.  Written by Ian Hinson   November 1993 *)„„INTERFACE„„PROCEDURE ReadPosns;„{ Updates values of JoyA_X, JoyA_Y, JoyB_X, and JoyB_Y }„„PROCEDURE ReadButtons;„{ Updates the state of all buttons }„„{ Call the function for whichever button(s) you want to test„  after updating all their states with a call to ReadButtons. }„FUNCTION JoyA_Button1: BOOLEAN;„FUNCTION JoyA_Button2: BOOLEAN;„FUNCTION JoyB_Button1: BOOLEAN;„FUNCTION JoyB_Button2: BOOLEAN;„FUNCTION AnyButton: BOOLEAN;„„VAR„{ These variables provide the X&Y positions after„  they have been updated by a call to ReadPositions }„JoyA_X, JoyA_Y, JoyB_X, JoyB_Y: WORD;„„„IMPLEMENTATION„„VAR„buttons: SET OF (JoyA_1, JoyA_2, JoyB_1, JoyB_2);„„PROCEDURE ReadPosns; ASSEMBLER;„   ASM„   mov ah,$84„   mov dx,1„   int $15„   mov JoyA_X,ax„   mov JoyA_Y,bx„   mov JoyB_X,cx„   mov JoyB_Y,dx„   END;„„PROCEDURE ReadButtons; ASSEMBLER;„   ASM„   mov ah,$84„   mov dx,0„   int $15„   shr al,4„   xor al,$0F„   mov buttons,al„   END;„„FUNCTION JoyA_Button1: BOOLEAN;„  BEGIN„    JoyA_Button1 := JoyA_1 IN buttons;„  END;„„FUNCTION JoyA_Button2: BOOLEAN;„  BEGIN„    JoyA_Button2 := JoyA_2 IN buttons;„  END;„„FUNCTION JoyB_Button1: BOOLEAN;„  BEGIN„    JoyB_Button1 := JoyB_1 IN buttons;„  END;„„FUNCTION JoyB_Button2: BOOLEAN;„  BEGIN„    JoyB_Button2 := JoyB_2 IN buttons;„  END;„„FUNCTION AnyButton: BOOLEAN;„  BEGIN„    AnyButton := buttons <> [];„  END;„„END.„„                                                                                           11     05-25-9408:17ALL                      SEAN PALMER              Accessing The Joystick   SWAG9405            19     …   {by Sean Palmer}„{public domain}„{feel free to put this in SWAG or whatever}„„unit joy;„„{unit for accessing joystick 0}„„interface„„var„ installed:boolean; {true if joystick 0 present at unit startup}„var„ X,Y:word;          {stick position}„var„ A,B:boolean;       {buttons down?}„const„ Cal_L:word=$FFFF;   {rect containing calibration extent of 'center'}„ Cal_T:word=$FFFF;„ Cal_R:word=0;„ Cal_B:word=0;„„procedure sample;   {take a sample of current joystick 0 state}„procedure swirlCalibrate;„procedure centerCalibrate;„„„implementation„„procedure sample;assembler;asm„ xor si,si     {x count}„ xor di,di     {y count}„ mov dx,$201   {Game port}„ out dx,al     {Fire the joystick one-shots}„@@L:„ in  al,dx     {get joystick bits}„ mov ah,al     {save original value}„ shr al,1      {joy 0 x expired? 0 if so, else 1}„ adc si,0      {accumulate in x}„ jc @@TOOLONG  {if overflow, give up}„ shr al,1      {joy 0 y expired? 0 if so, else 1}„ adc di,0      {accumulate in y}„ jc @@TOOLONG  {if overflow, give up}„ test ah,3„ jnz @@L       {keep going til they're both 0 or we overflow}„ not ah        {flip button bits so 1=pressed}„ mov al,ah„ and al,$10    {mask off buttons and store them}„ mov A,al„ and ah,$20„ mov B,ah„ mov X,si      {store x & y coords}„ mov Y,di„ jmp @@X„@@TOOLONG:„ mov X,-1      {overflowed, return -1 as error}„ mov Y,-1„ mov A,0„ mov B,0„@@X:„end;„„procedure swirlCalibrate;begin  {display message before starting this one!}„ repeat sample until not (A or B);{make sure button is up}„ repeat                           {collect max extents}„  sample;„  if x<Cal_L then Cal_L:=x;„  if x>Cal_R then Cal_R:=x;„  if y<Cal_T then Cal_T:=y;„  if y>Cal_B then Cal_B:=y;„  until a;                        {until user presses a button}„  Cal_L:=((Cal_L*3)+Cal_R)div 4;      {now adjust for center by}„  Cal_R:=((Cal_R*3)+Cal_L)div 4;      { weighted averaging}„  Cal_T:=((Cal_T*3)+Cal_B)div 4;„  Cal_B:=((Cal_B*3)+Cal_T)div 4;„ end;„„procedure centerCalibrate;var x2,y2:word;begin {doesn't require user„interaction}„ sample;„ x2:=x shr 1;„ y2:=y shr 1;„ Cal_L:=x-x2;„ Cal_R:=x+x2;„ Cal_T:=y-y2;„ Cal_B:=y+y2;„ end;„„begin„ sample;„ installed:=(x<>$FFFF);„end.„                                                                                                                          12     05-25-9408:17ALL                      CHRIS WILPER             Joystick Testing         SWAG9405            13     …   „Program JoyTest;„„uses„   crt;„„var„   ch:char;„   x1,y1,x2,y2:word;„„Function JoyExist:boolean;„var„   temp:byte;„begin„   asm„      mov ah,84h„      mov dx,00h„      int 15h„      mov temp,al„   end;„   if temp=0 then JoyExist:=false„   else JoyExist:=true;„end;„„Function JoyX:word;„var„   temp:word;„begin„   asm„      mov ah,84h„      mov dx,01h„      int 15h„      mov temp,ax„   end;„   JoyX:=temp;„end;„„Function JoyY:word;„var„   temp:word;„begin„   asm„      mov ah,84h„      mov dx,01h„      int 15h„      mov temp,bx„   end;„   JoyY:=temp;„end;„„Function JoyBtn1:boolean;„var„   temp:byte;„begin„   asm„      mov ah,84h„      mov dx,00h„      int 15h„      mov temp,al;„   end;„   if temp and 16 = 16 then JoyBtn1:=false„      else JoyBtn1:=true;„end;„„Function JoyBtn2:boolean;„var„   temp:byte;„begin„   asm„      mov ah,84h„      mov dx,00h„      int 15h„      mov temp,al;„   end;„   if temp and 32 = 32 then JoyBtn2:=false„      else JoyBtn2:=true;„end;„„Procedure JoyCalibrate;„„begin„„   writeln('Move Joystick to upper-left, and press a button...');„   repeat„      x1:=JoyX;„      y1:=JoyY;„   until JoyBtn1 or JoyBtn2;„   repeat until not JoyBtn1 or JoyBtn2;„   writeln('Move Joystick to lower-right, and press a button...');„   repeat„      x2:=JoyX;„      y2:=JoyY;„   until JoyBtn1 or JoyBtn2;„„end;„„begin„„   clrscr;„   if not joyexist then begin„      writeln('No joystick');„      halt;„   end;„   joycalibrate;„   write(#10#13,'Range is from (',x1,',',y1,') to (',x2,',',y2,')');„   ch:=readkey;„end.„„  