SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00019         INTERRUPT HANDLING ROUTINES                                       1      05-28-9313:48ALL                      SWAG SUPPORT TEAM        BITSTUFF.PAS             IMPORT              40     ®Fà {ã Well Percy (or is it Kerry?), I see that the regular crowd here haveã shown you how bit-level thingys work.  So, I'll give you a workingã example, including a Procedure to display the binary notation of anyã Integer, so you can play With the inFormation they've given you. Theã following Program reads & displays info from the equipment list Wordã (Note: I've made [lazy] use of global Variables, do not emulate)...ã}ã(*******************************************************************)ãProgram BitsNBytes;                 { ...or Digital Road Kill       }ãUsesã  Dos;                              { import Intr() and Registers   }ãVarã  NumberFDD,                        { number of floppy drives       }ã  InitVMode,                        { intial video mode             }ã  COMcount,                         { number of serial ports        }ã  LPTcount    : Byte;               { number of Printer ports       }ã  Is8087,                           { math copro installed?         }ã  IsMouse,                          { pointing device installed?    }ã  IsDMA,                            { DMA support installed?        }ã  IsGame,                           { game port installed?          }ã  IsModem     : Boolean;            { internal modem installed?     }ã  EqWord      : Word;               { the equipment list Word       }ã  Reg         : Registers;          { to access CPU Registers       }ã{-------------------------------------------------------------------}ãFunction BitSet(AnyWord : Word; BitNum : Byte) : Boolean;ã { return True if bit BitNum of AnyWord is 1, else False if it's 0  }ãbeginã  BitSet := (BitNum in [0..15]) and ODD(AnyWord SHR BitNum);ãend {BitSet};ã{-------------------------------------------------------------------}ãProcedure WriteBitWord( AnyWord : Word );   { show Word as binary   }ãVarã  BinString : String[16];                   { represent binary bits }ã  MaxBit,                                   { max number of bits    }ã  BitNum    : Byte;                         { bits 0..15            }ãbeginã  BinString := '0000000000000000';          { default to 0          }ã  MaxBit := Length(BinString);              { total bit count (16)  }ã  For BitNum := 0 to PRED(MaxBit) do        { process bits (0..15)  }ã    if BitSet(AnyWord, BitNum) thenã      INC(BinString[MaxBit - BitNum]);ã  Write( BinString );                       { Write the binary Form }ãend {WriteBitWord};ã{-------------------------------------------------------------------}ãProcedure ProcessEquipList;     { parse equipment list Word EqWord  }ãVarã  BitNum  : Byte;               { to check each bit                 }ã  EBitSet : Boolean;            { True if a BitNum is 1, else False }ãbeginã  For BitNum := 0 to 15 doã  begin                                     { EqWord has 16 bits    }ã    EBitSet := BitSet(EqWord,BitNum);       { is this bit set?      }ã    Case BitNum of                          { each bit has meaning  }ã      0       : if EBitSet then             { if EqWord.0 is set    }ã                  NumberFDD := (EqWord SHR 6) and $3 + 1ã                elseã                  NumberFDD := 0;ã      1       : Is8087    := EBitSet; { if math co-pro found  }ã      2       : IsMouse   := EBitSet; { if pointing device    }ã      3       : ; {reserved, do nothing}ã      4       : InitVMode := (EqWord SHR BitNum) and $3;ã      5..7    : ; {ignore}ã      8       : IsDMA     := EBitSet;ã      9       : COMcount  := (EqWord SHR BitNum) and $7;ã      10,11   : ; {ignore}ã      12      : IsGame    := EBitSet;ã      13      : IsModem   := EBitSet;ã      14      : LPTcount  := (EqWord SHR BitNum) and $7;ã      15      : ; {ignore}ã    end; {Case BitNum}ã  end; {For BitNum}ãend {ProcessEquipList};ã{-------------------------------------------------------------------}ãFunction Maybe(Truth : Boolean) : String;ãbeginã  if not Truth thenã    Maybe := ' not 'ã  elseã    Maybe := ' IS ';ãend {Maybe};ã{-------------------------------------------------------------------}ãbeginã  Intr( $11, Reg );ã  EqWord := Reg.AX;ã  WriteLn;ã  Write('Equipment list Word: ',EqWord,' decimal = ');ã  WriteBitWord( EqWord );ã  WriteLn(' binary');ã  WriteLn;ã  ProcessEquipList;ã  WriteLn('Number of floppies installed: ', NumberFDD );ã  WriteLn('Math-coprocessor',Maybe(Is8087),'installed' );ã  WriteLn('PS/2 Mouse',Maybe(IsMouse),'installed' );ã  Write('Initial video mode: ',InitVMode,' (' );ã  Case InitVMode ofã    0 : WriteLn('EGA, VGA, PGA)');ã    1 : WriteLn('40x25 colour)');ã    2 : WriteLn('80x25 colour)');ã    3 : WriteLn('80x25 monochrome)');ã  end;ã  WriteLn('DMA support',Maybe(IsDMA),'installed' );ã  WriteLn('Number of COMs installed: ',COMcount );ã  WriteLn('Game port',Maybe(IsGame),'installed' );ã  WriteLn('IBM Luggable modem',Maybe(IsModem),'installed');ã  WriteLn('Number of Printer ports: ',LPTcount );ãend {BitsNBytes}.ã(*******************************************************************)ãã                                                          2      05-28-9313:48ALL                      SWAG SUPPORT TEAM        CLOCK1.PAS               IMPORT              22     ®Fe {ãCARLOS BEGUIGNEã}ãProgram ClockOnScreen;ãã{$R-,V-,S-,M 1024, 0, 0ãã  ClockOnScreen - Installs resident clock on upper right corner of screen.ãã{$IFOPT S+ }ãã{ã  You must disable stack checking here, since a Runtime error 202 willã  be generated whenever the stack Pointer (as returned by SPtr) is likelyã  to drop below 1024.ã}ãUsesã  Dos, Crt;ãConstã  Offset       = $8E;    { Line 1, Column $8E/2 = 71 }ã  TimerTick    = $1C;                  { Timer interrupt }ã  black        = 0;ã  gray         = 7;ã  EnvSeg       = $002C;                { Segment of Dos environment }ã  ColourSeg    = $B800;                { Segment of colour video RAM }ã  MonoSeg      = $B000;                { Segment of monochrome ideo RAM }ã  CrtSegment   : Word = ColourSeg;ããTypeã  ScreenArray  = Array[0..7] of Recordã    number, attribute : Char;ã  end;ãã  ScreenPtr    = ScreenArray;ããVarã  VideoMode    : Byte Absolute $0000:$0449;ã  Screen       : ^ScreenPtr;            { Physical screen address }ã  ClockColour  : Char;ã  Int1CSave    : Procedure;ããProcedure ShowTime; Interrupt;ãConstã  separator    = ':';ãVarã  ThisMode     : Byte;ã  Time         : LongInt;ã  i            : Integer;ã  BIOSTicker   : LongInt Absolute $0000:$046C;ãã  Procedure DisplayDigit(offset : Integer; digit : Integer);ã  beginã    Screen^ [offset].number := Chr(digit div 10+Ord('0'));ã    Screen^ [offset+1].number := Chr(digit mod 10+Ord('0'));ã  end;  { DisplayDigit }ããbeginã  ThisMode := VideoMode;ã  if not ((ThisMode = 2) or (ThisMode = 3) or (ThisMode = 7)) Thenã    Exit;                              { Do not popup in a Graphic mode }ã  For i := 0 to 7 Doã    Screen^[i].attribute := ClockColour;ã  Time := (1365*BIOSTicker) div 24852;ã  DisplayDigit(0, Time div 3600);      { hours }ã  Screen^[2].number := separator;ã  Time := Time mod 3600;ã  DisplayDigit(3, Time div 60);        { minutes }ã  Screen^[5].number := separator;ã  DisplayDigit(6, Time mod 60);        { seconds }ã  Inline($9C); { PUSHF }ã  Int1CSave;ãend;  { ShowTime }ããProcedure Release(segment : Word);ãInLine(ã  $07/                 { POP   ES       ; get segment of block to release }ã  $B4/$49/             { MOV   AH, 49h  ; Free Allocated Memory }ã  $CD/$21);            { INT   21h      ; call Dos }ããbegin  { ClockOnScreen }ã  if VideoMode = 7 Thenã    CrtSegment := MonoSeg;ã  ClockColour := Chr(gray*16+black);      {display video attribute }ã  Screen := Ptr(CrtSegment, Offset);ã  GetIntVec(TimerTick, @Int1CSave);ã  SetIntVec(TimerTick, @ShowTime);ã  Release(MemW[PrefixSeg:EnvSeg]);        {Release the environment }ã  Keep(0);ã  readln;ãend.  { ClockOnScreen }ãã                                                                  3      05-28-9313:48ALL                      SWAG SUPPORT TEAM        INTREXAM.PAS             IMPORT              7      ®F% Okay, well, For the most part, calling an interrupt from TP is fairlyãsimple.  I'll use Interrupt 10h (service 0) as an example:ããProcedure CallInt;ãVarã  Regs : Registers;ãbeginã  Regs.AH := 0;       { Specify service 0 }ã  Regs.AL := $13;     { Mode number = 13 hex, MCGA 320x200x256 }ã  Intr($10,Regs);     { Call the interrupt }ãend;ããThis would shift the screen to the MCGA Graphics mode specified.  Now,ãit's easier to call this in BAsm (built-in Assembler):ããProcedure CallInt; Assembler;ãAsmã  MOV AH,0            { Specify service 0 }ã  MOV AL,13h          { Mode number = 13 hex, MCGA 320x200x256 }ã  inT 10h             { Call the interrupt }ãend;ãã                                                                                                            4      05-28-9313:48ALL                      SWAG SUPPORT TEAM        ISRINFO.PAS              IMPORT              6      ®F»o {ãSEAN PALMERãã> Does anyone know how to Write an ISR (interrupt service routine) that willã> continue With the interrupt afterwards. EX: if you Write an ISR that trapsã> the mouse Int 33h but let the mouse still operate.ããTry:ã}ããVarã  oldMouseHook : Procedure;ããProcedure mouseHook(AX,BX,CX,DX,SI,DI,DS,ES,BP); interrupt;ãbeginãã {Your stuff goes here}ã {make sure it doesn't take TOO long!}ãã Asmã   pushF;ã end;          {simulate an interrupt}ãã oldMouseHook; {call old handler}ãend;ãã{ to install: }ãã getIntVec($33,@oldMouseHook);ã setIntVec($33,@mouseHook);ãã{ to deinstall: }ãã setIntVec($33,@oldMouseHook);ãã                      5      05-28-9313:48ALL                      SWAG SUPPORT TEAM        REG1.PAS                 IMPORT              6      ®F ã  Registers DemoããPB>        Procedure GetScreenType (Var SType: Char);ãPB>        VarãPB>          Regs: Registers;ãPB>        beginãPB>          Regs.AH := $0F;ãPB>          Intr($10, Regs);ãPB>          if Regs.AL = 7 thenãPB>              sType := 'M';        <<<<<ãPB>          elseãPB>              sType := 'C';ãPB>        end;ãã   This Procedure would be ideal For a Function...ã           Function GetScreenType:Char;ã           ...ã           if Regs.AL=7 thenã              GetScreenType := 'M'ã           elseã              GetScreenType := 'C';ã           ...ã                                                                  6      05-31-9308:06ALL                      SWAG SUPPORT TEAM        Critical Error Trap      IMPORT              50     ®FQc ==============================================================================ã BBS: -=- Edge of the Century -=-ã  To: DANIEL KEMPTON               Date: 01-20-93 (05:13)ãFrom: GREG VIGNEAULT             Number: 3196   [140] PascalãSubj: CRITICAL ERROR HANDLER     Status: Publicã------------------------------------------------------------------------------ãDK> Can anyone PLEASE give me information on how to write a criticalã  > error handler.ãã Below is a quick'n-dirty critical error handler, written withoutã any Asm (so is usable from TP v4.0+).  To test it, put a write-ã protected diskette in drive A:, then run the program.  It shouldã report error #19 (13 hex, disk write-protected).ãã It'll need to be modified & trimmed to your purpose.  You mightã code your handler to simply ignore errors, then let your mainã program take appropriate action, depending on the error, etc.ãã DOS functions $00..$0C, $30, and $59 should be safe calls from theã handler.  Function $59 will return the extended error informationã code that you'll need to check (eg. #32 = share violation), as wellã as other data - which you can read up on, in a Dos reference text.ãã I've used one byte of the DOS intra-process communication area (atã $40:$F0) to return the value needed to tell Dos what to do aboutã the error, rather than juggle registers.  This should be okay.ãã This code is cramped, to fit into a single message ...ãã{*******************************************************************}ã PROGRAM Example;                       { Critical Error Handler    }ã USES Dos,      { import MsDos, GetIntVec, SetIntVec, Registers     }ã      Crt;      { import CheckBreak                                 }ã VAR OldISR     : POINTER;              { to save original ISR ptr  }ã     Reg        : Registers;            { to access CPU registers   }ã     errNumber  : WORD;                 { extended error code       }ã     errClass,                          { error class               }ã     errAction,                         { recommended action        }ã     errLocus   : BYTE;                 { error locus               }ã     FileName   : String[13];           { for ASCIIZ file name      }ã{-------------------------------------------------------------------}ã PROCEDURE cErrorISR( AX,BX,CX,DX,SI,DI,DS,ES,BP : WORD); Interrupt;ã    BEGIN  { This is it! ...                                        }ã    InLine($FB);                        { STI (allow interrupts)    }ã    Reg.AX := $3000;  MsDos(Reg);       { fn: get Dos version       }ã    IF (Reg.AH < 3) THEN Reg.AL := 3    { if less than Dos 3+ :FAIL }ã        ELSE BEGIN                      { else take a closer look.. }ã        Reg.AH := $59;  Reg.BX := 0;    { fn: get extended info     }ã        MsDos( Reg );                   { call Dos                  }ã        errNumber := Reg.AX;            { set|clear error number    }ã        errClass := Reg.BH; errAction := Reg.BL; errLocus := Reg.CH;ã        WriteLn;  Write( 'Critical error (#', errNumber, ') ' );ã        REPEAT WriteLn;                 { loop for user response    }ã          Write( 'Abort, Retry, Ignore, Fail (A|R|I|F) ? ',#7);ã          Reg.AH := 1;  MsDos(Reg);     { get user input, via Dos   }ã        UNTIL UpCase(CHR(Reg.AL)) IN ['A','R','I','F'];ã        CASE CHR(Reg.AL) OF             { ... depending on input    }ã            'i','I' : Reg.AL := 0;      { = ignore error            }ã            'r','R' : Reg.AL := 1;      { = retry the action        }ã            'a','A' : Reg.AL := 2;      { = abort                   }ã            'f','F' : Reg.AL := 3;      { = fail                    }ã            END; {case}ã        END; {if Reg.AH}ã    Mem[$40:$F0] := Reg.AL;             { to tell Dos what to think }ã    InLine( $8B/$E5/                    { mov   sp,bp               }ã            $5D/$07/$1F/$5F/$5E/        { pop   bp,es,ds,di,si      }ã            $5A/$59/$5B/$58/            { pop   dx,cx,bx,ax         }ã            $06/                        { push  es                  }ã            $2B/$C0/                    { sub   ax,ax               }ã            $8E/$C0/                    { mov   es,ax               }ã            $26/$A0/$F0/$04/            { mov   al,es:[4F0h]        }ã            $07/                        { pop   es                  }ã            $CF);                       { iret                      }ã    END {cErrorISR};ã{-------------------------------------------------------------------}ã BEGIN  { the main program...                                       }ã    CheckBreak := FALSE;                { don't allow Ctrl-Break!   }ã    errNumber := 0;                     { clear the error code      }ã    GetIntVec( $24, OldISR );           { save current ISR vector   }ã    SetIntVec( $24, @cErrorISR );       { set our ISR               }ã        {===========================================================}ã        { insert your test code here ...                            }ã        FileName := 'A:TEST.TXT' + CHR(0);  { ASCIIZ file name      }ã        Reg.DS := SEG( FileName );          { file name segment     }ã        Reg.DX := OFS( FileName[1] );       { file name offset      }ã        Reg.CX := 0;                        { normal attribute      }ã        Reg.AH := $3C;                      { fn: create file       }ã        MsDos( Reg );                       { via Dos               }ã        {===========================================================}ã    IF (errNumber <> 0) THEN BEGINã        Write(#13#10#10,'For error #',errNumber,', user requested ');ã        CASE Mem[$40:$F0] OFã            0   : WriteLn('IGNORE');    { just your imagination     }ã            1   : WriteLn('RETRY');     { ... endless futility ?    }ã            2   : WriteLn('ABORT');     { DOS won't come back here! }ã            3   : WriteLn('FAIL');      { call technical support    }ã            END; {case}ã        END; {if errNumber<>0}ã    SetIntVec( $24, OldISR );           { must restore original ISR }ã END.ã{*******************************************************************}ãã Greg_ãã Jan.20.1993.Toronto.Canada.        greg.vigneault@bville.gts.orgã---ã * Baudeville BBS Toronto CANADA 416-283-0114 2200+ confsã * PostLink(tm) v1.04  BAUDEVILLE (#1412) : RelayNet(tm)ã             7      05-31-9308:08ALL                      GAYLE DAVIS              Int29 Char Capture       IMPORT              22     ®FQc ==============================================================================ã BBS: -=- Edge of the Century -=-ã  To: PERCY WONG                   Date: 03-22-93 (10:19)ãFrom: GAYLE DAVIS                Number: 4475   [140] PascalãSubj: Capturing Dos Output       Status: Publicã------------------------------------------------------------------------------ãPW>-> PW>  EXEC(GETENV(COMSPEC),' \C DIR'); { or whatever it is }ãPW>-> >can i then capture each line (or even one line) of the Dir output toããPercy or Kerry ??,ããAn elegant  way of accomplishing  your goal  is  to grap INT29.  This is anãUNDOCUMENTED  DOS function,  however, it's  really simple  to use. DOS usesãthis to write EVERYTHING to the screen.  The problem is that there is a LOTãof data  output when screen writing  takes place. If you  try to capture toãmuch you will  need LOTS of memory. However, short  output like your tryingãto get is OK.ããHere is some sample code that will let you capture output :ããã{$A+,B-,D+,E+,F-,G+,I+,L+,N-,O-,P-,Q-,R-,S+,T-,V-,X+,Y+}ã{$M 4096,0,400000}ããUses DOS,Crt;ããTypeã  ISRRegisters =ã    recordã      case Byte ofã        1 : (BP, ES, DS, DI, SI, DX, CX, BX, AX, IP, CS, Flags : Word);ã        2 : (j1,j2,j3,j4,j5 : Word; DL, DH, CL, CH, BL, BH, AL, AH : Byte);ã    end;ããCONSTãã  OrigInt29 : Pointer = nil;             {Old int 29 vector}ããVarã    grab  : Array[1..32768] Of Char;   { this MAY NOT be enough !!!     }ã    idx : LongInt;                     { if output EXCEEDS this, might  }ã                                       { lock up machine, so be careful }ã    S   : String;ã    I   : LongInt;ãã{ Here is the MAGIC }ãprocedure Int29(BP : Word); interrupt;ããvarã  Regs : ISRRegisters absolute BP;ããbeginããã Grab[Idx] := CHAR(Regs.AL);ã Inc(idx);ãã { WILL LOOSE OUTPUT, BUT BETTER THAN LOCKING MACHINE !!}ã If Idx > SizeOf(Grab) THEN Idx := 1;ãã ASMã PopFã call OrigInt29ã END;ããend;ããBEGINãã  GetIntVec($29, OrigInt29);ã  SetIntVec($29, @Int29);ããã  Clrscr;ã  Idx := 1;ãã  {Shell to DOS and run your program}ãã  SwapVectors;ã  Exec(GetEnv('COMSPEC'), '/c '+ YOURPROGRAM);ã  SwapVectors;ãã  { GRAB now contains ALL of our output }ãã  FOR I := 1 TO Idx DOã      BEGINã      If Grab[i] = #10 Then BEGINã                           WriteLn(S);ã                           S := ''ã                           END ELSE If Grab[i] <> #13 THEN S := S + Grab[i];ãã      END;ãã  { ABSOLUTELY MUST BE DONE !! }ã  if OrigInt29 <> nil then SetIntVec($29, OrigInt29);ãããUtiExprt: To be continued in next message ...ã---ã * T.I.F.S.D.B.(from MD,USA 301-990-6362)ã * PostLink(tm) v1.05  TIFSDBU (#1258) : RelayNet(TM)ã                                                                       8      08-17-9308:40ALL                      SWAG SUPPORT TEAM        Hooking an interrupt     IMPORT              27     ®FÕù PROGRAM CatchInt;ããUSESã   Crt,Dos,Printer;ãã{This program illustrates how you can modify anã interrupt service routine to perform specialã services for you.}ãã VARã    OldInt,OldExitProc: pointer;ã    IntCount: array[0..255] of byte;ãã PROCEDURE GoOldInt(OldIntVector: pointer);ã INLINE (ã    $5B/   {POP BX - Get Segment}ã    $58/   {POP AX - Get Offset}ã    $89/   {MOV SP,BP}ã    $EC/ã    $5D/   {POP BP}ã    $07/   {POP ES}ã    $1F/   {POP DS}ã    $5F/   {POP DI}ã    $5E/   {POP SI}ã    $5A/   {POP DX}ã    $59/   {POP CX}ã    $87/   {XCHG SP,BP}ã    $EC/ã    $87/   {XCHG [BP],BX}ã    $5E/ã    $00/ã    $87/   {XCHG [BP+2],AX}ã    $46/ã    $02/ã    $87/   {XCHG SP,BP}ã    $EC/ã    $CB);  {RETF}ããã {$F+}ãã PROCEDURE NewExitProc;ãã VAR I: byte;ã VAR A: char;ãã FUNCTION Intr21Desc(IntNbr: byte): string;ãã VARã    St : string[30];ãã BEGINã    CASE IntNbr ofã       $25: St := 'Set Interrupt Vector';ã       $36: St := 'Get Disk Free Space';ã       $3C: St := 'Create File with Handle';ã       $3E: St := 'Close FILE';ã       $40: St := 'WriteFile or Device';ã       $41: St := 'Delete FILE';ã       $44: St := 'IOCTL';ã       $3D: St := 'Open File with Handle';ã       $3F: St := 'Read File or Device';ã       $42: St := 'Move File pointer';ã    ELSEã	St := 'Unknown DOS Service'ã    END;ã    Intr21Desc := St;ã END;ããã FUNCTION DecToHex(Deci: byte): string;ãã CONSTã    ConvStr: string[16] = '0123456789ABCDEF';ã BEGINã    DecToHex := ConvStr[Deci div 16 + 1] +ã		ConvStr[Deci mod 16 + 1]ã END;ããã BEGINã      ClrScr;ã      ExitProc := OldExitProc;ã      SetIntVec($21,OldInt);ã      WriteLn('Int   #   Description');ã      WriteLn(' #  Times');ã      WriteLn;ã      FOR I:= 0 TO 255 DOã	 BEGINã	    IF IntCount[I] <> 0 THENã	       BEGINã		  Write(DecToHex(I),'H');ã		  Write(' ',IntCount[I]:3);ã		  GotoXY(11,WhereY);ã		  WriteLn(Intr21Desc(I))ã	       ENDã	 ENDã END;ããã PROCEDURE NewInt(AX,BX,CX,DX,SI,ã		  DI,SD,ES,BP: Word); INTERRUPT;ãã VAR AH: byte;ãã BEGINã   Sound(1220);Delay(10);NoSound;ã   AH := Hi(AX);ã   IntCount[AH] := IntCount[AH]+1;ã   GoOldInt(OldInt)ã END;ã {$F-}ãã{************ Main Program *****************}ãã VAR I: byte;ã     F: text;ã     TestStr: string[40];ãã BEGINãã   ClrScr;ãã{Install new Exit PROCEDURE}ãã   OldExitProc := ExitProc;ã   ExitProc := @NewExitProc;ãã{Install new Interrupt Vector}ãã   GetIntVec($21, OldInt);ã   SetIntVec($21, @NewInt);ãã{********  Testing Section  ***********}ãã   WriteLn('Starting Testing');Delay(1000);ãã   FillChar(IntCount,SizeOf(IntCount),#0);ãã   FOR I:= 0 TO 255 DOã   WriteLn('Testing 1');    {WriteLn's to screens}ã			    {do not use the 21H }ã			    {Interrupt		}ãã   Write('TYPE anything TO test keyboard: ');ã   ReadLn(TestStr);ãã   Writeln('Disk Size ',ã	    DiskSize(3));	{Uses Service 36H}ããã   Assign (F,'TestFile');ã   Rewrite(f);		    {Uses Service 3CH,44H}ãã   FOR I:=0 TO 255 DOã   WriteLn(F,'This is only A test'); {Service 40H}ã   WriteLn(F,'This is A test too');ã   WriteLn(f,'Last test');ãã   Close(f);		    {Uses Service 3EH,40H}ãã   Assign(F,'TestFile');ã   Append(f);	    {Uses Service 3DH,3FH,42H,44H}ã   Close(F);		    {Uses Service 3EH,40H}ãã   Assign(F,'TestFile');ã   Erase(f)			{Uses Service 41H}ã END.ã                                                                                                                       9      08-17-9308:44ALL                      CHRIS PRIEDE             Trapping Int21           IMPORT              22     ®FQc ===========================================================================ã BBS: Canada Remote SystemsãDate: 07-15-93 (18:15)             Number: 26295ãFrom: CHRIS PRIEDE                 Refer#: 26227ã  To: PIERRE DARMON                 Recvd: NO  ãSubj: DOS interrupt handler          Conf: (552) R-TPã---------------------------------------------------------------------------ãPD>What additional steps need to be taken for $21? I even tried to removeãPD>the clicking part, which boils down to installing a new handler that justãPD>calls the old one. Still no go. What's wrong?ããPD>My ultimate goal is to trap file opens (function 3Dh), check the SHAREingãPD>mode used (in AL), modify it if necessary, and execute the old handler.ãPD>Doesn't sound like a very complicated thing to do but ... I am stuck.ãã    Your handler is changing some registers or suffering from someãregisters being changed by INT 21. DOS EXEC service trashes everything,ãincluding SS:SP, for example. In my opinion, one can't write a stableãINT 21 handler in Pascal or any other HLL. HLL interrupt handlers areãusable to certain extent, but this is too low level.ãã    It can be done in BASM, though. We will declare interrupt handler asãsimple procedure with no arguments to avoid entry/exit code TP generatesãfor interrupt handlers. Our handler will force all files to be opened inãDeny Write mode (modify for your needs).ãããconstã  shCompatibility = $00;ã  shDenyAll       = $10;ã  shDenyWrite     = $20;ã  shDenyRead      = $30;ã  shDenyNone      = $40;ããprocedure NewInt21; assembler;ãasmã  cmp   ah, 3Dh         {open file?}ã  je    @CheckModeALã  cmp   ah, 6Ch         {DOS 4.0+ extended open?}ã  je    @CheckModeBL    {extended takes mode in BX}ã  jmp   @Chainãã@CheckModeAL:ã  and   al, 10001111b     {clear sharing mode bits}ã  or    al, shDenyWrite   {set to our mode}ã  jmp   @Chainãã@CheckModeBL:ã  and   bl, 10001111bã  or    bl, shDenyWriteã  jmp   @Chainãã@I21:ã  DD      0       {temp. var. for old vector -- must be in code seg.}ãã@Chain:ã  push  dsã  push  axã  mov   ax, SEG @Dataã  mov   ds, axã  mov   ax, WORD PTR OldInt21ã  mov   WORD PTR cs:[offset @I21], axã  mov   ax, WORD PTR OldInt21 +2ã  mov   WORD PTR cs:[offset @I21 +2], axã  pop   axã  pop   dsã  jmp   DWORD PTR cs:[offset @I21]ãend;ããã    To try this save old vector in a global variable named OldInt21 andãinstall this handler as usual. It also traps function 6Ch, DOS 4.0+ãextended open/create. Very few programs use it, but why not...ã---ã * Faster-Than-Light (FTL) þ Atlanta, GA þ 404-292-8761/299-3930ã * PostLink(tm) v1.06  FTL (#93) : RelayNet (tm)ã                                                                      10     08-27-9320:26ALL                      JONATHAN WRITE           Changing the Int08 Rate  IMPORT              18     ®FâÖ {ãJONATHAN WRIGHTãã> A/D (analog to digital conversion).  Somehow I need to use the PCã> clock/timer to call my A/D sampling interrupt at various rates fromã> several hundred Hz to several thousand Hz.ãã> Hook interrupt 1Ch and point it to your interrupt handler.  Useã> a counter in this procedure to count the number of interrupts orããThis will not work correctly.  Using interrupt 1Ch as it is normally set up,ãyour interrupt routine will only be called 18 times a second (18.2, actually),ãso you could get a maximum of 18.2 Hz.  If you wait until a counter in thisãinterrupt (incremented by 1 each time) reaches 1820, it will take 10 seconds!ãIt WON'T be 100 Hz.ããIn order to hook the timer interrupt at a rate above 18.2 Hz, you'll need toãrevector int 08h (which calls int 1Ch anyway).  You'll have to set up a counterãin int 08h which makes sure that the ORIGINAL int 08h routine is still calledã18.2 times a second.  The value for this counter will vary, depending on howãfast you set timer channel 0.  The system clock has a maximum resolution ofãabout 1.19318 Mhz and IRQ0 is normally called 1193180/65536 times per second.ããHere's some code for changing the clock rate (sorry but it's ASM):ã}ã;*********************ã; called by SetClockRate (which is Pascal callable)ããClkRate PROC NEARãã  push  axã  mov   al,36hã  out   43h,alã  pop   axã  out   40h,al  xchg  ah,alã  out   40h,alã  retãClkRate ENDPãã;******************ã; call this routine from TP as SetClockRate (Hz : WORD);ãSetClockRate PROC FARããRate EQU word ptr [bp+06]ã  push  bpã  mov   bp,spã  cmp   rate,0ã  je    SCR01ãã  mov   ax,65535ã  xor   dx,dxã  mov   bx,rateã  div   bxã  jmp   SCR02ããSCR01:ã  xor   ax,axããSCR02:ã  call  ClkRateãã  mov   sp,bpã  pop   bpã  ret   2ããSetClockRate ENDPããI pulled these procedures from some OLD code which I may have inadvertenlyãscrewed up over time, but it looks o.k.ã  Actually revectoring int 08h is a bit more complex - you MUST make sure theãold it 08 is called appropriately because it controls a number of systemãfunctions and your PC WILL lock up if it's not called.  I recommend finding aãbook to help with that part.ã                                  11     08-27-9320:39ALL                      BRYCE OSTENSON           Handling Ctrl-Break      IMPORT              10     ®F7£ {ãBRYCE OSTENSONãã> I am looking for a way to diable the use of the control break and controlã> alt delete features.ããBTW: Simple concept...  Here's how it works - When the program begins,ãSavedInt23 is assigned to the original C-Break interrupt...  When theãSetCtrlBreak procedure is called with Status equaling false, the C-Breakãinterrupt is assigned to a CBreakHandler which has no substance...  Thusãwhen C-Break is called it does nothing.  When SetCtrlBreak is calledãwith Status equaling false, Interrupt 23h is assigned to the defaultãC-Break handler.ã}ããUNIT TBUtil;ããINTERFACEããUsesã  Dos;ããVarã  SavedInt23 : Pointer;ã  CBreak     : Boolean;ããProcedure SetCtrlBreak(Status : Boolean);ãFunction  GetCtrlBreak : Boolean;ããIMPLEMENTATIONããProcedure CBreakHandler; INTERRUPT;ãBeginãEnd;ããProcedure SetCtrlBreak(Status : Boolean);ãBeginã  If Status thenã    SetIntVec($23, SavedInt23);ã  Elseã    SetIntVec($23, @CBreakHandler);ã  CBreak := Status;ãEnd;ããFunction GetCtrlBreak : Boolean;ãBeginã  GetCtrlBreak := CBreak;ãEnd;ããBeginã  CBreak := True;ã  GetIntVec($23, SavedInt23); { Save the Ctrl-Break handler. }ãEnd.ãã                           12     11-02-9305:56ALL                      CHRIS LAUTENBACH         Hooking an Interrupt     IMPORT              26     ®F
Ü {ãCHRIS LAUTENBACHããº I understand basically what you're saying - have a TSR/ISR defineãº Variables Within itself, then have any child processes hook into thoseãº Variables via an interupt inquiry. However, I'm still a bit fuzzy on it.ãº Could you provide an example, or a better definition?ãã    Here's an example of how to hook an interrupt....ã}ããUnit ExampleInt;  { Interrupt hooker example }ãã{ Written 08/15/93 by Chris Lautenbach.  Released to the public domain.     }ãã{ This Unit, when placed in the Uses clause of your main Program, will hook }ã{ Dos Interrupt 28h (Dos Idle) which is called by Dos when it isn't busy.   }ã{ Under normal circumstances, this will produce a sort of 'multitasking'    }ã{ effect when Dos calls it.  Make sure you call the NotBusy Procedure in    }ã{ any keyboard wait loops -- or any other loop that continues For a While,  }ã{ otherwise Dos will not get a chance to service Int 28h.                   }ãã{ In addition to hooking Int28h, it also provides a custom Exit Procedure   }ã{ to deactivate the interrupt.  In this manner, this Unit can be totally    }ã{ transparent to the Program it is included in -- even if the Program       }ã{ terminates With an error, the interrupt is always disconnected.           }ãã{ Access to IntStart and IntStop are provided thru the Interface section to }ã{ allow disabling of the interrupt -- in Case a Dos shell or similar        }ã{ operation is required.                                                    }ããInterfaceããUsesã  Dos, Crt;ããProcedure IntStart;                         { Hook interrupt 28h - internal }ãProcedure IntStop;                        { Unhook interrupt 28h - internal }ãProcedure NotBusy; Inline($CD/$28);           { Call the Dos Idle interrupt }ããVarã  Int28Orig,ã  OldExitProc : Pointer;ããImplementationããProcedure JmpOldISR(OldISR : Pointer);                 { Jump to an old ISR }ãInline ($5B/$58/$87/$5E/$0E/$87/$46/$10/$89/ã        $EC/$5D/$07/$1F/$5F/$5E/$5A/$59/$CB);ãã{$F+}ãProcedure Int28Handler(Flags,CS,IP,AX,BX,CX,DX,SI,DI,DS,ES,BP:Word);interrupt;ãbeginã  Inline($FA);                                        { Turn interrupts off }ãã  { ... your code goes here ... }ãã  Inline($FB);                                    { Turn interrupts back on }ã  JmpOldIsr(Int28Orig);            { Jump to the original interrupt address }ãend;ã{$F-}ããProcedure IntStart;ãbeginã  GetIntVec($28, Int28Orig);                  { Save original Int 28 vector }ã  SetIntVec($28, @Int28Handler);       { Install our cool new Int 28 vector }ãend;ãã{$F+}ãProcedure IntStop;ãbeginã  SetIntVec($28, Int28Orig);                       { Restore Int 28 handler }ãend;ããProcedure IntExit;ãbeginã  ExitProc := OldExitProc;                     { Restore old Exit Procedure }ã  IntStop;                                       { Deactivate our interrupt }ãend;ã{$F-}ããbeginã  OldExitProc := ExitProc;                     { Save the current Exit proc }ã  ExitProc := @IntExit;                         { Install our new Exit proc }ã  IntStart;                                      { Initialize our interrupt }ãend.ãã                                                                                                  13     11-02-9305:57ALL                      JON JASIUNAS             Writing an ISR           IMPORT              8      ®FYj {ãJON JASIUNASããWrite you're own ISR, and perform whatever action you want whenever theãuser presses the desired key(s).ã}ããVarã  OldInt9 : Pointer;  {- To save original int $09 address }ã  OldExit : Pointer;  {- To save original Exit proc }ããProcedure TempInt9;  INTERRUPT;ãbeginã  { Check For keypress }ã  { if pressed process and Exit }ã  { else call original int $09 to process keystroke }ãend; { TempInt9 }ããProcedure CustomExit;  Far;ãbeginã{-Restore original Exit proc }ã  ExitProc := OldExit;ãã{-Restore original int $09 }ã  SetIntVec($09, OldInt9);ãend;    { CustomExit }ããbeginã{-Save original Exit proc and install yours }ã  OldExit  := ExitProc;ã  ExitProc := @CustomExit;ãã{-Save original int $09 and install yours }ã  GetIntVec($09, OldInt9);ã  SetIntVec($09, @TempInt9);ãend.ãã                                                                                                        14     01-27-9412:09ALL                      DOUGLAS WEBB             Interrupt Jumping        IMPORT              12     ®Fk {ã If you have an interrupt handler and you want to jump to the originalã interrupt handler and NOT return to your handler.ããCall the following procedure with a pointer to the old interrupt handlerã(which you'd better have saved :-).ã}ããPROCEDURE JumpToInterrupt(oldvector : Pointer);ãINLINE(                        { Jump to old Intr from local ISR  }ã   $5B/                        { POP  BX IP part of vector     }ã   $58/                        { POP  AX CS part of vector     }ã   $87/$5E/$0E/                { XCHG BX,[BP+14] switch ofs/bx }ã   $87/$46/$10/                { XCHG AX,[BP+16] switch seg/ax }ã   $8B/$E5/                    { MOV  SP,BP                    }ã   $5D/                        { POP  BP                       }ã   $07/                        { POP  ES                       }ã   $1F/                        { POP  DS                       }ã   $5F/                        { POP  DI                       }ã   $5E/                        { POP  SI                       }ã   $5A/                        { POP  DX                       }ã   $59/                        { POP  CX                       }ã   $CB                         { RETF      Jump [ToOldVector]  }ã   );                          { to original timer vector      }ã{end JumpToInterrupt}ãã                                                                                                                          15     01-27-9413:33ALL                      GREG ESTABROOKS          Disable the pause key    IMPORT              38     ®FÜ¨ { Updated KEYBOARD.SWG on January 27, 1994 }ããUNIT NoPause;		{  Unit to disable the pause key                }ã			{  Last Updated  Apr 26/93                      }ã			{  Copyright (C) Greg Estabrooks, 1993          }ãINTERFACEã{***********************************************************************}ãUSES DOS;                       { IMPORT SetIntVec,GetIntVec.           }ãVARã     OldExit   :POINTER;        {  To hold pointer to old exit proc     }ã     OldInt09  :POINTER;        {  To hold old int 9h handler           }ããPROCEDURE ForgetPauses;ãFUNCTION PausePressed :WORD;    { Returns number of times pause was     }ã                                { Since last time ForgetPauses was called.}ã{***********************************************************************}ãIMPLEMENTATIONãVARã     NumPauses :WORD;           {  To hold number of times pause        }ã                                {  was pressed. Not Directly accessible }ã                                {  by other processes.                  }ãPROCEDURE ForgetPauses; ASSEMBLER;ã                       {  Routine to Clear Pause counter variable       }ãASMã  Mov NumPauses,0               {  Clear Pause Variable                 }ãEND;{ForgetPauses}ããFUNCTION PausePressed :WORD; ASSEMBLER;ã                      { Function to return number of times pause pressed}ãASMã  Mov AX,NumPauses              {  Load number of pauses into register  }ãEND;{PausePressed}ããPROCEDURE TrapPause; ASSEMBLER;ãASMã  Push DSã  Push AXã  Push ESã  Mov AX,Seg @Data              {  Allow us to access numpauses.        }ã  Mov DS,AXã  Mov AX,$40                    {  Point ES, to bios data area          }ã  Mov ES,AXã  Mov AH,ES:[$18]               {  Put keyboard shift flags into AH     }ã  And AH,8                      {  Clear all but potential pause flags  }ã  Or AH,0                       {  Check for zero                       }ã  Jz @NormalKey                 {  If it was zero pause wasn't pressed  }ã  Add NumPauses,1               {  Add 1 to number of pauses pressed    }ã  Mov AH,ES:[$18]               {  Load Flags again                     }ã  And AH,$F7                    {  Clear pause flags                    }ã  Mov ES:[$18],AH               {  Load new flags byte back into bios   }ã@NormalKey:ã  PushF                         {  Push flags onto stack                }ã  Call [OldInt09]               {  Call old Int 9h handler              }ã@Exit:ã  Sti                           {  Allow Interrupts                     }ã  Pop ES                        {  Restore registers that were used     }ã  Pop AXã  Pop DSã  IRet                          {  Return from interrupt                }ãEND;{TrapPause}ãã{$F+}ãPROCEDURE Restore_Pause;ã                       {  Routine to restore int 9  and exit pointers   }ãBEGINã  SetIntVec(9,OldInt09);        { Restore Int pointer to old pointer    }ã  ExitProc := OldExit;          { Restore Exit Pointer                  }ãEND;{Restore_Pause}ã{$F-}ããPROCEDURE InitTrap;ã                   {  Routine to set Int pointers to TrapPause          }ãBEGINã  GetIntVec(9,OldInt09);        {  Get pointer to Old Int 9h            }ã  SetIntVec(9,@TrapPause);      {  Point Int 9 to TrapPause             }ã  OldExit := ExitProc;          {  Save Old Exit Pointer                }ã  ExitProc := @Restore_Pause;   {  Set exit Pointer to new exit         }ãEND;{InitTrap}ããBEGINã  InitTrap;		        { Set up New Int 9h Handler             }ãEND.{***********************************************************************}ãPROGRAM ShowNoPause;            { Demo of NoPause Unit. Greg Estabrooks.}ãUSES CRT,                       { IMPORT Clrscr,KeyPressed,ReadKey.     }ã     NoPause;                   { Unit containing Pause routines.       }ãVARã   Misc :WORD;                  { Holds changing number to show the system}ã                                { is not paused.                        }ãBEGINã  Clrscr;                       { Clear screen clutter.                 }ã  ForgetPauses;                 { Clear the pauses number holder.       }ã  Misc := 0;                    { Clear Counter.                        }ã  REPEAT                        { Loop Until a key other than Pause is  }ã                                { pressed.                              }ã    GOTOXY(1,1);                { Always show info at top corner.       }ã    Write(Misc:8,'...  You have pressed pause ',PausePressed:3,' times.');ã    INC(Misc);                  { Increase counter to show a change.    }ã  UNTIL KeyPressed;ãEND.{ShowNoPause};ã{***********************************************************************}ã                                                                                                                 16     02-03-9411:04ALL                      SWAG SUPPORT TEAM        How to Grab Interrupts   IMPORT              13     ®F¡ Uses Dos;ãvarã     ExitSave,ã     BKDISave,ã     BKDIHandler       : Pointer;ã     Regs              : Registers;ã     Abort             : Boolean;ãã{$F+}ãprocedure NewCntlBreakHandler(Flags,CS,IP,AX,BX,CX,DX,SI,DI,DS,ES,BP:Word);ãinterrupt;ãbeginãinline($FA);  { disable interrupts }ã              { do nada widda data }      { OR DO ANYTHING YOU WANT }ãinline($FB);  { enable interrupts }ãAbort := True;         { Use this for (while NOT abort do..) }ãend;ããprocedure NewBKDIHandler(Flags,CS,IP,AX,BX,CX,DX,SI,DI,DS,ES,BP:Word);ãinterrupt;ãbeginãinline($FA);  { disable interrupts }ã              { do nada widda data }      { OR DO ANYTHING YOU WANT }ãinline($FB);  { enable interrupts }ãAX := 0;      {This must remain. An oversight in Turbo Pascal.}ãend;ããprocedure MyExit;ãbeginã     ExitProc := ExitSave;ã     SetIntVec($1B, BKDISave);ã     SetIntVec($24, BKDIHandler);ãend;ã{$F-}ãããbeginã     ExitSave := ExitProc;ã     ExitProc := @MyExit;ã     Regs.AH := $35;    { Get Cntl-Break Interrupt Vector }ã     Regs.AL := $1B;ã     Intr($21,Regs);ã     BKDISave := Ptr(Regs.ES, Regs.BX);ã     SetIntVec($1B, @NewBKDIHandler);ã     Regs.AH := $35;    { Get Cntl-Break Handler Interrupt Vector }ã     Regs.AL := $23;ã     Intr($21,Regs);ã     BKDIHandler := Ptr(Regs.ES, Regs.BX);ã     SetIntVec($23, @NewCntlBreakHandler);ãã     { Do whatever here. When finished, the old interrupt vectors areã       restored in the MyExit procedure }ãend.ãã                                                                                            17     02-09-9411:50ALL                      TIM MCKAY                Disabling The Ctrl-Alt-D IMPORT              50     ®F   ãunit NonStop;                         {Makes your program UNSTOPPABLE!}ããinterfaceãã varã   Intr09 : pointer absolute $0000:$0024; {Interrupt $09, keyboard ISR}ã   OldIntr09 : pointer;                   {Original Interrupt $09     }ããconstã   NoBoot  : boolean = true;              {flag to disable soft boot  }ã   NoBreak : boolean = true;              {flag to disable Ctrl-Break }ã   NoCtrlC : boolean = true;              {flag to disable Ctrl-C     }ãã procedure InstallNonStopISR;ã procedure NonStopExitProc;ããimplementationãã varã   PreNonStopExitProc : pointer;ãã constã   Installed : boolean = false;ãã procedure NonStopISR; External; {$L NonStop}ãã procedure InstallNonStopISR;ãã beginã  if not Installed thenã  beginã   OldIntr09 := Intr09;ã   inline($fa);                       {CLI - disable interrupts         }ã   Intr09 := @NonStopISR;              {Link NonStop into interrupt chain}ã   inline($fb);                       {STI - enable interrupts          }ã   PreNonStopExitProc := ExitProc;    {Save old ExitProc                }ã   ExitProc := @NonStopExitProc;      {Link in NonStopExitProc          }ã   Installed := true;ã  end;ã end;ãã procedure NonStopExitProc;ãã beginã  ExitProc := PreNonStopExitProc;      {Point ExitProc to next  }ã  inline($fa);                         {CLI - disable interrupts}ã  Intr09 := OldIntr09;                 {Restore Original Vector }ã  inline($fb);                         {STI - enable interrupts }ã end;ããend.ãã*XX3402-000419-090294--72--85-43138-----NONSTOP.OBJ--1-OF--1ãU+o+0qtjPbBoPr+iEJBBG6UU++++53FpQa7j623nQqJhMalZQW+UJaJmQqZjPW+n9X8NW-A+ãECblGoYQ0qtjPbBoPr+iEJBBQ6U1+21dH7M0++-cW+A+E84IZUM+-2F-J234a+Q+G++++U2-ã3NM4++F1HoF3FNU5+0WW++A-+N8A7U+4HYx0HoxI++RCHo7GFI39++RCHoBIIYl1++ZDH2F7ãHZFGA1Y+l7+F+++00YtDHZBIHp-7Ip6++++oW+E+E86-YO0V++6++-tEi+++XhUilUOR+CeEãznM0+Dwq+++iXkOS+0uD-e++Aw0CqDwq7+-M-HA+I6w47+-M5ls4I9V++6v+i+++XhUaWWMLã+61Y-61A+5FAt4+mt+ca++-o2mO87VQ+UCE6UAk+R+MwIrI0ulcmt+ca++-o-XnURE9f119Yã0WM++5END0tp3SFVWi+AUCNVVi1aDTek6CMUK+QTnzhM-lw6b0s+l+dI+gENJ+925ZE0m+BIã+QEE-U22l-E4+EH6D3E-l3A4+E52PUM-+gFw-U21m6c5+A2++U6++8c+ã***** END OF BLOCK 1 *****ããã{ ------------------------   ASSEMBLER MODULE  --------------------- }ã;ASM NONSTOP.PASããDATA    SEGMENT WORD PUBLICã        ASSUME DS:DATAãEXTRN   NoBoot    : BYTEãEXTRN   NoBreak   : BYTEãEXTRN   NoCtrlC   : BYTEãEXTRN   OldIntr09 : DWORDãDATA    ENDSããCODE    SEGMENT BYTE PUBLICã        ASSUME CS:CODEããNonStopISR PROC FARã           PUBLIC NonStopISRãã        push    ds                     ;This is the initialization codeã        push    ax                     ;It will be used only onceã        mov     ax, seg DATA           ;To fix up the far jumpã        mov     ds, ax                 ;put Global Data Segment in DSã        mov     cs:[JmpCode], 0eah     ;install far jump op codeã        push    [OldIntr09]            ;put pointer to old interrupt 09ã        pop     cs:Offs                ;in far jump offsetã        pop     cs:Segm                ;in far jump segmentã        xor     ax,ax                  ;point DS to interrupt vector tableã        mov     ds,ax                  ;ie, ds=0ã        push    ds:[24h]               ;Put offset of Int 09ã        pop     ax                     ;in axã        add     ax, Entry - NonStopISR ;Adjust past init codeã        push    axã        pop     ds:[24h]               ;revector to regular entry pointã        pop     axã        pop     dsãEntry:ã        push    dsã        push    esã        push    axã        mov     ax, 40h                ;point esã        mov     es, ax                 ;to BIOS data areaã        mov     ax, seg DATA           ;point dsã        mov     ds, ax                 ;to data segmentã        mov     ah, es:[17h]           ;put keyboard shift flags in axã        and     ah, 00000100b          ;mask out everything but ctrl flagã        or      ah, 00000000b          ;see if zeroã        jz      NormalKey              ;chain on if ctrl not pressedã        in      al, 60h                ;get make/break codeã        xor     ah, ah                 ;zero ahã        or      ah, NoBoot             ;Is flag set to disable soft boot?ã        jz      CheckBreak             ;No? Go check for breakã        mov     ah, es:[17h]           ;get keyboard shift flagsã        and     ah, 00001000b          ;mask out all but alt flagã        or      ah, 00000000b          ;is result zero?ã        jz      CheckBreak             ;go on to check for breakã        cmp     al, 53h                ;is it del make?ã        jnz     CheckBreak             ;no, chain on to old int 09ã        jmp short TossIt               ;Soft boot attempted - no dice!ãCheckBreak:ã        xor     ah, ah                 ;zero ahã        or      ah, NoBreak            ;Flag set to disable ctrl-break?ã        jz      CheckCtrlC             ;No? Go check for Ctrl-Cã        cmp     al, 0E0h               ;is it Break make?ã        jnz     CheckCtrlC             ;No? Go check for Ctrl-Cã        jmp short TossIt               ;Ctrl-Break attempted - toss it!ãCheckCtrlC:ã        xor     ah, ah                 ;zero ahã        or      ah, NoCtrlC            ;flag set to disabe ctrl-c?ã        jz      NormalKey              ;No? Chain on to old ISRã        cmp     al, 2Eh                ;C pressed?ã        jnz     NormalKey              ;No? Chain on to old ISRãTossIt:ã        in      al, 61h                ;read keyboard control portã        mov     ah, alã        or      al, 10000000b          ;set the "reset" bitã        out     61h, al                ;send it back to controlã        xchg    ah, al                 ;get back control valueã        out     61, al                 ;send it out alsoã        cliã        mov     al, 20h                ;send EOI to theã        out     20h, al                ;interrupt controllerã        pop     ax;ã        pop     es;ã        pop     ds;ã        iret                           ;LATER, DUDE!ãNormalKey:ã        sti                            ;allow interruptsã        pop     ax                     ;cleanup andã        pop     esã        pop     dsãJmpCode db      ?                      ;Far jump to old Int 09ãOffs    dw      ?ãSegm    dw      ?ããNonStopISR  ENDPãCODE    ENDSã        END     NonStopISRãã      18     05-26-9406:20ALL                      MAYNARD PHILBROOK        Screen Blanker-InterruptsSWAG9405            28     ®F   {ãVia SLMAIL v3.5C  (#2081)ã -=> Quoting Joe Irwin to Maynard Philbrook <=-ã JI> either inline code or assembler that could be compiled to obj andã JI> linked that would read the keyboard and if a key is not pressed in aã JI> variable or set amount of time jump to a procedure.  I'm talking aboutã JI> a tsr routine and what I have in mind is a tsr dos screensaver.  I'veã JI> been working on this forever and am just not good enough with interuptsã JI> or assembler to do it. I'm using tp 5.5 which does not support the asmã JI> command but inline(/) only.  Any help would be appreciated.ã JI> Joe Irwinã JI> -!- FMail 0.92ã JI>  ! Origin: MK Tech BBS-MK Software (513)237-7737 Dayton,OH HST/v32ã JI> (1:110/290)ã}ããUses dos,crt;ããConst Set_Time :Word = 100;      { 0 for no blanking }ãVarãTemp,Temp1 : Integer;ãC :Char;ãOld_Screen :Array[0..1999] of Word;ãOLD_INT9, OLD_INT8 :Pointer;ãNO_Pressed :Word;      { Counter }ãSaved_Flag :Word;       { varifie Flag }ãã{$F+}ãProcedure New_Int9; Assembler;     { all of this could be done in TASM }ãasm     Push   ES;ã       Push    DS;ã        Push   BX;ã        Push   AX;ã        Mov    AX, Seg NO_Pressed;ã        Mov    DS, AX;ã        Mov    AX, Set_TIme;ã        Mov    NO_Pressed, AX;ã        Mov    AX, Word [Old_INT9];ã        Mov     Word ptr CS:@Return, AX;ã        Mov    AX, Word [OLD_INT9+2];ã        Mov    Word ptr CS:@Return+2, AX;ã        Cmp    Word Ptr Saved_Flag, 00;ã        Je     @Done;ã       Mov     Word ptr Saved_Flag, 00;ã        Mov    BX, 3999;ã        Mov    AX, $B800;ã        Mov    ES, AX;ã@loop:ã       Mov     AL, byte [OLD_SCREEN+BX];ã       Mov     [ES:BX], AL;ã        Dec    BX;ã        Jnz    @Loop;ã        Mov    AL, byte [OLD_SCREEN+BX];ã        Mov    [ES:BX], AL;ã@Done:ã        Pop    AX;ã        Pop    BX;ã        Pop    DS;ã        Pop    ES;ã        Jmp  [Dword(@Return)];ã@Return:ã       DD      0;ãEnd;ããProcedure New_Int8; Assembler;ãASmã       Push    ES;ã       Push    DS;ã        Push    BX;ã        Push    AX;ã        Mov    AX, Seg NO_Pressed;ã        Mov    DS, AX;ã        Mov    AX, Word [Old_INT8];ã        Mov     Word ptr @Return, AX;ã        Mov    AX, Word [OLD_INT8+2];ã        Mov    Word ptr @Return+2, AX;ã        Cmp    NO_PRESSED, $00;ã        Je     @Done;ã        Dec    Word Ptr NO_PRESSED;ã        Jnz    @Done;ã        Mov    Saved_Flag, $01;ã       Mov     AX, $B800;ã        Mov    ES, AX;ã       Mov     BX, 3999;ã@loop:ã       Mov     AL, byte ptr [ES:BX];ã       Mov     byte  ptr OLD_SCREEN+BX, AL;ã        Mov    byte [ES:BX], 0 ;ã        Dec    BX;ã        Jnz    @Loop;ã        Mov    AL, byte ptr [ES:BX];ã        Mov    byte ptr OLD_SCREEN+BX, AL;ã@DONE:ã        Pop    AX;ã        Pop    BX;ã        Pop    DS;ã        Pop    ES;ã        Jmp    [Dword(@Return)];ã@Return:ã       DD      0;ãEnd;ããBEGINãã   Val(Paramstr(1), Temp, Temp1);ã   If Temp1 = 0 Then Set_Time := temp*18;ã   NO_PRESSED := Set_Time;ã   SAVED_FLAG := 00;ã   GetIntVec($08, OLD_INT8);ã   GetIntVec($09, OLD_INT9);ã   SetIntVec($09, @New_Int9);ã   SetIntVec($08, @New_Int8);ããã   While NOT Keypressed DO;ã   { process  your program here }ããSetIntVec($08, old_int8);      { to restore it back to normal }ãSetIntVec($09, old_int9);ãCLrScr;ãWriteLn(' Program Writen Bye Maynard A. Phibrook Jr. ');ãWriteLn('          1-203-456-2521  (1993)');ããEND.ã                                                                                                      19     05-26-9411:03ALL                      KEVIN MESS               Interrupt Table          SWAG9405            40     ®F   {$R-,S+,I+,D+,T+,F-,V+,B-,N-,L+ }ã{$M 4096,0,0 }ããprogram interrupt_table (input,output);ãã{ãã  A Program that displays all interrupt vectors.ãã  Version 1.00 - 03/10/88 - First releaseãã  Kevin Messã  PO Box 35ã  Boulder City, NV   89005ã  Compuserve 71121,3360ãã}ããusesã  crt,dos,cursors; { Cursors unit as written by Scott Bussinger }ããconstã  bell        = ^G;ããtypeã  string4     = string [4];ã  keyset      = (ESC,PGUP,PGDN,nothing);ã  pointer_rec = recordã                  case integer ofã                    0 : (address         : pointer);ã                    1 : (offset, segment : word)ã                end; { record }ã  screentype  = recordã                   position : array [1..4000] of byte;ã                   x,y      : byte;ã                end; { record }ãvarã  vector      : array [$00..$FF] of pointer_rec absolute $0000:0000;ã  colorscreen : screentype absolute $B800:0000;ã  monoscreen  : screentype absolute $B000:0000;ã  savedscreen : screentype;ã  intnumber   : byte;ã  finished    : Boolean;ãã{*************************************}ããfunction hex (decimal : word) : string4;ãã   constã      hexdigit  : array [$0..$F] of char = '0123456789ABCDEF';ãã   varã      temp    : string4;ãã   beginã      temp := '';ã      temp := hexdigit [ hi (decimal) div 16 ] +ã              hexdigit [ hi (decimal) mod 16 ] +ã              hexdigit [ lo (decimal) div 16 ] +ã              hexdigit [ lo (decimal) mod 16 ] ;ã      hex  := tempã   end;ãã{*************************************}ããprocedure frame (x1,y1,x2,y2 : byte);ãã   constã      upperleft  = #201;ã      lowerleft  = #200;ã      upperright = #187;ã      lowerright = #188;ã      horizontal = #205;ã      vertical   = #186;ãã   varã      i          : byte;ãã   beginã      gotoxy (x1-1,y1-1);ã      write  (upperleft);ã      gotoxy (x2+1,y1-1);ã      write  (upperright);ã      gotoxy (x1-1,y2+1);ã      write  (lowerleft);ã      gotoxy (x2+1,y2+1);ã      write  (lowerright);ã      for i := x1 to x2 doã         beginã            gotoxy (i,y1-1);ã            write  (horizontal);ã            gotoxy (i,y2+1);ã            write  (horizontal)ã         end;ã      for i := y1 to y2 doã         beginã            gotoxy (x1-1,i);ã            write  (vertical);ã            gotoxy (x2+1,i);ã            write  (vertical)ã         end;ã   end; { frame }ããã{*************************************}ããprocedure display_screen (first_intnumber : byte);ãã  varã     x,y,ã     last_intnumber,ã     intnumber      : byte;ãã  begin { display_screen }ã     last_intnumber := first_intnumber + $3F;ã     x := 5;ã     y := 1;ã     for intnumber := first_intnumber to last_intnumber doã       with vector [intnumber] doã         beginã           gotoxy (x,y);ã           write (copy(hex(intnumber),3,2),hex(segment):6,':',hex(offset));ã           inc (y);ã           if ((intnumber + 1) mod $10) = 0 thenã             if intnumber <> last_intnumber thenã                beginã                  inc (x,19);ã                  y := 1ã                endã         end; { with }ã  end; { display_screen }ããã{*************************************}ãããfunction endkey : keyset;ãã   varã     anykey : char;ã     exit   : keyset;ãã   beginã     repeatã        exit := nothing;ã        anykey := readkey;ã        if anykey = #0 thenã           anykey := readkey;ã        case anykey ofã           #27 : exit := ESC;ã           #73 : exit := PGUP;ã           #81 : exit := PGDN;ã           else  write (bell);ã        end; { case }ã     until exit in [ESC,PGUP,PGDN];ã     endkey := exitã   end;ãã{*************************************}ããprocedure int_table (intnumber : byte);ãã   begin { int_table }ã      if monodisplay thenã         savedscreen := monoscreenã      elseã         beginã            savedscreen := colorscreen;ã            textcolor (white);ã            textbackground (blue)ã         end;ã      savedscreen.x := wherex;ã      savedscreen.y := wherey;ã      makecursor (nocursor);ã      frame  (2,2,79,19);ã      window (2,2,79,19);ã      clrscr;ã      gotoxy (12,18);ã      write ('PgUp - Previous Page,  PgDn - Next Page,  Esc to Exit');ã      finished  := FALSE;ã      repeatã         display_screen (intnumber);ã         case endkey ofã            PGUP : if intnumber >= $40 thenã                      dec (intnumber,$40)ã                   elseã                      intnumber := $C0;ã            PGDN : if intnumber <= $80 thenã                      inc (intnumber,$40)ã                   elseã                      intnumber := $00;ã            ESC  : finished := TRUEã         end { case }ã      until finished;ã      window (1,1,80,25);ã      if monodisplay thenã         monoscreen := savedscreenã      elseã         colorscreen  := savedscreen;ã      gotoxy (savedscreen.x,savedscreen.y);ã      makecursor (restorecursor)ã   end;  { int_table }ãã{*************************************}ãããbegin { main }ã   intnumber := $00;ã   int_table (intnumber)ãend. { main }ã                                                    