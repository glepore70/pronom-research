SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00012         COMMAND LINE ROUTINES                                             1      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Get Command line INFO    IMPORT              15     !}πì {„> This leads me to a question that I've often wondered about, but never„> Really bothered to ask anyone: why use a delimiter (commonly '/' or '-')„> preceeding the parameter option?„„How would you parse the following command tail:„„COPY XYZZY.PAS V:\/S/P/O„„if it was entered as„„COPY XYZZY.PAS V:\SPO„„The delimiter is there to - yes - delimit the parameter from the Text preceding„it.„„(and BTW: All the code examples shown here won't take care of this problem,„since they don't allow imbedded parameters. Try this one instead:)„}„„Function CAPS(S : String) : String; Assembler;„Asm„  PUSH    DS„  LDS     SI,S„  LES     DI,@Result„  CLD„  LODSB„  STOSB„  xor     CH,CH„  MOV     CL,AL„  JCXZ    @OUT„@LOOP:  LODSB„  CMP     AL,'a'„  JB      @NEXT„  CMP     AL,'z'„  JA      @NEXT„  SUB     AL,20h„@NEXT:  STOSB„  LOOP    @LOOP„@OUT:   POP   DS„end;„„Function Switch(C : Char) : Boolean;„Var„  CommandTail         : ^String;„  P                   : Word;„„begin„  CommandTail := PTR(PrefixSeg, $0080);„  P := POS('/' + UpCase(C), CAPS(CommandTail^));„  if P = 0 then„    Switch := False„  ELSE„  begin„    Switch := True;„    DELETE(CommandTail^, P, 2)„  end„end;„„{„The CAPS routine only converts the 'a' to 'z' range (I have one in my library„that converts all international Characters, but this was a simple one I could„Type in without looking in my library).„„The Switch Function also has the added benefit that it strips off the switch„from the command line after having tested For it. This way, you should Program„your Programs in the following way:„„[...]„}„begin„  GetSwitchs;„  CopyFile(ParamStr(1),ParamStr(2))„end.„„{„and the switches can then be at ANY place on the command line, and the Program„will still Function correctly.„}                                                2      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Get Command Line         IMPORT              5      !}çX {There are basically two ways of retrieving the command line. One way is to use„the ParamStr Variable: ParamStr(1) contains the first paramter, ParamStr(2)„contains the second parameter etc. Another way is to fetch the entire command„line String from your environment. This can be done as follows:„}„„Program GetCommandLine;„„Type„„  PCommandLine = ^TCommandLine;„  TCommandLine = String;„„Var„„  CommandLine : PCommandLine;„„begin„  CommandLine := Ptr ( PrefixSeg, $80 );„end.„                                  3      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Get Command Line #2      IMPORT              10     !}≤ {„ In TP there is, of course, ParamCount and ParamStr.„„ The actual command line can be found in the PSP segment, at offset„ $80 (hexadecimal).  The Byte at $80 contains the count of Characters,„ including the leading delimiter Character (usually a space).„„ In TP the PSP segment may be accessed using PrefixSeg.  Note that TP„ omits the carriage-return that normally appends the input Character„ line.  This is a problem For Programs that look For it as the end of„ the String.„„ If you're using a non-TP compiler, you'll need to get the PSP segment„ value via a Dos Function $62 call.„„ Here's a simple TP Program to illustrate.  Compile it, then invoke„ it With some command-line input...„}„(*********************************************************************)„Program CommandLine;    { CL.PAS }„Var„  CharCount, i : Word;„begin„  CharCount := Mem[PrefixSeg:$80];  { number of input Characters }„  WriteLn('Input Characters: ', CharCount );„  For i := 1 to CharCount DO„    Write( CHR( Mem[PrefixSeg:$80+i] ));„  WriteLn;„end.„(*********************************************************************)„                                               4      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Get Command Line #3      IMPORT              4      !}ñ˘ Program CommandLine;    { CL.PAS }„Var„  CharCount,„  i         :Word;„begin„  CharCount := Mem[PrefixSeg:$80];  { number of input Characters}„  WriteLn('Input Characters: ', CharCount );„  For i := 1 to CharCount do Write( CHR( Mem[PrefixSeg:$80+i] ));„    WriteLn;„end.„„„„„                                                                                                            5      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Parse Command Line       IMPORT              249    !}f¸ {*************************************************************************)„            Program name: Command parse sub routines„                  Author: Kenneth W. Fox„                          1449 Maple Rd.„                          KintnersVille Pa. 18930„                          USA„           Date Started : 5 AUG 1992„           Date finished: 10 jan 1993„           date last Rev: 20 JAn 1993„*************************************************************************„„Commandline args:„-----------------„NONE„„Description of Program:„-----------------------„set of  Procedures to handle all commandline Parameters With or without regard„to Case -- selected by the Boolean Var Nocase -- if True then  everrything„is converted to uppercase prior to testing„„all arguments returned from switches are left in whatever Case they were„entered on the commandline unless ConvertArgsToUpper is set to True.„„Includes following Procedures:„„Procedure NAME          : PURPOSE„------------------------:-------------------------------------------------„ FnameCheck             : to validate Program name„                          stops people from renanming the Program  if you don't„                          want them to -- if you don't care then don't call„                          this routine.„„ DispCmdline            : use to display commandline parameters when debugging„„ ConvertArgtoNumber     : converts specified arg from a String to a numeric„                          value.„„ CheckHelp              : routine to check to see if the Strings designated„                          as commandline help Strings are present or not.„                          the use of this routine requires the File„                          Helpuser.pas. Additionally this routine checks to„                          see if the 'info' switch was present -- conveniaet„                          way to display registration info in share ware..„„„ CmdParse               : main routine to parse command line-- this Procedure„                          is called With Various arguments to alter the content„                          of the CmdArray data structure.„„„„Additonal mods to be made:„---------------------------„1) add subroutine in cmdline parser to capture delimited Strings (such as„those between quotes)„„2) add subroutine to check if any items one the commandline besides the valid„switches and such were present --„„to be used For spotting invalid commandline parameters return value should„be Boolean invalid and the paramString(#)...„„NOTES: may run into trouble writing the routine when the delimited Strings„Function  is added.. possible errors include capturing elements of the„delimited String as invalid args -- will also check For no closing delimiter..„„3) develop a version of the cmd line parser which Uses a linked list instead„of a set of Arrays to save the values in -- will save some memory..„„4) convert the whole Procedure to an itelligent macro which merely requires„a list of the command args (doesn't use a fixed Array size -- will„dynamically allocate space based on number of arguments specified in the„arg pickup header File. regrettably , some form of header File will need„to be used in order to specify what will be searched For --„„5) a possible solution is a way to make a mini compiler macro which will„read in the switches to be processed from a File along With definitions„„eventually convert the whole thing into a Unit // overlay .„„„Rev History:„------------„„notes on errors -- if  the switch Strings are not Varying their length„ when Const SwitchLength is changed, then the $I CmdParse.H File is not„in the correct path„„ remember that the commandArray initialization Procedure is in the„CmdParse.h File and the appropriate adjustments to the qty and values of„the switches need to be made there .. if you are experiencing problems„ With the capture of switches, ensure that you ahe init'd you Array values„correctly„„ added Boolean present field For argdsw Array„„9/5/92 -- moved the call to initCmdArray from the calling routine into the„          initialization section of cmdparse.pas -- because i forgot to add„          it to chkLabel.pas and was going nuts tring to find the error.„          live and learn.„„9/5/92 -- added the DispCmdline Procedure as a result of the above session„          of psychosis..„„9/6/92 -- re organized cmdparse.pas into more subroutines -- made it easier„          to follow what was going on.. also added removeable code to„          implement a delimited String parser.. this routine will need to„          access the commandline directly instead of using the ParamStr()„(99 min left), (H)elp, More?           Function of turbo.„„9/6/92 -- added the ConvertArgtoNumber  routine„          **** NOTE ***** "HelpUser" is a Procedure I add to all Programs„          which use command line args or otherwise -- I normally use an„          $I IncludeFile to implement it.. the Include Staement MUST„          occur BEFORE the include StaTement For CmdParse.pas File..  or„          you can delete the reference to the File from the Program„„9/6/92 -- added the standard help codes to the switches Array in cmdParse.H„          ( /? , /h , /H , help , HELP ).„„9/6/92 -- added FnameCheck to this File-- FnameCheck requires a Constant or„          String called "ProgName" containing the name of the MAIN Program„          it checks the ParamStr(0) to verify that the Filename of the„          Program has not been renamed -- useful For copyright purposes,„          annoying to users.. use at own peril„„9/6/92 -- updated header File to list Procedures avail in cmdparse.pas„„1/8/93 -- added the info switch to and DisplayInfo routines to show„          registration / info request address.„„„end desc.„}„„{HEADER File For cmdparse.pas -- include in Calling File   }„„{PROGNAME.pas}  {<<<<----- Program using this header File   }„{ 20 Jan 1993} {<<<<----- date this File last changed      }„{ Ken Fox    }  {<<<<----- Person who last updated this File}„„(*„Uses Dos,Crt;„„Const„  VersionNum = 'V1.0 BETA';„  ProgNameStr = 'NEWPROJ.EXE';„  ProgNameShortStr = 'NP.EXE';„  copyRightStr = ProgNameStr+' ' + VersionNum +„                ', Copyright 1992 - 1993, Ken Fox. All Rights Reserved.';„„  DefaultFileName = 'NEWPROJ.DAT';„„*)„„{--------------------------------------------------------------------------}„{                          procs Available in CmdParse.H                   }„{ Procedure   initCmdArray(Var CmdArray : CommandLineArrayType);           }„{   this proc is included in ths File becuase the args to check For are    }„{ part of the calling routine, not the parser itself. note that the excess }„{ switches are commented out and will there For not compile but it will    }„{ make it easier to add stuff in the future should you so desire           }„{--------------------------------------------------------------------------}„{                          procs Available in CmdParse.Pas                 }„{ additional info on the following procs may be found in the cmdparse.Pas  }„{ File in the ....\tp\include directory..                                  }„{                                                                          }„{ Procedure DispCmdline;                                                   }„{                                                                          }„{ Procedure CmdParse(Var CmdArray : CommandLineArrayType;                  }„{                            NoCase,                                       }„{                            ConvertArgsToUpper   : Boolean );             }„{                                                                          }„{ Procedure ConvertArgtoNumber(ArgNum : Integer;                           }„{                             Var  CmdArray : CommandLineArrayType;        }„{                             Var  ResultNumber: Word);                    }„{                                                                          }„{ Procedure FnameCheck(progname , progname2 :pathStr;                      }„{                      errorlevel : Byte);                                 }„{                                                                          }„{ Procedure CheckHelp;                                                     }„{                                                                          }„{--------------------------------------------------------------------------}„„Const„SwitchLength = 4;   {   maxlegth of a switch to be tested for}„ArgLength = 11;     {   max length of an argument from the commandline}„DelimLength = 1;     {   maxlength of delimiter if used}„SwitchNum = 6;      {   the number of switches and hence the size of the Array}„                    {      of switches  without arguments                  }„ArgdSwitchNum = 2;  {   the number of switches and hence the size of the Array}„                    {      of switches  With arguments                 }„DelimNum = 1;       {   number of args With delimited Strings          }„„„Type„SwitchType = String[Switchlength];„ArgType = String[ArgLength];„DelimType = String[DelimLength];„„SwitchesType = Record„         Switch : Array[1..SwitchNum] of SwitchType;„         Present : Array[1..switchNum] of Boolean„         end;„„SwitchWithArgType = Record„              Switch  : Array[1..ArgdSwitchNum] Of SwitchType;„              Arg     : Array[1..ArgdSwitchNum] Of ArgType;„              Present : Array[1..ArgdSwitchNum] of Boolean„              end;„„SwitchedArgWithEmbeddedSpacesType = Record„              Switch     : Array[1..DelimNum] Of SwitchType;„              StartDelim : Array[1..DelimNum] of DelimType;„              Arg        : Array[1..DelimNum] Of ArgType;„              endDelim   : Array[1..DelimNum] of DelimType;„              Present    : Array[1..DelimNum] of Boolean„              end;„„„CommandLineArrayType = Record„           Switches : SwitchesType;„           ArgDSw   : SwitchWithArgType;„           {    DelimSw  : SwitchedArgWithEmbeddedSpacesType; }„           NoParams : Boolean           {True if nothing on commandline}„           end;„„Var„NoCase,„ConvertArgsToUpper„                  : Boolean;„„CmdArray                : CommandLineArrayType;„„Procedure   initCmdArray(Var CmdArray : CommandLineArrayType);„„begin„   {DEFAULT VALUES SET}„   NoCase := True;„   ConvertArgsToUpper := True;„„with CmdArray do„   begin„   Switches.Switch[1] := '/?' ;     {default help String}„   Switches.Switch[2] := '/h' ;     {default help String}„   Switches.Switch[3] := '/H' ;     {default help String}„   Switches.Switch[4] := 'HELP' ;   {default help String}„   Switches.Switch[5] := 'help' ;   {default help String}„   Switches.Switch[6] := 'INFO'     {show author contact Info}„„{   Switches.Switch[6] := '  ' ;}   {NOT USED}„{   Switches.Switch[7] := '  ' ;}   {NOT USED}„{   Switches.Switch[8] := '  ' ;}   {NOT USED}„{   Switches.Switch[9] := '  ' ;}   {NOT USED}„{   Switches.Switch[10] := '  ' ;}  {NOT USED}„{   Switches.Switch[11] := '  ' ;}  {NOT USED}„{   Switches.Switch[12] := '  ' ;}  {NOT USED}„„{  ArgDSw.Switch[1] := '' ;}       {not used}„{  ArgDSw.Switch[2] := '' ;}       {not used}„{  ArgDSw.Switch[3] := '' ;}       {NOT USED}„{  ArgDSw.Switch[4] := '' ;}       {NOT USED}„{  ArgDSw.Switch[5] := '' ;}       {NOT USED}„{  ArgDSw.Switch[6] := '' ;}       {NOT USED}„{  ArgDSw.Switch[7] := '' ;}       {NOT USED}„{  ArgDSw.Switch[8] := '' ;}       {NOT USED}„{  ArgDSw.Switch[9] := '' ;}       {NOT USED}„{  ArgDSw.Switch[10] := '' ;}      {NOT USED}„{  ArgDSw.Switch[11] := '' ;}      {NOT USED}„{  ArgDSw.Switch[12] := '' ;}      {NOT USED}„{  ArgDSw.Switch[13] := '' ;}      {NOT USED}„(*„With DelimSw Do„{     Switch[1]     := '' ;     }  {NOT USED}„{     StartDelim[1] := '' ;     }  {NOT USED}„{     endDelim[1]   := '' ;     }  {NOT USED}„{     Switch[2] := '' ;         }  {NOT USED}„{     StartDelim[2] := '' ;     }  {NOT USED}„{     endDelim[2]   := '' ;     }  {NOT USED}„„{     Switch[3] := '' ;         }  {NOT USED}„{     StartDelim[3] := '' ;     }  {NOT USED}„{     endDelim[3]   := '' ;     }  {NOT USED}„„{     Switch[4] := '' ;         }  {NOT USED}„{     StartDelim[4] := '' ;     }  {NOT USED}„{     endDelim[4]   := '' ;     }  {NOT USED}„„{     Switch[5] := '' ;         }  {NOT USED}„{     StartDelim[5] := '' ;     }  {NOT USED}„{     endDelim[5]   := '' ;     }  {NOT USED}„„{     Switch[6] := '' ;         }  {NOT USED}„{     StartDelim[6] := '' ;     }  {NOT USED}„{     endDelim[6]   := '' ;     }  {NOT USED}„„{     Switch[7] := '' ;         }  {NOT USED}„{     StartDelim[7] := '' ;     }  {NOT USED}„{     endDelim[7]   := '' ;     }  {NOT USED}„„{     Switch[8] := '' ;         }  {NOT USED}„{     StartDelim[8] := '' ;     }  {NOT USED}„{     endDelim[8]   := '' ;     }  {NOT USED}„„{     Switch[9] := '' ;         }  {NOT USED}„{     StartDelim[9] := '' ;     }  {NOT USED}„{     endDelim[9]   := '' ;     }  {NOT USED}„„{     Switch[10] := '' ;        }  {NOT USED}„{     StartDelim[10] := '' ;    }  {NOT USED}„{     endDelim[10]   := '' ;    }  {NOT USED}„„{     Switch[11] := '' ;        }  {NOT USED}„{     StartDelim[11] := '' ;    }  {NOT USED}„{     endDelim[11]   := '' ;    }  {NOT USED}„(99 min left), (H)elp, More? „{     Switch[12] := '' ;        }  {NOT USED}„{     StartDelim[12] := '' ;    }  {NOT USED}„{     endDelim[12]   := '' ;    }  {NOT USED}„„{     Switch[13] := '' ;        }  {NOT USED}„{     StartDelim[13] := '' ;    }  {NOT USED}„{     endDelim[13]   := '' ;    }  {NOT USED}„„{     Switch[14] := '' ;        }  {NOT USED}„{     StartDelim[14] := '' ;    }  {NOT USED}„{     endDelim[14]   := '' ;    }  {NOT USED}„end {with DelimSw }„*)„end; {WITH CmdArray}„„end;„„Procedure CmdParse(Var CmdArray : CommandLineArrayType;„                             NoCase,„                             ConvertArgsToUpper   : Boolean );„„{ Procedure to handle all commandline Parameters With or without regard }„{to Case -- selected by the Boolean Var Nocase -- if True then  everrything}„{is converted to uppercase prior to testing}„„{all arguments returned from switches are left in whatever Case they were }„{entered on the commandline unless ConvertArgsToUpper is set to True.}„„Const„   Blank = ' ';„„Var„   counter                 : Integer;„   Blanks                  : ArgType;„„{+++++++++++++++++++++++  Private Procedures to CmdParse Main  +++++++++++++}„Procedure ConvertArgsToUpperCase(Var CmdArray:CommandLineArrayType);„Var„  Counter,„  Counter2   : Integer;„begin   {--------->>>> ConvertArgsToUpperCase <<<<------------}„„  For Counter := 1 to ArgDSwitchNum Do„      For Counter2 := 1 to Length(CmdArray.ArgDSw.Arg[counter]) DO„          CmdArray.ArgDSw.Arg[counter,Counter2] :=„                UPCASE(CmdArray.ArgDSw.Arg[counter,Counter2] );„„end;    {--------->>>> ConvertArgsToUpperCase <<<<------------}„„{----------------------------------------------------------------------}„Procedure ConvertSwitchesToUpperCase(Var CmdArray:CommandLineArrayType);„Var„  Counter,„  Counter2   : Integer;„„begin  {--------->>>> ConvertSwitchesToUpperCase  <<<<------------}„   For Counter := 1 to SwitchNum Do„      begin„      For Counter2 := 1 to Length(CmdArray.Switches.Switch[counter]) DO„          CmdArray.Switches.Switch[counter,Counter2] :=„             UPCASE(CmdArray.Switches.Switch[counter,Counter2]);„      end;„   For Counter := 1 to ArgDSwitchNum Do„      For Counter2 := 1 to Length(CmdArray.ArgDSw.Switch[counter]) DO„          CmdArray.ArgDSw.Switch[counter,Counter2] :=„                UPCASE(CmdArray.ArgDSw.Switch[counter,Counter2] );„„end;  {--------->>>> ConvertSwitchesToUpperCase  <<<<------------}„„{----------------------------------------------------------------------}„„Procedure InitializeArrays(Var CmdArray:CommandLineArrayType;„                           Var Nocase : Boolean  );„Var„   Counter„          : Integer;„„begin     {--------->>>> InitializeArrays  <<<<------------}„„  cmdArray.NoParams := False;„  For Counter := 1 to SwitchNum Do„    CmdArray.Switches.present[counter] := False;„  For Counter := 1 to ArgDSwitchNum Do„    begin„       CmdArray.ArgDSw.present[counter] := False;„       CmdArray.ArgDSw.Arg[counter] := Blanks;„    end;„  if NoCase then                           {convert all Switches in CmdArray}„     ConvertSwitchesToUpperCase(CmdArray); {to uppercaseif nocase is set to }„                                           {True}„end;       {--------->>>> InitializeArrays  <<<<------------}„{----------------------------------------------------------------------}„Procedure ParseNow(Var CmdArray:CommandLineArrayType;„                           Var Nocase : Boolean  );„Var„Counter,Counter2,„Start,„SwitLen,CurrentArgLen   : Integer;„Blanks                  : ArgType;„TestStr                 : SwitchType;„WorkStr                 : String;„„Label„   Next_Parameter;„„begin   {--------->>>> ParseNow <<<<------------}„  {check For switches without args first}„„  For counter := 1 to ParamCount Do„    begin  {number of Parameters Loop}„       TestStr:= ParamStr(counter);„„       if Nocase Then    { covert paramStr(counter) to upper Case if NoCase}„          begin          { is set to True}„            WorkStr := TestStr;„            For Counter2 := 1 to SwitchLength DO„                TestStr[counter2]  := UPCASE((WorkStr[counter2]));„          end;„„      For Counter2 := 1 to SwitchNum Do„           begin  { Switches without arguments loop }„              SwitLen := Length(CmdArray.Switches.Switch[Counter2]);„              if CmdArray.Switches.Switch[Counter2] =„                    Copy(TestStr,1,SwitLen) then„„                    begin„                       CmdArray.Switches.Present[Counter2] := True;„                       Goto Next_Parameter;„                     end;„           end; { Switches without arguments loop }„„       For counter2 := 1 to ArgDSwitchNum  Do„           begin     { Switches With arguments test loop }„„              SwitLen := Length(CmdArray.ArgDSw.Switch[Counter2]);„              if CmdArray.ArgDSw.Switch[Counter2] =„                    Copy(TestStr,1,SwitLen) then„„                 begin„                    CmdArray.ArgDSw.present[Counter2] := True;„                    Start := length(CmdArray.ArgDSw.Switch[Counter2]) + 1;„                    CurrentArgLen := length(paramStr(counter)) - (start-1);„                    CmdArray.ArgDSw.Arg[Counter2] :=„                          Copy(ParamStr(Counter),Start,CurrentArgLen);„„                    Goto Next_Parameter; {used inplace of an Exit}„                 end;„           end;     { Switches With arguments test loop }„„    next_parameter:; {used to speed up execution -- Exit doesn't work here}„„    end;        {number of Parameters Loop}„„end;    {--------->>>> ParseNow <<<<------------}„„Procedure Parsedelimited(Var CmdArray : CommandLineArrayType;„                             NoCase,„                             ConvertArgsToUpper   : Boolean );„„{this Procedure will bag any String on the commandline With embedded spaces}„(*  and is delimited by Characters such as "" , {}, [], (), <>, ^^, etc ...*)„„„begin    {--------->>>> Parsedelimited <<<<------------}„end;     {--------->>>> Parsedelimited <<<<------------}„{----------------------------------------------------------------------}„„{+++++++++++++++++++ end  Private Procedures to CmdParse Main  +++++++++++++}„„{==================================== MAIN Procedure ===================}„begin           {+++++++++>>>> Procedure CmdParse  <<<<++++++++++++}„  {Init Arrays}„  For counter := 1 to ArgLength do      {  the String Blanks needs to be }„      Blanks[Counter] := Blank;         {  global because most routines  }„                                        {  are useing it                 }„„  InitCmdArray(CmdArray); { this Procedure located in the cmdparse.h File}„                          { assigns values to switches, etc.}„„  InitializeArrays(CmdArray,NoCase);„„„„  If ParamCount = 0 then                { check command line For null String}„     begin                              { if nullString then set No Params  }„        cmdArray.NoParams := True;      { and return to the calling routine }„        Exit;„     end;„„„   ParseNow(CmdArray, Nocase);           { routine parses the commandline   }„                                         { passing through the switches w/o }„                                         { arguments first. When Delimited  }„ { If Not(NoDelimited) then }            { switch parsing is added, it will }„   { Parsedelimited(CmdArray,NoCase);}   { occur after all other parsing    }„                                         { as a seperate routine to follow  }„                                         { PARSENOW -- additionally -- add  }„                                         { Boolean Value "NoDelimited" to   }„                                         { calling routine and Cmdparse.h   }„                                         { to bypass checking For delimited }„„  if ConvertArgsToUpper then„       ConvertArgsToUpperCase(CmdArray);„„„end;     {+++++++++>>>> Procedure CmdParse  <<<<++++++++++++}„„{======================  end CmdParse MAIN Procedure ===================}„„{ /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\}„{                    Parser Utility routines                            }„{ /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\}„„Procedure ConvertArgtoNumber(ArgNum : Integer;„                             Var  CmdArray : CommandLineArrayType;„                             Var  ResultNumber: Word);„Var„  code : Integer;„„begin    {----------->>>> ConvertArgtoNumber <<<<---------------}„„  Val(CmdArray.ArgDsw.Arg[ArgNum],ResultNumber,code);„    if code <> 0 then„       begin„          WriteLn('Error commandline argument: ',„                       CmdArray.ArgDsw.Switch[ArgNum],'  ',„                       CmdArray.ArgDsw.Arg[ArgNum]);„          Writeln('press enter to continue');„          readln;„          HelpUser;  {see notes}„       end;„„end;     {----------->>>> ConvertArgtoNumber <<<<---------------}„„{/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\}„„Procedure FnameCheck(progname, progname2 :pathStr;„                     errorlevel : Byte);„Var„teststr1,teststr2 :pathStr;„„begin    {----------->>>> FnameCheck <<<<---------------}„„teststr1 := copy(paramstr(0),(length(paramstr(0)) - (Length(progname)-1) ),„                             Length(progname));„teststr2 := copy(paramstr(0),(length(paramstr(0)) - (Length(progname2)-1) ),„                             Length(progname2));„„if ((teststr1 <> ProgName) and (teststr2 <> ProgName2))„   then„     begin„     WriteLn('Unrecoverable Error in ',progname, ', Check FileNAME');„     halt(Errorlevel);„     end;„„end;     {----------->>>> FnameCheck <<<<---------------}„„{/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\}„„Procedure DispCmdline;„     { use For debugging -- displays the command line parameters}„     { readln at end shows screen Until enter is pressed}„VAr Count : Integer;„begin„ClrScr;„„For Count := 1 to  SwitchNum do„    if CmdArray.Switches.present[count] then„       WriteLn(CmdArray.Switches.Switch[count],'    Present');„„For Count := 1 to ArgdSwitchNum  do„    if CmdArray.ArgDsw.present[count] then„       begin„          WriteLn(CmdArray.ArgDsw.Switch[count],'   Present.');„          WriteLn('Value of:  ',CmdArray.ArgDsw.Arg[count]);„       end;„„Writeln;„Write('press ENTER to continue');„ReadLn;„Halt(0);„end;„„Procedure CheckHelp;„Var„   COUNT : Byte;„begin„   For count := 1 to 5 do„     if cmdArray.Switches.Present[Count] then„        helpUser;„„   if cmdArray.Switches.Present[6] then„     displayinfo;„end;„„{---------------------------Helpuser --------------------------}„Procedure HelpUser;„begin„   ClrScr;„   Writeln (CopyRightStr);„   WriteLn;„   WriteLn('USAGE: ');„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   Writeln;„   Writeln('Press Enter to continue.');„   ReadLn;„   Writeln;„   WriteLn('EXAMPLE:...............................');„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   WriteLn;„   Writeln (CopyRightStr);„   halt(0);„ end;„{-------------------------------------------------------------------------}„Procedure DisplayInfo;„   begin„      ClrScr;„      Writeln(copyrightStr);„      Writeln;„      Writeln('Ken Fox');„      WriteLn('1449 Maple Rd.');„      Writeln('Kintnersville Pa. 18930');„      WriteLn('215 672-9713       9 - 5 EST');„      Writeln;„      Writeln('Contact on shareware conference on Internet  -- KEN FOX');„      Writeln;„      halt(0);„„   end;„{--------------------------------------------------------------------------}„„this info is For all of the PASCAL conference people:„„to use the rotuines in this Program you need to do the following„„{$I path.......\Progname.h}„{$I Path.......\Helpuser.PAS}„{$I path.......\CMDPARSE.PAS}„„ progname.H is a copy of the CMDPARSE.H File which contains the specific„ settings For the Program you are writing .„„ HELPUSER.PAS is a Program specific help routine which get called by„ the routie CHECKHELP in CMDPARSE.PAS if the CheckHelp Procedure is„ used in the main Program. crude but effective.„„ CMDPARSE.PAS -- this File contains all of the parsing routines. I keep this„ File in my .....\TP\INCLUDE directory .„„ I set up a sepearte directory below the tp directory For each Program„ and copy the Files Helpuser.Pas and cmdparse.h into it thusly each„ copy of these two Files is customized For the give application While„ the actual parsing routines are kept in the INCLUDED FileS directory.„ there's no need to modify CMDPARSE.PAS„„ using the parser..„„       1) in the CMDPARSE.H File there are templates For all of the Array„ initializations. the switches to search For are manually inserted in to„ each Array item. additionally the Array sizes must be set where indicated„ in the CMDPARSE.H File.„{-------------------------------------------------------------------------}„  THE FOLLOWING ARE THE SETTINGS For Array SIZES„{-------------------------------------------------------------------------}„„Const„SwitchLength = 4;   {   maxlegth of a switch to be tested for}„ArgLength = 11;     {   max length of an argument from the commandline}„DelimLength = 1;     {   maxlength of delimiter if used}„SwitchNum = 6;      {   the number of switches and hence the size of the Array}„                    {      of switches  without arguments                  }„ArgdSwitchNum = 2;  {   the number of switches and hence the size of the Array}„                    {      of switches  With arguments                 }„DelimNum = 1;       {   number of args With delimited Strings          }„„{-------------------------------------------------------------------------}„     THE FOLLOWING SHOW HOW to INIT THE Array SEARCH VarIABLES..„     THESE LINES ARE ALL CONTAINED in  ---->>>> CMDPARSE.H„{-------------------------------------------------------------------------}„„   Switches.Switch[1] := '/?' ;     {default help String}„   Switches.Switch[2] := '/h' ;     {default help String}„   Switches.Switch[3] := '/H' ;     {default help String}„   Switches.Switch[4] := 'HELP' ;   {default help String}„   Switches.Switch[5] := 'help' ;   {default help String}„   Switches.Switch[6] := 'INFO'     {show author contact Info}„„{   Switches.Switch[6] := '  ' ;}   {NOT USED}„„{---------------------------------}„THE FOLLOWING ARE For SWITCHES WHICH WILL CAPTURE A VALUE AS WELL AS„TEST For THE PRESENCE of THE ARGUMENT„{---------------------------------}„{  ArgDSw.Switch[1] := '' ;}       {not used}„{  ArgDSw.Switch[2] := '' ;}       {not used}„{  ArgDSw.Switch[3] := '' ;}       {NOT USED}„{  ArgDSw.Switch[4] := '' ;}       {NOT USED}„{  ArgDSw.Switch[5] := '' ;}       {NOT USED}„{  ArgDSw.Switch[6] := '' ;}       {NOT USED}„{  ArgDSw.Switch[7] := '' ;}       {NOT USED}„„{-------------------------------------------------------------------------}„„       2) if you intend to use the routines in HELPUSER.PAS or to perform„a Filename validation  -- there is a template at the beginning of CMDPARSE.H„with Certain Constants which must be set.„„Uses Dos,Crt;„„Const„  VersionNum = 'V1.0 BETA';„  ProgNameStr = 'NEWPROJ.EXE';„  ProgNameShortStr = 'NP.EXE';„  copyRightStr = ProgNameStr+' ' + VersionNum +„                ', Copyright 1992 - 1993, Ken Fox. All Rights Reserved.';„„  DefaultFileName = 'NEWPROJ.DAT';„„{-------------------------------------------------------------------------}„„      3) To call the Various routines in  the CMDPARSE.PAS File there are„Templates which you can cut and paste into you Program from  CMDPARSE.H„„{--------------------------------------------------------------------------}„{                          procs Available in CmdParse.Pas                 }„{ additional info on the following procs may be found in the cmdparse.Pas  }„{ File in the ....\tp\include directory..                                  }„{                                                                          }„{ Procedure DispCmdline;                                                   }„{                                                                          }„{ Procedure CmdParse(Var CmdArray : CommandLineArrayType;                  }„{                            NoCase,                                       }„{                            ConvertArgsToUpper   : Boolean );             }„{                                                                          }„{ Procedure ConvertArgtoNumber(ArgNum : Integer;                           }„{                             Var  CmdArray : CommandLineArrayType;        }„{                             Var  ResultNumber: Word);                    }„{                                                                          }„{ Procedure FnameCheck(progname , progname2 :pathStr;                      }„{                      errorlevel : Byte);                                 }„{                                                                          }„{ Procedure CheckHelp;                                                     }„{                                                                          }„{--------------------------------------------------------------------------}„„      4) To test whether an ON/OFF switch is present (such as /?) on the„commandline  use the following:„„             if CmdArray.Switches.Present[number] then„                begin„                end;„„      5) to get the argument from a switch .„„            if CmdArray.ArgDsw.Present[number] then„               WhatEverVariable := CmdArray.ArgDsw.Arg[number];„„      6) the Procedure ConvertArgtoNumber is avail to convert a„String on the command line to a decimal number.. this is only good for„for whole numbers w/o nnn.0000111 etc.„„„hope this stuff is useful -- there are other notes and comments sprinkled„throughout so please check those before calling..„„finally - in the interest traversing the command tail only once the most„henious of Programming Constructs -- the Goto statement -- has been used.„please forgive me in advance....„„questions comments and suggestions are welcome..„„see the address in the CMDPASE.DOC File..„                                                                                                  6      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Kill Underscore          IMPORT              14     !}Û, {„This is another BAsm I've written to optimize my Program. Some of the„comma-delimited fields have the Underscore Character in the place of Spaces. It„is desirable For them to be replaced For use in my Program.„„BeFore writing this Procedure I was using:„„Procedure Kill_(Var Strng : String);„Repeat„  Subpos := Pos('_',String);„  if subpos > 0„     then Strng[subpos] := ' ';„Until Killpos Subpos = 0;„end;„„This was getting called approx 250,000 times in my project, and Turbo ProFiler„practically waved a red flag at me about it!  <grin>„„This is my new Procedure which screams as Compared to the previous routine.„„I am using TP 6.0 Professional.„„-------------  Code Snippet begins  --------------„}„Procedure KILL_(Var STRNG); Assembler;„{ This Procedure KILLS Underscores from a String _and MODifIES THE orIGinAL_ }„Asm„  LES DI, STRNG„  xor CX, CX„  MOV CL, [ES:DI] { Get String Length}„  MOV AL, '_'„  inC DI  { Point to FIRST String Char }„  CLD„@Scan_For_underscore_loop:„  SCASB„  JE @FOUND_UNDERSCorE„  LOOP @SCAN_For_UNDERSCorE_LOOP„  JMP @OUTTATHIS„@FOUND_UNDERSCorE:„  DEC DI„  MOV Byte PTR [ES:DI], ' '„  inc di„  jmp @scan_For_underscore_loop„(92 min left), (H)elp, More? @OUTTATHIS:„end;„„{„Does anyone more knowledgable in Assembly than I am have any suggestions For„this Procedure?   I Realize I am working With the original copy of the String„with this Procedure, and modifying it to boot, but I am saving the time to copy„it to/from the stack when I am making the changes.    My Program doES take this„into account, and ONLY passes Strings to the procedure.„}„                                                                                7      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Command Position         IMPORT              15     !}?¯ {„I have two BAsm Procedures I have written to speed up a Program which scans a„comma delimited line.    My testing has shown 50,000 iterations of this„Function to be approx 3 seconds faster than TP's  Var := Pos(',',String);„„I am fairly new to Assembly.   This Function doES in fact work, but not as fast„as I feel it should.    Can anyone see any places I have gone wrong in speed?„I've avoided copying the String to the stack, by just declaring a Pointer„Variable as the Function's input.  I'd like to squeeze a couple more seconds„out of it if I could.   The Procedures will deal With about 6 megs of data all„on comma delimited lines.„„I suppose I COULD speed it up, by not declaring ANY Variable, and hard-code it„to specifically use the String Variable I am currently passing to it.„ }„„Function Commapos(Var STRNG) : Byte; Assembler; Asm„ LES DI, STRNG     { Point ES:DI to beginning of STRNG }„ xor CH, CH        { Just in Case anything is in Register CH }„ MOV CL, [ES:DI]   { Load String Length into CL }„ MOV AH, CL        { Save len to Compute commapos later }„ inC DI            { Point to First Char in String }„ MOV AL, ','       { Looking For Comma }„ CLD„@SCANForCOMMALOOP:„ SCASB             { Compare [ES:DI] to contents of AL, inc DI, Dec CL}„ JE @FOUND_COMMA   { Found a Comma! }„ LOOP @SCANForCOMMALOOP  { No Such Luck! }„ MOV AL, 0         { Loop Fell through, no comma exists, set position to 0 }„ JMP @OUTTAHERE    { JumpOut of Loop and Exit } @FOUND_COMMA:„ DEC CL            { Reduce by one, since DI was advanced past the comma }„ SUB AH, CL        { Subtract CL from AH to give the position }„ MOV AL, AH        { Put the result into AL to return to Turbo } @OUTTAHERE:„end;„                                                                                      8      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Command parser           IMPORT              7      !}¡ {    Hey David, try this one out. It Uses a little known fact that TP„will parse the command line each time you call Paramstr(). So by„stuffing a String into the command-line buffer, we can have TP parse it„For us.„}„Program Parse;„Type„    String127 = String[127];„    Cmd = ^String127;„„Var„    My_String : Cmd;„    Index : Integer;„„begin„    My_String := Ptr(PrefixSeg, $80); {Point it to command line buffer}„    Write('Enter a line of Text (127 caracters Max) ');„    Readln(My_String^);„    For Index := 1 to Paramcount do„        Writeln(Paramstr(Index));„end.„„{    You can solve the problem of the 127 caracter limit by reading into„a standard String and splitting it into <127 caracter substrings.„}                                                          9      05-28-9313:34ALL                      SWAG SUPPORT TEAM        Handling PARAMSTR        IMPORT              15     !}Ü’ {„> It Word wrapped one line but you get the idea.  Is there an easier or„> faster way to do this?„}„Var„  Num, Code : Integer;„  Par : String;„„For F := 2 To ParamCount Do„ begin„ If Pos('/', ParamStr(F)) = 1 Then„   P := Copy(ParamStr(F), 2, 2);„„ If (Pos('A', P) = 1) Or (Pos('a', P) = 1) Then„ begin„   Val(Copy(P, 2, 1), Num, Code);„   If Num In [1..5] Then„     ReadString(Num);„ end;„ If (Pos('O',P) = 1) Or (Pos('o',P) = 1) Then Overide := False;„ If (Pos('S',P) = 1) Or (Pos('s',P) = 1) Then Spin := False;„ If (Pos('F',P) = 1) Or (Pos('f',P) = 1) Then ComLine(1,200);„ If (Pos('C',P) = 1) Or (Pos('c',P) = 1) Then ComLine(2,200);„ If (Pos('R',P) = 1) Or (Pos('r',P) = 1) Then„ begin„   Val(Copy(P, 2, 1), Num, Code);„   If Num In [0..10] Then„     Comline(3, Num);„ end;„ If (Pos('L',P) = 1) Or (Pos('l',P) = 1) Then ComLine(4,200);„ If (Pos('M',P) = 1) Or (Pos('m',P) = 1) Then ComLine(Random(4)+1,0);„ If (Pos('B',P) = 1) Or (Pos('b',P) = 1) Then DirectVideo := False;„ If (Pos('P',P) = 1) Or (Pos('p',P) = 1) Then„ begin„   Val(Copy(P, 2, 1), Num, Code);„   If Num In [0..3] Then„     Comline(5,200+Num);„ end;„ If (Pos('E',P) = 1) Or (Pos('p',P) = 1) Then ReturnLevel := True;„ If (Pos('?',P) = 1) Then Error;„end;„„{„Some Notes:„   I am not sure if it will return a 0 when the it asks For Val(Copy(P, 2, 1),„Num, Code) and the P Variable isn't R1, R2, R3, etc (when it is just R from a„/R) so you may have to trap that one differently or change the Program so they„have to say /R0 instead of /R.  I hope you follow the rest of the code and I„hope it works.  I have no idea what your Program is For so I couldn't test it„either (too lazy am I?  I think not... The above wasn't too easy to do!) So I„hope it works and good luck...„}„                                              10     11-02-9316:39ALL                      BRIAN PAPE               Parsing a String         IMPORT              18     !}ÕW {„From: BRIAN PAPE„Subj: Reading from strings (PARSE)„---------------------------------------------------------------------------„Can anyone out there tell me how to read a portion of one string„variable into another?„„I grabbed this code from one of my batch file utilities.  It isn't real„efficient, as it uses COPY and DELETE, but it doesn't have to be, since„it is only called once a program.  Where I have cfg:cfgrec, just replace„cfgrec with your own kind of record. }„„type„  MyRec = record„    r_var : integer;„  end;„...„Anyway, the GET function is what parses the /x:xxxx stuff out of a„regular string.  The PARSE procedure gets the actual command tail„from the PSP and keeps GETting parameters from it until it is empty.„BTW, the atoi() function I used is merely val() turned into a function.„----------------------------------„procedure parse(var cfg:cfgrec);„function get(var s:string):string;„var i,j : byte;slashflag : boolean;„begin„  i := 1;„  while (s[i] = ' ') and (i<=length(s)) do inc(i);„  slashflag := s[i] in ['-','/'];„  j := succ(i);„  while ((slashflag and not (s[j] in ['-','/'])) or„        (not slashflag and not (s[j] = ' '))) and„        (j<=length(s)) do inc(j);„  get := copy(s,i,j-i);„  delete(s,1,j-1);„end;  { get }„„var s:^string;t:string;„begin„  s := ptr(prefixseg,$80);  { DTA from PSP }„  cfg.working_msg := '';„  cfg.error_msg := '';„  cfg.drive := 0;„  cfg.pause_on_error := false;„  cfg.how_many_retries := 1;„  while s^<>'' do„    begin„      t := get(s^);„      if t[1] in ['-','/'] then„        begin„          if length(t)>=2 then„            case upcase(t[2]) of„              'C':cfg.how_many_retries :=„                  atoi(strip(copy(t,4,length(t)-3),' '));„              'H','?':begin writehelp; halt(0); end;„              'W':cfg.working_msg := copy(t,4,length(t)-3);„              'E':cfg.error_msg := copy(t,4,length(t)-3);„              'P':cfg.pause_on_error := true;„            end;  { case }„        end  { if }„      else„        cfg.drive := ord(upcase(t[1]))-65;„    end;  { while }„end;  { parse }„„                                                                                                            11     01-27-9411:55ALL                      JIM WALSH                Command Line Unit        IMPORT              67     !}   unit CmdLin;„(*„   This unit will process command line flags, (/N -N)„        a) as present or absent (Is_Param)„        b) with an integer (eg. /N54 /X-76) (Param_Int)„        c) with a real number (eg /J-987.65) (Param_Real)„        d) with strings, including delimited strings with embedded spaces„           ( eg. /X"This is the story!" /YFred)„„      Routines are included to count and return the parameters that„      aren't flags (Non_Flag_Count), and to return them without„      counting the flag parameters (Non_Flag_Param).„„      So ( /X76 Filename.txt /N"My name is Fred." George ) would count„      two non-flag params, #1 = filename.txt and #2 = george.„„      This is completely public domain, all I want in return for your use„      is appreciation.  If you improve this unit, please let me know.„      Some possible improvements would be to allow embedded strings in„      non-flag parameters.  I haven't done this because I haven't needed„      it.„„„      Jim Walsh      CIS:72571,173„„*)„„INTERFACE„„  function Is_Param(flag:Char) : Boolean;„  { Responds yes if the flag (ie N) is found in the command line (ie /N or -N) }„„  function Param_Int(flag:Char) : LongInt;„  { Returns the integer value after the parameter, ie -M100, or -M-123 }„„  function Param_Real(flag:Char) : Real;„  { Returns the Real value after the parameter, ie -X654.87, or -x-3.14159 }„„  function Param_Text(flag:Char) : String;„  { Returns the string after the parameter, ie -MHello -> 'Hello',            }„  {  -m"This is it, baby" -> 'This is it, baby', valid string delims='' "" [] }„„  function Non_Flag_Param(index:integer) : string;„  { Returns the indexth parameter, not preceded with a flag delimeter }„  { /X Text.txt /Y876.76 /G"Yes sir!" MeisterBrau /?                  }„  { For this command line 'Text.txt' is Non Flag Param #1,            }„  {    and 'MeisterBrau is #2.                                        }„  { NB: Delimeted Non flag parameters (eg "Meister Brau")             }„  {  not currently supported.                                         }„„  function Non_Flag_Count : integer;„  { Returns the number of non-flag type parameters }„„„IMPLEMENTATION„const„  flag_delims   : Set of Char = ['/','-'];„  no_of_string_delims = 3;„type„  string_delim_type = Array[1..3] of record„                                       start, stop : char„                                     end;„const„  string_delims : string_delim_type = ((start:#39; stop:#39),„                                       (start:#34; stop:#34),„                                       (start:'['; stop:']'));„„„function LowerCaseChar(c:char):char;„begin„  if (c>='A') and (c<='Z') Then LowerCaseChar:=Char(Ord(c)+$20)„                           Else LowerCaseChar:=c;„end;„„„{----------------------------------------------------------------------------}„  function WhereFlagOccurs(flag:Char) : integer;„  {  returns the index number of the paramter where the flag occurs  }„  {  if the flag is never found, it returns 0                        }„  var„    ti1      : integer;„    finished : boolean;„    paramcnt : integer;„    ts1      : string;„  begin„    flag:=LowerCaseChar(flag);„    finished:=false;„    ti1:=1;„    paramcnt:=ParamCount;„    While Not(finished) Do begin„      If ti1>paramcnt Then begin„        finished:=true;„        ti1:=0;„      end Else begin„        ts1:=ParamStr(ti1);„        If (ts1[1] In flag_delims) AND (LowerCaseChar(ts1[2])=flag) Then finished:=true;„      end;„      If Not(finished) Then Inc(ti1);„    end; {While}„    WhereFlagOccurs:=ti1;„  end;„„{----------------------------------------------------------------------------}„  function Is_Param(flag:Char) : Boolean;„  begin„    If WhereFlagOccurs(flag)=0 Then Is_Param:=false Else Is_Param:=true;„  end;„„{----------------------------------------------------------------------------}„  function Param_Int(flag:Char) : LongInt;„  var„    param_loc : integer;„    result    : longint;„    ts1       : string;„    ti1       : integer;„  begin„    param_loc:=WhereFlagOccurs(flag);„    If param_loc=0 Then result:=0„    Else begin„      ts1:=ParamStr(param_loc);     { Get the string }„      ts1:=Copy(ts1,3,255);         { Get rid of the delim and the flag }„      Val(ts1,result,ti1);          { Make the value }„      If ti1<>0 Then result:=0;     { Make sure there is no error }„    end; {If/Else}„    Param_Int:=result„  end;„„{----------------------------------------------------------------------------}„  function Param_Real(flag:Char) : Real;„  var„    param_loc : integer;„    result    : real;„    ts1       : string;„    ti1       : integer;„  begin„    param_loc:=WhereFlagOccurs(flag);„    If param_loc=0 Then result:=0.0„    Else begin„      ts1:=ParamStr(param_loc);     { Get the string }„      ts1:=Copy(ts1,3,255);         { Get rid of the delim and the flag }„      Val(ts1,result,ti1);          { Make the value }„      If ti1<>0 Then result:=0.0;   { Make sure there is no error }„    end; {If/Else}„    Param_Real:=result;„  end;„„{----------------------------------------------------------------------}„  function Which_String_Delim(S:string) : byte;„  { Returns the index of the strings first character in the array„    of string_delims, if the first char of S isn't a delim it returns 0 }„  var„    tc1 : char;„    tb1 : byte;„    finished : boolean;„    result   : byte;„  begin„    tc1:=S[1];„    tb1:=1;„    finished:=false;„    While Not(finished) Do begin„      If tb1>no_of_string_delims Then begin„        result:=0;„        finished:=true;„      end Else begin„        If tc1=string_delims[tb1].start Then begin„          result:=tb1;„          finished:=true;„        end;„      end;„      If Not(finished) Then Inc(tb1);„    end; {While}„    Which_String_Delim:=result;„  end; {function Which_String}„„{-------------------------------------------------------------------------}„  function Param_Text(flag:Char) : String;„  var„    param_loc : integer;„    param_cnt : integer;„    result    : string;„    ts1       : string;„    ti1       : integer;„    s_delim   : byte;          { This should be 0(no string), 1', 2", 3[ }„    finished  : boolean;„  begin„    param_loc:=WhereFlagOccurs(flag);„    If param_loc=0 Then result:=''„    Else begin„      ts1:=ParamStr(param_loc);     { Get the string }„      ts1:=Copy(ts1,3,255);         { Get rid of the delim and the flag }„      { See if the first char of ts1 is one of the string_delims }„      s_delim:=Which_String_Delim(ts1);„      If s_delim=0 Then result:=ts1„      Else begin„        result:=Copy(ts1,2,255);    { Drop the s_delim }„        finished:=false;„        param_cnt:=ParamCount;„        While Not(finished) Do begin„          Inc(param_loc);„          If param_loc>param_cnt Then finished:=true„          Else begin„            ts1:=ParamStr(param_loc);„            If ts1[Length(ts1)]=string_delims[s_delim].stop Then finished:=true;„            result:=result+' '+ts1;„          end; { If/Else }„        end; { While }„        result[0]:=Char(Length(result)-1);      { Drop the last delimeter }„      end; { If/Else a delimited string }„    end; { If/Else the flag is found }„    Param_Text:=result;„  end;„„{---------------------------------------------------------------------------}„  function Non_Flag_Param(index:integer) : string;„  var„    param_cnt : integer;„    ti1       : integer;„    ts1       : string;„    finished  : boolean;„    cur_index : integer;„  begin„    param_cnt:=ParamCount;„    cur_index:=0;„    ti1:=0;„    finished:=false;„    While Not(finished) Do begin„      Inc(ti1);„      IF cur_index>param_cnt Then begin„        ts1:='';„        finished:=true;„      end Else begin„        ts1:=ParamStr(ti1);„        If Not(ts1[1] IN flag_delims) Then begin„          Inc(cur_index);„          If cur_index=index Then finished:=true;„        end;„      end; {If/Else}„    end; {While}„    Non_Flag_Param:=ts1;„  end;„„{---------------------------------------------------------------------------}„  function Non_Flag_Count : integer;„  var„    param_cnt : integer;„    result    : integer;„    ti1       : integer;„    ts1       : string;„  begin„    param_cnt:=ParamCount;„    result:=0;„    ti1:=0;„    For ti1:=1 To param_cnt Do begin„      ts1:=ParamStr(ti1);„      If Not(ts1[1] IN flag_delims) Then begin„        Inc(result);„      end;„    end; {For}„    Non_Flag_Count:=result;„  end;„„„„„END.„                                           12     01-27-9411:55ALL                      LEE CRITES               Command Line Unit 2      IMPORT              113    !}   {„This unit will allow you to access the original command line as it was„originally entered by the user.  Here is the source code for the CmdLine„object.  It was developed by Computer Mavericks, using information gleened„from the info-pascal internet forum.  In the spirit of the forum, this is„offered into the public domain.  If you use it, think kind thoughs of Lee„Crites and the small staff here at CM.„„This was written using Borland Pascal 7.0's BPW in Real Mode.  (after all,„you'll probably not have to many command line parameters to check if you„are working in Windows or OS2, right???  It requires the STRINGS unit that„comes with BP7.  If you are working in TP6/TP5.5, and don't have access to„this, we do (should I say <did>) have a unit for doing null terminated„strings for each of those releases that we might be able to send out.  As„I remember, we took the BPW 1.0 Strings unit and played around with it„until it compiled in TP6, so I don't know which version that I still have„access to (it's been a while since I looked at our last tp6 archives).„„I threw this together over the weekend, and tested it using the whoami„program and test.bat file.  There might still be a problem floating around„in there somewhere.  This is about the first time that I've really sent„out some source code like this, and really haven't gone through it with a„fine tooth comb.  If there are bugs or (more importantly) imporvements„that some of you can see, please let me know.„}„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„{ =-=-=-=-=                                                   =-=-=-=-= }„{ =-=                                                               =-= }„{                               CMDLINE.PAS                             }„{ This unit contains the following:                                     }„{    -- CMDLINE, a mute object that will parse the physical command     }„{       line as input by the user, and return the information that was  }„{       requested.                                                      }„{ =-=                                                               =-= }„{ =-=-=-=-=                                                   =-=-=-=-= }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„{$D-} { debugging information off }„{$X+} { allow extended syntax }„{$V+} { require same var type }„{$R-} { range checking off }„{$E+} { Add 8087 software emulation code }„{$N+} { Use the 8087 software emulation code }„{$I-} { Enable IOResult for I/O checking }„{$B-} { Short-cut boolean evauation }„{$O+} { Allow this to be a part of an overlay }„Unit CmdLine;„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Interface„Uses Strings;  { Strings is a BP7 unit.  I have a TP6 version available }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Type„  TCmdLine = Object„     Constructor Init;„     Destructor Done; Virtual;„     { this will return the information requested -- the whole reason   }„     { for doing this in the first place.  It will return TRUE if the   }„     { ParmStrIn was found, otherwise false. This way you can check for }„     { switches entered with no data, since StrBack would otherwise be  }„     { null.                                                            }„     Function  GetParameter(ParmStrIn:String;Var StrBack:String):Boolean;„     Function  GetCommandLine:String;                 { the entire line }„     Function  GetActualProgram:String;       { the actual name entered }„     Function  GetCallingProgram:String;     { the fully qulaified name }„     Function  GetLaunchingProgram:String; { what environment called me }„     Procedure Trim;        { remove leading, trailing, multiple spaces }„     Procedure Capitalize;                   { just what it sounds like }„     Procedure Restore;                 { restores the original version }„     Function  GetDivideChars:String;      { returns the dividing chars }„     Procedure SetDivideChars(NewDivideChars:String);       { sets them }„„     Private„     DivideChars:String;             { the chars that signal a new parm }„     CommandLine,OriginalCommandLine:String;  { just what the name says }„     LaunchingProgram,CallingProgram,ActualProgram:String;„     End; { TCmdLine }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Var„  CommandLine:TCmdLine;„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„{PAGE}„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Implementation„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Const„  NONE = '<NONE>';„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Procedure MakeCaps(Var ss:String);„Var xx,ll:Byte;„Begin„  ll := Length(ss);„  For xx := 1 to ll Do ss[xx] := UpCase(ss[xx]);„End; { MakeCaps }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Procedure TrimString(Var ss:String);„Var xx:Integer;„Begin„  If (length(ss) < 1) Then exit;„  { remove leading spaces }„  While (ss[1] = chr(32)) Do Begin delete(ss,1,1);„  If (length(ss) < 1) Then exit; End;„  { remove trailing spaces }„  While (ss[length(ss)] = chr(32)) Do Delete(ss,length(ss),1);„  { remove imbedded spaces }„  xx := pos('  ',ss);„  While (xx <> 0) Do Begin Delete(ss,xx,1); xx := Pos('  ',ss); End;„End; { TrimString }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Procedure TCmdLine.Capitalize;„Begin„  MakeCaps(CommandLine);„End; { Capitalize }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Destructor TCmdLine.Done;   { I'm not sure what can/should be done here }„Begin„End; { CmdLine }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Function TCmdLine.GetActualProgram:String;„Begin„  GetActualProgram := ActualProgram;„End; { GetActualProgram }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Function TCmdLine.GetCallingProgram:String;„Begin„  GetCallingProgram := CallingProgram;„End; { GetCallingProgram }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Function TCmdLine.GetCommandLine:String;„Begin„  GetCommandLine := CommandLine;„End; { GetCommandLine }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Function TCmdLine.GetDivideChars:String;„Begin„  GetDivideChars := DivideChars;„End; { GetDivideChars }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Function TCmdLine.GetLaunchingProgram:String;„Begin„  GetLaunchingProgram := LaunchingProgram;„End; { GetLaunchingProgram }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Function TCmdLine.GetParameter(ParmStrIn:String;Var StrBack:String):Boolean;„Const AM:Char = Chr(254);„Var ss,PrmStr:String; ssLen,ParmLen:Integer;„  { =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„  Procedure SkipQuote(Var xx:Integer;WhichQuote:Char);„  Begin„    Inc(xx);„    While (xx <= ssLen) Do Begin„      If (ss[xx] = WhichQuote) Then Exit;„      Inc(xx);„      End;„  End; { SkipQuote }„  { =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„  Procedure Setup;„  Var xx,ll:Integer;„  Begin„    ss := CommandLine; MakeCaps(ss);„    PrmStr := ParmStrIn; MakeCaps(PrmStr);„    ssLen := Length(ss); ParmLen := Length(PrmStr);„    { change all dividechars into AMs }„    xx := 0;„    While (xx <= ssLen) Do Begin„       Inc(xx);„       Case ss[xx] Of„         '''','"','`': SkipQuote(xx,ss[xx]);„         Else If (Pos(ss[xx],DivideChars) > 0) Then ss[xx] := AM;„         End; { case }„       End; { while }„  End; { Setup }„  { =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„  Function IsThisIt(Var Start:Integer):Boolean;„  Var xx:Integer;„  Begin„    IsThisIt := False;„    For xx := 1 to ParmLen Do Begin„      If (ss[Start+xx] <> PrmStr[xx]) Then Exit;„      End; { yy }„    Start := Start+ParmLen;„    IsThisIt := True;„  End; { IsThisIt }„  { =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„  Function FindIt:Boolean;„  Var xx,yy,l1:Integer;„  Begin„    FindIt := False; StrBack := '';„    l1 := ssLen - ParmLen; If (l1 < 1) Then Exit;„    xx := 0;„    While (xx <= l1) Do Begin„       Inc(xx);„       If (ss[xx] = AM) Then Begin„          If IsThisIt(xx) Then Begin„             FindIt := True; yy := 0;„             { find the next AM, and copy the string out }„             While (xx+yy <= ssLen) And (ss[xx+yy] <> AM) Do Inc(yy);„             StrBack := Copy(CommandLine,xx+1,yy-1);„             { delete trailing space(s), if there }„             While (StrBack[Length(StrBack)] = ' ') Do„                Delete(StrBack,Length(StrBack),1);„             { we've got the answer, get out }„             Exit;„             End; { this is it }„          End; { found }„       End; { xx }„  End; { FindIt }„  { =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Begin„  { default to not found }„  GetParameter := False; StrBack := '';„  If (Length(CommandLine) < 1) or (CommandLine = NONE) Then Exit;„  If (Length(ParmStrIn) < 1) Then Exit;„„  Setup; GetParameter := FindIt;„End; { GetParameter }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Constructor TCmdLine.Init;„  { =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„  Function LaunchedBy:String;„  Var ParentSeg:^word; p:pchar;„  Begin„    ParentSeg := ptr(PrefixSeg,$0016); p := ptr(ParentSeg^-1,8);„    LaunchedBy := StrPas(p);„  End; { LaunchedBy }„  { =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„  Function RealCommandLine:String;„  Var ss:String;„  Begin„    ss := StrPas(ptr(PrefixSeg,130));„    If (Ord(ss[0]) > 0) Then ss[0] := Chr(Ord(ss[0])-1);„    RealCommandLine := ss;„  End; { RealCommandLine }„  { =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„  Function ActualProgramName:String;„  Var cc:Char; ss:String; p:PChar; xx,yy:Byte;„  Begin„    p := ptr(PrefixSeg,228); ss := ''; xx := 0; yy := 0;„    Repeat„      cc := p[xx];„      If (cc <> #0)„         Then Begin„              If (Ord(cc) > 47) and (Ord(cc) < 126) Then Begin„                 ss := ss+' '; ss[Ord(ss[0])] := p[xx]; End;„              End„         Else Begin Inc(yy); If (yy = 1) Then ss := ss+'.'; End;„      Inc(xx);„      Until (xx > 12) or (yy > 1);„      If (ss[Ord(ss[0])] = '.') Then ss[0] := Chr(Ord(ss[0])-1);„    ActualProgramName := ss;„  End; { ActualProgramName }„  { -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Begin„  LaunchingProgram := LaunchedBy;        { what environment launched me }„  OriginalCommandLine := RealCommandLine;   { the original command line }„  If (Length(OriginalCommandLine) < 1) Then OriginalCommandLine := NONE;„  CommandLine := OriginalCommandLine;                { default to exact }„  CallingProgram := ActualProgramName;     { just what the user entered }„  ActualProgram := ParamStr(0);   { BP returns the fully qualitied name }„„  SetDivideChars('-/');                   { set the default DivideChars }„End; { Init }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Procedure TCmdLine.Restore;„Begin„  CommandLine := OriginalCommandLine;„End; { Restore }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Procedure TCmdLine.SetDivideChars(NewDivideChars:String);„Begin„  DivideChars := NewDivideChars;„End; { SetDivideChars }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Procedure TCmdLine.Trim;„Begin„  TrimString(CommandLine);„End; { Trim }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„Begin { main block }„  CommandLine.Init;„End. { main block }„{ =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= }„„„„{ This is a test program showing some of the cmdline object functions }„Program whoami;„Uses DOS, CRT, CmdLine;„Var ss:String;„begin„  { show some general information that it returns }„  WriteLn('I was launched by [',CommandLine.GetLaunchingProgram,']');„  WriteLn('Program executed was [',CommandLine.GetCallingProgram,']');„  WriteLn('BP returnd [',CommandLine.GetActualProgram,']');„  WriteLn('Command line was [',CommandLine.GetCommandLine,']');„„  { these will change the part that you can use }„  CommandLine.Capitalize; CommandLine.Trim;„  WriteLn('Fixed command line [',CommandLine.GetCommandLine,']');„„  { this will return it to it's original value }„  CommandLine.Restore;„  WriteLn('Restored command line [',CommandLine.GetCommandLine,']');„„  { check for the existance of some parameter }„  If CommandLine.GetParameter('s',ss)„     Then WriteLn('Parameter "s" was [',ss,']')„     Else WriteLn('Parameter "s" was not found');„  If CommandLine.GetParameter('ss',ss)„     Then WriteLn('Parameter "ss" was [',ss,']')„     Else WriteLn('Parameter "ss" was not found');„end.„„{„------------------------------ test.bat ------------------------------„@Echo Off„whoami /a:france/b 'this-is "the" way'  /chest /store /left„whoami /aaa-bbb/s"this 'is'-it"   /sss„whoami -ss/shell„„}                                                                                               