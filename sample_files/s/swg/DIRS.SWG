SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00031         DIRECTORY HANDLING ROUTINES                                       1      05-28-9313:37ALL                      SWAG SUPPORT TEAM        ForEachFile Procedure    IMPORT              35     ¶∂Ñ {„ Can any one tell me a way to make pascal (TP 6.0) search a„ complete drive, including all subdirectories, even ones„ that are not in the path, looking For a specific File„ extension?  I.E., having the Program search For *.DOC and„ saving that to a Text File?„„ Here's part of a package I'm putting together.  You'd use it like this:„„}„„{File Test.Pas}„„Uses„  Dos, Foreach;„„Procedure PrintAllDocs;„„  Procedure PrintFile(Var Dir: DirStr; Var S : SearchRec); Far;„  begin„    Writeln('Found File ',Dir,S.Name);„  end;„„begin„  ForEachFile('c:\*.doc',  { Give the mask where you want to start looking }„              0, 0,        { Specify File attributes here; you'll just get„                             normal Files With 0 }„              True,        { Search recursively }„              @PrintFile); { Routine to call For each File }„end;„„begin„  PrintAllDocs;„end.„„„{Unit ForEach}„„Unit ForEach;„„{ Unit With a few different "foreach" Functions. }„{ This extract contains only ForEachFile. }„„Interface„„Uses„  Dos;„„Type„  FileStr = String[12];„  TFileAction = Procedure(Var Dir : DirStr;„                          Var S : SearchRec; ConText : Word);„„Procedure ForEachFile(Mask : PathStr; { File wildcard mask, including path }„                      Attr : Byte; { File attributes }„                      Match : Byte; { File attributes which„                                             must match attr exactly }„                      Subdirs : Boolean; { Whether to search recursively }„                      Action : Pointer);„{ Calls the Far local Procedure Action^ For each File found.„  Action^ should be a local Procedure With declaration„    Procedure Action(Var Path : String; Var S : SearchRec); Far;„  or, if not a local Procedure,„    Procedure Action(Var Path : String; Var S : SearchRec; Dummy : Word); Far;„  Each time Action is called S will be filled in For a File matching„  the search criterion.„}„„Implementation„„Function CallerFrame : Word;„{ Returns the BP value of the caller's stack frame; used For passing„  local Procedures and Functions around. Taken from Borland's Outline„  Unit. }„  Inline(„    $8B/$46/$00                   { MOV   AX,[BP] }„    );„„„  { ******** File routines ********* }„„Procedure ForEachFile(Mask    : PathStr; { File wildcard mask }„                      Attr    : Byte;    { File attributes }„                      Match   : Byte;    { Attributes which must match }„                      Subdirs : Boolean; { Whether to search recursively }„                      Action  : Pointer);{ Action; should point to„                                           a TFileAction local Far Procedure }„Var„  CurrentDir : DirStr;„  Doit       : TFileAction Absolute Action;„  Frame      : Word;„„  Procedure DoDir;„  { Tests all Files in current directory.  Assumes currentdir has trailing„    backslash }„  Var„    S : SearchRec;„  begin„    FindFirst(CurrentDir + Mask, Attr, S);„    While DosError = 0 do„    begin„      if (S.Attr and Match) = (Attr and Match) then„        Doit(CurrentDir, S, Frame);„      FindNext(S);„    end;„  end;„„  Function RealDir(Name : FileStr) : Boolean;„  begin„    RealDir := (Name <> '.') and (Name <> '..');„  end;„„  Procedure AddBackslash;„  begin„    CurrentDir := CurrentDir + '\';„  end;„„  Procedure DoAllDirs;„  Var„    S         : SearchRec;„    OldLength : Byte;„„    Procedure AddSuffix(Suffix : FileStr); { Separate proc to save stack space }„    begin„      CurrentDir := Copy(CurrentDir, 1, OldLength) + Suffix;„    end;„„  begin„    OldLength := Length(CurrentDir);„    DoDir;„    AddSuffix('*.*');„    FindFirst(CurrentDir, Directory, S);„    While DosError = 0 do„    begin„      if S.Attr = Directory then„      begin„        if RealDir(S.Name) then„        begin„          AddSuffix(S.Name);„          AddBackslash;„          DoAllDirs;            { do directory recursively }„        end;„      end;„      FindNext(S);„    end;„  end;„„Var„  Name : NameStr;„  Ext  : ExtStr;„„begin                           { ForEachFile }„  FSplit(Mask, CurrentDir, Name, Ext);„  Mask := Name+Ext;„  Frame := CallerFrame;„  if CurrentDir[Length(CurrentDir)] <> '\' then„    AddBackslash;„  if Subdirs then„    DoAllDirs„  else„    DoDir;„end;„„end.„                                                                                                             2      05-28-9313:37ALL                      SWAG SUPPORT TEAM        Search ALL Dirs and Subs IMPORT              7      ¶∂1~ Uses Crt, Dos, WinDos;„Procedure SearchSubDirs(Dir:PathStr;Target:SearchRec);„Var„  FoundDir: TSearchRec;„  FileSpec: PathStr;„  Path : DirStr;„  DummyName: NameStr;„  DummyExt : ExtStr;„begin„ If KeyPressed then Repeat Until KeyPressed;„ FileSpec:= Dir + '*.';„ FindFirst('*.*', AnyFile, FoundDir);„ While (DosError = 0) do„   begin„     With FoundDir do„       begin„         If Name[1] <> '.' then„           if Directory and Attr <> 0 then„             begin„               FSplit(FileSpec,Path,DummyName,DummyExt);„               FindFirst(Path + Name + '\' ,Target);„             end;„       end; {with FoundDir}„     if KeyPressed then Pause;„     FindNext(FoundDir);„   end; {read loop}„   If DosError <> 18 then DosErrorExit;„end;„                            3      05-28-9313:37ALL                      SWAG SUPPORT TEAM        Search All Dirs & Subs #2IMPORT              24     ¶∂øﬂ AH>>Hi everyone.  I have a small problem.  How does one go about accessing„  >>EVERY File in every directory, sub-directory on a drive? I guess this is„  >>part of the last question, but how do you access every sub-directory?„„Unit FindFile;„{$R-}„Interface„„Uses Dos;„„Type„  FileProc = Procedure ( x : PathStr );„„Procedure FindFiles (DirPath : PathStr;      (* initial path           *)„                     Mask : String;          (* mask to look For       *)„                     Recurse : Boolean;      (* recurse into sub-dirs? *)„                     FileDoer : FileProc);   (* what to do With found  *)„„(* Starting at <DirPath>, FindFiles will pass the path of all the Files„   it finds that match <Mask> to the <FileDoer> Procedure.  if <Recurse>„   is True, all such Files in subdirectories beneath <DirPath> will be„   visited as well.  if <Recurse> is False, the names of subdirectories„   in <DirPath> will be passed as well. *)„„Implementation„„Procedure FindFiles (DirPath : PathStr;      (* initial path           *)„                     Mask : String;          (* mask to look For       *)„                     Recurse : Boolean;      (* recurse into sub-dirs? *)„                     FileDoer : FileProc);   (* what to do With found  *)„„  Procedure SubVisit ( DirPath : PathStr );„  Var„    Looking4 : SearchRec;„„  begin„    FindFirst ( Concat ( DirPath, Mask ), AnyFile, looking4);„    While ( DosError = 0 ) Do begin„      if ( looking4.attr and ( VolumeID + Directory ) ) = 0„       then FileDoer ( Concat ( DirPath, looking4.name ) );„      FindNext ( Looking4 );„      end;   (* While *)„    if Recurse„     then begin„      FindFirst ( Concat ( DirPath, '*.*' ), AnyFile, looking4);„      While ( DosError = 0 ) and ( looking4.name [1] = '.' ) Do„        FindNext (looking4);   (* skip . and .. directories *)„      While ( DosError = 0 ) Do begin„        if ( ( looking4.attr and Directory ) = Directory )„         then SubVisit ( Concat ( DirPath, looking4.name, '\' ) );„        FindNext ( Looking4 );„        end;   (* While *)„      end;   (* if recursing *)„  end;   (* SubVisit *)„„„begin   (* FindFiles *)„  SubVisit ( DirPath );„end;   (* FindFiles *)„„end.„„   --------------------------------------------------------------------„„Program Visit;„„Uses Dos, FindFile;„„{$F+}„Procedure FoundOne ( Path : PathStr );  (* MUST be Compiled With $F+ *)„{$F-}„begin„  WriteLn ( Path );„end;„„begin„  WriteLn ( '-------------------------------------------------------------');„  FindFiles ( '\', '*.*', True, FoundOne );„  WriteLn ( '-------------------------------------------------------------');„end.„„   -----------------------------------------------------------------------„„FoundOne will be passed every File & subdirectory.  if you just want the„subdirectories, ignore any name that doesn't end in a '\' Character!„                                                                                            4      05-28-9313:37ALL                      SWAG SUPPORT TEAM        ALLDIRS4.PAS             IMPORT              19     ¶∂Dø {„>Is there any easy way do turn *.* wildcards into a bunch of Filenames?„>This may be confusing, so here's what I want to do:„>I know C, basic, pascal, and batch.  (but not too well)„>I want to make a Program to read Files from c:\ece\ and, according to my„>Filespecs ( *.* *.dwg plot???.plt hw1-1.c) I want the Program to take„>each File individually, and Compress it and put it on b:.  I also want„>the Program to work in reverse.  I.E.:  unpack Filespecs from b: and„>into c:.  I want this because I take so many disks to school, and I„>don't like packing and unpacking each File individually.  I also don't„>want one big archive.  Any suggestions as to how to do it, or what I„>could do is appreciated.„„The easiest way would be to use the findfirst() and findnext()„Procedures. Here's a stub Program in TP. You'll need to put code in„the main routine to handle command line arguments, and call fsplit()„to split up the Filenames to pass to searchDir() or searchAllDirs().„then just put whatever processing you want to do With each File in„the process() Procedure.„}„„Uses„  Dos, Crt;„„Var„  Path      : PathStr;„  Dir       : DirStr;„  Name      : NameStr;„  Ext       : ExtStr;„  FullName  : PathStr;„  F         : SearchRec;„  Ch        : Char;„  I         : Integer;„„Procedure Process(dir : DirStr; s : SearchRec);„begin„  Writeln(dir, s.name);„end;„„„{„ Both searchDir and searchAllDirs require the following parameters„ path  - the path to the File, which must end With a backslash.„         if there is no ending backslash these won't work.„ fspec - the File specification.„}„„Procedure SearchDir(Path : PathStr; fspec : String);„Var„  f : SearchRec;„begin„  Findfirst(Path + fspec, AnyFile, f);„  While DosError = 0 do„  begin„    Process(path, f);„    Findnext(f);„  end;„end;„„Procedure searchAllDirs(path : pathStr; fspec : String);„Var„  d : SearchRec;„begin„  SearchDir(Path, fspec);„  FindFirst(Path + '*.*', Directory, d);„  While DosError = 0 do„  begin„    if (d.Attr and Directory = Directory) and (d.name[1] <> '.') then„    begin„      SearchAllDirs(Path + d.name + '\', fspec);„    end;„    Findnext(d);„  end;„end;„„begin„  SearchAllDirs( '\', '*.*' );„end.„                                                                                                                      5      05-28-9313:37ALL                      SWAG SUPPORT TEAM        ALLDIRS5.PAS             IMPORT              11     ¶∂ü {„> Can any one tell me a way to make pascal (TP 6.0) search a Complete„> drive, including all subdirectories, even ones that are not in the„> path, looking For a specific File extension?  I.E., having the Program„> search For *.doC and saving that to a Text File?„„Ok, here goes nothing.„}„„{$M 65000 0 655360}„{Assign enough stack space For recursion}„„Program FindAllFiles;„„Uses Dos;„„Var„  FileName : Text;„„Procedure ScanDir(path : PathStr);„„Var„  SearchFile : SearchRec;„begin„  if Path[Length(Path)] <> '\' then„    Path := Path + '\';„  FindFirst(Path + '*.*', $37, SearchFile); { Find Files and Directories }„  While DosError = 0 do { While There are more Files }„  begin„    if ((SearchFile.Attr and $10) = $10) and (SearchFile.Name[1] <> '.') then„      ScanDir(Path + SearchFile.Name)„      { Found a directory Make sure it's not . or .. Scan this dir also }„    else„    if Pos('.doC',SearchFile.Name)>0 then„      Writeln(FileName, Path + SearchFile.Name);„      { if the .doC appears in the File name, Write path to File. }„    FindNext(SearchFile);„  end;„end;„„begin„  Assign(FileName,'doCS'); { File to contain list of .doCs }„  ReWrite(FileName);„  ScanDir('C:\'); { Drive to scan. }„  Close(FileName);„end.„                                                   6      05-28-9313:37ALL                      SWAG SUPPORT TEAM        DELTREE.PAS              IMPORT              8      ¶∂e% Procedure ClrDir ( path : pathStr );„„Var FileInfo : searchRec;„    f        : File;„    path2    : pathStr;„    s        : String;„„begin FindFirst ( path + '\*.*', AnyFile, FileInfo );„      While DosError = 0 Do„      begin if (FileInfo.Name[1] <> '.') and (FileInfo.attr <> VolumeId) then„              if ( (FileInfo.Attr and Directory) = Directory ) then„                begin Path2 := Path + '\' + FileInfo.Name;„                      ClrDir ( path2 );„                end„            else„              if ((FileInfo.Attr and VolumeID) <> VolumeID) then begin„                Assign ( f, path + '\' + FileInfo.Name );„                Erase ( f );„              end;„„            FindNext ( FileInfo );„      end;„„      if (DosError = 18) and not ((Length(path) = 2)„                                   and ( path[2] = ':')) then„        RmDir ( path );„„end;„                             7      05-28-9313:37ALL                      SWAG SUPPORT TEAM        DIRDEMO.PAS              IMPORT              54     ¶∂‹Ï { DIRDEMO.PAS„  Author: Trevor Carlsen. Released into the public domain 1989„                          Last modification 1992.„  Demonstrates in a very simple way how to display a directory in a screen„  Window and scroll backwards or Forwards.  }„„Uses„  Dos,„  Crt,„  keyinput;„„Type„  str3    = String[3];„  str6    = String[6];„  str16   = String[16];„  sType   = (_name,_ext,_date,_size);„  DirRec  = Record„              name  : NameStr;„              ext   : ExtStr;„              size  : str6;„              date  : str16;„              Lsize,„              Ldate : LongInt;„              dir   : Boolean;„            end;„„Const„  maxdir       = 1000;     { maximum number of directory entries }„  months : Array[1..12] of str3 =„           ('Jan','Feb','Mar','Apr','May','Jun',„            'Jul','Aug','Sep','Oct','Nov','Dec');„  WinX1 = 14; WinX2 = 1;„  WinY1 = 65; WinY2 = 23;„  LtGrayOnBlue      = $17;„  BlueOnLtGray      = $71;„  page              = 22;„  maxlines : Word   = page;„„Type„  DataArr           = Array[1..maxdir] of DirRec;„„Var„  DirEntry          : DataArr;„  x, numb           : Integer;„  path              : DirStr;„  key               : Byte;„  finished          : Boolean;„  OldAttr           : Byte;„„Procedure quicksort(Var s; left,right : Word; SortType: sType);„  Var„    data      : DataArr Absolute s;„    pivotStr,„    tempStr   : String;„    pivotLong,„    tempLong  : LongInt;„    lower,„    upper,„    middle    : Word;„„  Procedure swap(Var a,b);„    Var x : DirRec Absolute a;„        y : DirRec Absolute b;„        t : DirRec;„    begin„      t := x;„      x := y;„      y := t;„    end;„„  begin„    lower := left;„    upper := right;„    middle:= (left + right) div 2;„    Case SortType of„      _name: pivotStr   := data[middle].name;„      _ext : pivotStr   := data[middle].ext;„      _size: pivotLong  := data[middle].Lsize;„      _date: pivotLong  := data[middle].Ldate;„    end; { Case SortType }„    Repeat„      Case SortType of„        _name: begin„                 While data[lower].name < pivotStr do inc(lower);„                 While pivotStr < data[upper].name do dec(upper);„               end;„        _ext : begin„                 While data[lower].ext < pivotStr do inc(lower);„                 While pivotStr < data[upper].ext do dec(upper);„               end;„        _size: begin„                 While data[lower].Lsize < pivotLong do inc(lower);„                 While pivotLong < data[upper].Lsize do dec(upper);„               end;„        _date: begin„                 While data[lower].Ldate < pivotLong do inc(lower);„                 While pivotLong < data[upper].Ldate do dec(upper);„               end;„      end; { Case SortType }„      if lower <= upper then begin„        swap(data[lower],data[upper]);„        inc(lower);„        dec(upper);„       end;„    Until lower > upper;„    if left < upper then quicksort(data,left,upper,SortType);„    if lower < right then quicksort(data,lower,right,SortType);„  end; { quicksort }„„Function Form(st : String; len : Byte): String;„  { Replaces spaces in a numeric String With zeroes  }„  Var„    x : Byte ;„  begin„    Form := st;„    For x := 1 to len do„      if st[x] = ' ' then„        Form[x] := '0'„  end;„„Procedure ReadDir(Var count : Integer);„  { Reads the current directory and places in the main Array }„  Var„    DirInfo    : SearchRec;„„  Procedure CreateRecord;„    Var„      Dt : DateTime;„      st : str6;„    begin„      With DirEntry[count] do begin„        FSplit(DirInfo.name,path,name,ext);             { Split File name up }„        if ext[1] = '.' then                                { get rid of dot }„          ext := copy(ext,2,3);„        name[0] := #8;  ext[0] := #3; { Force to a set length For Formatting }„        Lsize := DirInfo.size;„        Ldate := DirInfo.time;„        str(DirInfo.size:6,size);„        UnPackTime(DirInfo.time,Dt);„        date := '';„        str(Dt.day:2,st);„        date := st + '-' + months[Dt.month] + '-';„        str((Dt.year-1900):2,st);„        date := date + st + #255#255;„        str(Dt.hour:2,st);„        date := date + st + ':';„        str(Dt.Min:2,st);„        date := date + st;„        date := Form(date,length(date));„        dir := DirInfo.attr and Directory = Directory;„      end; { With }„    end; { CreateRecord }„„  begin { ReadDir }„    count := 0;         { For keeping a Record of the number of entries read }„    FillChar(DirEntry,sizeof(DirEntry),32);           { initialize the Array }„    FindFirst('*.*',AnyFile,DirInfo);„    While (DosError = 0) and (count < maxdir) do begin„      inc(count);„      CreateRecord;„      FindNext(DirInfo);„    end; { While }„    if count < page then„      maxlines := count;„    quicksort(DirEntry,1,count,_name);„  end; { ReadDir }„„Procedure DisplayDirectory(n : Integer);„  Var„    x,y : Integer;„  begin„    y := 1;„    For x := n to n + maxlines do„      With DirEntry[x] do begin„        GotoXY(4,y);inc(y);„        Write(name,'  ');„        Write(ext,' ');„        if dir then Write('<DIR>')„        else Write('     ');„        Write(size:8,date:18);„      end; { With }„  end; { DisplayDirectory }„„begin { main }„  ClrScr;„  GotoXY(5,24);„  OldAttr  := TextAttr;„  TextAttr := BlueOnLtGray;„  Write(' F1=Sort by name F2=Sort by extension F3=Sort by size F4=Sort by date ');„  GotoXY(5,25);„  Write('   Use arrow keys to scroll through directory display - <ESC> quits   ');„  TextAttr := LtGrayOnBlue;„  Window(WinX1,WinX2,WinY1,WinY2);  { make the Window }„  ClrScr;„  HiddenCursor;„  ReadDir(numb);„  x := 1; finished := False;„  Repeat„    DisplayDirectory(x); { display maxlines Files }„      Case KeyWord of„      F1 {name} : begin„                    x := 1;„                    quicksort(DirEntry,1,numb,_name);„                  end;„      F2 {ext}  : begin„                    x := 1;„                    quicksort(DirEntry,1,numb,_ext);„                  end;„      F3 {size} : begin„                    x := 1;„                    quicksort(DirEntry,1,numb,_size);„                  end;„      F4 {date} : begin„                    x := 1;„                    quicksort(DirEntry,1,numb,_date);„                  end;„      home      : x := 1;„      endKey    : x := numb - maxlines;„      UpArrow   : if x > 1 then„                    dec(x);„      DownArrow : if x < (numb - maxlines) then„                    inc(x);„      PageDn    : if (x + page) > (numb - maxlines) then„                    x := numb - maxlines„                  else inc(x,page);„      PageUp    : if (x - page) > 0 then„                    dec(x,page)„                  else x := 1;„      escape    : finished := True„      end; { Case }„  Until finished;„  NormalCursor;„  TextAttr := OldAttr;„  ClrScr;„end.„„                         8      05-28-9313:37ALL                      SWAG SUPPORT TEAM        DIREXIST.PAS             IMPORT              7      ¶∂5_ {„  re: Finding a directory„„>Obviously that's not the quickest routine in the world, and though„>it works, I was wondering if you have anything easier/faster?„„  ...I don't know how much better this routine is, but you may„  want to give it a try:„}„„{ Determine if a directory exists. }„„Function DirExist(st_Dir : DirStr) : Boolean;„Var„  wo_Fattr : Word;„  fi_Temp  : File;„begin„  assign(fi_Temp, (st_Dir + '.'));„  getfattr(fi_Temp, wo_Fattr);„  if (Doserror <> 0) then„    DirExist := False„  else„    DirExist := ((wo_Fattr and directory) <> 0)„end; { DirExist. }„„{„notE: The "DirStr" Type definition is found in the standard TP„      Dos Unit. Add this Unit to your Program's "Uses" statement„      to use this routine.„}„                                    9      05-28-9313:37ALL                      SWAG SUPPORT TEAM        DIRTREE.PAS              IMPORT              105    ¶∂:W Program Vtree2;„„{$B-,D+,R-,S-,V-}„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ Uses and GLOBAL VarIABLES & ConstANTS              ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Uses„  Crt, Dos;„„Const„  NL        = #13#10;„  NonVLabel = ReadOnly + Hidden + SysFile + Directory + Archive;„„Type„„  FPtr      = ^Dir_Rec;„„  Dir_Rec   = Record                             { Double Pointer Record    }„    DirName : String[12];„    DirNum  : Integer;„    Next    : Fptr;„  end;„„  Str_Type  = String[65];„„Var„  Version   : String;„  Dir       : str_Type;„  Loop      : Boolean;„  Level     : Integer;„  Flag      : Array[1..5] of String[20];„  TreeOnly  : Boolean;„  Filetotal : LongInt;„  Bytetotal : LongInt;„  Dirstotal : LongInt;„  tooDeep   : Boolean;„  ColorCnt  : Byte;„„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ Procedure Beepit                                   ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Procedure Beepit;„„begin„  Sound (760);                                          { Beep the speaker }„  Delay (80);„  NoSound;„end;„„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ Procedure Usage                                    ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Procedure Usage;„„begin„  BEEPIT;„  Write (NL,„    'Like the Dos TREE command, and similar to PC Magazine''s VTREE, but gives',NL,„    'you a Graphic representation of your disk hierarchical tree structure and',NL,„    'the number of Files and total Bytes in each tree node (optionally can be',NL,„    'omitted).  Also allows starting at a particular subdirectory rather than',NL,„    'displaying the entire drive''s tree structure.  Redirection of output and',NL,„    'input is an option.',NL,NL, 'USAGE:     VTREE2 {path} {/t} {/r}',NL,NL,„    '/t or /T omits the number of Files and total Bytes inFormation.',NL,„    '/r or /R activates redirection of input and output.',NL,NL, Version);„  Halt;„end;„„{„⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„≥ Function Format                                    ≥„¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Function Format (Num : LongInt) : String;   {converts Integer to String}„                                            {with commas inserted      }„Var„  NumStr : String[12];„  Place  : Byte;„„begin„  Place := 3;„  STR (Num, NumStr);„  Num := Length (NumStr);                  {re-use Num For Length value }„„  While Num > Place do                     {insert comma every 3rd place}„  begin„    inSERT (',',NumStr, Num - (Place -1));„    inC (Place, 3);„  end;„„  Format := NumStr;„end;„„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ Procedure DisplayDir                               ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Procedure DisplayDir (DirP : str_Type; DirN : str_Type; Levl : Integer;„                     NumSubsVar2 : Integer; SubNumVar2 : Integer;„                     NumSubsVar3 : Integer;„                     NmbrFil : Integer; FilLen : LongInt);„„{NumSubsVar2 is the # of subdirs. in previous level;„ NumSumsVar3 is the # of subdirs. in the current level.„ DirN is the current subdir.; DirP is the previous path}„„Const„  LevelMax = 5;„Var„  BegLine : String;„  MidLine : String;„  Blank   : String;„  WrtStr  : String;„„begin„„  if Levl > 5 then„  begin„    BEEPIT;„    tooDeep := True;„    Exit;„  end;„„  Blank   := '               ';                  { Init. Variables          }„  BegLine := '';„  MidLine := ' ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ';„„  if Levl = 0 then                               { Special handling For     }„    if Dir = '' then                             { initial (0) dir. level   }„      if not TreeOnly then„        WrtStr := 'ROOT ƒƒ'„      else„        WrtStr := 'ROOT'„    else„      if not TreeOnly then„        WrtStr := DirP + ' ƒƒ'„      else„        WrtStr := DirP„  else„  begin                                        { Level 1+ routines        }„    if SubNumVar2 = NumSubsVar2 then           { if last node in subtree, }„    begin                                    { use ¿ƒ symbol & set flag }„      BegLine  := '¿ƒ';                      { padded With blanks       }„      Flag[Levl] := ' ' + Blank;„    end„    else                                       { otherwise, use √ƒ symbol }„    begin                                    { & set flag padded With   }„      BegLine    := '√ƒ';                    { blanks                   }„      Flag[Levl] := '≥' + Blank;„    end;„„    Case Levl of                               { Insert ≥ & blanks as     }„      1: BegLine := BegLine;                  { needed, based on level   }„      2: Begline := Flag[1] + BegLine;„      3: Begline := Flag[1] + Flag[2] + BegLine;„      4: Begline := Flag[1] + Flag[2] + Flag[3] + BegLine;„      5: Begline := Flag[1] + Flag[2] + Flag[3] + Flag[4] + BegLine;„    end; {end Case}„„    if (NumSubsVar3 = 0) then                  { if cur. level has no     }„      WrtStr := BegLine + DirN                 { subdirs., leave end blank}„    else„    begin„      WrtStr := BegLine + DirN + COPY(Midline,1,(13-Length(DirN)));„      if Levl < LevelMax then„        WrtStr := WrtStr + 'ƒø'„      else                                   { if level 5, special      }„      begin                                { end to indicate more     }„        DELETE (WrtStr,Length(WrtStr),1);  { levels                   }„        WrtStr := WrtStr + 'Ø';„      end;„    end;„  end;                                         { end level 1+ routines    }„„  if ODD(ColorCnt) then„    TextColor (3)„  else„    TextColor (11);„  inC (ColorCnt);„„  if ((Levl < 4) or ((Levl = 4) and (NumSubsVar3=0))) and not TreeOnly then„    WriteLn (WrtStr,'':(65-Length(WrtStr)), Format(NmbrFil):3,„             Format(FilLen):11)„  else„    WriteLn (WrtStr);                            { Write # of Files & Bytes  }„                                                 { only if it fits, else     }„end;                                             { Write only tree outline   }„„„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ Procedure DisplayHeader                            ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Procedure DisplayHeader;„„begin„  WriteLn ('DIRECtoRIES','':52,'FileS','      ByteS');„  WriteLn ('ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ');„end;„„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ Procedure DisplayTally                             ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Procedure DisplayTally;„„begin„  WriteLn('':63,'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ');„  WriteLn('NUMBER of DIRECtoRIES: ', Dirstotal:3, '':29,„          'toTALS: ', Format (Filetotal):5, Format (Bytetotal):11);„end;„„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ Procedure ReadFiles                                ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Procedure ReadFiles (DirPrev : str_Type; DirNext : str_Type;„                     SubNumVar1 : Integer; NumSubsVar1 : Integer);„„Var„  FileInfo  : SearchRec;„  FileBytes : LongInt;„  NumFiles  : Integer;„  NumSubs   : Integer;„  Dir_Ptr   : FPtr;„  CurPtr    : FPtr;„  FirstPtr  : FPtr;„„begin„  FileBytes := 0;„  NumFiles  := 0;„  NumSubs   := 0;„  Dir_Ptr   := nil;„  CurPtr    := nil;„  FirstPtr  := nil;„„  if Loop then„    FindFirst (DirPrev + DirNext + '\*.*', NonVLabel, FileInfo);„  Loop      := False;                            { Get 1st File             }„„  While DosError = 0 do                          { Loop Until no more Files }„  begin„    if (FileInfo.Name <> '.') and (FileInfo.Name <> '..') then„    begin„      if (FileInfo.attr = directory) then    { if fetched File is dir., }„      begin                                { store a Record With dir. }„        NEW (Dir_Ptr);                     { name & occurence number, }„        Dir_Ptr^.DirName  := FileInfo.name;{ and set links to         }„        inC (NumSubs);                     { other Records if any     }„        Dir_Ptr^.DirNum   := NumSubs;„        if CurPtr = nil then„        begin„          Dir_Ptr^.Next := nil;„          CurPtr        := Dir_Ptr;„          FirstPtr      := Dir_Ptr;„        end„        else„        begin„          Dir_Ptr^.Next := nil;„          CurPtr^.Next  := Dir_Ptr;„          CurPtr        := Dir_Ptr;„        end;„      end„      else„      begin                                { Tally # of Bytes in File }„        FileBytes := FileBytes + FileInfo.size;„        inC (NumFiles);                    { Increment # of Files,    }„      end;                                 { excluding # of subdirs.  }„    end;„    FindNext (FileInfo);                       { Get next File            }„  end;    {end While}„„  Bytetotal := Bytetotal + FileBytes;„  Filetotal := Filetotal + NumFiles;„  Dirstotal := Dirstotal + NumSubs;„„  DisplayDir (DirPrev, DirNext, Level, NumSubsVar1, SubNumVar1, NumSubs,„              NumFiles, FileBytes);            { Pass info to & call      }„  inC (Level);                                 { display routine, & inc.  }„                                               { level number             }„„„  While (FirstPtr <> nil) do                   { if any subdirs., then    }„  begin                                      { recursively loop thru    }„    Loop     := True;                        { ReadFiles proc. til done }„    ReadFiles ((DirPrev + DirNext + '\'),FirstPtr^.DirName,„                FirstPtr^.DirNum, NumSubs);„    FirstPtr := FirstPtr^.Next;„  end;„„  DEC (Level);                                 { Decrement level when     }„                                               { finish a recursive loop  }„                                               { call to lower level of   }„                                               { subdir.                  }„end;„„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ Procedure Read_Parm                                ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„Procedure Read_Parm;„„Var„  Cur_Dir : String;„  Param   : String;„  i       : Integer;„„begin„„  if ParamCount > 3 then„    Usage;„  Param := '';„„  For i := 1 to ParamCount do                    { if either param. is a T, }„  begin                                        { set TreeOnly flag            }„    Param := ParamStr(i);„    if Param[1] = '/' then„      Case Param[2] of„        't','T': begin„                   TreeOnly := True;„                   if ParamCount = 1 then„                     Exit;„                 end;                          { Exit if only one param   }„„        'r','R': begin„                   ASSIGN (Input,'');          { Override Crt Unit, &     }„                   RESET (Input);              { make input & output      }„                   ASSIGN (Output,'');         { redirectable             }„                   REWrite (Output);„                   if ParamCount = 1 then„                     Exit;„                 end;                          { Exit if only one param   }„        '?'    : Usage;„„        else„          Usage;„      end; {Case}„  end;„„  GETDIR (0,Cur_Dir);                            { Save current dir         }„  For i := 1 to ParamCount do„  begin„    Param := ParamStr(i);                      { Set Var to param. String }„    if (POS ('/',Param) = 0) then„    begin„      Dir := Param;„{$I-} CHDIR (Dir);                           { Try to change to input   }„      if Ioresult = 0 then                   { dir.; if it exists, go   }„      begin                                { back to orig. dir.       }„{$I+}   CHDIR (Cur_Dir);„        if (POS ('\',Dir) = Length (Dir)) then„          DELETE (Dir,Length(Dir),1);       { Change root symbol back  }„        Exit;                                { to null, 'cause \ added  }„      end                                  { in later                 }„      else„      begin„        BEEPIT;„        WriteLn ('No such directory -- please try again.');„        HALT;„      end;„    end;„  end;„end;„„{„   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„   ≥ MAin Program                                       ≥„   ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„}„„begin„„  Version   := 'Version 1.6, 7-16-90 -- Public Domain by John Land';„                                                 { Sticks in EXE File      }„„  Dir       := '';                               { Init. global Vars.      }„  Loop      := True;„  Level     := 0;„  TreeOnly  := False;„  tooDeep   := False;„  Filetotal := 0;„  Bytetotal := 0;„  Dirstotal := 1;                                { Always have a root dir. }„  ColorCnt  := 1;„„  ClrScr;„„  if ParamCount > 0 then„    Read_Parm;              { Deal With any params.   }„„  if not TreeOnly then„    DisplayHeader;„„  ReadFiles (Dir,'',0,0);                        { do main read routine    }„„  TextColor(Yellow);„„  if not TreeOnly then„    DisplayTally;             { Display totals          }„„  if tooDeep then„    WriteLn (NL,NL,'':22,'Ø CANnot DISPLAY MorE THAN 5 LEVELS Æ',NL);„                                                 { if ReadFiles detects >5 }„                                                 { levels, tooDeep flag set}„„end.„        10     05-28-9313:37ALL                      SWAG SUPPORT TEAM        DIRVIEW.PAS              IMPORT              16     ¶∂Ã3 {„Well, here goes...a directory viewer, sorry it has no box but the„command that i used to create the box was from a Unit. Weel, the Program„is very "raw" but i think it's enough to give you an idea...„}„„Program ListBox;„„Uses„  Crt, Dos;„„Const„  S = '           ';„„Var„  List         : Array[1..150] of String[12];„  AttrList     : Array[1..150] of String[15];„  Pos, First   : Integer;„  C            : Char;„  Cont         : Integer;„  DirInfo      : SearchRec;„  NumFiles     : Integer;„„begin„  TextBackground(Black);„  TextColor(LightGray);„  ClrScr;„„  For Cont := 1 to 15 do„  begin„    List[Cont] := '';„    AttrList[Cont] := '';„  end;„„  NumFiles := 0;„  FindFirst('C:\*.*', AnyFile, DirInfo);„„  While DosError = 0 do„  begin„    Inc(NumFiles, 1);„    List[NumFiles] := Concat(DirInfo.Name,„                      Copy(S, 1, 12 - Length(DirInfo.Name)));„    If (DirInfo.Attr = $10) Then„      AttrList[NumFiles] := '<DIR>'„    Else„      Str(DirInfo.Size, AttrList[NumFiles]);„    AttrList[NumFiles] := Concat(AttrList[NumFiles],„                          Copy(S, 1, 9 - Length(AttrList[NumFiles])));„    FindNext(DirInfo);„  end;„„  First := 1;„  Pos   := 1;„„  Repeat„    For Cont := First To First + 15 do„    begin„      If (Cont - First + 1 = Pos) Then„      begin„        TextBackground(Blue);„        TextColor(Yellow);„      end„      Else„      begin„        TextBackGround(Black);„        TextColor(LightGray);„      end;„      GotoXY(30, Cont - First + 3);„      Write(' ', List[Cont], '  ', AttrList[Cont]);„    end;„    C := ReadKey;„    If (C = #72) Then„      If (Pos > 1) Then„        Dec(Pos, 1)„      Else„      If (First > 1) Then„        Dec(First,1);„„    If (C = #80) Then„      If (Pos < 15) Then„        Inc(Pos, 1)„      Else„      If (First + 15 < NumFiles) Then„        Inc(First,1);„  Until (Ord(c) = 13);„end.„                                                                   11     05-28-9313:37ALL                      SWAG SUPPORT TEAM        FAST-DEL.PAS             IMPORT              8      ¶∂¿– { DR> DEL/ERASE command is able to erase an entire directory by using DEL *.*„ DR> With such speed.  It clearly has a method other than deleting File by„ DR> File.„„  Function $41 of Int $21 will do what you want.  You'll need to„make an ASCIIZ Filename of the path and File(s), and set a Pointer„to it in DS:DX.  When it returns, if the carry flag (CF) is set,„then AX holds the Dos error code.„}„Function DosDelete (FileName : PathStr) : Word; {returns error if any}„Var Regs : Registers;„begin„  FileName[65] := 0;             {make asciiz- maybe, not sure}„  Regs.DS := Seg(FileName);      {segment to String}„  Regs.DX := offset(FileName)+1; {add one since f[0] is length}„  Regs.AH := $41;„  Regs.AL := 0;                  {Initialize}„  Intr ($21, Regs);„  if Regs.AL <> 0 {error} then DosDelete := Regs.AX else DosDelete := 0;„end;„                                                        12     05-28-9313:37ALL                      SWAG SUPPORT TEAM        MAKEDIR1.PAS             IMPORT              19     ¶∂Ó+ Program MakeChangeDir;„„{ Purpose:      - Make directories where they don't exist               }„{                                                                       }„{ Useful for:   - Installation Type Programs                            }„{                                                                       }„{ Useful notes: - seems to handles even directories With extentions     }„{                 (i.e. DIRDIR.YYY)                                     }„{               - there are some defaults that have been set up :-      }„{                 change if needed                                      }„{               - doesn't check to see how legal the required directory }„{                 is (i.e. spaces, colon in the wrong place, etc.)      }„{                                                                       }„{ Legal junk:   - this has been released to the public as public domain }„{               - if you use it, give me some credit!                   }„{                                                                       }„„Var„  Slash : Array[1..20] of Integer;„„Procedure MkDirCDir(Target : String);„Var„  i,„  count   : Integer;„  dir,„  home,„  tempdir : String;„„begin„  { sample directory below to make }„  Dir := Target;„  { add slash at end if not given }„  if Dir[Length(Dir)] <> '\' then„    Dir := Dir + '\';„  { if colon where normally is change to that drive }„  if Dir[2] = ':' then„    ChDir(Copy(Dir, 1, 2))„  else„  { assume current drive (and directory) }„  begin„    GetDir(0, Home);„    if Dir[1] <> '\' then„      Dir := Home + '\' + Dir„    else„      Dir := Home + Dir;„  end;„„  Count := 0;„  { search directory For slashed and Record them }„  For i := 1 to Length(Dir) do„  begin„    if Dir[i] = '\' then„    begin„      Inc(Count);„      Slash[Count] := i;„    end;„  end;„  { For each step of the way, change to the directory }„  { if get error, assume it doesn't exist - make it }„  { then change to it }„  For i := 2 to Count do„  begin„    TempDir := Copy(Dir, 1, Slash[i] - 1);„    {$I-}„    ChDir(TempDir);„    if IOResult <> 0 then„    begin„      MkDir(TempDir);„      ChDir(TempDir);„    end;„  end;„end;„„begin„  MkDirCDir('D:\HI.ZZZ\GEEKS\2JKD98');„end.„                                                                            13     05-28-9313:37ALL                      SWAG SUPPORT TEAM        MAKEDIR2.PAS             IMPORT              7      ¶∂’ó {„    Hi Mark, there is a Procedure in Turbo Pascal called MkDir that allows„you to create a subdirectory. However if you want source code For a similar„routine try the following. I just whipped it up so it doesn't contain any„error checking, but you could add a simple if else after the Dos call to„check the register flags. Anyhow, I hope that this helps ya out.„}„Procedure Make_Directory (Directory: String);„{ parameters:  Directory - name of the new directory„  sample-call: Make_Directory('\tools') }„Var„    Regs: Registers;„begin„  With Regs do„  begin„    Directory := Directory + chr(0);„    AX := $3900;„    DS := Seg(Directory[1]);„    DX := ofs(Directory[1]);„    MSDos(Dos.Registers(Regs));„  end;„end;„                                                  14     08-18-9312:22ALL                      JOSE ALMEIDA             Get a programs directory IMPORT              9      ¶∂@ { Gets the program directory.„  Part of the Heartware Toolkit v2.00 (HTfile.PAS) for Turbo Pascal.„  Author: Jose Almeida. P.O.Box 4185. 1504 Lisboa Codex. Portugal.„          I can also be reached at RIME network, site ->TIB or #5314.„  Feel completely free to use this source code in any way you want, and, if„  you do, please don't forget to mention my name, and, give me and Swag the„  proper credits. }„„FUNCTION Get_Prg_Dir : string;„„{ DESCRIPTION:„    Gets the program directory.„  SAMPLE CALL:„    St := Get_Prg_Dir;„ RETURNS:„    The program directory, e.g., E:\TP\„ NOTES:„    The program directory is always where the program .EXE file is located.„    This function add a backslash at the end of string. }„„var„  Tmp : string;„„BEGIN { Get_Prg_Dir }„  Tmp := ParamStr(0);„  while (Tmp[Length(Tmp)] <> '\') and (Length(Tmp) <> 0) do„    Delete(Tmp,Length(Tmp),1);„  if Tmp = '' then„    Tmp := Get_Cur_Dir;„  Get_Prg_Dir := Tmp;„END; { Get_Prg_Dir }„                                                               15     08-27-9319:58ALL                      LAWRENCE JOHNSTONE       Every Dir in Pascal      IMPORT              11     ¶∂¸¿ {„LAWRENCE JOHNSTONE„„≥Can someone give me some code (in TP) that recognizes all Sub-dirs„≥and Sub-sub-dirs, etc. in drive C and changes into every single one„≥of them one at a time?„}„„PROGRAM EveryDir;„„USES„  DOS„„PROCEDURE ProcessDirs( Path: DOS.PathStr );„VAR„  SR : SearchRec;„BEGIN„  IF Path[Length(Path)] <> '\' THEN { Make sure last char is '\' }„    Path := Path + '\';„„  { Change to directory specified by Path.  Handle root as special case }„  {$I-}„  IF (Length(Path) = 3) AND (Copy(Path, 2, 2) = ':\') THEN„    ChDir(Path)„  ELSE„    ChDir(Copy(Path, 1, Length(Path) - 1);„  IF IOResult <> 0 THEN„    EXIT; { Quit if we get a DOS error }„  {$I-}„„  { Process all subdirectories of that directory, except for }„  { the '.' and '..' aliases                                 }„  FindFirst(Path + '*.*', Directory, SR);„  WHILE DosError = 0 DO„  BEGIN„    IF ((SR.Attr AND Directory) <> 0) AND„        (SR.Name <> '.') AND (SR.Name <> '..') THEN„      ProcessDirs( Path + SR.Name );„    FindNext(SR);„  END; { while }„END; {ProcessDirs}„„VAR„  CurDir : DOS.PathStr;„„BEGIN„  GetDir(3, CurDir);  { Get default directory on C }„  ProcessDirs('C:\'); { Process all directories on C }„  ChDir(CurDir);      { Restore default directory on C }„END.„                           16     08-27-9319:59ALL                      PER-ERIC LARSSON         Find a file anywhere     IMPORT              18     ¶∂Vv {„PER-ERIC LARSSON„„> I've seen some posts asking how to search through directories or how to„> find a File anywhere on the disk, so here's a little Procedure I wrote„> to do it...  Give it a whirl and feel free to ask questions...„„There is a built in trap in the method you describe. I've fallen into it many„times myself so here's a clue. The problem:„if Your Procedure (that is called once per File) does some processing of the„File you SHOULD first make a backup copy. personally I rename the original„File to .BAK and then take that File as input, writing to a new File With the„original name, perhaps deleting the .bak File if everything works out fine.„For most purposes this works fine. But if you do this using findnext to find„the next File to work With it will Repeat itself til the end of time or„diskspace.„„Therefore i recommend :„First get all Filenames to work With,„Then start processing the Files.„}„„Procedure runFile(ft : String);„begin„  { Process File here}„end;„„Procedure RUNALLFileS(FT : String);„Type„  plista = ^tlista;„  tlista = Record„    namn : String;„    prev : plista;„  end;„Var„ S    : SearchRec;„ Dir  : DirStr;„ Name : NameStr;„ Ext  : ExtStr;„ pp   : plista;„„Function insertbefore(before : plista) : plista;„Var„  p : plista;„begin„  getmem(p, sizeof(tlista));„  p^.prev := before;„  insertbefore := p;„end;„„Function deleteafter(before : plista) : plista;„begin„  deleteafter := before^.prev;„  freemem(before, sizeof(tlista));„end;„„begin„  pp := nil;„  FSplit(fT, Dir, Name, Ext);„  FINDFIRST(ft, $3f, S);„  While DosERROR = 0 DO„  begin„    if (S.ATTR and $18) = 0 then„    begin„      pp := insertbefore(pp);„      pp^.namn := dir + s.name;„   end;„   FINDNEXT(S);„  end;„  if pp <> nil then„  Repeat„    runFile(pp^.namn);„    pp := deleteafter(pp);„  Until pp = nil;„end;„„begin„  if paramcount > 0 then„  begin„    For filaa := 1 to paramcount do„      runALLFileS(paramstr(filaa));„  end;„  Writeln('Klar')„end.„„{„This is a cutout example from a Program i wrote„It won't compile but it'll show a way to do it !„}„                                                                                                                17     08-27-9321:21ALL                      JON KENT                 Setting a files path     IMPORT              11     ¶∂…Y {„JON KENT„„Here's one way to set a File's path "on the fly" using Typed Constants.„}„„Uses„  Dos;„„Const„  TestFile1 : String = 'TEST1.DAT';„  TestFile2 : String = 'DATA\TEST2.DAT';„Var„  CurrentPath : String;„„Function FileStretch(SType : Byte; FileFullName : String) : String;„Var„  P : PathStr;„  D : DirStr;„  N : NameStr;„  E : ExtStr;„begin„  P := FExpand(FileFullName);„  FSplit(P, D, N, E);„  if D[LENGTH(D)] = '\' then„    D[0] := CHR(PRED(LENGTH(D)));„  Case SType OF„    1 :  FileStretch := D;„    2 :  FileStretch := N + E;„    3 :  FileStretch := D + '\' + N;„    4 :  FileStretch := N;„    else FileStretch := '';„  end;„end;„„begin„  CurrentPath := FileStretch(1,ParamStr(0));    { Get EXE's Path  }„  TestFile1   := CurrentPath + '\' + TestFile1; { Set DAT Paths   }„  TestFile2   := CurrentPath + '\' + TestFile2;„„  {...}„„end.„{-----------------------------}„„{  if CurrentPath = C:\WORK then„„       TestFile1 = C:\WORK\TEST1.DAT„       TestFile2 = C:\WORK\DATA\TEST2.DAT„„  This works Really well when you want to store a Program's configuration„  File or data Files in the same directory as the Program regardless its„  location.„}                                                                                                                              18     09-26-9309:10ALL                      MARTIN RICHARDSON        Check for Directory      IMPORT              7      ¶∂Ê› „{*****************************************************************************„ * Function ...... IsDir()„ * Purpose ....... To check for the existance of a directory„ * Parameters .... Dir        Dir to check for„ * Returns ....... TRUE if Dir exists„ * Notes ......... None„ * Author ........ Martin Richardson„ * Date .......... May 13, 1992„ *****************************************************************************}„FUNCTION IsDir( Dir: STRING ) : BOOLEAN;„VAR„   fHandle: FILE;„   wAttr: WORD;„BEGIN„     WHILE Dir[LENGTH(Dir)] = '\' DO DEC( Dir[0] );„     Dir := Dir + '\.';„     ASSIGN( fHandle, Dir );„     GETFATTR( fHandle, wAttr );„     IsDir := ( (wAttr AND DIRECTORY) = DIRECTORY );„END;„„                                                            19     11-02-9306:08ALL                      HERBERT ZARB             Change File Attr         IMPORT              7      ¶∂–È { Updated FILES.SWG on November 2, 1993 }„„{„Herbert Zarb <panther!jaguar!hzarb@relay.iunet.it>„„  This simple Program changes the attribute of the File or directory from„   hidden to archive or vice-versa...„}„„Program hide_unhide;„{ Accepts two command line parameters :„        1st parameter can be either +h (hide) or -h(unhide).„        2nd parameter must be the full path }„Uses„  Dos;„„Const„  bell    = #07;„  hidden  = $02;„  archive = $20;„„Var„  f : File;„„begin„  if paramcount >= 2 then„  begin„    Assign(f, paramstr(2));„    if paramstr(1) = '+h' then„      SetFAttr(f, hidden)„    else„    if paramstr(1) = '-h' then„      SetFAttr(f, Archive)„    else„      Write(bell);„  end„  else„    Write(bell);„end.„                                             20     11-02-9306:08ALL                      TIMO SALMI               Another Change File Attr IMPORT              11     ¶∂œ® { Updated FILES.SWG on November 2, 1993 }„„{„ts@uwasa.fi (Timo Salmi)„„ Q: How can one hide (or unhide) a directory using a TP Program?„„ A: SetFAttr which first comes to mind cannot be used For this.„Instead interrupt Programming is required.  Here is the code.„Incidentally, since MsDos 5.0 the attrib command can be used to hide„and unhide directories.„(* Hide a directory. Before using it would be prudent to check„   that the directory exists, and that it is a directory.„   With a contribution from Jan Nielsen jak@hdc.hha.dk„   Based on information from Duncan (1986), p. 410 *)„}„Procedure HIDE(dirname : String);„Var„  regs : Registers;„begin„  FillChar(regs, SizeOf(regs), 0);    { standard precaution }„  dirname := dirname + #0;           { requires ASCII Strings }„  regs.ah := $43;                    { Function }„  regs.al := $01;                    { subFunction }„  regs.ds := Seg(dirname[1]);        { point to the name }„  regs.dx := Ofs(dirname[1]);„  regs.cx := 2; { set bit 1 on }     { to unhide set regs.cx := 0 }„  Intr ($21, regs);                  { call the interrupt }„  if regs.Flags and FCarry <> 0 then { were we successful }„    Writeln('Failed to hide');„end;„                                                                                      21     11-02-9310:27ALL                      DAVID DRZYZGA            Multiple Dir Picks       IMPORT              22     ¶∂Ú¿ {„DAVID DRZYZGA„„> And I can't seem to get the OpDir system to work With multiple Files, or„> at least I can't get the "tagging" Function to work.„„Here's a somewhat stripped snipit of code from one of my apps that will give„you a clear example of how to use the multiple pick Function of the DirList„Object:„}„„Program DirTest;„„{$I OPDEFINE.INC}„„Uses„  Dos,„  OpRoot,„  OpConst,„  OpString,„  OpCrt,„  OpCmd,„  OpFrame,„  OpWindow,„  OpPick,„  OpDir,„  OpColor;„„Const„  SliderChar    = '≤';„  ScrollBarChar = '∞';„  Frame1        : FrameArray = '⁄¿øŸƒƒ≥≥';„  Counter       : Word = 1;„„Var„  Dir          : DirList;„  Finished     : Boolean;„  SelectedItem : Word;„  DirWinOpts   : LongInt;„  I            : Integer;„„Procedure ProcessFile(FileName : String);„begin„  {This is where you would process each of the tagged Files}„end;„„begin„  DirWinOpts := DefWindowOptions+wBordered;„  if not Dir.InitCustom(20, 4, 50, 19, {Window coordinates}„                        DefaultColorSet,  {ColorSet}„                        DirWinOpts,    {Window options}„                        MaxAvail,      {Heap space For Files}„                        PickVertical,  {Pick orientation}„                        MultipleFile)  {Command handler}„  then„  begin„    WriteLn('Failed to Init DirList,  Status = ', InitStatus);„    Halt;„  end;„„  {Set desired DirList features}„  With Dir do„  begin„    wFrame.AddShadow(shBR, shSeeThru);„    wFrame.AddCustomScrollBar(frRR, 0, MaxLongInt, 1, 1, SliderChar,„                              ScrollBarChar, DefaultColorSet);„„    SetSelectMarker(#251' ', '');„    SetPosLimits(1, 1, ScreenWidth, ScreenHeight-1);„    SetPadSize(1, 1);„    diOptionsOn(diOptimizeSize);„    AddMaskHeader(True, 1, 30, heTC);„    SetSortOrder(SortDirName);„    SetNameSizeTimeFormat('<dir>', 'Mm/dd/yy', 'Hh:mmt');„    SetMask('*.*', AnyFile);„  end;„„  {<AltP>: process selected list}„  PickCommands.AddCommand(ccUser0, 1, $1900, 0);„„  {Pick Files}„  Finished := False;„  Repeat„    Dir.Process;„    Case Dir.GetLastCommand of„      ccSelect : ;„      ccError  : ;„      ccUser0  :„      begin„        Counter := 1;„        if Dir.GetSelectedCount > 0 then„        begin„          Dir.InitSequence(SelectedItem);„          While Dir.HaveSelected(SelectedItem) do„          begin„            ProcessFile(Dir.GetMultiPath(SelectedItem));„            Inc(Counter);„            Dir.NextSelected(SelectedItem);„            Dir.ResetList;„          end;„        end„      end;„„      ccQuit : Finished := True;„    end;„  Until Finished;„„  Dir.Erase;„  ClrScr;„  Dir.Done;„end.„                                                                                                       22     01-27-9413:32ALL                      ROBERT ROTHENBURG        Files Wildcard Matching  IMPORT              99     ¶∂≠º (* -------------------------------------------------------------- *)„(* FileSpec.PAS v1.0a by Robert Walking-Owl November 1993         *)„(* -------------------------------------------------------------- *)„„{ Things to add...                                                 }„{ - have # and $ be symbols for ASCII chars in dec/hex?            }„„(* Buggie Things:                                                 *)„(* - anti-sets don't work with variable lenght sets, since they   *)„(*   end with the first character NOT in the set...               *)„„{$F+}„„unit FileSpec;„„interface„„uses Dos;„„const„  DosNameLen  = 12;     (* Maximum Length of DOS filenames        *)„  UnixNameLen = 32;     (* Maximum Length of Unix Filenames       *)„„  MaxWildArgs = 32;     (* Maximum number of wildcard arguments   *)„  MaxNameLen  = 127;„„  fCaseSensitive = $01; (* Case Sensitive Flag                    *)„  fExtendedWilds = $02; (* Use extented wildcard forms (not,sets  *)„  fUndocumented  = $80; (* Use DOS 'undocumented' filespecs       *)„„type„  SpecList   = array [1..MaxWildArgs] of record„                   Name:  string[ MaxNameLen ];  (* or use DOS ParamStr?  *)„                   Truth: Boolean„                   end;„  PWildCard  = ^TWildCard;„  TWildCard  = object„                 private„                   FileSpecs: SpecList;     (* List of filespecs      *)„                   NumNegs,                 (* Number of "not" specs  *)„                   FSpCount:  word;         (* Total number of specs  *)„                   function StripQuotes( x: string ): string;„                   procedure   FileSplit(Path: string;„                                   var Dir,Name,Ext: string);„                 public„                   PathChar,                (* path seperation char   *)„                   NotChar,                 (* "not" char - init '~'  *)„                   QuoteChar:     Char;     (* quote char - init '"'  *)„                   Flags,                   (* Mode flags ...         *)„                   FileNameLen:   Byte;     (* MaxLength of FileNames *)„                   constructor Init;„                   procedure   AddSpec( name: string);„                   function    FitSpec( name: string): Boolean;„                   destructor  Done;„               (* Methods to RemoveSpec() or ChangeSpec() aren't added *)„               (* since for most applications they seem unnecessary.   *)„               (* An IsValid() spec to see if a specification is valid *)„               (* syntax is also unnecessary, since no harm is done,   *)„               (* and DOS and Unix ignore them anyway ....             *)„               end;„„„implementation„„procedure UpCaseStr( var S: string); assembler;„asm„                PUSH    DS„                LDS     SI,S„                MOV     AL,BYTE PTR DS:[SI]„                XOR     CX,CX„                MOV     CL,AL„@STRINGLOOP:    INC     SI„                MOV     AL,BYTE PTR DS:[SI]„                CMP     AL,'a'„                JB      @NOTLOCASE„                CMP     AL,'z'„                JA      @NOTLOCASE„                SUB     AL,32„                MOV     BYTE PTR DS:[SI],AL„@NOTLOCASE:     LOOP    @STRINGLOOP„                POP     DS„end;„„„constructor TWildCard.Init;„begin„  FSpCount  := 0;„  NumNegs   := 0;„  NotChar   := '~';„  QuoteChar := '"';„  Flags := fExtendedWilds or fUndocumented;„  FileNameLen := DosNameLen;„  PathChar := '\';„end;„„destructor TWildCard.Done;„begin„  FSpCount := 0„end;„„function TWildCard.StripQuotes( x: string ): string;„begin„  if x<>''„    then if (x[1]=QuoteChar) and (x[length(x)]=QuoteChar)„      then StripQuotes := Copy(x,2,Length(x)-2)„      else StripQuotes := x„end;„„procedure TWildCard.AddSpec( Name: string);„var„  Truth: Boolean;„begin„  if Name <> '' then begin„  Truth := True;„  if (Flags and fExtendedWilds)<>0„    then begin„      if Name[1]=NotChar„        then begin„          inc(NumNegs);„          Truth := False;„          Name  := Copy( Name , 2, Pred(Length(Name)) );„         end;„      Name := StripQuotes( Name );„    end;„  if (FSpCount<>MaxWildArgs) and (Name<>'')„    then begin„      inc( FSpCount );„      FileSpecs[ FSpCount ].Name := Name;„      FileSpecs[ FSpCount ].Truth := Truth„      end;„  end„end;„„procedure TWildCard.FileSplit(Path: string; var Dir,Name,Ext: string);„var„  i,p,e: byte;„  InSet: Boolean;„begin„  p:=0;„  if (Flags and fCaseSensitive)=0„    then UpCaseStr(Path);„  for i:=1 to length(Path) do if Path[i]=PathChar then p:=i;„  i:=Length(Path);„  InSet := False;„  e := succ(length(Path));„  repeat„    if not Inset„       then case Path[i] of„              '.': e := i;„              ']',„              '}',„              ')': InSet := True;„            end„       else if Path[i] in ['[','{','('] then InSet := False;„    dec(i);„  until i=0;„  if p=0„    then Dir := ''„    else Dir := Copy(Path,1,p);„  Name := Copy(Path,Succ(p),pred(e-p));„  if e<=length(Path)„    then Ext := Copy(Path,e,succ(Length(Path)-e))„    else Ext := '';„end;„„function TWildCard.FitSpec( name: string): Boolean;„„procedure Puff(var x: string); (* Pad filename with spaces *)„begin„  while length(x)<FileNameLen do x:=x+' ';„end;„„„var x,b: set of char;„procedure GetSet(s: string; EndSet: char; var k: byte);„var„    c: char;„    u: string;„    i: byte;„    A: Boolean;„begin„  A := False;„  if s[k]=',' then repeat„      inc(k)„    until (k>=FileNameLen) or (s[k]=EndSet) or (s[k]<>',');„  u := '';„  if (k<FileNameLen) and (s[k]<>EndSet) then begin„    repeat„      u := u + s[k];„      inc(k);„    until (k>=FileNameLen) or (s[k]=EndSet) or (s[k]=',');„    if u<>'' then begin„      if u[1]=NotChar„        then begin„          A := True;„          u := Copy(u,2,pred(length(u)));„          end;„      u := StripQuotes(u);„      if (length(u)=3) and (u[2]='-')„        then begin„           for c := u[1] to u[3]„             do if A then b := b+[ c ]„                   else x := x+[ c ]„           end„        else begin„           for i:=1 to length(u)„             do if A then b := b+[ u[i] ]„                   else x:=x+[ u[i] ];„           end„    end;„  end;„end;„„function Match(n,s: string): Boolean;  (* Does a field match? *)„var i,j,k: byte;„    c: char;„    T: Boolean;„    Scrap: string;„begin„  i := 1; (* index of filespec *)„  j := 1; (* index of name     *)„  T := True;„  Puff(n);„  Puff(s);„  repeat„    if s[i]='*' then i:=FileNameLen (* Abort *)„      else„         case s[i] of„         '(' : if ((Flags and fExtendedWilds)<>0) then begin„                 Scrap := '';„                 inc(i);„                 repeat„                   Scrap := Scrap + s[i];„                   inc(i);„                 until (i>=FileNameLen) or (s[i]=')');„                 Scrap := StripQuotes(Scrap);„                 if Pos(Scrap,Copy(n,j,Length(n)))=0„                   then T := False;„               end;„         '[' : if ((Flags and fExtendedWilds)<>0) then begin„                x := [];  b := [];„                k:=succ(i);„                repeat„                  GetSet(s,']',k);„                until (k>=FileNameLen) or (s[k]=']');„                i := k;„                if x=[] then FillChar(x,SizeOf(x),#255);„                x := x-b;„                if not (n[j] in x) then T := False;„               end;„          '{' : if ((Flags and fExtendedWilds)<>0) then begin„                  x := [];  b := [];„                  k:=succ(i);„                  repeat„                   GetSet(s,'}',k);„                  until (k>=FileNameLen) or (s[k]='}');„                  i := succ(k);„                  if x=[] then FillChar(x,SizeOf(x),#255);„                  x := x-b;„                  while (n[j] in x) and (j<=FileNameLen)„                    do inc(j);„               end;„       else if T and (s[i]<>'?')„          then if s[i]<>n[j] then  T := False;„       end;„    inc(i);„    inc(j);„  until (not T) or (s[i]='*') or (i>FileNameLen) or (j>FileNameLen);„  Match := T;„end;„„var i,„    NumMatches : byte;„    dn,de,nn,ne,sn,se: string;„    Negate : Boolean;„begin„  Negate := False;„  if FSpCount=0 then NumMatches := 1„    else begin„      NumMatches := 0;„      for i:=1 to FSpCount„        do begin„          FileSplit(name,dn,nn,ne);„          FileSplit(FileSpecs[i].Name,de,sn,se);„            if ne='' then ne:='.   ';„          if (Flags and fUnDocumented)<>0 then begin„            if sn='' then sn:='*';„            if se='' then se:='.*';„            if dn='' then dn:='*';„            if de='' then de:='*';„          end;„          if (Match(dn,de) and Match(nn,sn) and Match(ne,se))„             then begin„               inc(NumMatches);„               if not FileSpecs[i].Truth„                  then Negate := True;„               end;„          end;„      end;„  if (NumNegs=FSpCount) and (NumMatches=0)„    then FitSpec := True„    else FitSpec := (NumMatches<>0) xor Negate;„end;„„„end.„„{---------------------  DEMO ------------------------- }„„(* Demo program to "test" the FileSpec unit                             *)„(* Checks to see if file matches filespec... good for testing/debugging *)„(* the FileSpec object/unit, as well as learning the syntax of FileSpec *)„„program FileSpec_Test(input, output);„  uses FileSpec;„var p,                                       (* User-entered "filespec"  *)„    d:  String;                              (* Filename to "test"       *)„    FS: TWildCard;                           (* FileSpec Object          *)„begin„  FS.Init;                                   (* Initialize               *)„  WriteLn;„  Write('Enter filespec -> '); ReadLN(p);    (* Get filespec...          *)„  FS.AddSpec(p);                             (* ... Add Spec to list ... *)„  Write('Enter file -----> '); ReadLN(d);    (* ... Get Filename ...     *)„  if FS.FitSpec(d)                           (* Is the file in the list? *)„    then WriteLN('The files match.')„    else WriteLN('The files don''t match.');„  FS.Done;                                   (* Done... clean up etc.    *)„end.„„„FileSpec v1.0a„--------------„„"FileSpec" is a public domain Turbo Pascal unit that gives you advanced,„Unix-like filespecs and wildcard-matching capabilities for your software.„This version should be compatible with Turbo Pascal v5.5 upwards (since„it uses OOP).„„The advantage is that you can check to see if a filename is within the„specs a user has given--even multiple filespecs; thus utilities like„file-finders or archive-viewers can have multiple file-search specif-„ications.„„To use, first initialize the TWildCard object (.Init).„„You then use .AddSpec() to add the wildcards (e.g. user-specified) to the„list; and use .FitSpec() to see if a filename "fits" in that list.„„When done, use the .Done destructor. (Check your TPascal manual if you do„not understand how to use objects).„„"FileSpec" supports standard DOS wilcards (* and ?); also supported are the„undocumented DOS wildcards (eg. FILENAME = FILENAME.* and .EXT = *.EXT).„„However, "FileSpec" supports many extended features which can make a program„many times more powerful.  Filenames or wildcards can be in quotes (eg. "*.*"„is equivalent to *.*).„„Also supported are "not" (or "but") wildcards using the ~ character.  Thus„a hypothetical directory-lister with the argument ~*.TXT would list all„files _except_ those that match *.TXT.„„Fixed and variable length "sets" are also supported:„„[a-m]*.*           <- Any files beginning with letters A-M„[a-z,~ux]*.*       <- Any files beginning with a any letter except X or U„*.?[~q]?           <- Any files except those that match *.?Q?„foo[abc]*.*        <- Files of FOO?*.* where '?' is A,B or C„foo["abc"]*.*      <- Same as above.„foo[a-c]*.*        <- Same as above.„test{0-9}.*        <- Files of TEST0.* through TEST9999.*„x{}z.*             <- Filenames beginning with X and ending with Z„x{0123456789}z.*   <- Same as above, only with numbers between X and Z.„("read")*.*        <- Filenames that contain the text "READ"„„If this seems confusing, use the FS-TEST.PAS program included with this„archive to experiment and learn the syntax used by "FileSpec".„„Playing around with the included demos (LS.PAS, a directory lister; and„XFIND, a file-finder) will also give you an idea how to use the FileSpecs„unit.„„One Note: if you use the FileSpec unit with your software, please let users„know about it in the documentation, so that they know they can take full„advantage of the added features.„„                                                 23     01-27-9413:32ALL                      ROBERT ROTHENBURG        DOS Files Listing        IMPORT              8      ¶∂‚ program ListFiles(input,output);„  uses Dos,„       FileSpec;„„var„  FS: TWildCard;„„procedure WriteName(Name: string; Attr: word);„var T: String;„begin„  if Attr=Directory„    then Name := '['+Name+']';„  Name := Name + '                ';     (* 16 spaces *)„  Write( Copy(Name,1,16) );„end;„„procedure ListFiles;„var„  Search:  SearchRec;„begin„    FindFirst('*.*',AnyFile,Search);„    if DosError<>18 then begin„       if FS.FitSpec(Search.Name)„             then WriteName(Search.Name,Search.Attr);„         repeat„           FindNext(Search);„           if DosError<>18„             then if FS.FitSpec(Search.Name)„                  then WriteName(Search.Name,Search.Attr);„         until DosError = 18;„       end;„end;„„var„  i:      Byte;„begin„  FS.Init;„  for i := 1 to ParamCount do FS.AddSpec(ParamStr(i));„  ListFiles;„  FS.Done;„  WriteLn;„end.„                                    24     01-27-9413:34ALL                      ROBERT ROTHENBURG        File Finder              IMPORT              13     ¶∂≈π „program XFind(input,output);„  uses Dos,„       FileSpec;„„var„  FS: TWildCard;„„„procedure WriteSpec(Name: string);„begin„   Name := FExpand(Name);„   WriteLn(Name);„end;„„procedure FindFiles(Dir: String);„var„  Search:  SearchRec;„  CurDir:  String;„  DirList: array [1..128] of string[12];„  i,„  DirNum:  Byte;„begin„  CurDir := FExpand('.');„  if (Dir<>'.') and (Dir<>'..') then begin„    ChDir(FExpand(Dir));„    DirNum := 0;„    FindFirst('*.*',AnyFile,Search);„    if DosError<>18 then begin„         if Search.Attr=Directory„           then begin„               inc(DirNum);„               DirList[ DirNum ] := Search.Name;„             end„           else if FS.FitSpec(Search.Name)„             then WriteSpec(Search.Name);„         repeat„           FindNext(Search);„           if DosError<>18„             then if Search.Attr=Directory„               then begin„                  inc(DirNum);„                  DirList[ DirNum ] := Search.Name;„                 end„               else if FS.FitSpec(Search.Name)„                  then WriteSpec(Search.Name);„         until DosError = 18;„       end;„    if DirNum<>0„      then for i := 1 to DirNum do FindFiles(DirList[i]);„    ChDir(CurDir);„  end;„end;„„var„  i:      Byte;„begin„  if ParamCount = 0„    then WriteLn('Usage: XFIND file1 [file2 file3 ... ]')„    else begin„       FS.Init;„       for i := 1 to ParamCount do FS.AddSpec(ParamStr(i));„       FindFiles('\');„       FS.Done;„      end;„end.„                                                              25     02-03-9416:18ALL                      EDDY THILLEMAN           Recursive Directory Roam IMPORT              21     ¶∂ı´ „{$M 65520,0,655360}„„Uses DOS;„„Type„  String12 = string[12];„„Const„  FAttr : word = $23; { readonly-, hidden-, archive attributen }„„Var„  CurDir  : PathStr;„  StartDir: DirStr;„  FMask   : String12;„  subdirs : boolean;„„„Function UpStr(const s:string):string; assembler;„{ by Brain Pape, found in the SWAG collection }„asm„  push ds„  lds  si,s„  les  di,@result„  lodsb            { load and store length of string }„  stosb„  xor  ch,ch„  mov  cl,al„  @upperLoop:„  lodsb„  cmp  al,'a'„  jb   #cont„  cmp  al,'z'„  ja   #cont„  sub  al,' '„  #cont:„  stosb„  loop @UpperLoop„  pop  ds„end;  { UpStr }„„„Procedure ParseCmdLine;„var„  t  : byte;„  cmd: string;„begin„  for t := 2 to ParamCount do begin„    cmd := UpStr(Copy(ParamStr(t),1,2));„    if cmd = '/S' then subdirs := true;„  end;„end;„„„Function NoTrailingBackslash (path : String) : String;„begin„ if (length(path) > 3) and (path[length(path)] = '\') then„   path[0] := chr(length(path) - 1);„ NoTrailingBackslash := path;„end;„„„Procedure PathAnalyze (P: PathStr; Var D: DirStr; Var Name: String12);„Var„  N: NameStr;„  E: ExtStr;„„begin„  FSplit(P, D, N, E);„  Name := N + E;„end;„„„Procedure Process (var SR: SearchRec);„{ here you can put anything you want to do in each directory with each file }„begin„  writeln(FExpand(SR.Name));„end;„„„Procedure FindFiles;„var„  FR : SearchRec;„„begin„  FindFirst(FMask, FAttr, FR);„  while DosError = 0 do„  begin„    Process(FR);„    FindNext(FR);„  end;„end;„„„{$S+}„Procedure AllDirs;„{ recursively roam through subdirectories }„var„  DR : SearchRec;„„begin„  FindFirst('*.*', Directory, DR);„  while DosError = 0 do begin„    if DR.Attr and Directory = Directory then begin„      if ((DR.Name <> '.') and (DR.Name <> '..')) then begin„        ChDir(DR.Name);„        AllDirs;       { Recursion!!! }„        ChDir('..');„      end„    end;„    FindNext(DR);„  end;„  FindFiles;„end;„{$S-}„„„begin„  subdirs := false;„  GetDir (0, CurDir);„  if ParamCount > 1 then ParseCmdLine;„„  PathAnalyze (FExpand(ParamStr(1)), StartDir, FMask);„  if Length (StartDir) > 0 then ChDir (NoTrailingBackslash(StartDir));„  if IOResult <> 0 then„  begin„    Writeln('Cannot find directory.');„    Halt(1);„  end;„  if Length (FMask) = 0 then FMask := '*.*';„  if subdirs then AllDirs else FindFiles;„  ChDir (CurDir);„end.„„{--------------- cut here -------------------}„„you can give an optional filemask to see only files which meet this„filemask.„                                                                                                                  26     02-15-9408:40ALL                      DANIEL BRONSTEIN         Qualified path/file      IMPORT              20     ¶∂ {******************************************************************„ * Create a function for returning a fully qualified path/file    *„ * string, with the *'s replaced by the appropriate number of ?'s.*„ *                                                                *„ * (C) Daniel A. Bronstein, Michigan State University, 1991.      *„ *     May be used freely with acknowledgement.                   *„ *****************************************************************}„„unit qualify;„„Interface„uses dos;                    {for pathstr definition}„„function fqualify(var ps:pathstr):pathstr;„„Implementation„„{$F+} {Far call so loading of the variable is simplified for asm.}„function fqualify(var ps:pathstr):pathstr;„begin„  asm„    push  ds                 {Save DS, else will crash after exit}„    push  si                 {and just to be safe, save SI too.}„    lds   si,ps              {Load address of pathstring,}„    xor   ax,ax              {clear AX,}„    cld                      {set direction flag and}„    lodsb                    {get length byte, incrementing SI.}„    mov   bx,ax              {Move length to BX and add}„    mov   byte ptr[si+bx],0  {a #0 to end to create ASCIIZ string.}„    les   di,@result         {Load address of the output string}„    mov   bx,di              {and save it in BX.}„    inc   di                 {Point past length byte of result}„    mov   ah,60h             {and call DOS function 60h.}„    int   21h„    jnc   @ok                {If no carry then ok, else return}„    mov   byte ptr[es:bx],0  {a 0 length string.}„    jmp   @xit„@ok:„    xor   cx,cx              {Clear CX and}„@0loop:„    inc   di                 {loop until find end of returned}„    inc   cx                 {ASCIIZ string.}„    cmp   byte ptr[es:di],0  {**Note that on 286 & 386 inc/cmp is faster}„    jne   @0loop             {**than CMPSB, so used here.}„    mov   byte ptr[es:bx],cl {Set the length byte of the result.}„@xit:„    pop   si                 {Restore SI and}„    pop   ds                 {DS, then}„  end;                       {exit.}„end;„{$F-}„„begin„end.„„{ ==================================  DEMO    ============================}„„PROGRAM Qualtest;„„USES DOS, Qualify;„„VAR„  MyString, YourString : PathStr;„„BEGIN„  MyString := 'Foo*.*';„  YourString := FQualify(MyString);„  Writeln(YourString);„  Readln;„„END.                                                            27     02-15-9408:40ALL                      MATTHEW PALCIC           DOS Directory Routines   IMPORT              90     ¶∂ùá „{ Updated DIRS.SWG on February 15, 1994 }„„Unit PDir;„„(*„„   Palcic Directory Routines„   Copyright (C) 1989, Matthew J. Palcic„   Requires Turbo Pascal 5.5 or higher„„   v1.0, 18 Aug 89 - Original release.„„*)„„„INTERFACE„„uses Dos,Objects;„„(*------------------------------------------------------------------------*)„„TYPE„„  AttrType = Byte;„  FileStr = String[12];„„  BaseEntryPtr = ^BaseEntry;„  BaseEntry = object(Node)„    Attr: AttrType;„    Time: Longint;„    Size: Longint;„    Name: FileStr;„    constructor Init;„    destructor Done; virtual;„    procedure ConvertRec(S:SearchRec);„    function FileName: FileStr; virtual;„    function FileExt: ExtStr; virtual;„    function FullName: PathStr; virtual;„    function FileTime: Longint; virtual;„    function FileAttr: AttrType; virtual;„    function FileSize: Longint; virtual;„    function IsDirectory: Boolean;„    constructor Load(var S: Stream);„    procedure Store(var S: Stream); virtual;„    end;„„  FileEntryPtr = ^FileEntry;„  FileEntry = object(BaseEntry)„    constructor Init;„    destructor Done; virtual;„    procedure ForceExt(E:ExtStr);„    procedure ChangeName(P:PathStr); virtual;„     (* Change the name in memory *)„    procedure ChangePath(P:PathStr); virtual;„    procedure ChangeTime(T:Longint); virtual;„    procedure ChangeAttr(A:AttrType); virtual;„    procedure Erase; virtual;„    function Rename(NewName:PathStr): Boolean; virtual;„     (* Physically rename file on disk, returns False if Rename fails *)„    function ResetTime: Boolean;„    function ResetAttr: Boolean;„    function SetTime(T:Longint): Boolean; virtual;„    function SetAttr(A:AttrType): Boolean; virtual;„    constructor Load(var S: Stream);„    procedure Store(var S: Stream); virtual;„    end;„„  DirEntryPtr = ^DirEntry;„  DirEntry = object(FileEntry)„    DirEntries: List;„    constructor Init;„    constructor Clear;„    destructor Done; virtual;„    procedure FindFiles(FileSpec: FileStr; Attrib: AttrType);„    procedure FindDirectories(FileSpec: FileStr; Attrib: AttrType);„    constructor Load(var S: Stream);„    procedure Store(var S: Stream); virtual;„    end;„„  DirStream = object(DosStream)„    procedure RegisterTypes; virtual;„    end;„„function ExtensionPos(FName : PathStr): Word;„function CurDir: PathStr;„function ReadString(var S: Stream): String;„procedure WriteString(var S: Stream; Str: String);„„(*------------------------------------------------------------------------*)„„IMPLEMENTATION„„  (*--------------------------------------------------------------------*)„  (* Methods for BaseEntry                                               *)„  (*--------------------------------------------------------------------*)„„  constructor BaseEntry.Init;„    begin„    end;„„  destructor BaseEntry.Done;„    begin„    end;„„  procedure BaseEntry.ConvertRec;„    begin„    Name := S.Name;„    Size := S.Size;„    Time := S.Time;„    Attr := S.Attr;„    end;„„  function BaseEntry.FileName;„    begin„    FileName := Name;„    end;„„  function BaseEntry.FullName;„    begin„    FullName := Name;„    end;„„  function BaseEntry.FileExt;„    var„      ep: word;„    begin„    ep := ExtensionPos(Name);„    if ep > 0 then„      FileExt := Copy(Name, Succ(ep), 3)„    else„      FileExt[0] := #0;„  end;„„„  function BaseEntry.FileAttr;„    begin„    FileAttr := Attr;„    end;„„  function BaseEntry.FileSize;„    begin„    FileSize := Size;„    end;„„  function BaseEntry.FileTime;„    begin„    FileTime := Time;„    end;„„  function BaseEntry.IsDirectory;„    begin„    IsDirectory := (FileAttr and Dos.Directory) = Dos.Directory;„    end;„„  constructor BaseEntry.Load;„    begin„    S.Read(Attr,SizeOf(Attr));„    S.Read(Time,SizeOf(Time));„    S.Read(Size,SizeOf(Size));„    Name := ReadString(S);„    end;„„  procedure BaseEntry.Store;„    begin„    S.Write(Attr,SizeOf(Attr));„    S.Write(Time,SizeOf(Time));„    S.Write(Size,SizeOf(Size));„    WriteString(S,Name);„    end;„„  (*--------------------------------------------------------------------*)„  (* Methods for FileEntry                                              *)„  (*--------------------------------------------------------------------*)„„  constructor FileEntry.Init;„    begin„    BaseEntry.Init; (* Call ancestor's Init *)„    Name := '';„    Size := 0;„    Time := $210000; (* Jan. 1 1980, 12:00a *)„    Attr := $00;  (* ReadOnly  = $01;„                     Hidden    = $02;„                     SysFile   = $04;„                     VolumeID  = $08;„                     Directory = $10;„                     Archive   = $20;„                     AnyFile   = $3F; *)„    end;„„  destructor FileEntry.Done;„    begin„    BaseEntry.Done;„    end;„„  function FileEntry.Rename;„    var„      F: File;„    begin„    Assign(F,FullName);„    System.Rename(F,NewName); (* Explicit call to 'System.Rename' avoid„                                 calling method 'FileEntry.Rename' *)„    if IOResult = 0 then„      begin„      ChangePath(NewName);„      Rename := True;„      end„    else„      Rename := False;„    end;„„  procedure FileEntry.ForceExt;„    var„      ep: Word;„      TempBool: Boolean;„    begin„    ep := ExtensionPos(FullName);„    if ep > 0 then„      TempBool := Rename(Concat(Copy(FullName, 1, ep),FileExt))„    else„      TempBool := Rename(Concat(FullName,'.',FileExt));„    end;„„  procedure FileEntry.ChangeName;„    begin„    Name := P;„    end;„„  procedure FileEntry.ChangePath;„    begin„    Name := P;  (* FileEntry object does not handle path *)„    end;„„  procedure FileEntry.ChangeTime;„    begin„    Time := T;„    end;„„  procedure FileEntry.ChangeAttr;„    begin„    Attr := A;„    end;„„  procedure FileEntry.Erase;„    var„      F:File;„    begin„    Assign(F,FullName);„    Reset(F);„    System.Erase(F); (* Remove ambiguity about 'Erase' call *)„    Close(F);„    end;„„  function FileEntry.ResetTime;„    var„      F:File;„    begin„    Assign(F,FullName);„    Reset(F);„    SetFTime(F,FileTime);„    ResetTime := IOResult = 0;„    Close(F);„    end;„„  function FileEntry.SetTime;„    var„      F:File;„    begin„    Assign(F,FullName);„    Reset(F);„    SetFTime(F,T);„    SetTime := IOResult = 0;„    Close(F);„    end;„„  function FileEntry.ResetAttr;„    var„      F:File;„    begin„    Assign(F,FullName);„    SetFAttr(F,FileAttr);„    ResetAttr := IOResult = 0;„    end;„„  function FileEntry.SetAttr;„    var„      F:File;„    begin„    ChangeAttr(A);„    SetAttr := ResetAttr;„    end;„„  constructor FileEntry.Load;„    begin„    BaseEntry.Load(S);„    end;„„  procedure FileEntry.Store;„    begin„    BaseEntry.Store(S);„    end;„„  (*--------------------------------------------------------------------*)„  (* Methods for DirEntry                                               *)„  (*--------------------------------------------------------------------*)„„  constructor DirEntry.Init;„    var„      TempNode: Node;„    begin„    FileEntry.Init;„    DirEntries.Delete;„    end;„„  destructor DirEntry.Done;„    begin„    DirEntries.Delete;„    FileEntry.Done;„    end;„„  constructor DirEntry.Clear;„    begin„    DirEntries.Clear;„    Init;„    end;„„  procedure DirEntry.FindFiles;„    var„      DirInfo: SearchRec;„      TempFile: FileEntryPtr;„    begin„    FindFirst(FileSpec,Attrib,DirInfo);„    while (DosError = 0) do„      begin„      TempFile := New(FileEntryPtr,Init);„      TempFile^.ConvertRec(DirInfo);„      DirEntries.Append(TempFile);„      FindNext(DirInfo);„      end;„    end;„„  procedure DirEntry.FindDirectories;„    var„      DirInfo: SearchRec;„      TempDir: DirEntryPtr;„    begin„„    if FileSpec <> '' then„      FindFiles(FileSpec,Attrib and not Dos.Directory);„„    FindFirst('*.*',Dos.Directory,DirInfo);„    while (DosError = 0) do„      begin„      if (DirInfo.Name[1] <> '.') and„         ((DirInfo.Attr and Dos.Directory) = Dos.Directory) then„         { if first character is '.' then name is either '.' or '..' }„        begin„        TempDir := New(DirEntryPtr,Clear);„        TempDir^.ConvertRec(DirInfo);„        DirEntries.Append(TempDir);„        end;„      FindNext(DirInfo);„      end;„„    TempDir := DirEntryPtr(DirEntries.First);„    while TempDir <> nil do„      begin„      if TempDir^.IsDirectory then„        begin„        ChDir(TempDir^.FileName);„        TempDir^.FindDirectories(FileSpec,Attrib);„        ChDir('..');„        end;„      TempDir := DirEntryPtr(DirEntries.Next(TempDir));„      end;„    end;„„  constructor DirEntry.Load;„    begin„    FileEntry.Load(S);„    DirEntries.Load(S);„    end;„„  procedure DirEntry.Store;„    begin„    FileEntry.Store(S);„    DirEntries.Store(S);„    end;„„  (*--------------------------------------------------------------------*)„  (* Methods for DirStream                                               *)„  (*--------------------------------------------------------------------*)„„  procedure DirStream.RegisterTypes;„    begin„    DosStream.RegisterTypes;„    Register(TypeOf(BaseEntry),@BaseEntry.Store,@BaseEntry.Load);„    Register(TypeOf(FileEntry),@FileEntry.Store,@FileEntry.Load);„    Register(TypeOf(DirEntry),@DirEntry.Store,@DirEntry.Load);„    end;„„(*---------------------------------------------------------------------*)„(*  Miscellaneous Unit procedures and functions                        *)„(*---------------------------------------------------------------------*)„„function ExtensionPos;„  var„    Index: Word;„  begin„  Index := Length(FName)+1;„  repeat„    dec(Index);„    until (FName[Index] = '.') OR (Index = 0);„  IF (Pos('\', Copy(FName, Succ(Index), SizeOf(FName))) <> 0) THEN Index := 0;„  ExtensionPos := Index;„  end;„„function CurDir;„  var„    P: PathStr;„  begin„  GetDir(0,P); { 0 = Current drive }„  CurDir := P;„  end;„„function ReadString;„  var„    T: String;„    L: Byte;„„  begin„  S.Read(L, 1);„  T[0] := Chr(L);„  S.Read(T[1], L);„  IF S.Status = 0 then„    ReadString := T„  else„    ReadString := '';„  end;„„procedure WriteString;„  begin„  S.Write(Str, Length(Str) + 1);„  end;„„(* No initialization code *)„end.„„{===============================    DEMO ============================ }„„program PDTest;„„uses Objects,PDir,Dos;„„var„  DP: DirEntryPtr;„  St: DirStream;„  Orig: PathStr;„„procedure ProcessDir(D: DirEntryPtr; DirName: PathStr);„  var„    DirPtr : DirEntryPtr;„  begin„  DirPtr := DirEntryPtr(D^.DirEntries.First);„  while DirPtr <> nil do„    begin„    if DirPtr^.IsDirectory then„      ProcessDir(DirPtr,DirName+'\'+DirPtr^.FileName)„      {recursively process subdirectories}„    else„      WriteLn(DirName+'\'+DirPtr^.FileName);„    DirPtr := DirEntryPtr(D^.DirEntries.Next(DirPtr));„    end;„  end;„„„„begin„Orig := CurDir;„WriteLn('Palcic''s File Finder v1.0');„„if ParamCount = 0 then { Syntax is incorrect }„  begin„  WriteLn;„  WriteLn('Syntax: PFF filespec');„  WriteLn;„  WriteLn('Directory names can not be passed.');„  WriteLn;„  WriteLn('Example: PFF *.ZIP');„  WriteLn;„  Halt;„  end;„„ChDir('C:\');„New(DP,Clear);„„WriteLn;„Write('Scanning for ',ParamStr(1),'...');„DP^.FindDirectories(ParamStr(1),Archive);„WriteLn;„WriteLn;„„ProcessDir(DP,'C:');„„WriteLn;„WriteLn('Back to original directory ',Orig);„ChDir(Orig);„„St.Init('PFF.DAT',SCreate);„DP^.Store(St);„St.Done;„„Dispose(DP,Done);„„end.„                                                                                                                             28     02-15-9408:41ALL                      SWAG SUPPORT TEAM        DOS Search Engine        IMPORT              40     ¶∂k UNIT Engine;„„{$V-}„„(**************************************************************************)„(* SEARCH ENGINE                                                          *)„(*        Input Parameters:                                               *)„(*              Mask  : The file specification to search for              *)„(*                      May contain wildcards                             *)„(*              Attr  : File attribute to search for                      *)„(*              Proc  : Procedure to process each found file              *)„(*                                                                        *)„(*        Output Parameters:                                              *)„(*              ErrorCode  : Contains the final error code.               *)„(**************************************************************************)„„(************************)„(**)   INTERFACE      (**)„(************************)„„USES DOS;„„TYPE„    ProcType     = PROCEDURE (VAR S : SearchRec; P : PathStr);„    FullNameStr  = STRING[12];„„    PROCEDURE SearchEngine(Mask : PathStr; Attr : Byte; Proc : ProcType; VAR ErrorCode : Byte);„„    FUNCTION GoodDirectory(S : SearchRec) : Boolean;„    PROCEDURE ShrinkPath(VAR path   : PathStr);„    PROCEDURE ErrorMessage(ErrCode  : Byte);„    PROCEDURE SearchEngineAll(path  : PathStr; Mask : FullNameStr; Attr : Byte; Proc : ProcType; VAR ErrorCode : Byte);„„    (************************)„    (**) IMPLEMENTATION   (**)„    (************************)„„VAR„    EngineMask : FullNameStr;„    EngineAttr : Byte;„    EngineProc : ProcType;„    EngineCode : Byte;„„    PROCEDURE SearchEngine(Mask : PathStr; Attr : Byte; Proc : ProcType; VAR ErrorCode : Byte);„„    VAR„       S : SearchRec;„       P : PathStr;„       Ext : ExtStr;„„    BEGIN„       FSplit(Mask, P, Mask, Ext);„       Mask := Mask + Ext;„       FindFirst(P + Mask, Attr, S);„       IF DosError <> 0 THEN„          BEGIN„               ErrorCode := DosError;„               Exit;„          END;„„    WHILE DosError = 0 DO„          BEGIN„               Proc(S, P);„               FindNext(S);„          END;„    IF DosError = 18 THEN ErrorCode := 0„    ELSE ErrorCode := DosError;„END;„„FUNCTION GoodDirectory(S : SearchRec) : Boolean;„BEGIN„    GoodDirectory := (S.name <> '.') AND (S.name <> '..') AND (S.Attr AND Directory = Directory);„END;„„PROCEDURE ShrinkPath(VAR path : PathStr);„VAR P : Byte;„    Dummy : NameStr;„BEGIN„    FSplit(path, path, Dummy, Dummy);„    Dec(path[0]);„END;„„{$F+} PROCEDURE SearchOneDir(VAR S : SearchRec; P : PathStr); {$F-}„      {Recursive procedure to search one directory}„BEGIN„    IF GoodDirectory(S) THEN„       BEGIN„            P := P + S.name;„            SearchEngine(P + '\' + EngineMask, EngineAttr, EngineProc, EngineCode);„            SearchEngine(P + '\*.*',Directory OR Archive, SearchOneDir, EngineCode);„       END;„END;„„PROCEDURE SearchEngineAll(path : PathStr; Mask : FullNameStr; Attr : Byte; Proc : ProcType; VAR ErrorCode : Byte);„„BEGIN„    (* Set up Unit global variables for use in recursive directory search procedure *)„    EngineMask := Mask;„    EngineProc := Proc;„    EngineAttr := Attr;„    SearchEngine(path + Mask, Attr, Proc, ErrorCode);„    SearchEngine(path + '*.*', Directory OR Attr, SearchOneDir, ErrorCode);„    ErrorCode := EngineCode;„END;„„PROCEDURE ErrorMessage(ErrCode : Byte);„BEGIN„    CASE ErrCode OF„         0 : ;                              {OK -- no error}„         2 : WriteLn('File not found');„         3 : WriteLn('Path not found');„         5 : WriteLn('Access denied');„         6 : WriteLn('Invalid handle');„         8 : WriteLn('Not enough memory');„         10 : WriteLn('Invalid environment');„         11 : WriteLn('Invalid format');„         18 : ;                    {OK -- merely no more files}„    ELSE WriteLN('ERROR #', ErrCode);„    END;„END;„„„END.„„„{ ===============================   DEMO     ==============================}„„{$R-,S+,I+,D+,F-,V-,B-,N-,L+ }„{$M 2048,0,0 }„PROGRAM DirSum;„        (*******************************************************)„        (* Uses SearchEngine to write the names of all files   *)„        (* in the current directory and display the total disk *)„        (* space that they occupy.                             *)„        (*******************************************************)„USES DOS,ENGINE;„„VAR„   Template  : PathStr;„   ErrorCode : Byte;„   Total     : LongInt;„„{$F+} PROCEDURE WriteIt(VAR S : SearchRec; P : PathStr);  {$F-}„BEGIN   WriteLn(S.name); Total := Total + S.Size END;„„BEGIN„     Total := 0;„     GetDir(0, Template);„     IF Length(Template) = 3 THEN Dec(Template[0]);„     {^Avoid ending up with "C:\\*.*"!}„     Template := Template + '\*.*';„     SearchEngine(Template, AnyFile, WriteIt, ErrorCode);„     IF ErrorCode <> 0 THEN ErrorMessage(ErrorCode) ELSE„        WriteLn('Total size of displayed files: ', Total : 8);„END.„                                                           29     02-22-9411:40ALL                      SWAG SUPPORT TEAM        Directory Select FunctionIMPORT              116    ¶∂   Program DIRSEL;„Uses„   Crt,Dos;  { ** needed for DIRSELECT functions ** }„„{ ** The following Type & Var declarations are for the main program only  ** }„{ ** However, the string length of the returned parameter from DIRSELECT  ** }„{ ** must be a least 12 characters.                                       ** }„„Type„   strtype = String[12];„Var„   spec,fname : strtype;„„{ ************************************************************************** }„{ ** List of Procedures/Functions needed for DIRSELECT                    ** }„{ ** Procedure CURSOR     - turns cursor on or off                        ** }„{ ** Procedure FRAME      - draws single or double frame                  ** }„{ ** Function ISCOLOR     - returns the current video mode                ** }„{ ** Procedure SAVESCR    - saves current video screen                    ** }„{ ** Procedure RESTORESCR - restores old video screen                     ** }„{ ** Procedure SCRGET     - get character/attribute                       ** }„{ ** Procedure SCRPUT     - put character/attribute                       ** }„{ ** Procedure FNAMEPOS   - finds proper screen position                  ** }„{ ** Procedure HILITE     - highlights proper name                        ** }„{ ** Function DIRSELECT   - directory selector                            ** }„{ ************************************************************************** }„„Procedure CURSOR( attrib : Boolean );„Var„   regs : Registers;„Begin„   If NOT attrib Then { turn cursor off }„   Begin„      regs.ah := 1;„      regs.cl := 7;„      regs.ch := 32;„      Intr($10,regs)„   End„   Else { turn cursor on }„   Begin„      Intr($11,regs);„      regs.cx := $0607;„      If regs.al AND $10 <> 0 Then regs.cx := $0B0C;„      regs.ah := 1;„      Intr($10,regs)„   End„End;„„Procedure FRAME(t,l,b,r,ftype : Integer);„Var„   i : Integer;„Begin„   GoToXY(l,t);„   If ftype = 2 Then„      Write(Chr(201))„   Else„      Write(Chr(218));„   GoToXY(r,t);„   If ftype = 2 Then„      Write(Chr(187))„   Else„      Write(Chr(191));„   GoToXY(l+1,t);„   For i := 1 To (r - (l + 1)) Do„      If ftype = 2 Then„         Write(Chr(205))„      Else„         Write(Chr(196));„   GoToXY(l+1,b);„   For i := 1 To (r - (l + 1)) Do„      If ftype = 2 Then„         Write(Chr(205))„      Else„         Write(Chr(196));„   GoToXY(l,b);„   If ftype = 2 Then„      Write(Chr(200))„   Else„      Write(Chr(192));„   GoToXY(r,b);„   If ftype = 2 Then„      Write(Chr(188))„   Else„      Write(Chr(217));„   For i := (t+1) To (b-1) Do„   Begin„      GoToXY(l,i);„      If ftype = 2 Then„         Write(Chr(186))„      Else„         Write(Chr(179))„   End;„   For i := (t+1) To (b-1) Do„   Begin„      GoToXY(r,i);„      If ftype = 2 Then„         Write(Chr(186))„      Else„         Write(Chr(179))„   End„End;„„Function ISCOLOR : Boolean;  { returns FALSE for MONO or TRUE for COLOR }„Var„   regs       : Registers;„   video_mode : Integer;„   equ_lo     : Byte;„Begin„   Intr($11,regs);„   video_mode := regs.al and $30;„   video_mode := video_mode shr 4;„   Case video_mode of„      1 : ISCOLOR := FALSE;  { Monochrome }„      2 : ISCOLOR := TRUE    { Color }„   End„End;„„Procedure SAVESCR( Var screen );„Var„   vidc : Byte Absolute $B800:0000;„   vidm : Byte Absolute $B000:0000;„Begin„   If NOT ISCOLOR Then  { if MONO }„      Move(vidm,screen,4000)„   Else                 { else COLOR }„      Move(vidc,screen,4000)„End;„„Procedure RESTORESCR( Var screen );„Var„   vidc : Byte Absolute $B800:0000;„   vidm : Byte Absolute $B000:0000;„Begin„   If NOT ISCOLOR Then  { if MONO }„      Move(screen,vidm,4000)„   Else                 { else COLOR }„      Move(screen,vidc,4000)„End;„„Procedure SCRGET( Var ch,attr : Byte );„Var„   regs : Registers;„Begin„   regs.bh := 0;„   regs.ah := 8;„   Intr($10,regs);„   ch := regs.al;„   attr := regs.ah„End;„„Procedure SCRPUT( ch,attr : Byte );„Var„   regs : Registers;„Begin„   regs.al := ch;„   regs.bl := attr;„   regs.ch := 0;„   regs.cl := 1;„   regs.bh := 0;„   regs.ah := 9;„   Intr($10,regs);„End;„„Procedure FNAMEPOS(Var arypos,x,y : Integer);„{ determine position on screen of filename }„Const„   FPOS1 =  2;„   FPOS2 = 15;„   FPOS3 = 28;„   FPOS4 = 41;„   FPOS5 = 54;„   FPOS6 = 67;„Begin„   Case arypos of„        1: Begin x := FPOS1; y :=  2 End;„        2: Begin x := FPOS2; y :=  2 End;„        3: Begin x := FPOS3; y :=  2 End;„        4: Begin x := FPOS4; y :=  2 End;„        5: Begin x := FPOS5; y :=  2 End;„        6: Begin x := FPOS6; y :=  2 End;„        7: Begin x := FPOS1; y :=  3 End;„        8: Begin x := FPOS2; y :=  3 End;„        9: Begin x := FPOS3; y :=  3 End;„       10: Begin x := FPOS4; y :=  3 End;„       11: Begin x := FPOS5; y :=  3 End;„       12: Begin x := FPOS6; y :=  3 End;„       13: Begin x := FPOS1; y :=  4 End;„       14: Begin x := FPOS2; y :=  4 End;„       15: Begin x := FPOS3; y :=  4 End;„       16: Begin x := FPOS4; y :=  4 End;„       17: Begin x := FPOS5; y :=  4 End;„       18: Begin x := FPOS6; y :=  4 End;„       19: Begin x := FPOS1; y :=  5 End;„       20: Begin x := FPOS2; y :=  5 End;„       21: Begin x := FPOS3; y :=  5 End;„       22: Begin x := FPOS4; y :=  5 End;„       23: Begin x := FPOS5; y :=  5 End;„       24: Begin x := FPOS6; y :=  5 End;„       25: Begin x := FPOS1; y :=  6 End;„       26: Begin x := FPOS2; y :=  6 End;„       27: Begin x := FPOS3; y :=  6 End;„       28: Begin x := FPOS4; y :=  6 End;„       29: Begin x := FPOS5; y :=  6 End;„       30: Begin x := FPOS6; y :=  6 End;„       31: Begin x := FPOS1; y :=  7 End;„       32: Begin x := FPOS2; y :=  7 End;„       33: Begin x := FPOS3; y :=  7 End;„       34: Begin x := FPOS4; y :=  7 End;„       35: Begin x := FPOS5; y :=  7 End;„       36: Begin x := FPOS6; y :=  7 End;„       37: Begin x := FPOS1; y :=  8 End;„       38: Begin x := FPOS2; y :=  8 End;„       39: Begin x := FPOS3; y :=  8 End;„       40: Begin x := FPOS4; y :=  8 End;„       41: Begin x := FPOS5; y :=  8 End;„       42: Begin x := FPOS6; y :=  8 End;„       43: Begin x := FPOS1; y :=  9 End;„       44: Begin x := FPOS2; y :=  9 End;„       45: Begin x := FPOS3; y :=  9 End;„       46: Begin x := FPOS4; y :=  9 End;„       47: Begin x := FPOS5; y :=  9 End;„       48: Begin x := FPOS6; y :=  9 End;„       49: Begin x := FPOS1; y := 10 End;„       50: Begin x := FPOS2; y := 10 End;„       51: Begin x := FPOS3; y := 10 End;„       52: Begin x := FPOS4; y := 10 End;„       53: Begin x := FPOS5; y := 10 End;„       54: Begin x := FPOS6; y := 10 End;„       55: Begin x := FPOS1; y := 11 End;„       56: Begin x := FPOS2; y := 11 End;„       57: Begin x := FPOS3; y := 11 End;„       58: Begin x := FPOS4; y := 11 End;„       59: Begin x := FPOS5; y := 11 End;„       60: Begin x := FPOS6; y := 11 End;„       61: Begin x := FPOS1; y := 12 End;„       62: Begin x := FPOS2; y := 12 End;„       63: Begin x := FPOS3; y := 12 End;„       64: Begin x := FPOS4; y := 12 End;„       65: Begin x := FPOS5; y := 12 End;„       66: Begin x := FPOS6; y := 12 End;„       67: Begin x := FPOS1; y := 13 End;„       68: Begin x := FPOS2; y := 13 End;„       69: Begin x := FPOS3; y := 13 End;„       70: Begin x := FPOS4; y := 13 End;„       71: Begin x := FPOS5; y := 13 End;„       72: Begin x := FPOS6; y := 13 End;„       73: Begin x := FPOS1; y := 14 End;„       74: Begin x := FPOS2; y := 14 End;„       75: Begin x := FPOS3; y := 14 End;„       76: Begin x := FPOS4; y := 14 End;„       77: Begin x := FPOS5; y := 14 End;„       78: Begin x := FPOS6; y := 14 End;„       79: Begin x := FPOS1; y := 15 End;„       80: Begin x := FPOS2; y := 15 End;„       81: Begin x := FPOS3; y := 15 End;„       82: Begin x := FPOS4; y := 15 End;„       83: Begin x := FPOS5; y := 15 End;„       84: Begin x := FPOS6; y := 15 End;„       85: Begin x := FPOS1; y := 16 End;„       86: Begin x := FPOS2; y := 16 End;„       87: Begin x := FPOS3; y := 16 End;„       88: Begin x := FPOS4; y := 16 End;„       89: Begin x := FPOS5; y := 16 End;„       90: Begin x := FPOS6; y := 16 End;„       91: Begin x := FPOS1; y := 17 End;„       92: Begin x := FPOS2; y := 17 End;„       93: Begin x := FPOS3; y := 17 End;„       94: Begin x := FPOS4; y := 17 End;„       95: Begin x := FPOS5; y := 17 End;„       96: Begin x := FPOS6; y := 17 End;„       97: Begin x := FPOS1; y := 18 End;„       98: Begin x := FPOS2; y := 18 End;„       99: Begin x := FPOS3; y := 18 End;„      100: Begin x := FPOS4; y := 18 End;„      101: Begin x := FPOS5; y := 18 End;„      102: Begin x := FPOS6; y := 18 End;„      103: Begin x := FPOS1; y := 19 End;„      104: Begin x := FPOS2; y := 19 End;„      105: Begin x := FPOS3; y := 19 End;„      106: Begin x := FPOS4; y := 19 End;„      107: Begin x := FPOS5; y := 19 End;„      108: Begin x := FPOS6; y := 19 End;„      109: Begin x := FPOS1; y := 20 End;„      110: Begin x := FPOS2; y := 20 End;„      111: Begin x := FPOS3; y := 20 End;„      112: Begin x := FPOS4; y := 20 End;„      113: Begin x := FPOS5; y := 20 End;„      114: Begin x := FPOS6; y := 20 End;„      115: Begin x := FPOS1; y := 21 End;„      116: Begin x := FPOS2; y := 21 End;„      117: Begin x := FPOS3; y := 21 End;„      118: Begin x := FPOS4; y := 21 End;„      119: Begin x := FPOS5; y := 21 End;„      120: Begin x := FPOS6; y := 21 End„      Else„      Begin„         x := 0;„         y := 0;„      End„   End„End;„„Procedure HILITE(old,new : Integer);  { highlight a filename on the screen }„Var„   i,oldx,oldy,newx,newy : Integer;„   ccolor,locolor,hicolor,cchar : Byte;„Begin„   FNAMEPOS(old,oldx,oldy); { get position in the array of the filename }„   FNAMEPOS(new,newx,newy); { get position in the array of the filename }„   For i := 0 To 11 Do„   Begin„      If old < 121 Then  { if valid position, reverse video, old selection }„      Begin„         GoToXY((oldx + i),oldy);„         SCRGET(cchar,ccolor);„         locolor := ccolor AND $0F;„         locolor := locolor shl 4;„         hicolor := ccolor AND $F0;„         hicolor := hicolor shr 4;„         ccolor  := locolor + hicolor;„         SCRPUT(cchar,ccolor)„      End;„      GoToXY((newx + i),newy);         { reverse video, new selection }„      SCRGET(cchar,ccolor);„      locolor := ccolor AND $0F;„      locolor := locolor shl 4;„      hicolor := ccolor AND $F0;„      hicolor := hicolor shr 4;„      ccolor  := locolor + hicolor;„      SCRPUT(cchar,ccolor)„   End„End;„„Function DIRSELECT(mask : strtype; attr : Integer) : strtype;„Const„   OFF   = FALSE;„   ON    = TRUE;„Var„   i,oldcurx,oldcury,„   newcurx,newcury,„   oldpos,newpos,„   scrrows,fncnt        : Integer;„   ch                   : Char;„   dos_dir              : Array[1..120] of String[12];„   fileinfo             : SearchRec;„   screen               : Array[1..4000] of Byte;„Begin„   fncnt := 0;„   FindFirst(mask,attr,fileinfo);„   If DosError <> 0 Then   { if not found, return NULL }„   Begin„      DIRSELECT := '';„      Exit„   End;„   While (DosError = 0) AND (fncnt <> 120) Do   { else, collect filenames }„   Begin„      Inc(fncnt);„      dos_dir[fncnt] := fileinfo.Name;„      FindNext(fileinfo)„   End;„   oldcurx := WhereX;     { store old CURSOR position }„   oldcury := WhereY;„   SAVESCR(screen);„   CURSOR(OFF);„   scrrows := (fncnt DIV 6) + 3;„   Window(1,1,80,scrrows + 1);„   ClrScr;„   GoToXY(1,1);„   i := 1;„   While (i <= fncnt) AND (i <= 120) Do     { display all filenames }„   Begin„      FNAMEPOS(i,newcurx,newcury);„      GoToXY(newcurx,newcury);„      Write(dos_dir[i]);„      Inc(i)„   End;„   FRAME(1,1,scrrows,80,1);  { draw the frame }„   HILITE(255,1);            { highlight the first filename }„   oldpos := 1;„   newpos := 1;„   While TRUE Do             { get keypress and do appropriate action }„   Begin„      ch := ReadKey;„      Case ch of„         #27:  { Esc  }„         Begin„            Window(1,1,80,25);„            RESTORESCR(screen);„            GoToXY(oldcurx,oldcury);„            CURSOR(ON);„            DIRSELECT := '';„            Exit                       { return NULL }„         End;„         #71:  { Home }                { goto first filename }„         Begin„            oldpos := newpos;„            newpos := 1;„            HILITE(oldpos,newpos)„         End;„         #79:  { End  }                { goto last filename }„         Begin„            oldpos := newpos;„            newpos := fncnt;„            HILITE(oldpos,newpos)„         End;„         #72:  { Up   }                { move up one filename }„         Begin„            i := newpos;„            i := i - 6;„            If i >= 1 Then„            Begin„               oldpos := newpos;„               newpos := i;„               HILITE(oldpos,newpos)„            End„         End;„         #80:  { Down }                { move down one filename }„         Begin„            i := newpos;„            i := i + 6;„            If i <= fncnt Then„            Begin„               oldpos := newpos;„               newpos := i;„               HILITE(oldpos,newpos)„            End„         End;„         #75:  { Left }                { move left one filename }„         Begin„            i := newpos;„            Dec(i);„            If i >= 1 Then„            Begin„               oldpos := newpos;„               newpos := i;„               HILITE(oldpos,newpos)„            End„         End;„         #77:  { Right }               { move right one filename }„         Begin„            i := newpos;„            Inc(i);„            If i <= fncnt Then„            Begin„               oldpos := newpos;„               newpos := i;„               HILITE(oldpos,newpos)„            End„         End;„         #13:  { CR }„         Begin„            Window(1,1,80,25);„            RESTORESCR(screen);„            GoToXY(oldcurx,oldcury);    { return old CURSOR position }„            CURSOR(ON);„            DIRSELECT := dos_dir[newpos];„            Exit                        { return with filename }„         End„      End„   End„End;„„{ ************************************************************************** }„{ ** Main Program : NOTE that the following is a demo program only.       ** }„{ **                It is not needed to use the DIRSELECT function.       ** }„{ ************************************************************************** }„„Begin„   While TRUE Do„   Begin„      Writeln;„      Write('Enter a filespec => ');„      Readln(spec);„      fname := DIRSELECT(spec,0);„      If Length(fname) = 0 Then„      Begin„         Writeln('Filespec not found.');„         Halt„      End;„      Writeln('The file you have chosen is ',fname,'.')„   End„End.„„{ ** EOF( DIRSEL.PAS )  ** }„                                                                                              30     05-25-9408:09ALL                      LARRY HADLEY             Directory Object         SWAG9405            97     ¶∂   {„  Next in this continuing series of code: the actual directry„  object.„}„„Unit Dirs;„{„  A directory management object from a concept originally by Allan„  Holub, as discussed in Byte Dec/93 (Vol 18, No 13, page 213)„„  Turbo Pascal code by Larry Hadley, tested using BP7.„}„INTERFACE„„Uses Sort, DOS;„„TYPE„   pSortSR = ^oSortSR;„   oSortSR = OBJECT(oSortTree)„      procedure   DeleteNode(var Node); virtual;„   end;„„   callbackproc = procedure(name :string; lev :integer);„„   prec  = ^searchrec;„„   pentry = ^entry;„   entry  = record„      fil          :prec;„      next, last   :pentry;„   end;„„   pdir  = ^dir;„   dir   = record„      flist  :pentry;„      count  :word;„      path   :string[80];„   end;„„   pDirectry = ^Directry;„   Directry  = OBJECT„      dirroot   :pdir;„„      constructor Init(path, filespec :string; attribute :byte);„      destructor  Done;„„      procedure   Load(path, filespec :string; attribute :byte);„      procedure   Sort;„      procedure   Print;„   END;„„CONST„   NotDir  = ReadOnly+Hidden+SysFile+VolumeID+Archive;„   dosattr : array[0..8] of char = '.rhsvdaxx';„„procedure TraverseTree(root :string; pcallproc :pointer; do_depth :boolean);„„IMPLEMENTATION„„var„   treeroot :pSortSR; { sorting tree object }„„procedure disposelist(ls :pentry);„var„   lso :pentry;„begin„   while ls<>NIL do„   begin„      dispose(ls^.fil);„      lso := ls;„      ls := ls^.next;„      dispose(lso);„   end;„end;„„{ Define oSortSR.DeleteNode method so object knows how to dispose of„  individual data pointers in the event that "Done" is called before„  tree is empty. }„procedure   oSortSR.DeleteNode(var Node);„var„   pNode :pRec ABSOLUTE Node;„begin„   dispose(pNode);„end;„„constructor Directry.Init(path, filespec :string; attribute :byte);„var„   pathspec :string;„   node     :pentry;„   i        :word;„BEGIN„   FillChar(Self, SizeOf(Self), #0);„   Load(path, filespec, attribute); { scan specified directory }„   if dirroot^.count=0 then         { if no files were found, abort }„   begin„      if dirroot<>NIL then„      begin„         disposelist(dirroot^.flist);„         dispose(dirroot);„      end;„      FAIL;„   end;„ { the following code expands the pathspec to a full qualified path }„   pathspec := dirroot^.path+'\';„   node := dirroot^.flist;„   while ((node^.fil^.name='.') or (node^.fil^.name='..')) and„         (node^.next<>NIL) do„      node := node^.next;„   if node^.fil^.name='..' then„      pathspec := pathspec+'.'„   else„      pathspec := pathspec+node^.fil^.name;„   pathspec := FExpand(pathspec);„   i := Length(pathspec);„   repeat„      Dec(i);„   until (i=0) or (pathspec[i]='\');„   if i>0 then„   begin„      Delete(pathspec, i, Length(pathspec));„      dirroot^.path := pathspec;„   end;„END;„„destructor  Directry.Done;„begin„   if dirroot<>NIL then„   begin„      disposelist(dirroot^.flist);„      dispose(dirroot);„   end;„end;„„procedure   Directry.Load(path, filespec :string; attribute :byte);„{ scan a specified directory with a specified wildcard and attribute„  byte }„var„   count   : word;„   pstr    : pathstr;„   dstr    : dirstr;„   srec    : SearchRec;„   dirx    : pdir;„   firstfl, thisfl, lastfl  : pentry;„begin„   count := 0;„   New(firstfl);„   with firstfl^ do„   begin„      next := NIL; last := NIL; New(fil);„   end;„   thisfl := firstfl; lastfl := firstfl;„   dstr  := path;„   if path = '' then dstr := '.';„   if dstr[Length(dstr)]<>'\' then dstr := dstr+'\';„   if filespec = '' then filespec := '*.*';„   pstr := dstr+filespec;„„   FindFirst(pstr, attribute, srec);„   while DosError=0 do { while new files are found... }„   begin„      if srec.attr = (srec.attr and attribute) then„ { make sure the attribute byte matches our required atttribute mask }„      begin„         if count>0 then„ { if this is NOT first file found, link in new node }„         begin„            New(thisfl);„            lastfl^.next := thisfl;„            thisfl^.last := lastfl;„            thisfl^.next := NIL;„            New(thisfl^.fil);„            lastfl := thisfl;„         end;„         thisfl^.fil^ := srec;„         Inc(count);„      end;„      FindNext(srec);„   end;„ { construct root node }„   New(dirx);„   with dirx^ do„      flist := firstfl;„   dirx^.path  := path;  { path specifier for directory list }„   dirx^.count := count; { number of files in the list }„„   if dirroot=NIL then„      dirroot := dirx„   else„   begin„      disposelist(dirroot^.flist);„      dispose(dirroot);„      dirroot := dirx;„   end;„end;„„{ The following function is the far-local function needed for the„  SORT method (which uses the sort unit posted earlier)„  Note that this is hard-coded to sort by filename, then extension.„  I plan to rewrite this later to allow user-selectable sort„  parameters and ordering. }„function Comp(d1, d2 :pointer):integer; far;„   var„      data1 :pRec ABSOLUTE d1;„      data2 :pRec ABSOLUTE d2;„      name1, name2, ext1, ext2  :string;„   begin„ { This assures that the '.' and '..' dirs will always be the first„   listed. }„      if (data1^.name='.') or (data1^.name='..') then„      begin„         Comp := -1;„         EXIT;„      end;„      if (data2^.name='.') or (data2^.name='..') then„      begin„         Comp := 1;„         EXIT;„      end;„      with data1^ do„      begin„         name1 := Copy(name, 1, Pos('.', name)-1);„         ext1  := Copy(name, Pos('.', name)+1, 3);„      end;„      with data2^ do„      begin„         name2 := Copy(name, 1, Pos('.', name)-1);„         ext2  := Copy(name, Pos('.', name)+1, 3);„      end;„      if name1=name2 then„ { If filename portion is equal, use extension to resolve tie }„      begin„         if ext1=ext2 then„ { There should be NO equal filenames, but handle anyways for„   completeness... }„            Comp := 0„         else„            if ext1>ext2 then„               Comp := 1„            else„               Comp := -1;„      end„      else„         if name1>name2 then„            Comp := 1„         else„            Comp := -1;„   end;„„{ Sort method uses the sort unit to sort the collected directory„  entries. }„procedure   Directry.Sort;„var„   s1, s2 :string;„   p1     :pentry;„„ { This local procedure keeps code more readable }„   procedure UpdatePtr(var prev :pentry; NewEntry :pointer);„   begin„      if NewEntry<>NIL then { check to see if tree is empty }„      begin„         New(prev^.next);„         prev^.next^.fil  := NewEntry;„         prev^.next^.last := prev;„         prev := prev^.next;„         prev^.next := NIL;„      end„      else„         prev := prev^.next;„       { tree is empty, flag "done" with NIL pointer }„   end;„„begin„   p1 := dirroot^.flist;„   New(treeroot, Init(Comp));„{ Create a sort tree, point to our COMP function }„   while p1<>NIL do„{ Go through our linked list and insert the items into the sorting„  tree, dispose of original nodes as we go. }„   begin„      if p1^.last<>NIL then„         dispose(p1^.last);„      treeroot^.InsertNode(p1^.fil);„      if p1^.next=NIL then„      begin„         dispose(p1);„         p1 := NIL;„      end„      else„         p1 := p1^.next;„   end;„{ Reconstruct directory list from sorted tree }„   New(dirroot^.flist);„   with dirroot^ do„   begin„      flist^.next := NIL;„      flist^.last := NIL;„      flist^.fil := treeroot^.ReadLeftNode;„   end;„   if dirroot^.flist^.fil<>NIL then„   begin„      p1 := dirroot^.flist;„      while p1<>NIL do„         UpdatePtr(p1, treeroot^.ReadLeftNode);„   end;„{ We're done with sorting tree... }„   dispose(treeroot, Done);„end;„„procedure   Directry.Print;„{ currently prints the entire list, may modify this later to allow„  selective printing }„var„   s, s1 :string;„   e     :pentry;„   dt    :DateTime;„   dbg   :byte;„„   procedure DoDateEle(var sb :string; de :word);„   begin„      Str(de, sb);„      if Length(sb)=1 then { Add leading 0's}„         sb := '0'+sb;„   end;„„begin„   if dirroot=NIL then EXIT; { make sure empty dirs aren't attempted }„   e := dirroot^.flist;„   while e<>NIL do„   begin„      s := '';„      with e^.fil^ do„      begin„         dbg := 1;„         repeat„            case dbg of { parse attribute bits }„              1: s := s+dosattr[(attr and $01)];„              2: s := s+dosattr[(attr and $02)];„              3: if (attr and $04) = $04 then„                    s := s+dosattr[3]„                 else„                    s := s+dosattr[0];„              4: if (attr and $08) = $08 then„                    s := s+dosattr[4]„                 else„                    s := s+dosattr[0];„              5: if (attr and $10) = $10 then„                    s := s+dosattr[5]„                 else„                    s := s+dosattr[0];„              6: if (attr and $20) = $20 then„                    s := s+dosattr[6]„                 else„                    s := s+dosattr[0];„              else„                 s := s+dosattr[0];„            end;„            Inc(dbg);„         until dbg>8;„         s := s+' ';„   { Kludge to make sure that extremely large files (>=100MB) don't„     overflow size field... }„         if size<100000000 then„            Str(size:8, s1)„         else„         begin„            Str((size div 1000):7, s1); { decimal kilobytes }„            s1 := s1+'k';„         end;„         s := s+s1+' ';„   { Format date/time fields }„         UnpackTime(Time, dt);„         {month}„         DoDateEle(s1, dt.month); s := s+s1+'/';„         {day}„         DoDateEle(s1, dt.day);   s := s+s1+'/';„         {year}„         DoDateEle(s1, dt.year);  s := s+s1+' ';„         {hour}„         DoDateEle(s1, dt.hour);  s := s+s1+':';„         {minutes}„         DoDateEle(s1, dt.min);   s := s+s1+':';„         {seconds}„         DoDateEle(s1, dt.sec);   s := s+s1+' - ';„         s := s+dirroot^.path+'\'+name;„      end;„      Writeln(s); s := '';„      e := e^.next;„   end;„   Writeln; Writeln('  ', dirroot^.count, ' files found.'); Writeln;„end;„„{ If TraverseTree is not given a callback procedure, this one is„  used. }„procedure   DefaultCallback(name :string; lev :integer); far;„var„   s :string;„const„   spaces = '                                               ';„begin„   s := Copy(spaces, 1, lev*4); s := s+name;„   Writeln(s);„end;„„{ TraverseTree is untested as yet, rest of code (above) works fine.„  Note that TraverseTree is NOT a member method of DIRECTRY. Read„  the BYTE Dec/93 article for a clarification of why it is good„  that it not be a member.}„procedure TraverseTree(root :string; pcallproc :pointer; do_depth :boolean);„var„   level    :integer;„   fullpath :string;„   rootdir  :pdir;„const„   callproc : callbackproc = DefaultCallBack;„„ { Actual recursive procedure to scan down directory structure„   using the DIRECTRY object. }„   procedure Tree(newroot :string; callee :callbackproc; do_last :boolean);„   var„      subdirs  :pdirectry;„      direntry :pentry;„„      Procedure DoDir;„      begin„         New(subdirs, Init(newroot, '*.*', NotDir));„         if subdirs<>NIL then„         begin„            subdirs^.sort;„            direntry := subdirs^.dirroot^.flist;„            while direntry<>NIL do„            begin„               fullpath := newroot+'\'+direntry^.fil^.name;„               callee(newroot, level);„               direntry := direntry^.next;„            end;„            dispose(subdirs, done);„         end;„      end;„„   begin„      if not(do_last) then„         DoDir;„„      New(subdirs, Init(newroot, '*.*', directory));„„      if subdirs<>NIL then„      begin„         subdirs^.sort;„         direntry := subdirs^.dirroot^.flist;„         while direntry<>NIL do„         begin„            Inc(level);„            fullpath := newroot+'\'+direntry^.fil^.name;„            Tree(fullpath, callee, do_last);„            dec(level);„            direntry := direntry^.next;„         end;„         dispose(subdirs, done);„      end;„„      if do_last then„         DoDir;„   end;„„begin„   level := 0;„„   if pcallproc<>NIL then„      callproc := callbackproc(pcallproc^);„„   root := fexpand(root);„   if root[Length(root)]='\' then„      Delete(root, Length(root), 1);„„   if not(do_depth) then„      callproc(root, level);„„   Tree(root, callproc, do_depth);„„   if do_depth then„      callproc(root, level);„end;„„END.„                      31     05-26-9406:20ALL                      TIMO SALMI               Hiding a Directory       SWAG9405            8      ¶∂   {„> browsing. Q59 (How do you hide a directory?) leapt out at me as it's„something„„Q53 actually.„„> I have been trying to do for ages. However on closer examination the„'solution'„> proved to be calling the SETFATTR function (either directly or through it's„> DOS interrupt.) This worried me- I am SURE I tried this, and without„success.„> It worked fine for ordinary files, but NOT directories. In fact I have a„„That's very strange since I have no problems when I test„}„„uses Dos;„„procedure HIDE (dirname : string);„var regs : registers;„begin„  FillChar (regs, SizeOf(regs), 0);„  dirname := dirname + #0;„  regs.ah := $43;„  regs.al := $01;„  regs.ds := Seg(dirname[1]);„  regs.dx := Ofs(dirname[1]);„  regs.cx := 2; { set bit 1 on }„  Intr ($21, regs);„  if regs.Flags and FCarry <> 0 then„    writeln ('Failed to hide');„end;  (* hide *)„„begin„  HIDE ('r:\tmpdir');„end.„              